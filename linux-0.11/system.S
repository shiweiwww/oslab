
system：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <pg_dir>:
.text
.globl idt,gdt,pg_dir,tmp_floppy_area
pg_dir:
.globl startup_32
startup_32:
	movl $0x10,%eax
       0:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
       5:	8e d8                	mov    %eax,%ds
	mov %ax,%es
       7:	8e c0                	mov    %eax,%es
	mov %ax,%fs
       9:	8e e0                	mov    %eax,%fs
	mov %ax,%gs
       b:	8e e8                	mov    %eax,%gs
	lss stack_start,%esp
       d:	0f b2 25 40 bd 01 00 	lss    0x1bd40,%esp
	call setup_idt
      14:	e8 58 00 00 00       	call   71 <setup_idt>
	call setup_gdt
      19:	e8 83 00 00 00       	call   a1 <setup_gdt>
	movl $0x10,%eax		# reload all the segment registers
      1e:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds		# after changing gdt. CS was already
      23:	8e d8                	mov    %eax,%ds
	mov %ax,%es		# reloaded in 'setup_gdt'
      25:	8e c0                	mov    %eax,%es
	mov %ax,%fs
      27:	8e e0                	mov    %eax,%fs
	mov %ax,%gs
      29:	8e e8                	mov    %eax,%gs
	lss stack_start,%esp
      2b:	0f b2 25 40 bd 01 00 	lss    0x1bd40,%esp
	xorl %eax,%eax
      32:	31 c0                	xor    %eax,%eax
1:	incl %eax		# check that A20 really IS enabled
      34:	40                   	inc    %eax
	movl %eax,0x000000	# loop forever if it isn't
      35:	a3 00 00 00 00       	mov    %eax,0x0
	cmpl %eax,0x100000
      3a:	39 05 00 00 10 00    	cmp    %eax,0x100000
	je 1b
      40:	74 f2                	je     34 <OLDSS+0x8>
 * NOTE! 486 should set bit 16, to check for write-protect in supervisor
 * mode. Then it would be unnecessary with the "verify_area()"-calls.
 * 486 users probably want to set the NE (#5) bit also, so as to use
 * int 16 for math errors.
 */
	movl %cr0,%eax		# check math chip
      42:	0f 20 c0             	mov    %cr0,%eax
	andl $0x80000011,%eax	# Save PG,PE,ET
      45:	25 11 00 00 80       	and    $0x80000011,%eax
/* "orl $0x10020,%eax" here for 486 might be good */
	orl $2,%eax		# set MP
      4a:	83 c8 02             	or     $0x2,%eax
	movl %eax,%cr0
      4d:	0f 22 c0             	mov    %eax,%cr0
	call check_x87
      50:	e8 05 00 00 00       	call   5a <check_x87>
	jmp after_page_tables
      55:	e9 a6 53 00 00       	jmp    5400 <after_page_tables>

0000005a <check_x87>:

/*
 * We depend on ET to be correct. This checks for 287/387.
 */
check_x87:
	fninit
      5a:	db e3                	fninit 
	fstsw %ax
      5c:	9b df e0             	fstsw  %ax
	cmpb $0,%al
      5f:	3c 00                	cmp    $0x0,%al
	je 1f			/* no coprocessor: have to set bits */
      61:	74 0b                	je     6e <check_x87+0x14>
	movl %cr0,%eax
      63:	0f 20 c0             	mov    %cr0,%eax
	xorl $6,%eax		/* reset MP, set EM */
      66:	83 f0 06             	xor    $0x6,%eax
	movl %eax,%cr0
      69:	0f 22 c0             	mov    %eax,%cr0
	ret
      6c:	c3                   	ret    
      6d:	90                   	nop
      6e:	db e4                	fnsetpm(287 only) 
.align 2
1:	.byte 0xDB,0xE4		/* fsetpm for 287, ignored by 387 */
	ret
      70:	c3                   	ret    

00000071 <setup_idt>:
 *  are enabled elsewhere, when we can be relatively
 *  sure everything is ok. This routine will be over-
 *  written by the page tables.
 */
setup_idt:
	lea ignore_int,%edx
      71:	8d 15 28 54 00 00    	lea    0x5428,%edx
	movl $0x00080000,%eax
      77:	b8 00 00 08 00       	mov    $0x80000,%eax
	movw %dx,%ax		/* selector = 0x0008 = cs */
      7c:	66 89 d0             	mov    %dx,%ax
	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
      7f:	66 ba 00 8e          	mov    $0x8e00,%dx

	lea idt,%edi
      83:	8d 3d b8 54 00 00    	lea    0x54b8,%edi
	mov $256,%ecx
      89:	b9 00 01 00 00       	mov    $0x100,%ecx

0000008e <rp_sidt>:
rp_sidt:
	movl %eax,(%edi)
      8e:	89 07                	mov    %eax,(%edi)
	movl %edx,4(%edi)
      90:	89 57 04             	mov    %edx,0x4(%edi)
	addl $8,%edi
      93:	83 c7 08             	add    $0x8,%edi
	dec %ecx
      96:	49                   	dec    %ecx
	jne rp_sidt
      97:	75 f5                	jne    8e <rp_sidt>
	lidt idt_descr
      99:	0f 01 1d a8 54 00 00 	lidtl  0x54a8
	ret
      a0:	c3                   	ret    

000000a1 <setup_gdt>:
 *  is VERY complicated at two whole lines, so this
 *  rather long comment is certainly needed :-).
 *  This routine will beoverwritten by the page tables.
 */
setup_gdt:
	lgdt gdt_descr
      a1:	0f 01 15 b0 54 00 00 	lgdtl  0x54b0
	ret
      a8:	c3                   	ret    
	...

00001000 <pg0>:
	...

00002000 <pg1>:
	...

00003000 <pg2>:
	...

00004000 <pg3>:
	...

00005000 <tmp_floppy_area>:
	...

00005400 <after_page_tables>:
 */
tmp_floppy_area:
	.fill 1024,1,0

after_page_tables:
	pushl $0		# These are the parameters to main :-)
    5400:	6a 00                	push   $0x0
	pushl $0
    5402:	6a 00                	push   $0x0
	pushl $0
    5404:	6a 00                	push   $0x0
	pushl $L6		# return address for main, if it decides to.
    5406:	68 12 54 00 00       	push   $0x5412
	pushl $main
    540b:	68 84 66 00 00       	push   $0x6684
	jmp setup_paging
    5410:	eb 3c                	jmp    544e <setup_paging>

00005412 <L6>:
L6:
	jmp L6			# main should never return here, but
    5412:	eb fe                	jmp    5412 <L6>

00005414 <int_msg>:
    5414:	55                   	push   %ebp
    5415:	6e                   	outsb  %ds:(%esi),(%dx)
    5416:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
    541a:	6e                   	outsb  %ds:(%esi),(%dx)
    541b:	20 69 6e             	and    %ch,0x6e(%ecx)
    541e:	74 65                	je     5485 <setup_paging+0x37>
    5420:	72 72                	jb     5494 <setup_paging+0x46>
    5422:	75 70                	jne    5494 <setup_paging+0x46>
    5424:	74 0a                	je     5430 <ignore_int+0x8>
    5426:	0d                   	.byte 0xd
	...

00005428 <ignore_int>:
/* This is the default interrupt "handler" :-) */
int_msg:
	.asciz "Unknown interrupt\n\r"
.align 2
ignore_int:
	pushl %eax
    5428:	50                   	push   %eax
	pushl %ecx
    5429:	51                   	push   %ecx
	pushl %edx
    542a:	52                   	push   %edx
	push %ds
    542b:	1e                   	push   %ds
	push %es
    542c:	06                   	push   %es
	push %fs
    542d:	0f a0                	push   %fs
	movl $0x10,%eax
    542f:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %ax,%ds
    5434:	8e d8                	mov    %eax,%ds
	mov %ax,%es
    5436:	8e c0                	mov    %eax,%es
	mov %ax,%fs
    5438:	8e e0                	mov    %eax,%fs
	pushl $int_msg
    543a:	68 14 54 00 00       	push   $0x5414
	call printk
    543f:	e8 0f 2f 00 00       	call   8353 <printk>
	popl %eax
    5444:	58                   	pop    %eax
	pop %fs
    5445:	0f a1                	pop    %fs
	pop %es
    5447:	07                   	pop    %es
	pop %ds
    5448:	1f                   	pop    %ds
	popl %edx
    5449:	5a                   	pop    %edx
	popl %ecx
    544a:	59                   	pop    %ecx
	popl %eax
    544b:	58                   	pop    %eax
	iret
    544c:	cf                   	iret   
    544d:	90                   	nop

0000544e <setup_paging>:
 * some kind of marker at them (search for "16Mb"), but I
 * won't guarantee that's all :-( )
 */
.align 2
setup_paging:
	movl $1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */
    544e:	b9 00 14 00 00       	mov    $0x1400,%ecx
	xorl %eax,%eax
    5453:	31 c0                	xor    %eax,%eax
	xorl %edi,%edi			/* pg_dir is at 0x000 */
    5455:	31 ff                	xor    %edi,%edi
	cld;rep;stosl
    5457:	fc                   	cld    
    5458:	f3 ab                	rep stos %eax,%es:(%edi)
	movl $pg0+7,pg_dir		/* set present bit/user r/w */
    545a:	c7 05 00 00 00 00 07 	movl   $0x1007,0x0
    5461:	10 00 00 
	movl $pg1+7,pg_dir+4		/*  --------- " " --------- */
    5464:	c7 05 04 00 00 00 07 	movl   $0x2007,0x4
    546b:	20 00 00 
	movl $pg2+7,pg_dir+8		/*  --------- " " --------- */
    546e:	c7 05 08 00 00 00 07 	movl   $0x3007,0x8
    5475:	30 00 00 
	movl $pg3+7,pg_dir+12		/*  --------- " " --------- */
    5478:	c7 05 0c 00 00 00 07 	movl   $0x4007,0xc
    547f:	40 00 00 
	movl $pg3+4092,%edi
    5482:	bf fc 4f 00 00       	mov    $0x4ffc,%edi
	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) */
    5487:	b8 07 f0 ff 00       	mov    $0xfff007,%eax
	std
    548c:	fd                   	std    
1:	stosl			/* fill pages backwards - more efficient :-) */
    548d:	ab                   	stos   %eax,%es:(%edi)
	subl $0x1000,%eax
    548e:	2d 00 10 00 00       	sub    $0x1000,%eax
	jge 1b
    5493:	7d f8                	jge    548d <setup_paging+0x3f>
	xorl %eax,%eax		/* pg_dir is at 0x0000 */
    5495:	31 c0                	xor    %eax,%eax
	movl %eax,%cr3		/* cr3 - page directory start */
    5497:	0f 22 d8             	mov    %eax,%cr3
	movl %cr0,%eax
    549a:	0f 20 c0             	mov    %cr0,%eax
	orl $0x80000000,%eax
    549d:	0d 00 00 00 80       	or     $0x80000000,%eax
	movl %eax,%cr0		/* set paging (PG) bit */
    54a2:	0f 22 c0             	mov    %eax,%cr0
	ret			/* this also flushes prefetch-queue */
    54a5:	c3                   	ret    
	...

000054a8 <idt_descr>:
    54a8:	ff 07                	incl   (%edi)
    54aa:	b8 54 00 00 00       	mov    $0x54,%eax
	...

000054b0 <gdt_descr>:
    54b0:	ff 07                	incl   (%edi)
    54b2:	b8 5c 00 00 66       	mov    $0x6600005c,%eax
    54b7:	90                   	nop

000054b8 <idt>:
	...

00005cb8 <gdt>:
	...
    5cc0:	ff 0f                	decl   (%edi)
    5cc2:	00 00                	add    %al,(%eax)
    5cc4:	00 9a c0 00 ff 0f    	add    %bl,0xfff00c0(%edx)
    5cca:	00 00                	add    %al,(%eax)
    5ccc:	00 92 c0 00 00 00    	add    %dl,0xc0(%edx)
	...

000064b8 <printf>:
 */
	for(;;) pause();
}

static int printf(const char *fmt, ...)
{
    64b8:	53                   	push   %ebx
    64b9:	83 ec 08             	sub    $0x8,%esp
	va_list args;
	int i;

	va_start(args, fmt);
    64bc:	8d 44 24 14          	lea    0x14(%esp),%eax
	write(1,printbuf,i=vsprintf(printbuf, fmt, args));
    64c0:	52                   	push   %edx
    64c1:	50                   	push   %eax
    64c2:	ff 74 24 18          	pushl  0x18(%esp)
    64c6:	68 c0 e5 01 00       	push   $0x1e5c0
    64cb:	e8 6e 21 00 00       	call   863e <vsprintf>
    64d0:	83 c4 0c             	add    $0xc,%esp
    64d3:	50                   	push   %eax
    64d4:	68 c0 e5 01 00       	push   $0x1e5c0
    64d9:	6a 01                	push   $0x1
    64db:	89 c3                	mov    %eax,%ebx
    64dd:	e8 46 1e 01 00       	call   18328 <write>
	va_end(args);
	return i;
}
    64e2:	83 c4 18             	add    $0x18,%esp
    64e5:	89 d8                	mov    %ebx,%eax
    64e7:	5b                   	pop    %ebx
    64e8:	c3                   	ret    
    64e9:	8d 76 00             	lea    0x0(%esi),%esi

000064ec <init>:

static char * argv[] = { "-/bin/sh",NULL };
static char * envp[] = { "HOME=/usr/root", NULL };

void init(void)
{
    64ec:	56                   	push   %esi
    64ed:	53                   	push   %ebx
    64ee:	83 ec 08             	sub    $0x8,%esp

/*	setup((void *) &drive_info);
	(void) open("/dev/tty0",O_RDWR,0);
	(void) dup(0);
	(void) dup(0);*/
	printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
    64f1:	8b 15 60 0b 02 00    	mov    0x20b60,%edx
    64f7:	89 d0                	mov    %edx,%eax
    64f9:	c1 e0 0a             	shl    $0xa,%eax
    64fc:	50                   	push   %eax
    64fd:	52                   	push   %edx
    64fe:	68 a0 86 01 00       	push   $0x186a0
    6503:	e8 b0 ff ff ff       	call   64b8 <printf>
		NR_BUFFERS*BLOCK_SIZE);
	printf("Free mem: %d bytes\n\r",memory_end-main_memory_start);
    6508:	58                   	pop    %eax
    6509:	a1 a4 e5 01 00       	mov    0x1e5a4,%eax
    650e:	5a                   	pop    %edx
    650f:	2b 05 a0 e5 01 00    	sub    0x1e5a0,%eax
    6515:	50                   	push   %eax
    6516:	68 4f 86 01 00       	push   $0x1864f
    651b:	e8 98 ff ff ff       	call   64b8 <printf>
static inline _syscall0(int,fork)
    6520:	83 c4 10             	add    $0x10,%esp
    6523:	b8 02 00 00 00       	mov    $0x2,%eax
    6528:	cd 80                	int    $0x80
    652a:	85 c0                	test   %eax,%eax
    652c:	78 3a                	js     6568 <init+0x7c>
    652e:	85 c0                	test   %eax,%eax
    6530:	89 c3                	mov    %eax,%ebx
    6532:	0f 85 0e 01 00 00    	jne    6646 <init+0x15a>
	if (!(pid=fork())) {
		close(0);
    6538:	83 ec 0c             	sub    $0xc,%esp
    653b:	6a 00                	push   $0x0
    653d:	e8 c4 1d 01 00       	call   18306 <close>
		if (open("/etc/rc",O_RDONLY,0))
    6542:	83 c4 0c             	add    $0xc,%esp
    6545:	6a 00                	push   $0x0
    6547:	6a 00                	push   $0x0
    6549:	68 64 86 01 00       	push   $0x18664
    654e:	e8 89 1d 01 00       	call   182dc <open>
    6553:	83 c4 10             	add    $0x10,%esp
    6556:	85 c0                	test   %eax,%eax
    6558:	0f 84 05 01 00 00    	je     6663 <init+0x177>
			_exit(1);
    655e:	83 ec 0c             	sub    $0xc,%esp
    6561:	6a 01                	push   $0x1
			close(0);close(1);close(2);
			setsid();
			(void) open("/dev/tty0",O_RDWR,0);
			(void) dup(0);
			(void) dup(0);
			_exit(execve("/bin/sh",argv,envp));
    6563:	e8 66 1d 01 00       	call   182ce <_exit>
static inline _syscall0(int,fork)
    6568:	f7 d8                	neg    %eax
    656a:	a3 68 2e 02 00       	mov    %eax,0x22e68
    656f:	89 e6                	mov    %esp,%esi
    6571:	8d 76 00             	lea    0x0(%esi),%esi
    6574:	b8 02 00 00 00       	mov    $0x2,%eax
    6579:	cd 80                	int    $0x80
    657b:	85 c0                	test   %eax,%eax
    657d:	78 40                	js     65bf <init+0xd3>
		if (!pid) {
    657f:	85 c0                	test   %eax,%eax
static inline _syscall0(int,fork)
    6581:	89 c3                	mov    %eax,%ebx
		if (!pid) {
    6583:	74 53                	je     65d8 <init+0xec>
    6585:	8d 76 00             	lea    0x0(%esi),%esi
		}
		while (1)
			if (pid == wait(&i))
    6588:	83 ec 0c             	sub    $0xc,%esp
    658b:	56                   	push   %esi
    658c:	e8 53 1e 01 00       	call   183e4 <wait>
    6591:	83 c4 10             	add    $0x10,%esp
    6594:	39 d8                	cmp    %ebx,%eax
    6596:	75 f0                	jne    6588 <init+0x9c>
				break;
		printf("\n\rchild %d died with code %04x\n\r",pid,i);
    6598:	51                   	push   %ecx
    6599:	ff 74 24 04          	pushl  0x4(%esp)
    659d:	53                   	push   %ebx
    659e:	68 c8 86 01 00       	push   $0x186c8
    65a3:	e8 10 ff ff ff       	call   64b8 <printf>
static inline _syscall0(int,sync)
    65a8:	83 c4 10             	add    $0x10,%esp
    65ab:	b8 24 00 00 00       	mov    $0x24,%eax
    65b0:	cd 80                	int    $0x80
    65b2:	85 c0                	test   %eax,%eax
    65b4:	79 be                	jns    6574 <init+0x88>
    65b6:	f7 d8                	neg    %eax
    65b8:	a3 68 2e 02 00       	mov    %eax,0x22e68
    65bd:	eb b5                	jmp    6574 <init+0x88>
			printf("Fork failed in init\r\n");
    65bf:	83 ec 0c             	sub    $0xc,%esp
static inline _syscall0(int,fork)
    65c2:	f7 d8                	neg    %eax
			printf("Fork failed in init\r\n");
    65c4:	68 6c 86 01 00       	push   $0x1866c
static inline _syscall0(int,fork)
    65c9:	a3 68 2e 02 00       	mov    %eax,0x22e68
			printf("Fork failed in init\r\n");
    65ce:	e8 e5 fe ff ff       	call   64b8 <printf>
			continue;
    65d3:	83 c4 10             	add    $0x10,%esp
    65d6:	eb 9c                	jmp    6574 <init+0x88>
			close(0);close(1);close(2);
    65d8:	83 ec 0c             	sub    $0xc,%esp
    65db:	6a 00                	push   $0x0
    65dd:	e8 24 1d 01 00       	call   18306 <close>
    65e2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    65e9:	e8 18 1d 01 00       	call   18306 <close>
    65ee:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    65f5:	e8 0c 1d 01 00       	call   18306 <close>
			setsid();
    65fa:	e8 75 1d 01 00       	call   18374 <setsid>
			(void) open("/dev/tty0",O_RDWR,0);
    65ff:	83 c4 0c             	add    $0xc,%esp
    6602:	6a 00                	push   $0x0
    6604:	6a 02                	push   $0x2
    6606:	68 82 86 01 00       	push   $0x18682
    660b:	e8 cc 1c 01 00       	call   182dc <open>
			(void) dup(0);
    6610:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    6617:	e8 36 1d 01 00       	call   18352 <dup>
			(void) dup(0);
    661c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    6623:	e8 2a 1d 01 00       	call   18352 <dup>
			_exit(execve("/bin/sh",argv,envp));
    6628:	53                   	push   %ebx
    6629:	68 c0 aa 01 00       	push   $0x1aac0
    662e:	68 c8 aa 01 00       	push   $0x1aac8
    6633:	68 40 86 01 00       	push   $0x18640
    6638:	e8 53 1d 01 00       	call   18390 <execve>
    663d:	83 c4 14             	add    $0x14,%esp
    6640:	50                   	push   %eax
    6641:	e8 88 1c 01 00       	call   182ce <_exit>
	if (pid>0)
    6646:	0f 8e 23 ff ff ff    	jle    656f <init+0x83>
    664c:	89 e6                	mov    %esp,%esi
		while (pid != wait(&i))
    664e:	83 ec 0c             	sub    $0xc,%esp
    6651:	56                   	push   %esi
    6652:	e8 8d 1d 01 00       	call   183e4 <wait>
    6657:	83 c4 10             	add    $0x10,%esp
    665a:	39 d8                	cmp    %ebx,%eax
    665c:	75 f0                	jne    664e <init+0x162>
    665e:	e9 0c ff ff ff       	jmp    656f <init+0x83>
		execve("/bin/sh",argv_rc,envp_rc);
    6663:	56                   	push   %esi
    6664:	68 d0 aa 01 00       	push   $0x1aad0
    6669:	68 d8 aa 01 00       	push   $0x1aad8
    666e:	68 40 86 01 00       	push   $0x18640
    6673:	e8 18 1d 01 00       	call   18390 <execve>
		_exit(2);
    6678:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
			_exit(execve("/bin/sh",argv,envp));
    667f:	e8 4a 1c 01 00       	call   182ce <_exit>

00006684 <main>:
{			/* The startup routine assumes (well, ...) this */
    6684:	55                   	push   %ebp
    6685:	89 e5                	mov    %esp,%ebp
    6687:	57                   	push   %edi
    6688:	56                   	push   %esi
    6689:	53                   	push   %ebx
    668a:	83 ec 4c             	sub    $0x4c,%esp
 	ROOT_DEV = ORIG_ROOT_DEV;
    668d:	0f b7 05 fc 01 09 00 	movzwl 0x901fc,%eax
    6694:	a3 6c 0b 02 00       	mov    %eax,0x20b6c
 	drive_info = DRIVE_INFO;
    6699:	be 80 00 09 00       	mov    $0x90080,%esi
    669e:	fc                   	cld    
    669f:	b9 08 00 00 00       	mov    $0x8,%ecx
    66a4:	bf 60 0d 02 00       	mov    $0x20d60,%edi
    66a9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	memory_end = (1<<20) + (EXT_MEM_K<<10);
    66ab:	0f b7 05 02 00 09 00 	movzwl 0x90002,%eax
    66b2:	c1 e0 0a             	shl    $0xa,%eax
    66b5:	05 00 00 10 00       	add    $0x100000,%eax
{			/* The startup routine assumes (well, ...) this */
    66ba:	83 e4 f0             	and    $0xfffffff0,%esp
	memory_end &= 0xfffff000;
    66bd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
{			/* The startup routine assumes (well, ...) this */
    66c2:	83 ec 10             	sub    $0x10,%esp
	if (memory_end > 16*1024*1024)
    66c5:	3d 00 00 00 01       	cmp    $0x1000000,%eax
    66ca:	0f 8e 4e 02 00 00    	jle    691e <main+0x29a>
		memory_end = 16*1024*1024;
    66d0:	c7 05 a4 e5 01 00 00 	movl   $0x1000000,0x1e5a4
    66d7:	00 00 01 
	if (memory_end > 12*1024*1024) 
    66da:	a1 a4 e5 01 00       	mov    0x1e5a4,%eax
    66df:	3d 00 00 c0 00       	cmp    $0xc00000,%eax
    66e4:	0f 8e 3e 02 00 00    	jle    6928 <main+0x2a4>
		buffer_memory_end = 4*1024*1024;
    66ea:	c7 05 a8 e5 01 00 00 	movl   $0x400000,0x1e5a8
    66f1:	00 40 00 
	mem_init(main_memory_start,memory_end);
    66f4:	83 ec 08             	sub    $0x8,%esp
	main_memory_start = buffer_memory_end;
    66f7:	a1 a8 e5 01 00       	mov    0x1e5a8,%eax
	mem_init(main_memory_start,memory_end);
    66fc:	ff 35 a4 e5 01 00    	pushl  0x1e5a4
    6702:	50                   	push   %eax
	main_memory_start = buffer_memory_end;
    6703:	a3 a0 e5 01 00       	mov    %eax,0x1e5a0
	mem_init(main_memory_start,memory_end);
    6708:	e8 c4 3e 00 00       	call   a5d1 <mem_init>
	trap_init();
    670d:	e8 67 14 00 00       	call   7b79 <trap_init>
	blk_dev_init();
    6712:	e8 67 ba 00 00       	call   1217e <blk_dev_init>
	chr_dev_init();
    6717:	e8 21 f4 00 00       	call   15b3d <chr_dev_init>
	tty_init();
    671c:	e8 3b eb 00 00       	call   1525c <tty_init>
{
    6721:	83 c4 10             	add    $0x10,%esp
    6724:	b9 71 00 00 00       	mov    $0x71,%ecx
		time.tm_sec = CMOS_READ(0);
    6729:	b8 80 00 00 00       	mov    $0x80,%eax
    672e:	ba 70 00 00 00       	mov    $0x70,%edx
    6733:	ee                   	out    %al,(%dx)
    6734:	eb 00                	jmp    6736 <main+0xb2>
    6736:	eb 00                	jmp    6738 <main+0xb4>
    6738:	89 ca                	mov    %ecx,%edx
    673a:	ec                   	in     (%dx),%al
    673b:	eb 00                	jmp    673d <main+0xb9>
    673d:	eb 00                	jmp    673f <main+0xbb>
		time.tm_min = CMOS_READ(2);
    673f:	ba 70 00 00 00       	mov    $0x70,%edx
		time.tm_sec = CMOS_READ(0);
    6744:	0f b6 d8             	movzbl %al,%ebx
		time.tm_min = CMOS_READ(2);
    6747:	b8 82 00 00 00       	mov    $0x82,%eax
    674c:	ee                   	out    %al,(%dx)
    674d:	eb 00                	jmp    674f <main+0xcb>
    674f:	eb 00                	jmp    6751 <main+0xcd>
    6751:	89 ca                	mov    %ecx,%edx
    6753:	ec                   	in     (%dx),%al
    6754:	eb 00                	jmp    6756 <main+0xd2>
    6756:	eb 00                	jmp    6758 <main+0xd4>
		time.tm_hour = CMOS_READ(4);
    6758:	ba 70 00 00 00       	mov    $0x70,%edx
		time.tm_min = CMOS_READ(2);
    675d:	0f b6 f0             	movzbl %al,%esi
		time.tm_hour = CMOS_READ(4);
    6760:	b8 84 00 00 00       	mov    $0x84,%eax
    6765:	ee                   	out    %al,(%dx)
    6766:	eb 00                	jmp    6768 <main+0xe4>
    6768:	eb 00                	jmp    676a <main+0xe6>
    676a:	89 ca                	mov    %ecx,%edx
    676c:	ec                   	in     (%dx),%al
    676d:	eb 00                	jmp    676f <main+0xeb>
    676f:	eb 00                	jmp    6771 <main+0xed>
		time.tm_mday = CMOS_READ(7);
    6771:	ba 70 00 00 00       	mov    $0x70,%edx
		time.tm_hour = CMOS_READ(4);
    6776:	0f b6 f8             	movzbl %al,%edi
		time.tm_mday = CMOS_READ(7);
    6779:	b8 87 00 00 00       	mov    $0x87,%eax
    677e:	ee                   	out    %al,(%dx)
    677f:	eb 00                	jmp    6781 <main+0xfd>
    6781:	eb 00                	jmp    6783 <main+0xff>
    6783:	89 ca                	mov    %ecx,%edx
    6785:	ec                   	in     (%dx),%al
    6786:	eb 00                	jmp    6788 <main+0x104>
    6788:	eb 00                	jmp    678a <main+0x106>
    678a:	0f b6 c0             	movzbl %al,%eax
    678d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		time.tm_mon = CMOS_READ(8);
    6790:	ba 70 00 00 00       	mov    $0x70,%edx
    6795:	b8 88 00 00 00       	mov    $0x88,%eax
    679a:	ee                   	out    %al,(%dx)
    679b:	eb 00                	jmp    679d <main+0x119>
    679d:	eb 00                	jmp    679f <main+0x11b>
    679f:	89 ca                	mov    %ecx,%edx
    67a1:	ec                   	in     (%dx),%al
    67a2:	eb 00                	jmp    67a4 <main+0x120>
    67a4:	eb 00                	jmp    67a6 <main+0x122>
    67a6:	0f b6 c0             	movzbl %al,%eax
    67a9:	89 45 b0             	mov    %eax,-0x50(%ebp)
		time.tm_year = CMOS_READ(9);
    67ac:	ba 70 00 00 00       	mov    $0x70,%edx
    67b1:	b8 89 00 00 00       	mov    $0x89,%eax
    67b6:	ee                   	out    %al,(%dx)
    67b7:	eb 00                	jmp    67b9 <main+0x135>
    67b9:	eb 00                	jmp    67bb <main+0x137>
    67bb:	89 ca                	mov    %ecx,%edx
    67bd:	ec                   	in     (%dx),%al
    67be:	eb 00                	jmp    67c0 <main+0x13c>
    67c0:	eb 00                	jmp    67c2 <main+0x13e>
    67c2:	0f b6 c0             	movzbl %al,%eax
    67c5:	89 45 ac             	mov    %eax,-0x54(%ebp)
	} while (time.tm_sec != CMOS_READ(0));
    67c8:	ba 70 00 00 00       	mov    $0x70,%edx
    67cd:	b8 80 00 00 00       	mov    $0x80,%eax
    67d2:	ee                   	out    %al,(%dx)
    67d3:	eb 00                	jmp    67d5 <main+0x151>
    67d5:	eb 00                	jmp    67d7 <main+0x153>
    67d7:	89 ca                	mov    %ecx,%edx
    67d9:	ec                   	in     (%dx),%al
    67da:	eb 00                	jmp    67dc <main+0x158>
    67dc:	eb 00                	jmp    67de <main+0x15a>
    67de:	0f b6 c0             	movzbl %al,%eax
    67e1:	39 c3                	cmp    %eax,%ebx
    67e3:	0f 85 40 ff ff ff    	jne    6729 <main+0xa5>
	BCD_TO_BIN(time.tm_sec);
    67e9:	89 da                	mov    %ebx,%edx
    67eb:	c1 fb 04             	sar    $0x4,%ebx
    67ee:	83 e2 0f             	and    $0xf,%edx
    67f1:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
    67f4:	8d 04 42             	lea    (%edx,%eax,2),%eax
	BCD_TO_BIN(time.tm_min);
    67f7:	89 f2                	mov    %esi,%edx
    67f9:	c1 fe 04             	sar    $0x4,%esi
	BCD_TO_BIN(time.tm_sec);
    67fc:	89 45 b8             	mov    %eax,-0x48(%ebp)
	BCD_TO_BIN(time.tm_min);
    67ff:	83 e2 0f             	and    $0xf,%edx
    6802:	8d 04 b6             	lea    (%esi,%esi,4),%eax
    6805:	8d 04 42             	lea    (%edx,%eax,2),%eax
	BCD_TO_BIN(time.tm_hour);
    6808:	89 fa                	mov    %edi,%edx
    680a:	c1 ff 04             	sar    $0x4,%edi
	BCD_TO_BIN(time.tm_min);
    680d:	89 45 bc             	mov    %eax,-0x44(%ebp)
	BCD_TO_BIN(time.tm_hour);
    6810:	83 e2 0f             	and    $0xf,%edx
    6813:	8d 04 bf             	lea    (%edi,%edi,4),%eax
    6816:	8d 04 42             	lea    (%edx,%eax,2),%eax
	BCD_TO_BIN(time.tm_mday);
    6819:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    681c:	c1 7d b4 04          	sarl   $0x4,-0x4c(%ebp)
    6820:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	BCD_TO_BIN(time.tm_mon);
    6823:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    6826:	c1 7d b0 04          	sarl   $0x4,-0x50(%ebp)
    682a:	8b 75 b0             	mov    -0x50(%ebp),%esi
	BCD_TO_BIN(time.tm_hour);
    682d:	89 45 c0             	mov    %eax,-0x40(%ebp)
	BCD_TO_BIN(time.tm_mday);
    6830:	83 e2 0f             	and    $0xf,%edx
    6833:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
	BCD_TO_BIN(time.tm_year);
    6836:	8b 4d ac             	mov    -0x54(%ebp),%ecx
    6839:	c1 7d ac 04          	sarl   $0x4,-0x54(%ebp)
	BCD_TO_BIN(time.tm_mday);
    683d:	8d 04 42             	lea    (%edx,%eax,2),%eax
	BCD_TO_BIN(time.tm_mon);
    6840:	8d 14 b6             	lea    (%esi,%esi,4),%edx
	BCD_TO_BIN(time.tm_year);
    6843:	8b 75 ac             	mov    -0x54(%ebp),%esi
    6846:	83 e1 0f             	and    $0xf,%ecx
	BCD_TO_BIN(time.tm_mday);
    6849:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	BCD_TO_BIN(time.tm_year);
    684c:	8d 04 b6             	lea    (%esi,%esi,4),%eax
    684f:	8d 04 41             	lea    (%ecx,%eax,2),%eax
	startup_time = kernel_mktime(&time);
    6852:	83 ec 0c             	sub    $0xc,%esp
	BCD_TO_BIN(time.tm_year);
    6855:	89 45 cc             	mov    %eax,-0x34(%ebp)
	BCD_TO_BIN(time.tm_mon);
    6858:	83 e3 0f             	and    $0xf,%ebx
	startup_time = kernel_mktime(&time);
    685b:	8d 45 b8             	lea    -0x48(%ebp),%eax
	time.tm_mon--;
    685e:	8d 54 53 ff          	lea    -0x1(%ebx,%edx,2),%edx
	startup_time = kernel_mktime(&time);
    6862:	50                   	push   %eax
	time.tm_mon--;
    6863:	89 55 c8             	mov    %edx,-0x38(%ebp)
	startup_time = kernel_mktime(&time);
    6866:	e8 d0 2f 00 00       	call   983b <kernel_mktime>
    686b:	83 c4 10             	add    $0x10,%esp
    686e:	a3 c4 e9 01 00       	mov    %eax,0x1e9c4
	sched_init();
    6873:	e8 cb 0c 00 00       	call   7543 <sched_init>
	buffer_init(buffer_memory_end);
    6878:	83 ec 0c             	sub    $0xc,%esp
    687b:	ff 35 a8 e5 01 00    	pushl  0x1e5a8
    6881:	e8 1e 61 00 00       	call   c9a4 <buffer_init>
	hd_init();
    6886:	e8 5b e5 00 00       	call   14de6 <hd_init>
	floppy_init();
    688b:	e8 3a d6 00 00       	call   13eca <floppy_init>
	sti();
    6890:	fb                   	sti    
	move_to_user_mode();
    6891:	89 e0                	mov    %esp,%eax
    6893:	6a 17                	push   $0x17
    6895:	50                   	push   %eax
    6896:	9c                   	pushf  
    6897:	6a 0f                	push   $0xf
    6899:	68 9f 68 00 00       	push   $0x689f
    689e:	cf                   	iret   
    689f:	b8 17 00 00 00       	mov    $0x17,%eax
    68a4:	8e d8                	mov    %eax,%ds
    68a6:	8e c0                	mov    %eax,%es
    68a8:	8e e0                	mov    %eax,%fs
    68aa:	8e e8                	mov    %eax,%gs
static inline _syscall1(int,setup,void *,BIOS)
    68ac:	31 c0                	xor    %eax,%eax
    68ae:	83 c4 10             	add    $0x10,%esp
    68b1:	bb 60 0d 02 00       	mov    $0x20d60,%ebx
    68b6:	cd 80                	int    $0x80
    68b8:	85 c0                	test   %eax,%eax
    68ba:	0f 88 9d 00 00 00    	js     695d <main+0x2d9>
	(void) open("/dev/tty0",O_RDWR,0);
    68c0:	51                   	push   %ecx
    68c1:	6a 00                	push   $0x0
    68c3:	6a 02                	push   $0x2
    68c5:	68 82 86 01 00       	push   $0x18682
    68ca:	e8 0d 1a 01 00       	call   182dc <open>
	(void) dup(0);
    68cf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    68d6:	e8 77 1a 01 00       	call   18352 <dup>
	(void) dup(0);
    68db:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    68e2:	e8 6b 1a 01 00       	call   18352 <dup>
	(void) open("/var/process.log",O_CREAT|O_TRUNC|O_WRONLY,0666);
    68e7:	83 c4 0c             	add    $0xc,%esp
    68ea:	68 b6 01 00 00       	push   $0x1b6
    68ef:	68 41 02 00 00       	push   $0x241
    68f4:	68 8c 86 01 00       	push   $0x1868c
    68f9:	e8 de 19 01 00       	call   182dc <open>
static inline _syscall0(int,fork)
    68fe:	83 c4 10             	add    $0x10,%esp
    6901:	b8 02 00 00 00       	mov    $0x2,%eax
    6906:	cd 80                	int    $0x80
    6908:	85 c0                	test   %eax,%eax
    690a:	78 48                	js     6954 <main+0x2d0>
    690c:	85 c0                	test   %eax,%eax
    690e:	74 3d                	je     694d <main+0x2c9>
    6910:	ba 1d 00 00 00       	mov    $0x1d,%edx
    6915:	8d 76 00             	lea    0x0(%esi),%esi
static inline _syscall0(int,pause)
    6918:	89 d0                	mov    %edx,%eax
    691a:	cd 80                	int    $0x80
    691c:	eb fa                	jmp    6918 <main+0x294>
    691e:	a3 a4 e5 01 00       	mov    %eax,0x1e5a4
    6923:	e9 b2 fd ff ff       	jmp    66da <main+0x56>
	else if (memory_end > 6*1024*1024)
    6928:	3d 00 00 60 00       	cmp    $0x600000,%eax
    692d:	7e 0f                	jle    693e <main+0x2ba>
		buffer_memory_end = 2*1024*1024;
    692f:	c7 05 a8 e5 01 00 00 	movl   $0x200000,0x1e5a8
    6936:	00 20 00 
    6939:	e9 b6 fd ff ff       	jmp    66f4 <main+0x70>
		buffer_memory_end = 1*1024*1024;
    693e:	c7 05 a8 e5 01 00 00 	movl   $0x100000,0x1e5a8
    6945:	00 10 00 
    6948:	e9 a7 fd ff ff       	jmp    66f4 <main+0x70>
		init();
    694d:	e8 9a fb ff ff       	call   64ec <init>
    6952:	eb bc                	jmp    6910 <main+0x28c>
static inline _syscall0(int,fork)
    6954:	f7 d8                	neg    %eax
    6956:	a3 68 2e 02 00       	mov    %eax,0x22e68
    695b:	eb b3                	jmp    6910 <main+0x28c>
static inline _syscall1(int,setup,void *,BIOS)
    695d:	f7 d8                	neg    %eax
    695f:	a3 68 2e 02 00       	mov    %eax,0x22e68
    6964:	e9 57 ff ff ff       	jmp    68c0 <main+0x23c>
    6969:	90                   	nop

0000696a <show_task>:
#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))



void show_task(int nr,struct task_struct * p)
{
    696a:	56                   	push   %esi
    696b:	53                   	push   %ebx
    696c:	83 ec 04             	sub    $0x4,%esp
    696f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
	int i,j = 4096-sizeof(struct task_struct);
    6973:	be 44 0c 00 00       	mov    $0xc44,%esi

	printk("%d: pid=%d, state=%d, ",nr,p->pid,p->state);
    6978:	ff 33                	pushl  (%ebx)
    697a:	ff b3 2c 02 00 00    	pushl  0x22c(%ebx)
    6980:	ff 74 24 18          	pushl  0x18(%esp)
    6984:	68 b4 87 01 00       	push   $0x187b4
    6989:	e8 c5 19 00 00       	call   8353 <printk>
	i=0;
    698e:	b8 00 00 00 00       	mov    $0x0,%eax
	while (i<j && !((char *)(p+1))[i])
    6993:	83 c4 10             	add    $0x10,%esp
		i++;
    6996:	80 bb bc 03 00 00 00 	cmpb   $0x0,0x3bc(%ebx)
    699d:	75 0f                	jne    69ae <show_task+0x44>
    699f:	40                   	inc    %eax
    69a0:	39 f0                	cmp    %esi,%eax
    69a2:	7d 0a                	jge    69ae <show_task+0x44>
    69a4:	80 bc 03 bc 03 00 00 	cmpb   $0x0,0x3bc(%ebx,%eax,1)
    69ab:	00 
    69ac:	74 f1                	je     699f <show_task+0x35>
	printk("%d (of %d) chars free in kernel stack\n\r",i,j);
    69ae:	83 ec 04             	sub    $0x4,%esp
    69b1:	56                   	push   %esi
    69b2:	50                   	push   %eax
    69b3:	68 d4 89 01 00       	push   $0x189d4
    69b8:	e8 96 19 00 00       	call   8353 <printk>
}
    69bd:	83 c4 14             	add    $0x14,%esp
    69c0:	5b                   	pop    %ebx
    69c1:	5e                   	pop    %esi
    69c2:	c3                   	ret    

000069c3 <show_stat>:

void show_stat(void)
{
    69c3:	55                   	push   %ebp
    69c4:	57                   	push   %edi
    69c5:	56                   	push   %esi
    69c6:	53                   	push   %ebx
    69c7:	83 ec 0c             	sub    $0xc,%esp
	int i;

	for (i=0;i<NR_TASKS;i++)
    69ca:	be 00 00 00 00       	mov    $0x0,%esi
    69cf:	bd 40 bc 01 00       	mov    $0x1bc40,%ebp
		if (task[i])
    69d4:	83 7c b5 00 00       	cmpl   $0x0,0x0(%ebp,%esi,4)
    69d9:	74 4e                	je     6a29 <show_stat+0x66>
{
    69db:	8b 5c b5 00          	mov    0x0(%ebp,%esi,4),%ebx
	int i,j = 4096-sizeof(struct task_struct);
    69df:	bf 44 0c 00 00       	mov    $0xc44,%edi
	printk("%d: pid=%d, state=%d, ",nr,p->pid,p->state);
    69e4:	ff 33                	pushl  (%ebx)
    69e6:	ff b3 2c 02 00 00    	pushl  0x22c(%ebx)
    69ec:	56                   	push   %esi
    69ed:	68 b4 87 01 00       	push   $0x187b4
    69f2:	e8 5c 19 00 00       	call   8353 <printk>
    69f7:	83 c4 10             	add    $0x10,%esp
	i=0;
    69fa:	b8 00 00 00 00       	mov    $0x0,%eax
		i++;
    69ff:	80 bb bc 03 00 00 00 	cmpb   $0x0,0x3bc(%ebx)
    6a06:	75 0f                	jne    6a17 <show_stat+0x54>
    6a08:	40                   	inc    %eax
    6a09:	39 f8                	cmp    %edi,%eax
    6a0b:	7d 0a                	jge    6a17 <show_stat+0x54>
    6a0d:	80 bc 03 bc 03 00 00 	cmpb   $0x0,0x3bc(%ebx,%eax,1)
    6a14:	00 
    6a15:	74 f1                	je     6a08 <show_stat+0x45>
	printk("%d (of %d) chars free in kernel stack\n\r",i,j);
    6a17:	83 ec 04             	sub    $0x4,%esp
    6a1a:	57                   	push   %edi
    6a1b:	50                   	push   %eax
    6a1c:	68 d4 89 01 00       	push   $0x189d4
    6a21:	e8 2d 19 00 00       	call   8353 <printk>
    6a26:	83 c4 10             	add    $0x10,%esp
	for (i=0;i<NR_TASKS;i++)
    6a29:	46                   	inc    %esi
    6a2a:	83 fe 3f             	cmp    $0x3f,%esi
    6a2d:	7e a5                	jle    69d4 <show_stat+0x11>
			show_task(i,task[i]);
}
    6a2f:	83 c4 0c             	add    $0xc,%esp
    6a32:	5b                   	pop    %ebx
    6a33:	5e                   	pop    %esi
    6a34:	5f                   	pop    %edi
    6a35:	5d                   	pop    %ebp
    6a36:	c3                   	ret    

00006a37 <math_state_restore>:
 *  'math_state_restore()' saves the current math information in the
 * old math state array, and gets the new ones from the current task
 */
void math_state_restore()
{
	if (last_task_used_math == current)
    6a37:	a1 c8 e9 01 00       	mov    0x1e9c8,%eax
    6a3c:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    6a42:	74 36                	je     6a7a <math_state_restore+0x43>
		return;
	__asm__("fwait");
    6a44:	9b                   	fwait
	if (last_task_used_math) {
    6a45:	85 c0                	test   %eax,%eax
    6a47:	74 06                	je     6a4f <math_state_restore+0x18>
		__asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
    6a49:	dd b0 50 03 00 00    	fnsave 0x350(%eax)
	}
	last_task_used_math=current;
    6a4f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6a54:	a3 c8 e9 01 00       	mov    %eax,0x1e9c8
	if (current->used_math) {
    6a59:	66 83 b8 64 02 00 00 	cmpw   $0x0,0x264(%eax)
    6a60:	00 
    6a61:	74 07                	je     6a6a <math_state_restore+0x33>
		__asm__("frstor %0"::"m" (current->tss.i387));
    6a63:	dd a0 50 03 00 00    	frstor 0x350(%eax)
    6a69:	c3                   	ret    
	} else {
		__asm__("fninit"::);
    6a6a:	db e3                	fninit 
		current->used_math=1;
    6a6c:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6a71:	66 c7 80 64 02 00 00 	movw   $0x1,0x264(%eax)
    6a78:	01 00 
    6a7a:	c3                   	ret    

00006a7b <schedule>:
 *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other
 * tasks can run. It can not be killed, and it cannot sleep. The 'state'
 * information in task[0] is never used.
 */
void schedule(void)
{
    6a7b:	53                   	push   %ebx
    6a7c:	83 ec 08             	sub    $0x8,%esp
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6a7f:	b9 3c bd 01 00       	mov    $0x1bd3c,%ecx
    6a84:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6a8a:	76 5a                	jbe    6ae6 <schedule+0x6b>
		if (*p) {
    6a8c:	83 39 00             	cmpl   $0x0,(%ecx)
    6a8f:	74 4a                	je     6adb <schedule+0x60>
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6a91:	8b 11                	mov    (%ecx),%edx
    6a93:	83 ba 4c 02 00 00 00 	cmpl   $0x0,0x24c(%edx)
    6a9a:	74 20                	je     6abc <schedule+0x41>
    6a9c:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6aa1:	39 82 4c 02 00 00    	cmp    %eax,0x24c(%edx)
    6aa7:	7d 13                	jge    6abc <schedule+0x41>
					(*p)->signal |= (1<<(SIGALRM-1));
    6aa9:	81 4a 0c 00 20 00 00 	orl    $0x2000,0xc(%edx)
					(*p)->alarm = 0;
    6ab0:	8b 01                	mov    (%ecx),%eax
    6ab2:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    6ab9:	00 00 00 
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
    6abc:	8b 11                	mov    (%ecx),%edx
    6abe:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    6ac4:	25 ff fe fb ff       	and    $0xfffbfeff,%eax
    6ac9:	f7 d0                	not    %eax
    6acb:	85 42 0c             	test   %eax,0xc(%edx)
    6ace:	74 0b                	je     6adb <schedule+0x60>
    6ad0:	83 3a 01             	cmpl   $0x1,(%edx)
    6ad3:	75 06                	jne    6adb <schedule+0x60>
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
    6ad5:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6adb:	83 e9 04             	sub    $0x4,%ecx
    6ade:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6ae4:	77 a6                	ja     6a8c <schedule+0x11>
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	*/
	i = (current_index+1) % NR_TASKS;
    6ae6:	8b 15 cc e9 01 00    	mov    0x1e9cc,%edx
    6aec:	8d 5a 01             	lea    0x1(%edx),%ebx
    6aef:	89 d8                	mov    %ebx,%eax
    6af1:	85 db                	test   %ebx,%ebx
    6af3:	79 03                	jns    6af8 <schedule+0x7d>
    6af5:	8d 42 40             	lea    0x40(%edx),%eax
    6af8:	83 e0 c0             	and    $0xffffffc0,%eax
    6afb:	29 c3                	sub    %eax,%ebx
	while(1)
	{
		p = &task[i];
		if (*p) break;
    6afd:	83 3c 9d 40 bc 01 00 	cmpl   $0x0,0x1bc40(,%ebx,4)
    6b04:	00 
    6b05:	75 15                	jne    6b1c <schedule+0xa1>
		i = (i+1) % NR_TASKS;
    6b07:	8d 4b 01             	lea    0x1(%ebx),%ecx
    6b0a:	89 c8                	mov    %ecx,%eax
    6b0c:	85 c9                	test   %ecx,%ecx
    6b0e:	79 03                	jns    6b13 <schedule+0x98>
    6b10:	8d 43 40             	lea    0x40(%ebx),%eax
    6b13:	83 e0 c0             	and    $0xffffffc0,%eax
    6b16:	89 cb                	mov    %ecx,%ebx
    6b18:	29 c3                	sub    %eax,%ebx
    6b1a:	eb e1                	jmp    6afd <schedule+0x82>
	}
	current_index = i;
    6b1c:	89 1d cc e9 01 00    	mov    %ebx,0x1e9cc
	next = current_index;
	switch_to(next);
    6b22:	89 da                	mov    %ebx,%edx
    6b24:	c1 e2 04             	shl    $0x4,%edx
    6b27:	83 c2 20             	add    $0x20,%edx
    6b2a:	8b 0c 9d 40 bc 01 00 	mov    0x1bc40(,%ebx,4),%ecx
    6b31:	39 0d 20 bc 01 00    	cmp    %ecx,0x1bc20
    6b37:	74 18                	je     6b51 <schedule+0xd6>
    6b39:	66 89 54 24 04       	mov    %dx,0x4(%esp)
    6b3e:	87 0d 20 bc 01 00    	xchg   %ecx,0x1bc20
    6b44:	ff 2c 24             	ljmp   *(%esp)
    6b47:	39 0d c8 e9 01 00    	cmp    %ecx,0x1e9c8
    6b4d:	75 02                	jne    6b51 <schedule+0xd6>
    6b4f:	0f 06                	clts   
}
    6b51:	83 c4 08             	add    $0x8,%esp
    6b54:	5b                   	pop    %ebx
    6b55:	c3                   	ret    

00006b56 <sys_pause>:

int sys_pause(void)
{
    6b56:	53                   	push   %ebx
    6b57:	83 ec 14             	sub    $0x14,%esp

	current->state = TASK_INTERRUPTIBLE;
    6b5a:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6b5f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    6b65:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6b6a:	50                   	push   %eax
    6b6b:	6a 57                	push   $0x57
    6b6d:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6b72:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6b78:	68 cb 87 01 00       	push   $0x187cb
    6b7d:	6a 03                	push   $0x3
    6b7f:	e8 0a 18 00 00       	call   838e <fprintk>
{
    6b84:	83 c4 20             	add    $0x20,%esp
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6b87:	b9 3c bd 01 00       	mov    $0x1bd3c,%ecx
    6b8c:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6b92:	76 5a                	jbe    6bee <sys_pause+0x98>
		if (*p) {
    6b94:	83 39 00             	cmpl   $0x0,(%ecx)
    6b97:	74 4a                	je     6be3 <sys_pause+0x8d>
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6b99:	8b 11                	mov    (%ecx),%edx
    6b9b:	83 ba 4c 02 00 00 00 	cmpl   $0x0,0x24c(%edx)
    6ba2:	74 20                	je     6bc4 <sys_pause+0x6e>
    6ba4:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6ba9:	39 82 4c 02 00 00    	cmp    %eax,0x24c(%edx)
    6baf:	7d 13                	jge    6bc4 <sys_pause+0x6e>
					(*p)->signal |= (1<<(SIGALRM-1));
    6bb1:	81 4a 0c 00 20 00 00 	orl    $0x2000,0xc(%edx)
					(*p)->alarm = 0;
    6bb8:	8b 01                	mov    (%ecx),%eax
    6bba:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    6bc1:	00 00 00 
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
    6bc4:	8b 11                	mov    (%ecx),%edx
    6bc6:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    6bcc:	25 ff fe fb ff       	and    $0xfffbfeff,%eax
    6bd1:	f7 d0                	not    %eax
    6bd3:	85 42 0c             	test   %eax,0xc(%edx)
    6bd6:	74 0b                	je     6be3 <sys_pause+0x8d>
    6bd8:	83 3a 01             	cmpl   $0x1,(%edx)
    6bdb:	75 06                	jne    6be3 <sys_pause+0x8d>
				(*p)->state=TASK_RUNNING;
    6bdd:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6be3:	83 e9 04             	sub    $0x4,%ecx
    6be6:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6bec:	77 a6                	ja     6b94 <sys_pause+0x3e>
	i = (current_index+1) % NR_TASKS;
    6bee:	8b 15 cc e9 01 00    	mov    0x1e9cc,%edx
    6bf4:	8d 5a 01             	lea    0x1(%edx),%ebx
    6bf7:	89 d8                	mov    %ebx,%eax
    6bf9:	85 db                	test   %ebx,%ebx
    6bfb:	79 03                	jns    6c00 <sys_pause+0xaa>
    6bfd:	8d 42 40             	lea    0x40(%edx),%eax
    6c00:	83 e0 c0             	and    $0xffffffc0,%eax
    6c03:	29 c3                	sub    %eax,%ebx
		if (*p) break;
    6c05:	83 3c 9d 40 bc 01 00 	cmpl   $0x0,0x1bc40(,%ebx,4)
    6c0c:	00 
    6c0d:	75 15                	jne    6c24 <sys_pause+0xce>
		i = (i+1) % NR_TASKS;
    6c0f:	8d 4b 01             	lea    0x1(%ebx),%ecx
    6c12:	89 c8                	mov    %ecx,%eax
    6c14:	85 c9                	test   %ecx,%ecx
    6c16:	79 03                	jns    6c1b <sys_pause+0xc5>
    6c18:	8d 43 40             	lea    0x40(%ebx),%eax
    6c1b:	83 e0 c0             	and    $0xffffffc0,%eax
    6c1e:	89 cb                	mov    %ecx,%ebx
    6c20:	29 c3                	sub    %eax,%ebx
    6c22:	eb e1                	jmp    6c05 <sys_pause+0xaf>
	current_index = i;
    6c24:	89 1d cc e9 01 00    	mov    %ebx,0x1e9cc
	switch_to(next);
    6c2a:	89 da                	mov    %ebx,%edx
    6c2c:	c1 e2 04             	shl    $0x4,%edx
    6c2f:	83 c2 20             	add    $0x20,%edx
    6c32:	8b 0c 9d 40 bc 01 00 	mov    0x1bc40(,%ebx,4),%ecx
    6c39:	39 0d 20 bc 01 00    	cmp    %ecx,0x1bc20
    6c3f:	74 18                	je     6c59 <sys_pause+0x103>
    6c41:	66 89 54 24 04       	mov    %dx,0x4(%esp)
    6c46:	87 0d 20 bc 01 00    	xchg   %ecx,0x1bc20
    6c4c:	ff 2c 24             	ljmp   *(%esp)
    6c4f:	39 0d c8 e9 01 00    	cmp    %ecx,0x1e9c8
    6c55:	75 02                	jne    6c59 <sys_pause+0x103>
    6c57:	0f 06                	clts   
	schedule();
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'R', jiffies);
    6c59:	83 ec 0c             	sub    $0xc,%esp
    6c5c:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6c61:	50                   	push   %eax
    6c62:	6a 52                	push   $0x52
    6c64:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6c69:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6c6f:	68 cb 87 01 00       	push   $0x187cb
    6c74:	6a 03                	push   $0x3
    6c76:	e8 13 17 00 00       	call   838e <fprintk>
	return 0;
}
    6c7b:	b8 00 00 00 00       	mov    $0x0,%eax
    6c80:	83 c4 28             	add    $0x28,%esp
    6c83:	5b                   	pop    %ebx
    6c84:	c3                   	ret    

00006c85 <sleep_on>:

void sleep_on(struct task_struct **p)
{
    6c85:	56                   	push   %esi
    6c86:	53                   	push   %ebx
    6c87:	83 ec 14             	sub    $0x14,%esp
    6c8a:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	struct task_struct *tmp;

	if (!p)
    6c8e:	85 db                	test   %ebx,%ebx
    6c90:	0f 84 77 01 00 00    	je     6e0d <sleep_on+0x188>
		return;
	if (current == &(init_task.task))
    6c96:	81 3d 20 bc 01 00 20 	cmpl   $0x1ac20,0x1bc20
    6c9d:	ac 01 00 
    6ca0:	75 10                	jne    6cb2 <sleep_on+0x2d>
		panic("task[0] trying to sleep");
    6ca2:	83 ec 0c             	sub    $0xc,%esp
    6ca5:	68 d7 87 01 00       	push   $0x187d7
    6caa:	e8 6a 16 00 00       	call   8319 <panic>
    6caf:	83 c4 10             	add    $0x10,%esp
	tmp = *p;
    6cb2:	8b 33                	mov    (%ebx),%esi
	*p = current;
    6cb4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6cb9:	89 03                	mov    %eax,(%ebx)
	current->state = TASK_UNINTERRUPTIBLE;
    6cbb:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6cc0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)

	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    6cc6:	83 ec 0c             	sub    $0xc,%esp
    6cc9:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6cce:	50                   	push   %eax
    6ccf:	6a 57                	push   $0x57
    6cd1:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6cd6:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6cdc:	68 cb 87 01 00       	push   $0x187cb
    6ce1:	6a 03                	push   $0x3
    6ce3:	e8 a6 16 00 00       	call   838e <fprintk>
{
    6ce8:	83 c4 20             	add    $0x20,%esp
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6ceb:	b9 3c bd 01 00       	mov    $0x1bd3c,%ecx
    6cf0:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6cf6:	76 5a                	jbe    6d52 <sleep_on+0xcd>
		if (*p) {
    6cf8:	83 39 00             	cmpl   $0x0,(%ecx)
    6cfb:	74 4a                	je     6d47 <sleep_on+0xc2>
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6cfd:	8b 11                	mov    (%ecx),%edx
    6cff:	83 ba 4c 02 00 00 00 	cmpl   $0x0,0x24c(%edx)
    6d06:	74 20                	je     6d28 <sleep_on+0xa3>
    6d08:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6d0d:	39 82 4c 02 00 00    	cmp    %eax,0x24c(%edx)
    6d13:	7d 13                	jge    6d28 <sleep_on+0xa3>
					(*p)->signal |= (1<<(SIGALRM-1));
    6d15:	81 4a 0c 00 20 00 00 	orl    $0x2000,0xc(%edx)
					(*p)->alarm = 0;
    6d1c:	8b 01                	mov    (%ecx),%eax
    6d1e:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    6d25:	00 00 00 
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
    6d28:	8b 11                	mov    (%ecx),%edx
    6d2a:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    6d30:	25 ff fe fb ff       	and    $0xfffbfeff,%eax
    6d35:	f7 d0                	not    %eax
    6d37:	85 42 0c             	test   %eax,0xc(%edx)
    6d3a:	74 0b                	je     6d47 <sleep_on+0xc2>
    6d3c:	83 3a 01             	cmpl   $0x1,(%edx)
    6d3f:	75 06                	jne    6d47 <sleep_on+0xc2>
				(*p)->state=TASK_RUNNING;
    6d41:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6d47:	83 e9 04             	sub    $0x4,%ecx
    6d4a:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6d50:	77 a6                	ja     6cf8 <sleep_on+0x73>
	i = (current_index+1) % NR_TASKS;
    6d52:	8b 15 cc e9 01 00    	mov    0x1e9cc,%edx
    6d58:	8d 5a 01             	lea    0x1(%edx),%ebx
    6d5b:	89 d8                	mov    %ebx,%eax
    6d5d:	85 db                	test   %ebx,%ebx
    6d5f:	79 03                	jns    6d64 <sleep_on+0xdf>
    6d61:	8d 42 40             	lea    0x40(%edx),%eax
    6d64:	83 e0 c0             	and    $0xffffffc0,%eax
    6d67:	29 c3                	sub    %eax,%ebx
		if (*p) break;
    6d69:	83 3c 9d 40 bc 01 00 	cmpl   $0x0,0x1bc40(,%ebx,4)
    6d70:	00 
    6d71:	75 15                	jne    6d88 <sleep_on+0x103>
		i = (i+1) % NR_TASKS;
    6d73:	8d 4b 01             	lea    0x1(%ebx),%ecx
    6d76:	89 c8                	mov    %ecx,%eax
    6d78:	85 c9                	test   %ecx,%ecx
    6d7a:	79 03                	jns    6d7f <sleep_on+0xfa>
    6d7c:	8d 43 40             	lea    0x40(%ebx),%eax
    6d7f:	83 e0 c0             	and    $0xffffffc0,%eax
    6d82:	89 cb                	mov    %ecx,%ebx
    6d84:	29 c3                	sub    %eax,%ebx
    6d86:	eb e1                	jmp    6d69 <sleep_on+0xe4>
	current_index = i;
    6d88:	89 1d cc e9 01 00    	mov    %ebx,0x1e9cc
	switch_to(next);
    6d8e:	89 da                	mov    %ebx,%edx
    6d90:	c1 e2 04             	shl    $0x4,%edx
    6d93:	83 c2 20             	add    $0x20,%edx
    6d96:	8b 0c 9d 40 bc 01 00 	mov    0x1bc40(,%ebx,4),%ecx
    6d9d:	39 0d 20 bc 01 00    	cmp    %ecx,0x1bc20
    6da3:	74 19                	je     6dbe <sleep_on+0x139>
    6da5:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
    6daa:	87 0d 20 bc 01 00    	xchg   %ecx,0x1bc20
    6db0:	ff 6c 24 08          	ljmp   *0x8(%esp)
    6db4:	39 0d c8 e9 01 00    	cmp    %ecx,0x1e9c8
    6dba:	75 02                	jne    6dbe <sleep_on+0x139>
    6dbc:	0f 06                	clts   
	schedule();
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'R', jiffies);
    6dbe:	83 ec 0c             	sub    $0xc,%esp
    6dc1:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6dc6:	50                   	push   %eax
    6dc7:	6a 52                	push   $0x52
    6dc9:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6dce:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6dd4:	68 cb 87 01 00       	push   $0x187cb
    6dd9:	6a 03                	push   $0x3
    6ddb:	e8 ae 15 00 00       	call   838e <fprintk>

	if (tmp){
    6de0:	83 c4 20             	add    $0x20,%esp
    6de3:	85 f6                	test   %esi,%esi
    6de5:	74 26                	je     6e0d <sleep_on+0x188>
		fprintk(3, "%ld\t%c\t%ld\n", tmp->pid, 'J', jiffies);
    6de7:	83 ec 0c             	sub    $0xc,%esp
    6dea:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6def:	50                   	push   %eax
    6df0:	6a 4a                	push   $0x4a
    6df2:	ff b6 2c 02 00 00    	pushl  0x22c(%esi)
    6df8:	68 cb 87 01 00       	push   $0x187cb
    6dfd:	6a 03                	push   $0x3
    6dff:	e8 8a 15 00 00       	call   838e <fprintk>
		tmp->state=0;
    6e04:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    6e0a:	83 c4 20             	add    $0x20,%esp
	}
}
    6e0d:	83 c4 14             	add    $0x14,%esp
    6e10:	5b                   	pop    %ebx
    6e11:	5e                   	pop    %esi
    6e12:	c3                   	ret    

00006e13 <interruptible_sleep_on>:

void interruptible_sleep_on(struct task_struct **p)
{
    6e13:	57                   	push   %edi
    6e14:	56                   	push   %esi
    6e15:	53                   	push   %ebx
    6e16:	83 ec 10             	sub    $0x10,%esp
    6e19:	8b 74 24 20          	mov    0x20(%esp),%esi
	struct task_struct *tmp;

	if (!p)
    6e1d:	85 f6                	test   %esi,%esi
    6e1f:	0f 84 77 01 00 00    	je     6f9c <interruptible_sleep_on+0x189>
		return;
	if (current == &(init_task.task))
    6e25:	81 3d 20 bc 01 00 20 	cmpl   $0x1ac20,0x1bc20
    6e2c:	ac 01 00 
    6e2f:	75 10                	jne    6e41 <interruptible_sleep_on+0x2e>
		panic("task[0] trying to sleep");
    6e31:	83 ec 0c             	sub    $0xc,%esp
    6e34:	68 d7 87 01 00       	push   $0x187d7
    6e39:	e8 db 14 00 00       	call   8319 <panic>
    6e3e:	83 c4 10             	add    $0x10,%esp
	tmp=*p;
    6e41:	8b 3e                	mov    (%esi),%edi
	*p=current;
    6e43:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6e48:	89 06                	mov    %eax,(%esi)
repeat:	current->state = TASK_INTERRUPTIBLE;
    6e4a:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6e4f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    6e55:	83 ec 0c             	sub    $0xc,%esp
    6e58:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6e5d:	50                   	push   %eax
    6e5e:	6a 57                	push   $0x57
    6e60:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6e65:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6e6b:	68 cb 87 01 00       	push   $0x187cb
    6e70:	6a 03                	push   $0x3
    6e72:	e8 17 15 00 00       	call   838e <fprintk>
{
    6e77:	83 c4 20             	add    $0x20,%esp
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6e7a:	b9 3c bd 01 00       	mov    $0x1bd3c,%ecx
    6e7f:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6e85:	76 5a                	jbe    6ee1 <interruptible_sleep_on+0xce>
		if (*p) {
    6e87:	83 39 00             	cmpl   $0x0,(%ecx)
    6e8a:	74 4a                	je     6ed6 <interruptible_sleep_on+0xc3>
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6e8c:	8b 11                	mov    (%ecx),%edx
    6e8e:	83 ba 4c 02 00 00 00 	cmpl   $0x0,0x24c(%edx)
    6e95:	74 20                	je     6eb7 <interruptible_sleep_on+0xa4>
    6e97:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6e9c:	39 82 4c 02 00 00    	cmp    %eax,0x24c(%edx)
    6ea2:	7d 13                	jge    6eb7 <interruptible_sleep_on+0xa4>
					(*p)->signal |= (1<<(SIGALRM-1));
    6ea4:	81 4a 0c 00 20 00 00 	orl    $0x2000,0xc(%edx)
					(*p)->alarm = 0;
    6eab:	8b 01                	mov    (%ecx),%eax
    6ead:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    6eb4:	00 00 00 
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
    6eb7:	8b 11                	mov    (%ecx),%edx
    6eb9:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    6ebf:	25 ff fe fb ff       	and    $0xfffbfeff,%eax
    6ec4:	f7 d0                	not    %eax
    6ec6:	85 42 0c             	test   %eax,0xc(%edx)
    6ec9:	74 0b                	je     6ed6 <interruptible_sleep_on+0xc3>
    6ecb:	83 3a 01             	cmpl   $0x1,(%edx)
    6ece:	75 06                	jne    6ed6 <interruptible_sleep_on+0xc3>
				(*p)->state=TASK_RUNNING;
    6ed0:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6ed6:	83 e9 04             	sub    $0x4,%ecx
    6ed9:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    6edf:	77 a6                	ja     6e87 <interruptible_sleep_on+0x74>
	i = (current_index+1) % NR_TASKS;
    6ee1:	8b 15 cc e9 01 00    	mov    0x1e9cc,%edx
    6ee7:	8d 5a 01             	lea    0x1(%edx),%ebx
    6eea:	89 d8                	mov    %ebx,%eax
    6eec:	85 db                	test   %ebx,%ebx
    6eee:	79 03                	jns    6ef3 <interruptible_sleep_on+0xe0>
    6ef0:	8d 42 40             	lea    0x40(%edx),%eax
    6ef3:	83 e0 c0             	and    $0xffffffc0,%eax
    6ef6:	29 c3                	sub    %eax,%ebx
		if (*p) break;
    6ef8:	83 3c 9d 40 bc 01 00 	cmpl   $0x0,0x1bc40(,%ebx,4)
    6eff:	00 
    6f00:	75 15                	jne    6f17 <interruptible_sleep_on+0x104>
		i = (i+1) % NR_TASKS;
    6f02:	8d 4b 01             	lea    0x1(%ebx),%ecx
    6f05:	89 c8                	mov    %ecx,%eax
    6f07:	85 c9                	test   %ecx,%ecx
    6f09:	79 03                	jns    6f0e <interruptible_sleep_on+0xfb>
    6f0b:	8d 43 40             	lea    0x40(%ebx),%eax
    6f0e:	83 e0 c0             	and    $0xffffffc0,%eax
    6f11:	89 cb                	mov    %ecx,%ebx
    6f13:	29 c3                	sub    %eax,%ebx
    6f15:	eb e1                	jmp    6ef8 <interruptible_sleep_on+0xe5>
	current_index = i;
    6f17:	89 1d cc e9 01 00    	mov    %ebx,0x1e9cc
	switch_to(next);
    6f1d:	89 da                	mov    %ebx,%edx
    6f1f:	c1 e2 04             	shl    $0x4,%edx
    6f22:	83 c2 20             	add    $0x20,%edx
    6f25:	8b 0c 9d 40 bc 01 00 	mov    0x1bc40(,%ebx,4),%ecx
    6f2c:	39 0d 20 bc 01 00    	cmp    %ecx,0x1bc20
    6f32:	74 19                	je     6f4d <interruptible_sleep_on+0x13a>
    6f34:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
    6f39:	87 0d 20 bc 01 00    	xchg   %ecx,0x1bc20
    6f3f:	ff 6c 24 08          	ljmp   *0x8(%esp)
    6f43:	39 0d c8 e9 01 00    	cmp    %ecx,0x1e9c8
    6f49:	75 02                	jne    6f4d <interruptible_sleep_on+0x13a>
    6f4b:	0f 06                	clts   
	schedule();
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'R', jiffies);
    6f4d:	83 ec 0c             	sub    $0xc,%esp
    6f50:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    6f55:	50                   	push   %eax
    6f56:	6a 52                	push   $0x52
    6f58:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    6f5d:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6f63:	68 cb 87 01 00       	push   $0x187cb
    6f68:	6a 03                	push   $0x3
    6f6a:	e8 1f 14 00 00       	call   838e <fprintk>

	if (*p && *p != current) {
    6f6f:	83 c4 20             	add    $0x20,%esp
    6f72:	83 3e 00             	cmpl   $0x0,(%esi)
    6f75:	74 15                	je     6f8c <interruptible_sleep_on+0x179>
    6f77:	8b 06                	mov    (%esi),%eax
    6f79:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    6f7f:	74 0b                	je     6f8c <interruptible_sleep_on+0x179>
		(**p).state=0;
    6f81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		goto repeat;
    6f87:	e9 be fe ff ff       	jmp    6e4a <interruptible_sleep_on+0x37>
	}
	*p=NULL;
    6f8c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	if (tmp)
    6f92:	85 ff                	test   %edi,%edi
    6f94:	74 06                	je     6f9c <interruptible_sleep_on+0x189>
		tmp->state=0;
    6f96:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
    6f9c:	83 c4 10             	add    $0x10,%esp
    6f9f:	5b                   	pop    %ebx
    6fa0:	5e                   	pop    %esi
    6fa1:	5f                   	pop    %edi
    6fa2:	c3                   	ret    

00006fa3 <wake_up>:

void wake_up(struct task_struct **p)
{
    6fa3:	8b 54 24 04          	mov    0x4(%esp),%edx
	if (p && *p) {
    6fa7:	85 d2                	test   %edx,%edx
    6fa9:	74 13                	je     6fbe <wake_up+0x1b>
    6fab:	83 3a 00             	cmpl   $0x0,(%edx)
    6fae:	74 0e                	je     6fbe <wake_up+0x1b>
		(**p).state=0;
    6fb0:	8b 02                	mov    (%edx),%eax
    6fb2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*p=NULL;
    6fb8:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    6fbe:	c3                   	ret    

00006fbf <ticks_to_floppy_on>:
static int  mon_timer[4]={0,0,0,0};
static int moff_timer[4]={0,0,0,0};
unsigned char current_DOR = 0x0C;

int ticks_to_floppy_on(unsigned int nr)
{
    6fbf:	56                   	push   %esi
    6fc0:	53                   	push   %ebx
    6fc1:	83 ec 04             	sub    $0x4,%esp
    6fc4:	8b 74 24 10          	mov    0x10(%esp),%esi
	extern unsigned char selected;
	unsigned char mask = 0x10 << nr;
    6fc8:	b8 10 00 00 00       	mov    $0x10,%eax
    6fcd:	89 c3                	mov    %eax,%ebx
    6fcf:	89 f1                	mov    %esi,%ecx
    6fd1:	d3 e3                	shl    %cl,%ebx

	if (nr>3)
    6fd3:	83 fe 03             	cmp    $0x3,%esi
    6fd6:	76 10                	jbe    6fe8 <ticks_to_floppy_on+0x29>
		panic("floppy_on: nr>3");
    6fd8:	83 ec 0c             	sub    $0xc,%esp
    6fdb:	68 ef 87 01 00       	push   $0x187ef
    6fe0:	e8 34 13 00 00       	call   8319 <panic>
    6fe5:	83 c4 10             	add    $0x10,%esp
	moff_timer[nr]=10000;		/* 100 s = very big :-) */
    6fe8:	c7 04 b5 f0 e9 01 00 	movl   $0x2710,0x1e9f0(,%esi,4)
    6fef:	10 27 00 00 
	cli();				/* use floppy_off to turn it off */
    6ff3:	fa                   	cli    
	mask |= current_DOR;
    6ff4:	0a 1d 48 bd 01 00    	or     0x1bd48,%bl
	if (!selected) {
    6ffa:	80 3d dc 0b 02 00 00 	cmpb   $0x0,0x20bdc
    7001:	75 05                	jne    7008 <ticks_to_floppy_on+0x49>
		mask &= 0xFC;
    7003:	83 e3 fc             	and    $0xfffffffc,%ebx
		mask |= nr;
    7006:	09 f3                	or     %esi,%ebx
	}
	if (mask != current_DOR) {
    7008:	3a 1d 48 bd 01 00    	cmp    0x1bd48,%bl
    700e:	74 37                	je     7047 <ticks_to_floppy_on+0x88>
		outb(mask,FD_DOR);
    7010:	ba f2 03 00 00       	mov    $0x3f2,%edx
    7015:	88 d8                	mov    %bl,%al
    7017:	ee                   	out    %al,(%dx)
		if ((mask ^ current_DOR) & 0xf0)
    7018:	32 05 48 bd 01 00    	xor    0x1bd48,%al
    701e:	a8 f0                	test   $0xf0,%al
    7020:	74 0d                	je     702f <ticks_to_floppy_on+0x70>
			mon_timer[nr] = HZ/2;
    7022:	c7 04 b5 e0 e9 01 00 	movl   $0x32,0x1e9e0(,%esi,4)
    7029:	32 00 00 00 
    702d:	eb 12                	jmp    7041 <ticks_to_floppy_on+0x82>
		else if (mon_timer[nr] < 2)
    702f:	b8 e0 e9 01 00       	mov    $0x1e9e0,%eax
    7034:	83 3c b0 01          	cmpl   $0x1,(%eax,%esi,4)
    7038:	7f 07                	jg     7041 <ticks_to_floppy_on+0x82>
			mon_timer[nr] = 2;
    703a:	c7 04 b0 02 00 00 00 	movl   $0x2,(%eax,%esi,4)
		current_DOR = mask;
    7041:	88 1d 48 bd 01 00    	mov    %bl,0x1bd48
	}
	sti();
    7047:	fb                   	sti    
	return mon_timer[nr];
    7048:	8b 04 b5 e0 e9 01 00 	mov    0x1e9e0(,%esi,4),%eax
}
    704f:	83 c4 04             	add    $0x4,%esp
    7052:	5b                   	pop    %ebx
    7053:	5e                   	pop    %esi
    7054:	c3                   	ret    

00007055 <floppy_on>:

void floppy_on(unsigned int nr)
{
    7055:	55                   	push   %ebp
    7056:	57                   	push   %edi
    7057:	56                   	push   %esi
    7058:	53                   	push   %ebx
    7059:	83 ec 0c             	sub    $0xc,%esp
    705c:	8b 6c 24 20          	mov    0x20(%esp),%ebp
	cli();
    7060:	fa                   	cli    
    7061:	89 ee                	mov    %ebp,%esi
    7063:	b8 10 00 00 00       	mov    $0x10,%eax
    7068:	89 c7                	mov    %eax,%edi
    706a:	89 e9                	mov    %ebp,%ecx
    706c:	d3 e7                	shl    %cl,%edi
	while (ticks_to_floppy_on(nr))
    706e:	eb 13                	jmp    7083 <floppy_on+0x2e>
		sleep_on(nr+wait_motor);
    7070:	83 ec 0c             	sub    $0xc,%esp
    7073:	8d 04 ad d0 e9 01 00 	lea    0x1e9d0(,%ebp,4),%eax
    707a:	50                   	push   %eax
    707b:	e8 05 fc ff ff       	call   6c85 <sleep_on>
    7080:	83 c4 10             	add    $0x10,%esp
	unsigned char mask = 0x10 << nr;
    7083:	89 fb                	mov    %edi,%ebx
	if (nr>3)
    7085:	83 fe 03             	cmp    $0x3,%esi
    7088:	76 10                	jbe    709a <floppy_on+0x45>
		panic("floppy_on: nr>3");
    708a:	83 ec 0c             	sub    $0xc,%esp
    708d:	68 ef 87 01 00       	push   $0x187ef
    7092:	e8 82 12 00 00       	call   8319 <panic>
    7097:	83 c4 10             	add    $0x10,%esp
	moff_timer[nr]=10000;		/* 100 s = very big :-) */
    709a:	c7 04 b5 f0 e9 01 00 	movl   $0x2710,0x1e9f0(,%esi,4)
    70a1:	10 27 00 00 
	cli();				/* use floppy_off to turn it off */
    70a5:	fa                   	cli    
	mask |= current_DOR;
    70a6:	0a 1d 48 bd 01 00    	or     0x1bd48,%bl
	if (!selected) {
    70ac:	80 3d dc 0b 02 00 00 	cmpb   $0x0,0x20bdc
    70b3:	75 05                	jne    70ba <floppy_on+0x65>
		mask &= 0xFC;
    70b5:	83 e3 fc             	and    $0xfffffffc,%ebx
		mask |= nr;
    70b8:	09 f3                	or     %esi,%ebx
	if (mask != current_DOR) {
    70ba:	3a 1d 48 bd 01 00    	cmp    0x1bd48,%bl
    70c0:	74 37                	je     70f9 <floppy_on+0xa4>
		outb(mask,FD_DOR);
    70c2:	ba f2 03 00 00       	mov    $0x3f2,%edx
    70c7:	88 d8                	mov    %bl,%al
    70c9:	ee                   	out    %al,(%dx)
		if ((mask ^ current_DOR) & 0xf0)
    70ca:	32 05 48 bd 01 00    	xor    0x1bd48,%al
    70d0:	a8 f0                	test   $0xf0,%al
    70d2:	74 0d                	je     70e1 <floppy_on+0x8c>
			mon_timer[nr] = HZ/2;
    70d4:	c7 04 b5 e0 e9 01 00 	movl   $0x32,0x1e9e0(,%esi,4)
    70db:	32 00 00 00 
    70df:	eb 12                	jmp    70f3 <floppy_on+0x9e>
		else if (mon_timer[nr] < 2)
    70e1:	b8 e0 e9 01 00       	mov    $0x1e9e0,%eax
    70e6:	83 3c b0 01          	cmpl   $0x1,(%eax,%esi,4)
    70ea:	7f 07                	jg     70f3 <floppy_on+0x9e>
			mon_timer[nr] = 2;
    70ec:	c7 04 b0 02 00 00 00 	movl   $0x2,(%eax,%esi,4)
		current_DOR = mask;
    70f3:	88 1d 48 bd 01 00    	mov    %bl,0x1bd48
	sti();
    70f9:	fb                   	sti    
{
    70fa:	83 3c b5 e0 e9 01 00 	cmpl   $0x0,0x1e9e0(,%esi,4)
    7101:	00 
    7102:	0f 85 68 ff ff ff    	jne    7070 <floppy_on+0x1b>
	sti();
    7108:	fb                   	sti    
}
    7109:	83 c4 0c             	add    $0xc,%esp
    710c:	5b                   	pop    %ebx
    710d:	5e                   	pop    %esi
    710e:	5f                   	pop    %edi
    710f:	5d                   	pop    %ebp
    7110:	c3                   	ret    

00007111 <floppy_off>:

void floppy_off(unsigned int nr)
{
	moff_timer[nr]=3*HZ;
    7111:	8b 44 24 04          	mov    0x4(%esp),%eax
    7115:	c7 04 85 f0 e9 01 00 	movl   $0x12c,0x1e9f0(,%eax,4)
    711c:	2c 01 00 00 
}
    7120:	c3                   	ret    

00007121 <do_floppy_timer>:

void do_floppy_timer(void)
{
    7121:	56                   	push   %esi
    7122:	53                   	push   %ebx
	int i;
	unsigned char mask = 0x10;
    7123:	be 10 00 00 00       	mov    $0x10,%esi

	for (i=0 ; i<4 ; i++,mask <<= 1) {
    7128:	b9 00 00 00 00       	mov    $0x0,%ecx
    712d:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (!(mask & current_DOR))
    7132:	89 f0                	mov    %esi,%eax
    7134:	84 05 48 bd 01 00    	test   %al,0x1bd48
    713a:	74 65                	je     71a1 <do_floppy_timer+0x80>
			continue;
		if (mon_timer[i]) {
    713c:	b8 e0 e9 01 00       	mov    $0x1e9e0,%eax
    7141:	83 3c 88 00          	cmpl   $0x0,(%eax,%ecx,4)
    7145:	74 34                	je     717b <do_floppy_timer+0x5a>
			if (!--mon_timer[i])
    7147:	ff 0c 88             	decl   (%eax,%ecx,4)
    714a:	83 3c 88 00          	cmpl   $0x0,(%eax,%ecx,4)
    714e:	75 51                	jne    71a1 <do_floppy_timer+0x80>
{
    7150:	8d 83 d0 e9 01 00    	lea    0x1e9d0(%ebx),%eax
	if (p && *p) {
    7156:	85 c0                	test   %eax,%eax
    7158:	74 47                	je     71a1 <do_floppy_timer+0x80>
    715a:	83 bb d0 e9 01 00 00 	cmpl   $0x0,0x1e9d0(%ebx)
    7161:	74 3e                	je     71a1 <do_floppy_timer+0x80>
		(**p).state=0;
    7163:	8b 83 d0 e9 01 00    	mov    0x1e9d0(%ebx),%eax
    7169:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*p=NULL;
    716f:	c7 83 d0 e9 01 00 00 	movl   $0x0,0x1e9d0(%ebx)
    7176:	00 00 00 
    7179:	eb 26                	jmp    71a1 <do_floppy_timer+0x80>
				wake_up(i+wait_motor);
		} else if (!moff_timer[i]) {
    717b:	83 bb f0 e9 01 00 00 	cmpl   $0x0,0x1e9f0(%ebx)
    7182:	75 17                	jne    719b <do_floppy_timer+0x7a>
			current_DOR &= ~mask;
    7184:	89 f0                	mov    %esi,%eax
    7186:	f7 d0                	not    %eax
    7188:	22 05 48 bd 01 00    	and    0x1bd48,%al
    718e:	a2 48 bd 01 00       	mov    %al,0x1bd48
			outb(current_DOR,FD_DOR);
    7193:	ba f2 03 00 00       	mov    $0x3f2,%edx
    7198:	ee                   	out    %al,(%dx)
    7199:	eb 06                	jmp    71a1 <do_floppy_timer+0x80>
		} else
			moff_timer[i]--;
    719b:	ff 8b f0 e9 01 00    	decl   0x1e9f0(%ebx)
	for (i=0 ; i<4 ; i++,mask <<= 1) {
    71a1:	41                   	inc    %ecx
    71a2:	83 c3 04             	add    $0x4,%ebx
    71a5:	d1 e6                	shl    %esi
    71a7:	83 f9 03             	cmp    $0x3,%ecx
    71aa:	7e 86                	jle    7132 <do_floppy_timer+0x11>
	}
}
    71ac:	5b                   	pop    %ebx
    71ad:	5e                   	pop    %esi
    71ae:	c3                   	ret    

000071af <add_timer>:
	void (*fn)();
	struct timer_list * next;
} timer_list[TIME_REQUESTS], * next_timer = NULL;

void add_timer(long jiffies, void (*fn)(void))
{
    71af:	57                   	push   %edi
    71b0:	56                   	push   %esi
    71b1:	53                   	push   %ebx
    71b2:	8b 7c 24 10          	mov    0x10(%esp),%edi
    71b6:	8b 74 24 14          	mov    0x14(%esp),%esi
	struct timer_list * p;

	if (!fn)
    71ba:	85 f6                	test   %esi,%esi
    71bc:	0f 84 92 00 00 00    	je     7254 <add_timer+0xa5>
		return;
	cli();
    71c2:	fa                   	cli    
	if (jiffies <= 0)
    71c3:	85 ff                	test   %edi,%edi
    71c5:	7f 07                	jg     71ce <add_timer+0x1f>
		(fn)();
    71c7:	ff d6                	call   *%esi
    71c9:	e9 85 00 00 00       	jmp    7253 <add_timer+0xa4>
	else {
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    71ce:	bb 20 ea 01 00       	mov    $0x1ea20,%ebx
    71d3:	81 fb 20 ed 01 00    	cmp    $0x1ed20,%ebx
    71d9:	73 1b                	jae    71f6 <add_timer+0x47>
			if (!p->fn)
    71db:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    71df:	74 0d                	je     71ee <add_timer+0x3f>
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    71e1:	83 c3 0c             	add    $0xc,%ebx
    71e4:	81 fb 20 ed 01 00    	cmp    $0x1ed20,%ebx
    71ea:	72 ef                	jb     71db <add_timer+0x2c>
    71ec:	eb 08                	jmp    71f6 <add_timer+0x47>
				break;
		if (p >= timer_list + TIME_REQUESTS)
    71ee:	81 fb 20 ed 01 00    	cmp    $0x1ed20,%ebx
    71f4:	72 10                	jb     7206 <add_timer+0x57>
			panic("No more time requests free");
    71f6:	83 ec 0c             	sub    $0xc,%esp
    71f9:	68 ff 87 01 00       	push   $0x187ff
    71fe:	e8 16 11 00 00       	call   8319 <panic>
    7203:	83 c4 10             	add    $0x10,%esp
		p->fn = fn;
    7206:	89 73 04             	mov    %esi,0x4(%ebx)
		p->jiffies = jiffies;
    7209:	89 3b                	mov    %edi,(%ebx)
		p->next = next_timer;
    720b:	a1 00 ea 01 00       	mov    0x1ea00,%eax
    7210:	89 43 08             	mov    %eax,0x8(%ebx)
		next_timer = p;
    7213:	89 1d 00 ea 01 00    	mov    %ebx,0x1ea00
			p->fn = p->next->fn;
			p->next->fn = fn;
			jiffies = p->jiffies;
			p->jiffies = p->next->jiffies;
			p->next->jiffies = jiffies;
			p = p->next;
    7219:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    721d:	74 34                	je     7253 <add_timer+0xa4>
    721f:	8b 43 08             	mov    0x8(%ebx),%eax
    7222:	89 c2                	mov    %eax,%edx
    7224:	8b 00                	mov    (%eax),%eax
    7226:	3b 03                	cmp    (%ebx),%eax
    7228:	7d 29                	jge    7253 <add_timer+0xa4>
			p->jiffies -= p->next->jiffies;
    722a:	8b 0b                	mov    (%ebx),%ecx
    722c:	2b 0a                	sub    (%edx),%ecx
    722e:	89 0b                	mov    %ecx,(%ebx)
			fn = p->fn;
    7230:	8b 73 04             	mov    0x4(%ebx),%esi
			p->fn = p->next->fn;
    7233:	8b 42 04             	mov    0x4(%edx),%eax
    7236:	89 43 04             	mov    %eax,0x4(%ebx)
			p->next->fn = fn;
    7239:	89 72 04             	mov    %esi,0x4(%edx)
			p->jiffies = p->next->jiffies;
    723c:	8b 02                	mov    (%edx),%eax
    723e:	89 03                	mov    %eax,(%ebx)
			p->next->jiffies = jiffies;
    7240:	89 0a                	mov    %ecx,(%edx)
			p = p->next;
    7242:	89 d3                	mov    %edx,%ebx
    7244:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    7248:	74 09                	je     7253 <add_timer+0xa4>
    724a:	8b 52 08             	mov    0x8(%edx),%edx
    724d:	8b 02                	mov    (%edx),%eax
    724f:	39 c8                	cmp    %ecx,%eax
    7251:	7c d7                	jl     722a <add_timer+0x7b>
		}
	}
	sti();
    7253:	fb                   	sti    
}
    7254:	5b                   	pop    %ebx
    7255:	5e                   	pop    %esi
    7256:	5f                   	pop    %edi
    7257:	c3                   	ret    

00007258 <do_timer>:

void do_timer(long cpl)
{
    7258:	57                   	push   %edi
    7259:	56                   	push   %esi
    725a:	53                   	push   %ebx
    725b:	83 ec 10             	sub    $0x10,%esp
    725e:	8b 7c 24 20          	mov    0x20(%esp),%edi
	extern int beepcount;
	extern void sysbeepstop(void);

	if (beepcount)
    7262:	83 3d c0 0c 02 00 00 	cmpl   $0x0,0x20cc0
    7269:	74 14                	je     727f <do_timer+0x27>
		if (!--beepcount)
    726b:	ff 0d c0 0c 02 00    	decl   0x20cc0
    7271:	83 3d c0 0c 02 00 00 	cmpl   $0x0,0x20cc0
    7278:	75 05                	jne    727f <do_timer+0x27>
			sysbeepstop();
    727a:	e8 38 02 01 00       	call   174b7 <sysbeepstop>

	if (cpl)
    727f:	85 ff                	test   %edi,%edi
    7281:	74 0d                	je     7290 <do_timer+0x38>
		current->utime++;
    7283:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7288:	ff 80 50 02 00 00    	incl   0x250(%eax)
    728e:	eb 0b                	jmp    729b <do_timer+0x43>
	else
		current->stime++;
    7290:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7295:	ff 80 54 02 00 00    	incl   0x254(%eax)

	if (next_timer) {
    729b:	83 3d 00 ea 01 00 00 	cmpl   $0x0,0x1ea00
    72a2:	74 4b                	je     72ef <do_timer+0x97>
		next_timer->jiffies--;
    72a4:	a1 00 ea 01 00       	mov    0x1ea00,%eax
    72a9:	ff 08                	decl   (%eax)
			void (*fn)(void);
			
			fn = next_timer->fn;
			next_timer->fn = NULL;
			next_timer = next_timer->next;
			(fn)();
    72ab:	83 3d 00 ea 01 00 00 	cmpl   $0x0,0x1ea00
    72b2:	74 3b                	je     72ef <do_timer+0x97>
    72b4:	a1 00 ea 01 00       	mov    0x1ea00,%eax
    72b9:	89 c2                	mov    %eax,%edx
    72bb:	83 38 00             	cmpl   $0x0,(%eax)
    72be:	7f 2f                	jg     72ef <do_timer+0x97>
			fn = next_timer->fn;
    72c0:	89 d0                	mov    %edx,%eax
    72c2:	8b 52 04             	mov    0x4(%edx),%edx
			next_timer->fn = NULL;
    72c5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			next_timer = next_timer->next;
    72cc:	a1 00 ea 01 00       	mov    0x1ea00,%eax
    72d1:	8b 40 08             	mov    0x8(%eax),%eax
    72d4:	a3 00 ea 01 00       	mov    %eax,0x1ea00
			(fn)();
    72d9:	ff d2                	call   *%edx
    72db:	83 3d 00 ea 01 00 00 	cmpl   $0x0,0x1ea00
    72e2:	74 0b                	je     72ef <do_timer+0x97>
    72e4:	8b 15 00 ea 01 00    	mov    0x1ea00,%edx
    72ea:	83 3a 00             	cmpl   $0x0,(%edx)
    72ed:	7e d1                	jle    72c0 <do_timer+0x68>
		}
	}
	if (current_DOR & 0xf0)
    72ef:	f6 05 48 bd 01 00 f0 	testb  $0xf0,0x1bd48
    72f6:	0f 84 89 00 00 00    	je     7385 <do_timer+0x12d>
	unsigned char mask = 0x10;
    72fc:	be 10 00 00 00       	mov    $0x10,%esi
	for (i=0 ; i<4 ; i++,mask <<= 1) {
    7301:	b9 00 00 00 00       	mov    $0x0,%ecx
    7306:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (!(mask & current_DOR))
    730b:	89 f0                	mov    %esi,%eax
    730d:	84 05 48 bd 01 00    	test   %al,0x1bd48
    7313:	74 65                	je     737a <do_timer+0x122>
		if (mon_timer[i]) {
    7315:	b8 e0 e9 01 00       	mov    $0x1e9e0,%eax
    731a:	83 3c 88 00          	cmpl   $0x0,(%eax,%ecx,4)
    731e:	74 34                	je     7354 <do_timer+0xfc>
			if (!--mon_timer[i])
    7320:	ff 0c 88             	decl   (%eax,%ecx,4)
    7323:	83 3c 88 00          	cmpl   $0x0,(%eax,%ecx,4)
    7327:	75 51                	jne    737a <do_timer+0x122>
{
    7329:	8d 83 d0 e9 01 00    	lea    0x1e9d0(%ebx),%eax
	if (p && *p) {
    732f:	85 c0                	test   %eax,%eax
    7331:	74 47                	je     737a <do_timer+0x122>
    7333:	83 bb d0 e9 01 00 00 	cmpl   $0x0,0x1e9d0(%ebx)
    733a:	74 3e                	je     737a <do_timer+0x122>
		(**p).state=0;
    733c:	8b 83 d0 e9 01 00    	mov    0x1e9d0(%ebx),%eax
    7342:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*p=NULL;
    7348:	c7 83 d0 e9 01 00 00 	movl   $0x0,0x1e9d0(%ebx)
    734f:	00 00 00 
    7352:	eb 26                	jmp    737a <do_timer+0x122>
		} else if (!moff_timer[i]) {
    7354:	83 bb f0 e9 01 00 00 	cmpl   $0x0,0x1e9f0(%ebx)
    735b:	75 17                	jne    7374 <do_timer+0x11c>
			current_DOR &= ~mask;
    735d:	89 f0                	mov    %esi,%eax
    735f:	f7 d0                	not    %eax
    7361:	22 05 48 bd 01 00    	and    0x1bd48,%al
    7367:	a2 48 bd 01 00       	mov    %al,0x1bd48
			outb(current_DOR,FD_DOR);
    736c:	ba f2 03 00 00       	mov    $0x3f2,%edx
    7371:	ee                   	out    %al,(%dx)
    7372:	eb 06                	jmp    737a <do_timer+0x122>
			moff_timer[i]--;
    7374:	ff 8b f0 e9 01 00    	decl   0x1e9f0(%ebx)
	for (i=0 ; i<4 ; i++,mask <<= 1) {
    737a:	41                   	inc    %ecx
    737b:	83 c3 04             	add    $0x4,%ebx
    737e:	d1 e6                	shl    %esi
    7380:	83 f9 03             	cmp    $0x3,%ecx
    7383:	7e 86                	jle    730b <do_timer+0xb3>
		do_floppy_timer();
	if ((--current->counter)>0) return;
    7385:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    738a:	ff 48 04             	decl   0x4(%eax)
    738d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    7391:	0f 8f e7 00 00 00    	jg     747e <do_timer+0x226>
	current->counter=0;
    7397:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    739c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	if (!cpl) return;
    73a3:	85 ff                	test   %edi,%edi
    73a5:	0f 84 d3 00 00 00    	je     747e <do_timer+0x226>
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    73ab:	b9 3c bd 01 00       	mov    $0x1bd3c,%ecx
    73b0:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    73b6:	76 5a                	jbe    7412 <do_timer+0x1ba>
		if (*p) {
    73b8:	83 39 00             	cmpl   $0x0,(%ecx)
    73bb:	74 4a                	je     7407 <do_timer+0x1af>
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    73bd:	8b 11                	mov    (%ecx),%edx
    73bf:	83 ba 4c 02 00 00 00 	cmpl   $0x0,0x24c(%edx)
    73c6:	74 20                	je     73e8 <do_timer+0x190>
    73c8:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    73cd:	39 82 4c 02 00 00    	cmp    %eax,0x24c(%edx)
    73d3:	7d 13                	jge    73e8 <do_timer+0x190>
					(*p)->signal |= (1<<(SIGALRM-1));
    73d5:	81 4a 0c 00 20 00 00 	orl    $0x2000,0xc(%edx)
					(*p)->alarm = 0;
    73dc:	8b 01                	mov    (%ecx),%eax
    73de:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
    73e5:	00 00 00 
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
    73e8:	8b 11                	mov    (%ecx),%edx
    73ea:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    73f0:	25 ff fe fb ff       	and    $0xfffbfeff,%eax
    73f5:	f7 d0                	not    %eax
    73f7:	85 42 0c             	test   %eax,0xc(%edx)
    73fa:	74 0b                	je     7407 <do_timer+0x1af>
    73fc:	83 3a 01             	cmpl   $0x1,(%edx)
    73ff:	75 06                	jne    7407 <do_timer+0x1af>
				(*p)->state=TASK_RUNNING;
    7401:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    7407:	83 e9 04             	sub    $0x4,%ecx
    740a:	81 f9 40 bc 01 00    	cmp    $0x1bc40,%ecx
    7410:	77 a6                	ja     73b8 <do_timer+0x160>
	i = (current_index+1) % NR_TASKS;
    7412:	8b 15 cc e9 01 00    	mov    0x1e9cc,%edx
    7418:	8d 5a 01             	lea    0x1(%edx),%ebx
    741b:	89 d8                	mov    %ebx,%eax
    741d:	85 db                	test   %ebx,%ebx
    741f:	79 03                	jns    7424 <do_timer+0x1cc>
    7421:	8d 42 40             	lea    0x40(%edx),%eax
    7424:	83 e0 c0             	and    $0xffffffc0,%eax
    7427:	29 c3                	sub    %eax,%ebx
		if (*p) break;
    7429:	83 3c 9d 40 bc 01 00 	cmpl   $0x0,0x1bc40(,%ebx,4)
    7430:	00 
    7431:	75 15                	jne    7448 <do_timer+0x1f0>
		i = (i+1) % NR_TASKS;
    7433:	8d 4b 01             	lea    0x1(%ebx),%ecx
    7436:	89 c8                	mov    %ecx,%eax
    7438:	85 c9                	test   %ecx,%ecx
    743a:	79 03                	jns    743f <do_timer+0x1e7>
    743c:	8d 43 40             	lea    0x40(%ebx),%eax
    743f:	83 e0 c0             	and    $0xffffffc0,%eax
    7442:	89 cb                	mov    %ecx,%ebx
    7444:	29 c3                	sub    %eax,%ebx
    7446:	eb e1                	jmp    7429 <do_timer+0x1d1>
	current_index = i;
    7448:	89 1d cc e9 01 00    	mov    %ebx,0x1e9cc
	switch_to(next);
    744e:	89 da                	mov    %ebx,%edx
    7450:	c1 e2 04             	shl    $0x4,%edx
    7453:	83 c2 20             	add    $0x20,%edx
    7456:	8b 0c 9d 40 bc 01 00 	mov    0x1bc40(,%ebx,4),%ecx
    745d:	39 0d 20 bc 01 00    	cmp    %ecx,0x1bc20
    7463:	74 19                	je     747e <do_timer+0x226>
    7465:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
    746a:	87 0d 20 bc 01 00    	xchg   %ecx,0x1bc20
    7470:	ff 6c 24 08          	ljmp   *0x8(%esp)
    7474:	39 0d c8 e9 01 00    	cmp    %ecx,0x1e9c8
    747a:	75 02                	jne    747e <do_timer+0x226>
    747c:	0f 06                	clts   
	schedule();
}
    747e:	83 c4 10             	add    $0x10,%esp
    7481:	5b                   	pop    %ebx
    7482:	5e                   	pop    %esi
    7483:	5f                   	pop    %edi
    7484:	c3                   	ret    

00007485 <sys_alarm>:

int sys_alarm(long seconds)
{
    7485:	56                   	push   %esi
    7486:	53                   	push   %ebx
    7487:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
	int old = current->alarm;
    748b:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7490:	8b 88 4c 02 00 00    	mov    0x24c(%eax),%ecx

	if (old)
    7496:	85 c9                	test   %ecx,%ecx
    7498:	74 1a                	je     74b4 <sys_alarm+0x2f>
		old = (old - jiffies) / HZ;
    749a:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    749f:	29 c1                	sub    %eax,%ecx
    74a1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    74a6:	f7 e9                	imul   %ecx
    74a8:	c1 fa 05             	sar    $0x5,%edx
    74ab:	89 c8                	mov    %ecx,%eax
    74ad:	c1 f8 1f             	sar    $0x1f,%eax
    74b0:	89 d1                	mov    %edx,%ecx
    74b2:	29 c1                	sub    %eax,%ecx
	current->alarm = (seconds>0)?(jiffies+HZ*seconds):0;
    74b4:	8b 35 20 bc 01 00    	mov    0x1bc20,%esi
    74ba:	b8 00 00 00 00       	mov    $0x0,%eax
    74bf:	85 db                	test   %ebx,%ebx
    74c1:	7e 0f                	jle    74d2 <sys_alarm+0x4d>
    74c3:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
    74c6:	8d 04 80             	lea    (%eax,%eax,4),%eax
    74c9:	8b 15 c0 e9 01 00    	mov    0x1e9c0,%edx
    74cf:	8d 04 82             	lea    (%edx,%eax,4),%eax
    74d2:	89 86 4c 02 00 00    	mov    %eax,0x24c(%esi)
	return (old);
}
    74d8:	89 c8                	mov    %ecx,%eax
    74da:	5b                   	pop    %ebx
    74db:	5e                   	pop    %esi
    74dc:	c3                   	ret    

000074dd <sys_getpid>:

int sys_getpid(void)
{
	return current->pid;
    74dd:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    74e2:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
}
    74e8:	c3                   	ret    

000074e9 <sys_getppid>:

int sys_getppid(void)
{
	return current->father;
    74e9:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    74ee:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
}
    74f4:	c3                   	ret    

000074f5 <sys_getuid>:

int sys_getuid(void)
{
	return current->uid;
    74f5:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    74fa:	0f b7 80 40 02 00 00 	movzwl 0x240(%eax),%eax
}
    7501:	c3                   	ret    

00007502 <sys_geteuid>:

int sys_geteuid(void)
{
	return current->euid;
    7502:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7507:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
}
    750e:	c3                   	ret    

0000750f <sys_getgid>:

int sys_getgid(void)
{
	return current->gid;
    750f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7514:	0f b7 80 46 02 00 00 	movzwl 0x246(%eax),%eax
}
    751b:	c3                   	ret    

0000751c <sys_getegid>:

int sys_getegid(void)
{
	return current->egid;
    751c:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7521:	0f b7 80 48 02 00 00 	movzwl 0x248(%eax),%eax
}
    7528:	c3                   	ret    

00007529 <sys_nice>:

int sys_nice(long increment)
{
	if (current->priority-increment>0)
    7529:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    752f:	8b 42 08             	mov    0x8(%edx),%eax
    7532:	2b 44 24 04          	sub    0x4(%esp),%eax
    7536:	85 c0                	test   %eax,%eax
    7538:	7e 03                	jle    753d <sys_nice+0x14>
		current->priority -= increment;
    753a:	89 42 08             	mov    %eax,0x8(%edx)
	return 0;
}
    753d:	b8 00 00 00 00       	mov    $0x0,%eax
    7542:	c3                   	ret    

00007543 <sched_init>:
	int i;
	struct desc_struct * p;

	if (sizeof(struct sigaction) != 16)
		panic("Struct sigaction MUST be 16 bytes");
	set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
    7543:	b8 08 af 01 00       	mov    $0x1af08,%eax
    7548:	66 c7 05 d8 5c 00 00 	movw   $0x68,0x5cd8
    754f:	68 00 
    7551:	66 a3 da 5c 00 00    	mov    %ax,0x5cda
    7557:	c1 c8 10             	ror    $0x10,%eax
    755a:	a2 dc 5c 00 00       	mov    %al,0x5cdc
    755f:	c6 05 dd 5c 00 00 89 	movb   $0x89,0x5cdd
    7566:	c6 05 de 5c 00 00 00 	movb   $0x0,0x5cde
    756d:	88 25 df 5c 00 00    	mov    %ah,0x5cdf
    7573:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
    7576:	b8 f0 ae 01 00       	mov    $0x1aef0,%eax
    757b:	66 c7 05 e0 5c 00 00 	movw   $0x68,0x5ce0
    7582:	68 00 
    7584:	66 a3 e2 5c 00 00    	mov    %ax,0x5ce2
    758a:	c1 c8 10             	ror    $0x10,%eax
    758d:	a2 e4 5c 00 00       	mov    %al,0x5ce4
    7592:	c6 05 e5 5c 00 00 82 	movb   $0x82,0x5ce5
    7599:	c6 05 e6 5c 00 00 00 	movb   $0x0,0x5ce6
    75a0:	88 25 e7 5c 00 00    	mov    %ah,0x5ce7
    75a6:	c1 c8 10             	ror    $0x10,%eax
	p = gdt+2+FIRST_TSS_ENTRY;
    75a9:	b8 e8 5c 00 00       	mov    $0x5ce8,%eax
	for(i=1;i<NR_TASKS;i++) {
    75ae:	ba 01 00 00 00       	mov    $0x1,%edx
    75b3:	b9 40 bc 01 00       	mov    $0x1bc40,%ecx
		task[i] = NULL;
    75b8:	c7 04 91 00 00 00 00 	movl   $0x0,(%ecx,%edx,4)
		p->a=p->b=0;
    75bf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    75c6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		p++;
    75cc:	83 c0 08             	add    $0x8,%eax
		p->a=p->b=0;
    75cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    75d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		p++;
    75dc:	83 c0 08             	add    $0x8,%eax
	for(i=1;i<NR_TASKS;i++) {
    75df:	42                   	inc    %edx
    75e0:	83 fa 3f             	cmp    $0x3f,%edx
    75e3:	7e d3                	jle    75b8 <sched_init+0x75>
	}
/* Clear NT, so that we won't have troubles with that later on */
	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
    75e5:	9c                   	pushf  
    75e6:	81 24 24 ff bf ff ff 	andl   $0xffffbfff,(%esp)
    75ed:	9d                   	popf   
	ltr(0);
    75ee:	b8 20 00 00 00       	mov    $0x20,%eax
    75f3:	0f 00 d8             	ltr    %ax
	lldt(0);
    75f6:	b0 28                	mov    $0x28,%al
    75f8:	0f 00 d0             	lldt   %ax
	outb_p(0x36,0x43);		/* binary, mode 3, LSB/MSB, ch 0 */
    75fb:	b0 36                	mov    $0x36,%al
    75fd:	ba 43 00 00 00       	mov    $0x43,%edx
    7602:	ee                   	out    %al,(%dx)
    7603:	eb 00                	jmp    7605 <sched_init+0xc2>
    7605:	eb 00                	jmp    7607 <sched_init+0xc4>
	outb_p(LATCH & 0xff , 0x40);	/* LSB */
    7607:	b0 9b                	mov    $0x9b,%al
    7609:	b2 40                	mov    $0x40,%dl
    760b:	ee                   	out    %al,(%dx)
    760c:	eb 00                	jmp    760e <sched_init+0xcb>
    760e:	eb 00                	jmp    7610 <sched_init+0xcd>
	outb(LATCH >> 8 , 0x40);	/* MSB */
    7610:	b0 2e                	mov    $0x2e,%al
    7612:	ee                   	out    %al,(%dx)
	set_intr_gate(0x20,&timer_interrupt);
    7613:	ba 42 77 00 00       	mov    $0x7742,%edx
    7618:	b8 00 00 08 00       	mov    $0x80000,%eax
    761d:	66 89 d0             	mov    %dx,%ax
    7620:	66 ba 00 8e          	mov    $0x8e00,%dx
    7624:	a3 b8 55 00 00       	mov    %eax,0x55b8
    7629:	89 15 bc 55 00 00    	mov    %edx,0x55bc
	outb(inb_p(0x21)&~0x01,0x21);
    762f:	ba 21 00 00 00       	mov    $0x21,%edx
    7634:	ec                   	in     (%dx),%al
    7635:	eb 00                	jmp    7637 <sched_init+0xf4>
    7637:	eb 00                	jmp    7639 <sched_init+0xf6>
    7639:	25 fe 00 00 00       	and    $0xfe,%eax
    763e:	ee                   	out    %al,(%dx)
	set_system_gate(0x80,&system_call);
    763f:	ba 6c 76 00 00       	mov    $0x766c,%edx
    7644:	b8 00 00 08 00       	mov    $0x80000,%eax
    7649:	66 89 d0             	mov    %dx,%ax
    764c:	66 ba 00 ef          	mov    $0xef00,%dx
    7650:	a3 b8 58 00 00       	mov    %eax,0x58b8
    7655:	89 15 bc 58 00 00    	mov    %edx,0x58bc
}
    765b:	c3                   	ret    

0000765c <bad_sys_call>:
    765c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    7661:	cf                   	iret   

00007662 <reschedule>:
    7662:	68 a0 76 00 00       	push   $0x76a0
    7667:	e9 0f f4 ff ff       	jmp    6a7b <schedule>

0000766c <system_call>:
    766c:	83 f8 49             	cmp    $0x49,%eax
    766f:	77 eb                	ja     765c <bad_sys_call>
    7671:	1e                   	push   %ds
    7672:	06                   	push   %es
    7673:	0f a0                	push   %fs
    7675:	52                   	push   %edx
    7676:	51                   	push   %ecx
    7677:	53                   	push   %ebx
    7678:	ba 10 00 00 00       	mov    $0x10,%edx
    767d:	8e da                	mov    %edx,%ds
    767f:	8e c2                	mov    %edx,%es
    7681:	ba 17 00 00 00       	mov    $0x17,%edx
    7686:	8e e2                	mov    %edx,%fs
    7688:	ff 14 85 e0 aa 01 00 	call   *0x1aae0(,%eax,4)
    768f:	50                   	push   %eax
    7690:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7695:	83 38 00             	cmpl   $0x0,(%eax)
    7698:	75 c8                	jne    7662 <reschedule>
    769a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    769e:	74 c2                	je     7662 <reschedule>

000076a0 <ret_from_sys_call>:
    76a0:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    76a5:	3b 05 40 bc 01 00    	cmp    0x1bc40,%eax
    76ab:	74 30                	je     76dd <ret_from_sys_call+0x3d>
    76ad:	66 83 7c 24 20 0f    	cmpw   $0xf,0x20(%esp)
    76b3:	75 28                	jne    76dd <ret_from_sys_call+0x3d>
    76b5:	66 83 7c 24 2c 17    	cmpw   $0x17,0x2c(%esp)
    76bb:	75 20                	jne    76dd <ret_from_sys_call+0x3d>
    76bd:	8b 58 0c             	mov    0xc(%eax),%ebx
    76c0:	8b 88 10 02 00 00    	mov    0x210(%eax),%ecx
    76c6:	f7 d1                	not    %ecx
    76c8:	21 d9                	and    %ebx,%ecx
    76ca:	0f bc c9             	bsf    %ecx,%ecx
    76cd:	74 0e                	je     76dd <ret_from_sys_call+0x3d>
    76cf:	0f b3 cb             	btr    %ecx,%ebx
    76d2:	89 58 0c             	mov    %ebx,0xc(%eax)
    76d5:	41                   	inc    %ecx
    76d6:	51                   	push   %ecx
    76d7:	e8 67 20 00 00       	call   9743 <do_signal>
    76dc:	58                   	pop    %eax
    76dd:	58                   	pop    %eax
    76de:	5b                   	pop    %ebx
    76df:	59                   	pop    %ecx
    76e0:	5a                   	pop    %edx
    76e1:	0f a1                	pop    %fs
    76e3:	07                   	pop    %es
    76e4:	1f                   	pop    %ds
    76e5:	cf                   	iret   

000076e6 <coprocessor_error>:
    76e6:	1e                   	push   %ds
    76e7:	06                   	push   %es
    76e8:	0f a0                	push   %fs
    76ea:	52                   	push   %edx
    76eb:	51                   	push   %ecx
    76ec:	53                   	push   %ebx
    76ed:	50                   	push   %eax
    76ee:	b8 10 00 00 00       	mov    $0x10,%eax
    76f3:	8e d8                	mov    %eax,%ds
    76f5:	8e c0                	mov    %eax,%es
    76f7:	b8 17 00 00 00       	mov    $0x17,%eax
    76fc:	8e e0                	mov    %eax,%fs
    76fe:	68 a0 76 00 00       	push   $0x76a0
    7703:	e9 ae 0b 01 00       	jmp    182b6 <math_error>

00007708 <device_not_available>:
    7708:	1e                   	push   %ds
    7709:	06                   	push   %es
    770a:	0f a0                	push   %fs
    770c:	52                   	push   %edx
    770d:	51                   	push   %ecx
    770e:	53                   	push   %ebx
    770f:	50                   	push   %eax
    7710:	b8 10 00 00 00       	mov    $0x10,%eax
    7715:	8e d8                	mov    %eax,%ds
    7717:	8e c0                	mov    %eax,%es
    7719:	b8 17 00 00 00       	mov    $0x17,%eax
    771e:	8e e0                	mov    %eax,%fs
    7720:	68 a0 76 00 00       	push   $0x76a0
    7725:	0f 06                	clts   
    7727:	0f 20 c0             	mov    %cr0,%eax
    772a:	a9 04 00 00 00       	test   $0x4,%eax
    772f:	0f 84 02 f3 ff ff    	je     6a37 <math_state_restore>
    7735:	55                   	push   %ebp
    7736:	56                   	push   %esi
    7737:	57                   	push   %edi
    7738:	e8 0f 0b 01 00       	call   1824c <math_emulate>
    773d:	5f                   	pop    %edi
    773e:	5e                   	pop    %esi
    773f:	5d                   	pop    %ebp
    7740:	c3                   	ret    
    7741:	90                   	nop

00007742 <timer_interrupt>:
    7742:	1e                   	push   %ds
    7743:	06                   	push   %es
    7744:	0f a0                	push   %fs
    7746:	52                   	push   %edx
    7747:	51                   	push   %ecx
    7748:	53                   	push   %ebx
    7749:	50                   	push   %eax
    774a:	b8 10 00 00 00       	mov    $0x10,%eax
    774f:	8e d8                	mov    %eax,%ds
    7751:	8e c0                	mov    %eax,%es
    7753:	b8 17 00 00 00       	mov    $0x17,%eax
    7758:	8e e0                	mov    %eax,%fs
    775a:	ff 05 c0 e9 01 00    	incl   0x1e9c0
    7760:	b0 20                	mov    $0x20,%al
    7762:	e6 20                	out    %al,$0x20
    7764:	8b 44 24 20          	mov    0x20(%esp),%eax
    7768:	83 e0 03             	and    $0x3,%eax
    776b:	50                   	push   %eax
    776c:	e8 e7 fa ff ff       	call   7258 <do_timer>
    7771:	83 c4 04             	add    $0x4,%esp
    7774:	e9 27 ff ff ff       	jmp    76a0 <ret_from_sys_call>
    7779:	90                   	nop

0000777a <sys_execve>:
    777a:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    777e:	50                   	push   %eax
    777f:	e8 93 6e 00 00       	call   e617 <do_execve>
    7784:	83 c4 04             	add    $0x4,%esp
    7787:	c3                   	ret    

00007788 <sys_fork>:
    7788:	e8 2d 0b 00 00       	call   82ba <find_empty_process>
    778d:	85 c0                	test   %eax,%eax
    778f:	78 0e                	js     779f <sys_fork+0x17>
    7791:	0f a8                	push   %gs
    7793:	56                   	push   %esi
    7794:	57                   	push   %edi
    7795:	55                   	push   %ebp
    7796:	50                   	push   %eax
    7797:	e8 23 08 00 00       	call   7fbf <copy_process>
    779c:	83 c4 14             	add    $0x14,%esp
    779f:	c3                   	ret    

000077a0 <hd_interrupt>:
    77a0:	50                   	push   %eax
    77a1:	51                   	push   %ecx
    77a2:	52                   	push   %edx
    77a3:	1e                   	push   %ds
    77a4:	06                   	push   %es
    77a5:	0f a0                	push   %fs
    77a7:	b8 10 00 00 00       	mov    $0x10,%eax
    77ac:	8e d8                	mov    %eax,%ds
    77ae:	8e c0                	mov    %eax,%es
    77b0:	b8 17 00 00 00       	mov    $0x17,%eax
    77b5:	8e e0                	mov    %eax,%fs
    77b7:	b0 20                	mov    $0x20,%al
    77b9:	e6 a0                	out    %al,$0xa0
    77bb:	eb 00                	jmp    77bd <hd_interrupt+0x1d>
    77bd:	eb 00                	jmp    77bf <hd_interrupt+0x1f>
    77bf:	31 d2                	xor    %edx,%edx
    77c1:	87 15 00 0c 02 00    	xchg   %edx,0x20c00
    77c7:	85 d2                	test   %edx,%edx
    77c9:	75 05                	jne    77d0 <hd_interrupt+0x30>
    77cb:	ba d7 42 01 00       	mov    $0x142d7,%edx
    77d0:	e6 20                	out    %al,$0x20
    77d2:	ff d2                	call   *%edx
    77d4:	0f a1                	pop    %fs
    77d6:	07                   	pop    %es
    77d7:	1f                   	pop    %ds
    77d8:	5a                   	pop    %edx
    77d9:	59                   	pop    %ecx
    77da:	58                   	pop    %eax
    77db:	cf                   	iret   

000077dc <floppy_interrupt>:
    77dc:	50                   	push   %eax
    77dd:	51                   	push   %ecx
    77de:	52                   	push   %edx
    77df:	1e                   	push   %ds
    77e0:	06                   	push   %es
    77e1:	0f a0                	push   %fs
    77e3:	b8 10 00 00 00       	mov    $0x10,%eax
    77e8:	8e d8                	mov    %eax,%ds
    77ea:	8e c0                	mov    %eax,%es
    77ec:	b8 17 00 00 00       	mov    $0x17,%eax
    77f1:	8e e0                	mov    %eax,%fs
    77f3:	b0 20                	mov    $0x20,%al
    77f5:	e6 20                	out    %al,$0x20
    77f7:	31 c0                	xor    %eax,%eax
    77f9:	87 05 d8 0b 02 00    	xchg   %eax,0x20bd8
    77ff:	85 c0                	test   %eax,%eax
    7801:	75 05                	jne    7808 <floppy_interrupt+0x2c>
    7803:	b8 d1 36 01 00       	mov    $0x136d1,%eax
    7808:	ff d0                	call   *%eax
    780a:	0f a1                	pop    %fs
    780c:	07                   	pop    %es
    780d:	1f                   	pop    %ds
    780e:	5a                   	pop    %edx
    780f:	59                   	pop    %ecx
    7810:	58                   	pop    %eax
    7811:	cf                   	iret   

00007812 <parallel_interrupt>:
    7812:	50                   	push   %eax
    7813:	b0 20                	mov    $0x20,%al
    7815:	e6 20                	out    %al,$0x20
    7817:	58                   	pop    %eax
    7818:	cf                   	iret   

00007819 <die>:
void reserved(void);
void parallel_interrupt(void);
void irq13(void);

static void die(char * str,long esp_ptr,long nr)
{
    7819:	57                   	push   %edi
    781a:	56                   	push   %esi
    781b:	53                   	push   %ebx
	long * esp = (long *) esp_ptr;
    781c:	8b 74 24 14          	mov    0x14(%esp),%esi
	int i;

	printk("%s: %04x\n\r",str,nr&0xffff);
    7820:	83 ec 04             	sub    $0x4,%esp
    7823:	0f b7 44 24 1c       	movzwl 0x1c(%esp),%eax
    7828:	50                   	push   %eax
    7829:	ff 74 24 18          	pushl  0x18(%esp)
    782d:	68 1a 88 01 00       	push   $0x1881a
    7832:	e8 1c 0b 00 00       	call   8353 <printk>
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7837:	83 c4 08             	add    $0x8,%esp
    783a:	ff 76 0c             	pushl  0xc(%esi)
    783d:	ff 76 10             	pushl  0x10(%esi)
    7840:	ff 76 08             	pushl  0x8(%esi)
    7843:	ff 36                	pushl  (%esi)
    7845:	ff 76 04             	pushl  0x4(%esi)
    7848:	68 fc 89 01 00       	push   $0x189fc
    784d:	e8 01 0b 00 00       	call   8353 <printk>
		esp[1],esp[0],esp[2],esp[4],esp[3]);
	printk("fs: %04x\n",_fs());
    7852:	83 c4 18             	add    $0x18,%esp
    7855:	66 8c e0             	mov    %fs,%ax
    7858:	0f b7 c0             	movzwl %ax,%eax
    785b:	50                   	push   %eax
    785c:	68 25 88 01 00       	push   $0x18825
    7861:	e8 ed 0a 00 00       	call   8353 <printk>
	printk("base: %p, limit: %p\n",get_base(current->ldt[1]),get_limit(0x17));
    7866:	83 c4 0c             	add    $0xc,%esp
    7869:	ba 17 00 00 00       	mov    $0x17,%edx
    786e:	0f 03 ca             	lsl    %dx,%ecx
    7871:	41                   	inc    %ecx
        :"memory"); \
__base;})
**/

static inline unsigned long _get_base(char * addr)
{
    7872:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7877:	05 d8 02 00 00       	add    $0x2d8,%eax
         unsigned long __base;
         __asm__("movb %3,%%dh\n\t"
    787c:	8a 70 07             	mov    0x7(%eax),%dh
    787f:	8a 50 04             	mov    0x4(%eax),%dl
    7882:	c1 e2 10             	shl    $0x10,%edx
    7885:	66 8b 50 02          	mov    0x2(%eax),%dx
{
    7889:	51                   	push   %ecx
    788a:	52                   	push   %edx
    788b:	68 2f 88 01 00       	push   $0x1882f
    7890:	e8 be 0a 00 00       	call   8353 <printk>
	if (esp[4] == 0x17) {
    7895:	83 c4 10             	add    $0x10,%esp
    7898:	83 7e 10 17          	cmpl   $0x17,0x10(%esi)
    789c:	75 50                	jne    78ee <die+0xd5>
		printk("Stack: ");
    789e:	83 ec 0c             	sub    $0xc,%esp
    78a1:	68 44 88 01 00       	push   $0x18844
    78a6:	e8 a8 0a 00 00       	call   8353 <printk>
		for (i=0;i<4;i++)
    78ab:	bb 00 00 00 00       	mov    $0x0,%ebx
    78b0:	83 c4 10             	add    $0x10,%esp
    78b3:	bf 17 00 00 00       	mov    $0x17,%edi
			printk("%p ",get_seg_long(0x17,i+(long *)esp[3]));
    78b8:	8b 56 0c             	mov    0xc(%esi),%edx
    78bb:	89 f8                	mov    %edi,%eax
    78bd:	0f a0                	push   %fs
    78bf:	8e e0                	mov    %eax,%fs
    78c1:	64 8b 04 9a          	mov    %fs:(%edx,%ebx,4),%eax
    78c5:	0f a1                	pop    %fs
    78c7:	83 ec 08             	sub    $0x8,%esp
    78ca:	50                   	push   %eax
    78cb:	68 4c 88 01 00       	push   $0x1884c
    78d0:	e8 7e 0a 00 00       	call   8353 <printk>
		for (i=0;i<4;i++)
    78d5:	83 c4 10             	add    $0x10,%esp
    78d8:	43                   	inc    %ebx
    78d9:	83 fb 03             	cmp    $0x3,%ebx
    78dc:	7e da                	jle    78b8 <die+0x9f>
		printk("\n");
    78de:	83 ec 0c             	sub    $0xc,%esp
    78e1:	68 80 86 01 00       	push   $0x18680
    78e6:	e8 68 0a 00 00       	call   8353 <printk>
    78eb:	83 c4 10             	add    $0x10,%esp
	}
	str(i);
    78ee:	ba 00 00 00 00       	mov    $0x0,%edx
    78f3:	89 d0                	mov    %edx,%eax
    78f5:	66 0f 00 c8          	str    %ax
    78f9:	83 e8 20             	sub    $0x20,%eax
    78fc:	c1 e8 04             	shr    $0x4,%eax
	printk("Pid: %d, process nr: %d\n\r",current->pid,0xffff & i);
    78ff:	83 ec 04             	sub    $0x4,%esp
    7902:	25 ff ff 00 00       	and    $0xffff,%eax
    7907:	50                   	push   %eax
    7908:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    790d:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    7913:	68 50 88 01 00       	push   $0x18850
    7918:	e8 36 0a 00 00       	call   8353 <printk>
	for(i=0;i<10;i++)
    791d:	bb 00 00 00 00       	mov    $0x0,%ebx
    7922:	83 c4 10             	add    $0x10,%esp
		printk("%02x ",0xff & get_seg_byte(esp[1],(i+(char *)esp[0])));
    7925:	8b 56 04             	mov    0x4(%esi),%edx
    7928:	8b 0e                	mov    (%esi),%ecx
    792a:	89 d0                	mov    %edx,%eax
    792c:	0f a0                	push   %fs
    792e:	8e e0                	mov    %eax,%fs
    7930:	64 8a 04 19          	mov    %fs:(%ecx,%ebx,1),%al
    7934:	0f a1                	pop    %fs
    7936:	0f b6 c0             	movzbl %al,%eax
    7939:	83 ec 08             	sub    $0x8,%esp
    793c:	50                   	push   %eax
    793d:	68 6a 88 01 00       	push   $0x1886a
    7942:	e8 0c 0a 00 00       	call   8353 <printk>
	for(i=0;i<10;i++)
    7947:	83 c4 10             	add    $0x10,%esp
    794a:	43                   	inc    %ebx
    794b:	83 fb 09             	cmp    $0x9,%ebx
    794e:	7e d5                	jle    7925 <die+0x10c>
	printk("\n\r");
    7950:	83 ec 0c             	sub    $0xc,%esp
    7953:	68 e0 8c 01 00       	push   $0x18ce0
    7958:	e8 f6 09 00 00       	call   8353 <printk>
	do_exit(11);		/* play segment exception */
    795d:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    7964:	e8 72 17 00 00       	call   90db <do_exit>
    7969:	83 c4 10             	add    $0x10,%esp
}
    796c:	5b                   	pop    %ebx
    796d:	5e                   	pop    %esi
    796e:	5f                   	pop    %edi
    796f:	c3                   	ret    

00007970 <do_double_fault>:

void do_double_fault(long esp, long error_code)
{
    7970:	83 ec 10             	sub    $0x10,%esp
	die("double fault",esp,error_code);
    7973:	ff 74 24 18          	pushl  0x18(%esp)
    7977:	ff 74 24 18          	pushl  0x18(%esp)
    797b:	68 70 88 01 00       	push   $0x18870
    7980:	e8 94 fe ff ff       	call   7819 <die>
}
    7985:	83 c4 1c             	add    $0x1c,%esp
    7988:	c3                   	ret    

00007989 <do_general_protection>:

void do_general_protection(long esp, long error_code)
{
    7989:	83 ec 10             	sub    $0x10,%esp
	die("general protection",esp,error_code);
    798c:	ff 74 24 18          	pushl  0x18(%esp)
    7990:	ff 74 24 18          	pushl  0x18(%esp)
    7994:	68 7d 88 01 00       	push   $0x1887d
    7999:	e8 7b fe ff ff       	call   7819 <die>
}
    799e:	83 c4 1c             	add    $0x1c,%esp
    79a1:	c3                   	ret    

000079a2 <do_divide_error>:

void do_divide_error(long esp, long error_code)
{
    79a2:	83 ec 10             	sub    $0x10,%esp
	die("divide error",esp,error_code);
    79a5:	ff 74 24 18          	pushl  0x18(%esp)
    79a9:	ff 74 24 18          	pushl  0x18(%esp)
    79ad:	68 90 88 01 00       	push   $0x18890
    79b2:	e8 62 fe ff ff       	call   7819 <die>
}
    79b7:	83 c4 1c             	add    $0x1c,%esp
    79ba:	c3                   	ret    

000079bb <do_int3>:

void do_int3(long * esp, long error_code,
		long fs,long es,long ds,
		long ebp,long esi,long edi,
		long edx,long ecx,long ebx,long eax)
{
    79bb:	56                   	push   %esi
    79bc:	53                   	push   %ebx
    79bd:	83 ec 10             	sub    $0x10,%esp
    79c0:	8b 74 24 1c          	mov    0x1c(%esp),%esi
	int tr;

	__asm__("str %%ax":"=a" (tr):"0" (0));
    79c4:	bb 00 00 00 00       	mov    $0x0,%ebx
    79c9:	89 d8                	mov    %ebx,%eax
    79cb:	66 0f 00 c8          	str    %ax
    79cf:	89 c3                	mov    %eax,%ebx
	printk("eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r",
    79d1:	ff 74 24 3c          	pushl  0x3c(%esp)
    79d5:	ff 74 24 44          	pushl  0x44(%esp)
    79d9:	ff 74 24 4c          	pushl  0x4c(%esp)
    79dd:	ff 74 24 54          	pushl  0x54(%esp)
    79e1:	68 24 8a 01 00       	push   $0x18a24
    79e6:	e8 68 09 00 00       	call   8353 <printk>
		eax,ebx,ecx,edx);
	printk("esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r",
    79eb:	83 c4 14             	add    $0x14,%esp
    79ee:	56                   	push   %esi
    79ef:	ff 74 24 34          	pushl  0x34(%esp)
    79f3:	ff 74 24 40          	pushl  0x40(%esp)
    79f7:	ff 74 24 40          	pushl  0x40(%esp)
    79fb:	68 4c 8a 01 00       	push   $0x18a4c
    7a00:	e8 4e 09 00 00       	call   8353 <printk>
		esi,edi,ebp,(long) esp);
	printk("\n\rds\tes\tfs\ttr\n\r%4x\t%4x\t%4x\t%4x\n\r",
    7a05:	83 c4 14             	add    $0x14,%esp
    7a08:	53                   	push   %ebx
    7a09:	ff 74 24 28          	pushl  0x28(%esp)
    7a0d:	ff 74 24 30          	pushl  0x30(%esp)
    7a11:	ff 74 24 38          	pushl  0x38(%esp)
    7a15:	68 74 8a 01 00       	push   $0x18a74
    7a1a:	e8 34 09 00 00       	call   8353 <printk>
		ds,es,fs,tr);
	printk("EIP: %8x   CS: %4x  EFLAGS: %8x\n\r",esp[0],esp[1],esp[2]);
    7a1f:	83 c4 20             	add    $0x20,%esp
    7a22:	ff 76 08             	pushl  0x8(%esi)
    7a25:	ff 76 04             	pushl  0x4(%esi)
    7a28:	ff 36                	pushl  (%esi)
    7a2a:	68 98 8a 01 00       	push   $0x18a98
    7a2f:	e8 1f 09 00 00       	call   8353 <printk>
}
    7a34:	83 c4 14             	add    $0x14,%esp
    7a37:	5b                   	pop    %ebx
    7a38:	5e                   	pop    %esi
    7a39:	c3                   	ret    

00007a3a <do_nmi>:

void do_nmi(long esp, long error_code)
{
    7a3a:	83 ec 10             	sub    $0x10,%esp
	die("nmi",esp,error_code);
    7a3d:	ff 74 24 18          	pushl  0x18(%esp)
    7a41:	ff 74 24 18          	pushl  0x18(%esp)
    7a45:	68 9d 88 01 00       	push   $0x1889d
    7a4a:	e8 ca fd ff ff       	call   7819 <die>
}
    7a4f:	83 c4 1c             	add    $0x1c,%esp
    7a52:	c3                   	ret    

00007a53 <do_debug>:

void do_debug(long esp, long error_code)
{
    7a53:	83 ec 10             	sub    $0x10,%esp
	die("debug",esp,error_code);
    7a56:	ff 74 24 18          	pushl  0x18(%esp)
    7a5a:	ff 74 24 18          	pushl  0x18(%esp)
    7a5e:	68 a1 88 01 00       	push   $0x188a1
    7a63:	e8 b1 fd ff ff       	call   7819 <die>
}
    7a68:	83 c4 1c             	add    $0x1c,%esp
    7a6b:	c3                   	ret    

00007a6c <do_overflow>:

void do_overflow(long esp, long error_code)
{
    7a6c:	83 ec 10             	sub    $0x10,%esp
	die("overflow",esp,error_code);
    7a6f:	ff 74 24 18          	pushl  0x18(%esp)
    7a73:	ff 74 24 18          	pushl  0x18(%esp)
    7a77:	68 a7 88 01 00       	push   $0x188a7
    7a7c:	e8 98 fd ff ff       	call   7819 <die>
}
    7a81:	83 c4 1c             	add    $0x1c,%esp
    7a84:	c3                   	ret    

00007a85 <do_bounds>:

void do_bounds(long esp, long error_code)
{
    7a85:	83 ec 10             	sub    $0x10,%esp
	die("bounds",esp,error_code);
    7a88:	ff 74 24 18          	pushl  0x18(%esp)
    7a8c:	ff 74 24 18          	pushl  0x18(%esp)
    7a90:	68 b0 88 01 00       	push   $0x188b0
    7a95:	e8 7f fd ff ff       	call   7819 <die>
}
    7a9a:	83 c4 1c             	add    $0x1c,%esp
    7a9d:	c3                   	ret    

00007a9e <do_invalid_op>:

void do_invalid_op(long esp, long error_code)
{
    7a9e:	83 ec 10             	sub    $0x10,%esp
	die("invalid operand",esp,error_code);
    7aa1:	ff 74 24 18          	pushl  0x18(%esp)
    7aa5:	ff 74 24 18          	pushl  0x18(%esp)
    7aa9:	68 b7 88 01 00       	push   $0x188b7
    7aae:	e8 66 fd ff ff       	call   7819 <die>
}
    7ab3:	83 c4 1c             	add    $0x1c,%esp
    7ab6:	c3                   	ret    

00007ab7 <do_device_not_available>:

void do_device_not_available(long esp, long error_code)
{
    7ab7:	83 ec 10             	sub    $0x10,%esp
	die("device not available",esp,error_code);
    7aba:	ff 74 24 18          	pushl  0x18(%esp)
    7abe:	ff 74 24 18          	pushl  0x18(%esp)
    7ac2:	68 c7 88 01 00       	push   $0x188c7
    7ac7:	e8 4d fd ff ff       	call   7819 <die>
}
    7acc:	83 c4 1c             	add    $0x1c,%esp
    7acf:	c3                   	ret    

00007ad0 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(long esp, long error_code)
{
    7ad0:	83 ec 10             	sub    $0x10,%esp
	die("coprocessor segment overrun",esp,error_code);
    7ad3:	ff 74 24 18          	pushl  0x18(%esp)
    7ad7:	ff 74 24 18          	pushl  0x18(%esp)
    7adb:	68 dc 88 01 00       	push   $0x188dc
    7ae0:	e8 34 fd ff ff       	call   7819 <die>
}
    7ae5:	83 c4 1c             	add    $0x1c,%esp
    7ae8:	c3                   	ret    

00007ae9 <do_invalid_TSS>:

void do_invalid_TSS(long esp,long error_code)
{
    7ae9:	83 ec 10             	sub    $0x10,%esp
	die("invalid TSS",esp,error_code);
    7aec:	ff 74 24 18          	pushl  0x18(%esp)
    7af0:	ff 74 24 18          	pushl  0x18(%esp)
    7af4:	68 f8 88 01 00       	push   $0x188f8
    7af9:	e8 1b fd ff ff       	call   7819 <die>
}
    7afe:	83 c4 1c             	add    $0x1c,%esp
    7b01:	c3                   	ret    

00007b02 <do_segment_not_present>:

void do_segment_not_present(long esp,long error_code)
{
    7b02:	83 ec 10             	sub    $0x10,%esp
	die("segment not present",esp,error_code);
    7b05:	ff 74 24 18          	pushl  0x18(%esp)
    7b09:	ff 74 24 18          	pushl  0x18(%esp)
    7b0d:	68 04 89 01 00       	push   $0x18904
    7b12:	e8 02 fd ff ff       	call   7819 <die>
}
    7b17:	83 c4 1c             	add    $0x1c,%esp
    7b1a:	c3                   	ret    

00007b1b <do_stack_segment>:

void do_stack_segment(long esp,long error_code)
{
    7b1b:	83 ec 10             	sub    $0x10,%esp
	die("stack segment",esp,error_code);
    7b1e:	ff 74 24 18          	pushl  0x18(%esp)
    7b22:	ff 74 24 18          	pushl  0x18(%esp)
    7b26:	68 18 89 01 00       	push   $0x18918
    7b2b:	e8 e9 fc ff ff       	call   7819 <die>
}
    7b30:	83 c4 1c             	add    $0x1c,%esp
    7b33:	c3                   	ret    

00007b34 <do_coprocessor_error>:

void do_coprocessor_error(long esp, long error_code)
{
    7b34:	83 ec 0c             	sub    $0xc,%esp
	if (last_task_used_math != current)
    7b37:	a1 c8 e9 01 00       	mov    0x1e9c8,%eax
    7b3c:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    7b42:	75 18                	jne    7b5c <do_coprocessor_error+0x28>
		return;
	die("coprocessor error",esp,error_code);
    7b44:	83 ec 04             	sub    $0x4,%esp
    7b47:	ff 74 24 18          	pushl  0x18(%esp)
    7b4b:	ff 74 24 18          	pushl  0x18(%esp)
    7b4f:	68 26 89 01 00       	push   $0x18926
    7b54:	e8 c0 fc ff ff       	call   7819 <die>
    7b59:	83 c4 10             	add    $0x10,%esp
}
    7b5c:	83 c4 0c             	add    $0xc,%esp
    7b5f:	c3                   	ret    

00007b60 <do_reserved>:

void do_reserved(long esp, long error_code)
{
    7b60:	83 ec 10             	sub    $0x10,%esp
	die("reserved (15,17-47) error",esp,error_code);
    7b63:	ff 74 24 18          	pushl  0x18(%esp)
    7b67:	ff 74 24 18          	pushl  0x18(%esp)
    7b6b:	68 38 89 01 00       	push   $0x18938
    7b70:	e8 a4 fc ff ff       	call   7819 <die>
}
    7b75:	83 c4 1c             	add    $0x1c,%esp
    7b78:	c3                   	ret    

00007b79 <trap_init>:

void trap_init(void)
{
    7b79:	55                   	push   %ebp
    7b7a:	57                   	push   %edi
    7b7b:	56                   	push   %esi
    7b7c:	53                   	push   %ebx
	int i;

	set_trap_gate(0,&divide_error);
    7b7d:	ba 97 7d 00 00       	mov    $0x7d97,%edx
    7b82:	b8 00 00 08 00       	mov    $0x80000,%eax
    7b87:	66 89 d0             	mov    %dx,%ax
    7b8a:	66 ba 00 8f          	mov    $0x8f00,%dx
    7b8e:	a3 b8 54 00 00       	mov    %eax,0x54b8
    7b93:	89 15 bc 54 00 00    	mov    %edx,0x54bc
	set_trap_gate(1,&debug);
    7b99:	ba cc 7d 00 00       	mov    $0x7dcc,%edx
    7b9e:	66 89 d0             	mov    %dx,%ax
    7ba1:	66 ba 00 8f          	mov    $0x8f00,%dx
    7ba5:	a3 c0 54 00 00       	mov    %eax,0x54c0
    7baa:	89 15 c4 54 00 00    	mov    %edx,0x54c4
	set_trap_gate(2,&nmi);
    7bb0:	ba d3 7d 00 00       	mov    $0x7dd3,%edx
    7bb5:	66 89 d0             	mov    %dx,%ax
    7bb8:	66 ba 00 8f          	mov    $0x8f00,%dx
    7bbc:	a3 c8 54 00 00       	mov    %eax,0x54c8
    7bc1:	89 15 cc 54 00 00    	mov    %edx,0x54cc
	set_system_gate(3,&int3);	/* int3-5 can be called from all */
    7bc7:	ba da 7d 00 00       	mov    $0x7dda,%edx
    7bcc:	66 89 d0             	mov    %dx,%ax
    7bcf:	66 ba 00 ef          	mov    $0xef00,%dx
    7bd3:	a3 d0 54 00 00       	mov    %eax,0x54d0
    7bd8:	89 15 d4 54 00 00    	mov    %edx,0x54d4
	set_system_gate(4,&overflow);
    7bde:	ba e1 7d 00 00       	mov    $0x7de1,%edx
    7be3:	66 89 d0             	mov    %dx,%ax
    7be6:	66 ba 00 ef          	mov    $0xef00,%dx
    7bea:	a3 d8 54 00 00       	mov    %eax,0x54d8
    7bef:	89 15 dc 54 00 00    	mov    %edx,0x54dc
	set_system_gate(5,&bounds);
    7bf5:	ba e8 7d 00 00       	mov    $0x7de8,%edx
    7bfa:	66 89 d0             	mov    %dx,%ax
    7bfd:	66 ba 00 ef          	mov    $0xef00,%dx
    7c01:	a3 e0 54 00 00       	mov    %eax,0x54e0
    7c06:	89 15 e4 54 00 00    	mov    %edx,0x54e4
	set_trap_gate(6,&invalid_op);
    7c0c:	ba ef 7d 00 00       	mov    $0x7def,%edx
    7c11:	66 89 d0             	mov    %dx,%ax
    7c14:	66 ba 00 8f          	mov    $0x8f00,%dx
    7c18:	a3 e8 54 00 00       	mov    %eax,0x54e8
    7c1d:	89 15 ec 54 00 00    	mov    %edx,0x54ec
	set_trap_gate(7,&device_not_available);
    7c23:	ba 08 77 00 00       	mov    $0x7708,%edx
    7c28:	66 89 d0             	mov    %dx,%ax
    7c2b:	66 ba 00 8f          	mov    $0x8f00,%dx
    7c2f:	a3 f0 54 00 00       	mov    %eax,0x54f0
    7c34:	89 15 f4 54 00 00    	mov    %edx,0x54f4
	set_trap_gate(8,&double_fault);
    7c3a:	ba 19 7e 00 00       	mov    $0x7e19,%edx
    7c3f:	66 89 d0             	mov    %dx,%ax
    7c42:	66 ba 00 8f          	mov    $0x8f00,%dx
    7c46:	a3 f8 54 00 00       	mov    %eax,0x54f8
    7c4b:	89 15 fc 54 00 00    	mov    %edx,0x54fc
	set_trap_gate(9,&coprocessor_segment_overrun);
    7c51:	ba f6 7d 00 00       	mov    $0x7df6,%edx
    7c56:	66 89 d0             	mov    %dx,%ax
    7c59:	66 ba 00 8f          	mov    $0x8f00,%dx
    7c5d:	a3 00 55 00 00       	mov    %eax,0x5500
    7c62:	89 15 04 55 00 00    	mov    %edx,0x5504
	set_trap_gate(10,&invalid_TSS);
    7c68:	ba 50 7e 00 00       	mov    $0x7e50,%edx
    7c6d:	66 89 d0             	mov    %dx,%ax
    7c70:	66 ba 00 8f          	mov    $0x8f00,%dx
    7c74:	a3 08 55 00 00       	mov    %eax,0x5508
    7c79:	89 15 0c 55 00 00    	mov    %edx,0x550c
	set_trap_gate(11,&segment_not_present);
    7c7f:	ba 57 7e 00 00       	mov    $0x7e57,%edx
    7c84:	66 89 d0             	mov    %dx,%ax
    7c87:	66 ba 00 8f          	mov    $0x8f00,%dx
    7c8b:	a3 10 55 00 00       	mov    %eax,0x5510
    7c90:	89 15 14 55 00 00    	mov    %edx,0x5514
	set_trap_gate(12,&stack_segment);
    7c96:	ba 5e 7e 00 00       	mov    $0x7e5e,%edx
    7c9b:	66 89 d0             	mov    %dx,%ax
    7c9e:	66 ba 00 8f          	mov    $0x8f00,%dx
    7ca2:	a3 18 55 00 00       	mov    %eax,0x5518
    7ca7:	89 15 1c 55 00 00    	mov    %edx,0x551c
	set_trap_gate(13,&general_protection);
    7cad:	ba 65 7e 00 00       	mov    $0x7e65,%edx
    7cb2:	66 89 d0             	mov    %dx,%ax
    7cb5:	66 ba 00 8f          	mov    $0x8f00,%dx
    7cb9:	a3 20 55 00 00       	mov    %eax,0x5520
    7cbe:	89 15 24 55 00 00    	mov    %edx,0x5524
	set_trap_gate(14,&page_fault);
    7cc4:	ba a9 a6 00 00       	mov    $0xa6a9,%edx
    7cc9:	66 89 d0             	mov    %dx,%ax
    7ccc:	66 ba 00 8f          	mov    $0x8f00,%dx
    7cd0:	a3 28 55 00 00       	mov    %eax,0x5528
    7cd5:	89 15 2c 55 00 00    	mov    %edx,0x552c
	set_trap_gate(15,&reserved);
    7cdb:	ba fd 7d 00 00       	mov    $0x7dfd,%edx
    7ce0:	66 89 d0             	mov    %dx,%ax
    7ce3:	66 ba 00 8f          	mov    $0x8f00,%dx
    7ce7:	a3 30 55 00 00       	mov    %eax,0x5530
    7cec:	89 15 34 55 00 00    	mov    %edx,0x5534
	set_trap_gate(16,&coprocessor_error);
    7cf2:	ba e6 76 00 00       	mov    $0x76e6,%edx
    7cf7:	66 89 d0             	mov    %dx,%ax
    7cfa:	66 ba 00 8f          	mov    $0x8f00,%dx
    7cfe:	a3 38 55 00 00       	mov    %eax,0x5538
    7d03:	89 15 3c 55 00 00    	mov    %edx,0x553c
	for (i=17;i<48;i++)
    7d09:	bf 11 00 00 00       	mov    $0x11,%edi
    7d0e:	be b8 54 00 00       	mov    $0x54b8,%esi
    7d13:	bb bc 54 00 00       	mov    $0x54bc,%ebx
    7d18:	b9 fd 7d 00 00       	mov    $0x7dfd,%ecx
    7d1d:	bd 00 00 08 00       	mov    $0x80000,%ebp
		set_trap_gate(i,&reserved);
    7d22:	89 ca                	mov    %ecx,%edx
    7d24:	89 e8                	mov    %ebp,%eax
    7d26:	66 89 d0             	mov    %dx,%ax
    7d29:	66 ba 00 8f          	mov    $0x8f00,%dx
    7d2d:	89 04 fe             	mov    %eax,(%esi,%edi,8)
    7d30:	89 14 fb             	mov    %edx,(%ebx,%edi,8)
	for (i=17;i<48;i++)
    7d33:	47                   	inc    %edi
    7d34:	83 ff 2f             	cmp    $0x2f,%edi
    7d37:	7e e9                	jle    7d22 <trap_init+0x1a9>
	set_trap_gate(45,&irq13);
    7d39:	ba 04 7e 00 00       	mov    $0x7e04,%edx
    7d3e:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d43:	66 89 d0             	mov    %dx,%ax
    7d46:	66 ba 00 8f          	mov    $0x8f00,%dx
    7d4a:	a3 20 56 00 00       	mov    %eax,0x5620
    7d4f:	89 15 24 56 00 00    	mov    %edx,0x5624
	outb_p(inb_p(0x21)&0xfb,0x21);
    7d55:	ba 21 00 00 00       	mov    $0x21,%edx
    7d5a:	ec                   	in     (%dx),%al
    7d5b:	eb 00                	jmp    7d5d <trap_init+0x1e4>
    7d5d:	eb 00                	jmp    7d5f <trap_init+0x1e6>
    7d5f:	25 fb 00 00 00       	and    $0xfb,%eax
    7d64:	ee                   	out    %al,(%dx)
    7d65:	eb 00                	jmp    7d67 <trap_init+0x1ee>
    7d67:	eb 00                	jmp    7d69 <trap_init+0x1f0>
	outb(inb_p(0xA1)&0xdf,0xA1);
    7d69:	b2 a1                	mov    $0xa1,%dl
    7d6b:	ec                   	in     (%dx),%al
    7d6c:	eb 00                	jmp    7d6e <trap_init+0x1f5>
    7d6e:	eb 00                	jmp    7d70 <trap_init+0x1f7>
    7d70:	25 df 00 00 00       	and    $0xdf,%eax
    7d75:	ee                   	out    %al,(%dx)
	set_trap_gate(39,&parallel_interrupt);
    7d76:	ba 12 78 00 00       	mov    $0x7812,%edx
    7d7b:	b8 00 00 08 00       	mov    $0x80000,%eax
    7d80:	66 89 d0             	mov    %dx,%ax
    7d83:	66 ba 00 8f          	mov    $0x8f00,%dx
    7d87:	a3 f0 55 00 00       	mov    %eax,0x55f0
    7d8c:	89 15 f4 55 00 00    	mov    %edx,0x55f4
}
    7d92:	5b                   	pop    %ebx
    7d93:	5e                   	pop    %esi
    7d94:	5f                   	pop    %edi
    7d95:	5d                   	pop    %ebp
    7d96:	c3                   	ret    

00007d97 <divide_error>:
    7d97:	68 a2 79 00 00       	push   $0x79a2

00007d9c <no_error_code>:
    7d9c:	87 04 24             	xchg   %eax,(%esp)
    7d9f:	53                   	push   %ebx
    7da0:	51                   	push   %ecx
    7da1:	52                   	push   %edx
    7da2:	57                   	push   %edi
    7da3:	56                   	push   %esi
    7da4:	55                   	push   %ebp
    7da5:	1e                   	push   %ds
    7da6:	06                   	push   %es
    7da7:	0f a0                	push   %fs
    7da9:	6a 00                	push   $0x0
    7dab:	8d 54 24 2c          	lea    0x2c(%esp),%edx
    7daf:	52                   	push   %edx
    7db0:	ba 10 00 00 00       	mov    $0x10,%edx
    7db5:	8e da                	mov    %edx,%ds
    7db7:	8e c2                	mov    %edx,%es
    7db9:	8e e2                	mov    %edx,%fs
    7dbb:	ff d0                	call   *%eax
    7dbd:	83 c4 08             	add    $0x8,%esp
    7dc0:	0f a1                	pop    %fs
    7dc2:	07                   	pop    %es
    7dc3:	1f                   	pop    %ds
    7dc4:	5d                   	pop    %ebp
    7dc5:	5e                   	pop    %esi
    7dc6:	5f                   	pop    %edi
    7dc7:	5a                   	pop    %edx
    7dc8:	59                   	pop    %ecx
    7dc9:	5b                   	pop    %ebx
    7dca:	58                   	pop    %eax
    7dcb:	cf                   	iret   

00007dcc <debug>:
    7dcc:	68 bb 79 00 00       	push   $0x79bb
    7dd1:	eb c9                	jmp    7d9c <no_error_code>

00007dd3 <nmi>:
    7dd3:	68 3a 7a 00 00       	push   $0x7a3a
    7dd8:	eb c2                	jmp    7d9c <no_error_code>

00007dda <int3>:
    7dda:	68 bb 79 00 00       	push   $0x79bb
    7ddf:	eb bb                	jmp    7d9c <no_error_code>

00007de1 <overflow>:
    7de1:	68 6c 7a 00 00       	push   $0x7a6c
    7de6:	eb b4                	jmp    7d9c <no_error_code>

00007de8 <bounds>:
    7de8:	68 85 7a 00 00       	push   $0x7a85
    7ded:	eb ad                	jmp    7d9c <no_error_code>

00007def <invalid_op>:
    7def:	68 9e 7a 00 00       	push   $0x7a9e
    7df4:	eb a6                	jmp    7d9c <no_error_code>

00007df6 <coprocessor_segment_overrun>:
    7df6:	68 d0 7a 00 00       	push   $0x7ad0
    7dfb:	eb 9f                	jmp    7d9c <no_error_code>

00007dfd <reserved>:
    7dfd:	68 60 7b 00 00       	push   $0x7b60
    7e02:	eb 98                	jmp    7d9c <no_error_code>

00007e04 <irq13>:
    7e04:	50                   	push   %eax
    7e05:	30 c0                	xor    %al,%al
    7e07:	e6 f0                	out    %al,$0xf0
    7e09:	b0 20                	mov    $0x20,%al
    7e0b:	e6 20                	out    %al,$0x20
    7e0d:	eb 00                	jmp    7e0f <irq13+0xb>
    7e0f:	eb 00                	jmp    7e11 <irq13+0xd>
    7e11:	e6 a0                	out    %al,$0xa0
    7e13:	58                   	pop    %eax
    7e14:	e9 cd f8 ff ff       	jmp    76e6 <coprocessor_error>

00007e19 <double_fault>:
    7e19:	68 70 79 00 00       	push   $0x7970

00007e1e <error_code>:
    7e1e:	87 44 24 04          	xchg   %eax,0x4(%esp)
    7e22:	87 1c 24             	xchg   %ebx,(%esp)
    7e25:	51                   	push   %ecx
    7e26:	52                   	push   %edx
    7e27:	57                   	push   %edi
    7e28:	56                   	push   %esi
    7e29:	55                   	push   %ebp
    7e2a:	1e                   	push   %ds
    7e2b:	06                   	push   %es
    7e2c:	0f a0                	push   %fs
    7e2e:	50                   	push   %eax
    7e2f:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    7e33:	50                   	push   %eax
    7e34:	b8 10 00 00 00       	mov    $0x10,%eax
    7e39:	8e d8                	mov    %eax,%ds
    7e3b:	8e c0                	mov    %eax,%es
    7e3d:	8e e0                	mov    %eax,%fs
    7e3f:	ff d3                	call   *%ebx
    7e41:	83 c4 08             	add    $0x8,%esp
    7e44:	0f a1                	pop    %fs
    7e46:	07                   	pop    %es
    7e47:	1f                   	pop    %ds
    7e48:	5d                   	pop    %ebp
    7e49:	5e                   	pop    %esi
    7e4a:	5f                   	pop    %edi
    7e4b:	5a                   	pop    %edx
    7e4c:	59                   	pop    %ecx
    7e4d:	5b                   	pop    %ebx
    7e4e:	58                   	pop    %eax
    7e4f:	cf                   	iret   

00007e50 <invalid_TSS>:
    7e50:	68 e9 7a 00 00       	push   $0x7ae9
    7e55:	eb c7                	jmp    7e1e <error_code>

00007e57 <segment_not_present>:
    7e57:	68 02 7b 00 00       	push   $0x7b02
    7e5c:	eb c0                	jmp    7e1e <error_code>

00007e5e <stack_segment>:
    7e5e:	68 1b 7b 00 00       	push   $0x7b1b
    7e63:	eb b9                	jmp    7e1e <error_code>

00007e65 <general_protection>:
    7e65:	68 89 79 00 00       	push   $0x7989
    7e6a:	eb b2                	jmp    7e1e <error_code>

00007e6c <verify_area>:
extern void write_verify(unsigned long address);

long last_pid=0;

void verify_area(void * addr,int size)
{
    7e6c:	56                   	push   %esi
    7e6d:	53                   	push   %ebx
    7e6e:	83 ec 04             	sub    $0x4,%esp
	unsigned long start;

	start = (unsigned long) addr;
    7e71:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	size += start & 0xfff;
    7e75:	89 d8                	mov    %ebx,%eax
    7e77:	25 ff 0f 00 00       	and    $0xfff,%eax
    7e7c:	8b 74 24 14          	mov    0x14(%esp),%esi
    7e80:	01 c6                	add    %eax,%esi
	start &= 0xfffff000;
    7e82:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
    7e88:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    7e8d:	05 e0 02 00 00       	add    $0x2e0,%eax
         __asm__("movb %3,%%dh\n\t"
    7e92:	8a 70 07             	mov    0x7(%eax),%dh
    7e95:	8a 50 04             	mov    0x4(%eax),%dl
    7e98:	c1 e2 10             	shl    $0x10,%edx
    7e9b:	66 8b 50 02          	mov    0x2(%eax),%dx
{
    7e9f:	01 d3                	add    %edx,%ebx
	start += get_base(current->ldt[2]);
	while (size>0) {
		size -= 4096;
		write_verify(start);
		start += 4096;
    7ea1:	85 f6                	test   %esi,%esi
    7ea3:	7e 1c                	jle    7ec1 <verify_area+0x55>
		size -= 4096;
    7ea5:	81 ee 00 10 00 00    	sub    $0x1000,%esi
		write_verify(start);
    7eab:	83 ec 0c             	sub    $0xc,%esp
    7eae:	53                   	push   %ebx
    7eaf:	e8 64 20 00 00       	call   9f18 <write_verify>
		start += 4096;
    7eb4:	81 c3 00 10 00 00    	add    $0x1000,%ebx
    7eba:	83 c4 10             	add    $0x10,%esp
    7ebd:	85 f6                	test   %esi,%esi
    7ebf:	7f e4                	jg     7ea5 <verify_area+0x39>
	}
}
    7ec1:	83 c4 04             	add    $0x4,%esp
    7ec4:	5b                   	pop    %ebx
    7ec5:	5e                   	pop    %esi
    7ec6:	c3                   	ret    

00007ec7 <copy_mem>:

int copy_mem(int nr,struct task_struct * p)
{
    7ec7:	55                   	push   %ebp
    7ec8:	57                   	push   %edi
    7ec9:	56                   	push   %esi
    7eca:	53                   	push   %ebx
    7ecb:	83 ec 0c             	sub    $0xc,%esp
    7ece:	8b 5c 24 24          	mov    0x24(%esp),%ebx
	unsigned long old_data_base,new_data_base,data_limit;
	unsigned long old_code_base,new_code_base,code_limit;

	code_limit=get_limit(0x0f);
    7ed2:	b8 0f 00 00 00       	mov    $0xf,%eax
    7ed7:	0f 03 f0             	lsl    %ax,%esi
    7eda:	46                   	inc    %esi
	data_limit=get_limit(0x17);
    7edb:	b0 17                	mov    $0x17,%al
    7edd:	0f 03 f8             	lsl    %ax,%edi
    7ee0:	47                   	inc    %edi
    7ee1:	a1 20 bc 01 00       	mov    0x1bc20,%eax
         __asm__("movb %3,%%dh\n\t"
    7ee6:	8a b0 df 02 00 00    	mov    0x2df(%eax),%dh
    7eec:	8a 90 dc 02 00 00    	mov    0x2dc(%eax),%dl
    7ef2:	c1 e2 10             	shl    $0x10,%edx
    7ef5:	66 8b 90 da 02 00 00 	mov    0x2da(%eax),%dx
    7efc:	89 d1                	mov    %edx,%ecx
{
    7efe:	8a b0 e7 02 00 00    	mov    0x2e7(%eax),%dh
    7f04:	8a 90 e4 02 00 00    	mov    0x2e4(%eax),%dl
    7f0a:	c1 e2 10             	shl    $0x10,%edx
    7f0d:	66 8b 90 e2 02 00 00 	mov    0x2e2(%eax),%dx
    7f14:	89 d5                	mov    %edx,%ebp
	old_code_base = get_base(current->ldt[1]);
	old_data_base = get_base(current->ldt[2]);
	if (old_data_base != old_code_base)
    7f16:	39 ca                	cmp    %ecx,%edx
    7f18:	74 10                	je     7f2a <copy_mem+0x63>
		panic("We don't support separate I&D");
    7f1a:	83 ec 0c             	sub    $0xc,%esp
    7f1d:	68 52 89 01 00       	push   $0x18952
    7f22:	e8 f2 03 00 00       	call   8319 <panic>
    7f27:	83 c4 10             	add    $0x10,%esp
	if (data_limit < code_limit)
    7f2a:	39 f7                	cmp    %esi,%edi
    7f2c:	73 10                	jae    7f3e <copy_mem+0x77>
		panic("Bad data_limit");
    7f2e:	83 ec 0c             	sub    $0xc,%esp
    7f31:	68 70 89 01 00       	push   $0x18970
    7f36:	e8 de 03 00 00       	call   8319 <panic>
    7f3b:	83 c4 10             	add    $0x10,%esp
	new_data_base = new_code_base = nr * 0x4000000;
    7f3e:	8b 44 24 20          	mov    0x20(%esp),%eax
    7f42:	89 c6                	mov    %eax,%esi
    7f44:	c1 e6 1a             	shl    $0x1a,%esi
	p->start_code = new_code_base;
    7f47:	89 b3 18 02 00 00    	mov    %esi,0x218(%ebx)
	set_base(p->ldt[1],new_code_base);
    7f4d:	89 f2                	mov    %esi,%edx
    7f4f:	52                   	push   %edx
    7f50:	66 89 93 da 02 00 00 	mov    %dx,0x2da(%ebx)
    7f57:	c1 ca 10             	ror    $0x10,%edx
    7f5a:	88 93 dc 02 00 00    	mov    %dl,0x2dc(%ebx)
    7f60:	88 b3 df 02 00 00    	mov    %dh,0x2df(%ebx)
    7f66:	5a                   	pop    %edx
	set_base(p->ldt[2],new_data_base);
    7f67:	52                   	push   %edx
    7f68:	66 89 93 e2 02 00 00 	mov    %dx,0x2e2(%ebx)
    7f6f:	c1 ca 10             	ror    $0x10,%edx
    7f72:	88 93 e4 02 00 00    	mov    %dl,0x2e4(%ebx)
    7f78:	88 b3 e7 02 00 00    	mov    %dh,0x2e7(%ebx)
    7f7e:	5a                   	pop    %edx
	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
    7f7f:	83 ec 04             	sub    $0x4,%esp
    7f82:	57                   	push   %edi
    7f83:	56                   	push   %esi
    7f84:	55                   	push   %ebp
    7f85:	e8 dc 1b 00 00       	call   9b66 <copy_page_tables>
    7f8a:	83 c4 10             	add    $0x10,%esp
		printk("free_page_tables: from copy_mem\n");
		free_page_tables(new_data_base,data_limit);
		return -ENOMEM;
	}
	return 0;
    7f8d:	ba 00 00 00 00       	mov    $0x0,%edx
	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
    7f92:	85 c0                	test   %eax,%eax
    7f94:	74 1f                	je     7fb5 <copy_mem+0xee>
		printk("free_page_tables: from copy_mem\n");
    7f96:	83 ec 0c             	sub    $0xc,%esp
    7f99:	68 bc 8a 01 00       	push   $0x18abc
    7f9e:	e8 b0 03 00 00       	call   8353 <printk>
		free_page_tables(new_data_base,data_limit);
    7fa3:	83 c4 08             	add    $0x8,%esp
    7fa6:	57                   	push   %edi
    7fa7:	56                   	push   %esi
    7fa8:	e8 54 1a 00 00       	call   9a01 <free_page_tables>
		return -ENOMEM;
    7fad:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
    7fb2:	83 c4 10             	add    $0x10,%esp
}
    7fb5:	89 d0                	mov    %edx,%eax
    7fb7:	83 c4 0c             	add    $0xc,%esp
    7fba:	5b                   	pop    %ebx
    7fbb:	5e                   	pop    %esi
    7fbc:	5f                   	pop    %edi
    7fbd:	5d                   	pop    %ebp
    7fbe:	c3                   	ret    

00007fbf <copy_process>:
 */
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss)
{
    7fbf:	56                   	push   %esi
    7fc0:	53                   	push   %ebx
    7fc1:	83 ec 04             	sub    $0x4,%esp
    7fc4:	8b 74 24 10          	mov    0x10(%esp),%esi
	struct task_struct *p;
	int i;
	struct file *f;

	p = (struct task_struct *) get_free_page();
    7fc8:	e8 a3 19 00 00       	call   9970 <get_free_page>
    7fcd:	89 c3                	mov    %eax,%ebx
	if (!p)
		return -EAGAIN;
    7fcf:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (!p)
    7fd4:	85 db                	test   %ebx,%ebx
    7fd6:	0f 84 d8 02 00 00    	je     82b4 <copy_process+0x2f5>
	task[nr] = p;
    7fdc:	89 1c b5 40 bc 01 00 	mov    %ebx,0x1bc40(,%esi,4)
	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
    7fe3:	83 ec 04             	sub    $0x4,%esp
    7fe6:	68 bc 03 00 00       	push   $0x3bc
    7feb:	ff 35 20 bc 01 00    	pushl  0x1bc20
    7ff1:	53                   	push   %ebx
    7ff2:	e8 d3 05 01 00       	call   185ca <memcpy>
	p->state = TASK_UNINTERRUPTIBLE;
    7ff7:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
	p->pid = last_pid;
    7ffd:	a1 20 ed 01 00       	mov    0x1ed20,%eax
    8002:	89 83 2c 02 00 00    	mov    %eax,0x22c(%ebx)
	p->father = current->pid;
    8008:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    800d:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    8013:	89 83 30 02 00 00    	mov    %eax,0x230(%ebx)
	p->counter = p->priority;
    8019:	8b 43 08             	mov    0x8(%ebx),%eax
    801c:	89 43 04             	mov    %eax,0x4(%ebx)
	p->signal = 0;
    801f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	p->alarm = 0;
    8026:	c7 83 4c 02 00 00 00 	movl   $0x0,0x24c(%ebx)
    802d:	00 00 00 
	p->leader = 0;		/* process leadership doesn't inherit */
    8030:	c7 83 3c 02 00 00 00 	movl   $0x0,0x23c(%ebx)
    8037:	00 00 00 
	p->utime = p->stime = 0;
    803a:	c7 83 54 02 00 00 00 	movl   $0x0,0x254(%ebx)
    8041:	00 00 00 
    8044:	c7 83 50 02 00 00 00 	movl   $0x0,0x250(%ebx)
    804b:	00 00 00 
	p->cutime = p->cstime = 0;
    804e:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
    8055:	00 00 00 
    8058:	c7 83 58 02 00 00 00 	movl   $0x0,0x258(%ebx)
    805f:	00 00 00 
	p->start_time = jiffies;
    8062:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    8067:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	p->tss.back_link = 0;
    806d:	c7 83 e8 02 00 00 00 	movl   $0x0,0x2e8(%ebx)
    8074:	00 00 00 
	p->tss.esp0 = PAGE_SIZE + (long) p;
    8077:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
    807d:	89 83 ec 02 00 00    	mov    %eax,0x2ec(%ebx)
	p->tss.ss0 = 0x10;
    8083:	c7 83 f0 02 00 00 10 	movl   $0x10,0x2f0(%ebx)
    808a:	00 00 00 
	p->tss.eip = eip;
    808d:	8b 44 24 50          	mov    0x50(%esp),%eax
    8091:	89 83 08 03 00 00    	mov    %eax,0x308(%ebx)
	p->tss.eflags = eflags;
    8097:	8b 44 24 58          	mov    0x58(%esp),%eax
    809b:	89 83 0c 03 00 00    	mov    %eax,0x30c(%ebx)
	p->tss.eax = 0;
    80a1:	c7 83 10 03 00 00 00 	movl   $0x0,0x310(%ebx)
    80a8:	00 00 00 
	p->tss.ecx = ecx;
    80ab:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    80af:	89 83 14 03 00 00    	mov    %eax,0x314(%ebx)
	p->tss.edx = edx;
    80b5:	8b 44 24 40          	mov    0x40(%esp),%eax
    80b9:	89 83 18 03 00 00    	mov    %eax,0x318(%ebx)
	p->tss.ebx = ebx;
    80bf:	8b 44 24 38          	mov    0x38(%esp),%eax
    80c3:	89 83 1c 03 00 00    	mov    %eax,0x31c(%ebx)
	p->tss.esp = esp;
    80c9:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    80cd:	89 83 20 03 00 00    	mov    %eax,0x320(%ebx)
	p->tss.ebp = ebp;
    80d3:	8b 44 24 24          	mov    0x24(%esp),%eax
    80d7:	89 83 24 03 00 00    	mov    %eax,0x324(%ebx)
	p->tss.esi = esi;
    80dd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    80e1:	89 83 28 03 00 00    	mov    %eax,0x328(%ebx)
	p->tss.edi = edi;
    80e7:	8b 44 24 28          	mov    0x28(%esp),%eax
    80eb:	89 83 2c 03 00 00    	mov    %eax,0x32c(%ebx)
	p->tss.es = es & 0xffff;
    80f1:	0f b7 44 24 48       	movzwl 0x48(%esp),%eax
    80f6:	89 83 30 03 00 00    	mov    %eax,0x330(%ebx)
	p->tss.cs = cs & 0xffff;
    80fc:	0f b7 44 24 54       	movzwl 0x54(%esp),%eax
    8101:	89 83 34 03 00 00    	mov    %eax,0x334(%ebx)
	p->tss.ss = ss & 0xffff;
    8107:	0f b7 44 24 60       	movzwl 0x60(%esp),%eax
    810c:	89 83 38 03 00 00    	mov    %eax,0x338(%ebx)
	p->tss.ds = ds & 0xffff;
    8112:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
    8117:	89 83 3c 03 00 00    	mov    %eax,0x33c(%ebx)
	p->tss.fs = fs & 0xffff;
    811d:	0f b7 44 24 44       	movzwl 0x44(%esp),%eax
    8122:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
	p->tss.gs = gs & 0xffff;
    8128:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
    812d:	89 83 44 03 00 00    	mov    %eax,0x344(%ebx)
	p->tss.ldt = _LDT(nr);
    8133:	89 f0                	mov    %esi,%eax
    8135:	c1 e0 04             	shl    $0x4,%eax
    8138:	83 c0 28             	add    $0x28,%eax
    813b:	89 83 48 03 00 00    	mov    %eax,0x348(%ebx)
	p->tss.trace_bitmap = 0x80000000;
    8141:	c7 83 4c 03 00 00 00 	movl   $0x80000000,0x34c(%ebx)
    8148:	00 00 80 
	if (last_task_used_math == current)
    814b:	83 c4 10             	add    $0x10,%esp
    814e:	a1 c8 e9 01 00       	mov    0x1e9c8,%eax
    8153:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    8159:	75 08                	jne    8163 <copy_process+0x1a4>
		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
    815b:	0f 06                	clts   
    815d:	dd b3 50 03 00 00    	fnsave 0x350(%ebx)
	if (copy_mem(nr,p)) {
    8163:	83 ec 08             	sub    $0x8,%esp
    8166:	53                   	push   %ebx
    8167:	56                   	push   %esi
    8168:	e8 5a fd ff ff       	call   7ec7 <copy_mem>
    816d:	83 c4 10             	add    $0x10,%esp
		task[nr] = NULL;
		free_page((long) p);
		return -EAGAIN;
	}
	for (i=0; i<NR_OPEN;i++)
    8170:	ba 00 00 00 00       	mov    $0x0,%edx
	if (copy_mem(nr,p)) {
    8175:	85 c0                	test   %eax,%eax
    8177:	74 21                	je     819a <copy_process+0x1db>
		task[nr] = NULL;
    8179:	c7 04 b5 40 bc 01 00 	movl   $0x0,0x1bc40(,%esi,4)
    8180:	00 00 00 00 
		free_page((long) p);
    8184:	83 ec 0c             	sub    $0xc,%esp
    8187:	53                   	push   %ebx
    8188:	e8 18 18 00 00       	call   99a5 <free_page>
		return -EAGAIN;
    818d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    8192:	83 c4 10             	add    $0x10,%esp
    8195:	e9 1a 01 00 00       	jmp    82b4 <copy_process+0x2f5>
		if ((f=p->filp[i]))
    819a:	8b 84 93 80 02 00 00 	mov    0x280(%ebx,%edx,4),%eax
    81a1:	85 c0                	test   %eax,%eax
    81a3:	74 04                	je     81a9 <copy_process+0x1ea>
			f->f_count++;
    81a5:	66 ff 40 04          	incw   0x4(%eax)
	for (i=0; i<NR_OPEN;i++)
    81a9:	42                   	inc    %edx
    81aa:	83 fa 13             	cmp    $0x13,%edx
    81ad:	7e eb                	jle    819a <copy_process+0x1db>
	if (current->pwd)
    81af:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    81b4:	83 b8 70 02 00 00 00 	cmpl   $0x0,0x270(%eax)
    81bb:	74 0a                	je     81c7 <copy_process+0x208>
		current->pwd->i_count++;
    81bd:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    81c3:	66 ff 40 30          	incw   0x30(%eax)
	if (current->root)
    81c7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    81cc:	83 b8 74 02 00 00 00 	cmpl   $0x0,0x274(%eax)
    81d3:	74 0a                	je     81df <copy_process+0x220>
		current->root->i_count++;
    81d5:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    81db:	66 ff 40 30          	incw   0x30(%eax)
	if (current->executable)
    81df:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    81e4:	83 b8 78 02 00 00 00 	cmpl   $0x0,0x278(%eax)
    81eb:	74 0a                	je     81f7 <copy_process+0x238>
		current->executable->i_count++;
    81ed:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    81f3:	66 ff 40 30          	incw   0x30(%eax)
	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
    81f7:	8d 93 e8 02 00 00    	lea    0x2e8(%ebx),%edx
    81fd:	89 f1                	mov    %esi,%ecx
    81ff:	c1 e1 04             	shl    $0x4,%ecx
    8202:	89 d0                	mov    %edx,%eax
    8204:	66 c7 81 d8 5c 00 00 	movw   $0x68,0x5cd8(%ecx)
    820b:	68 00 
    820d:	66 89 81 da 5c 00 00 	mov    %ax,0x5cda(%ecx)
    8214:	c1 c8 10             	ror    $0x10,%eax
    8217:	88 81 dc 5c 00 00    	mov    %al,0x5cdc(%ecx)
    821d:	c6 81 dd 5c 00 00 89 	movb   $0x89,0x5cdd(%ecx)
    8224:	c6 81 de 5c 00 00 00 	movb   $0x0,0x5cde(%ecx)
    822b:	88 a1 df 5c 00 00    	mov    %ah,0x5cdf(%ecx)
    8231:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
    8234:	8d 93 d0 02 00 00    	lea    0x2d0(%ebx),%edx
    823a:	89 d0                	mov    %edx,%eax
    823c:	66 c7 81 e0 5c 00 00 	movw   $0x68,0x5ce0(%ecx)
    8243:	68 00 
    8245:	66 89 81 e2 5c 00 00 	mov    %ax,0x5ce2(%ecx)
    824c:	c1 c8 10             	ror    $0x10,%eax
    824f:	88 81 e4 5c 00 00    	mov    %al,0x5ce4(%ecx)
    8255:	c6 81 e5 5c 00 00 82 	movb   $0x82,0x5ce5(%ecx)
    825c:	c6 81 e6 5c 00 00 00 	movb   $0x0,0x5ce6(%ecx)
    8263:	88 a1 e7 5c 00 00    	mov    %ah,0x5ce7(%ecx)
    8269:	c1 c8 10             	ror    $0x10,%eax
	p->state = TASK_RUNNING;	/* do this last, just in case */
    826c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)


	fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'N', jiffies);
    8272:	83 ec 0c             	sub    $0xc,%esp
    8275:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    827a:	50                   	push   %eax
    827b:	6a 4e                	push   $0x4e
    827d:	ff b3 2c 02 00 00    	pushl  0x22c(%ebx)
    8283:	68 cb 87 01 00       	push   $0x187cb
    8288:	6a 03                	push   $0x3
    828a:	e8 ff 00 00 00       	call   838e <fprintk>
	fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'J', jiffies);
    828f:	83 c4 14             	add    $0x14,%esp
    8292:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    8297:	50                   	push   %eax
    8298:	6a 4a                	push   $0x4a
    829a:	ff b3 2c 02 00 00    	pushl  0x22c(%ebx)
    82a0:	68 cb 87 01 00       	push   $0x187cb
    82a5:	6a 03                	push   $0x3
    82a7:	e8 e2 00 00 00       	call   838e <fprintk>

	return last_pid;
    82ac:	a1 20 ed 01 00       	mov    0x1ed20,%eax
    82b1:	83 c4 20             	add    $0x20,%esp
}
    82b4:	83 c4 04             	add    $0x4,%esp
    82b7:	5b                   	pop    %ebx
    82b8:	5e                   	pop    %esi
    82b9:	c3                   	ret    

000082ba <find_empty_process>:
int find_empty_process(void)
{
	int i;

	repeat:
		if ((++last_pid)<0) last_pid=1;
    82ba:	ff 05 20 ed 01 00    	incl   0x1ed20
    82c0:	83 3d 20 ed 01 00 00 	cmpl   $0x0,0x1ed20
    82c7:	79 0a                	jns    82d3 <find_empty_process+0x19>
    82c9:	c7 05 20 ed 01 00 01 	movl   $0x1,0x1ed20
    82d0:	00 00 00 
		for(i=0 ; i<NR_TASKS ; i++)
    82d3:	ba 00 00 00 00       	mov    $0x0,%edx
    82d8:	b9 40 bc 01 00       	mov    $0x1bc40,%ecx
			if (task[i] && task[i]->pid == last_pid) goto repeat;
    82dd:	83 3c 91 00          	cmpl   $0x0,(%ecx,%edx,4)
    82e1:	74 11                	je     82f4 <find_empty_process+0x3a>
    82e3:	8b 04 91             	mov    (%ecx,%edx,4),%eax
    82e6:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    82ec:	3b 05 20 ed 01 00    	cmp    0x1ed20,%eax
    82f2:	74 c6                	je     82ba <find_empty_process>
		for(i=0 ; i<NR_TASKS ; i++)
    82f4:	42                   	inc    %edx
    82f5:	83 fa 3f             	cmp    $0x3f,%edx
    82f8:	7e e3                	jle    82dd <find_empty_process+0x23>
	for(i=1 ; i<NR_TASKS ; i++)
    82fa:	ba 01 00 00 00       	mov    $0x1,%edx
    82ff:	b8 40 bc 01 00       	mov    $0x1bc40,%eax
		if (!task[i])
    8304:	83 3c 90 00          	cmpl   $0x0,(%eax,%edx,4)
    8308:	75 03                	jne    830d <find_empty_process+0x53>
			return i;
    830a:	89 d0                	mov    %edx,%eax
    830c:	c3                   	ret    
	for(i=1 ; i<NR_TASKS ; i++)
    830d:	42                   	inc    %edx
    830e:	83 fa 3f             	cmp    $0x3f,%edx
    8311:	7e f1                	jle    8304 <find_empty_process+0x4a>
	return -EAGAIN;
    8313:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
    8318:	c3                   	ret    

00008319 <panic>:
#include <linux/sched.h>

void sys_sync(void);	/* it's really int */

volatile void panic(const char * s)
{
    8319:	83 ec 14             	sub    $0x14,%esp
	printk("Kernel panic: %s\n\r",s);
    831c:	ff 74 24 18          	pushl  0x18(%esp)
    8320:	68 7f 89 01 00       	push   $0x1897f
    8325:	e8 29 00 00 00       	call   8353 <printk>
	if (current == task[0])
    832a:	83 c4 10             	add    $0x10,%esp
    832d:	a1 40 bc 01 00       	mov    0x1bc40,%eax
    8332:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    8338:	75 12                	jne    834c <panic+0x33>
		printk("In swapper task - not syncing\n\r");
    833a:	83 ec 0c             	sub    $0xc,%esp
    833d:	68 e0 8a 01 00       	push   $0x18ae0
    8342:	e8 0c 00 00 00       	call   8353 <printk>
    8347:	83 c4 10             	add    $0x10,%esp
    834a:	eb 05                	jmp    8351 <panic+0x38>
	else
		sys_sync();
    834c:	e8 74 3c 00 00       	call   bfc5 <sys_sync>
	for(;;);
    8351:	eb fe                	jmp    8351 <panic+0x38>

00008353 <printk>:
static char buf[1024];

extern int vsprintf(char * buf, const char * fmt, va_list args);

int printk(const char *fmt, ...)
{
    8353:	53                   	push   %ebx
    8354:	83 ec 08             	sub    $0x8,%esp
	va_list args;
	int i;

	va_start(args, fmt);
    8357:	8d 44 24 14          	lea    0x14(%esp),%eax
	i=vsprintf(buf,fmt,args);
    835b:	83 ec 04             	sub    $0x4,%esp
    835e:	50                   	push   %eax
    835f:	ff 74 24 18          	pushl  0x18(%esp)
    8363:	68 40 f1 01 00       	push   $0x1f140
    8368:	e8 d1 02 00 00       	call   863e <vsprintf>
    836d:	89 c3                	mov    %eax,%ebx
	va_end(args);
	__asm__("push %%fs\n\t"
    836f:	0f a0                	push   %fs
    8371:	1e                   	push   %ds
    8372:	0f a1                	pop    %fs
    8374:	53                   	push   %ebx
    8375:	68 40 f1 01 00       	push   $0x1f140
    837a:	6a 00                	push   $0x0
    837c:	e8 db d5 00 00       	call   1595c <tty_write>
    8381:	83 c4 08             	add    $0x8,%esp
    8384:	5b                   	pop    %ebx
    8385:	0f a1                	pop    %fs
		"addl $8,%%esp\n\t"
		"popl %0\n\t"
		"pop %%fs"
		::"r" (i):"ax","cx","dx");
	return i;
}
    8387:	89 d8                	mov    %ebx,%eax
    8389:	83 c4 18             	add    $0x18,%esp
    838c:	5b                   	pop    %ebx
    838d:	c3                   	ret    

0000838e <fprintk>:


int fprintk(int fd, const char *fmt, ...)
{
    838e:	57                   	push   %edi
    838f:	56                   	push   %esi
    8390:	53                   	push   %ebx
    8391:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    va_list args;
    int count;
    struct file * file;
    struct m_inode * inode;

    va_start(args, fmt);
    8395:	8d 44 24 18          	lea    0x18(%esp),%eax
    count=vsprintf(logbuf, fmt, args);
    8399:	83 ec 04             	sub    $0x4,%esp
    839c:	50                   	push   %eax
    839d:	ff 74 24 1c          	pushl  0x1c(%esp)
    83a1:	68 40 ed 01 00       	push   $0x1ed40
    83a6:	e8 93 02 00 00       	call   863e <vsprintf>
    83ab:	89 c7                	mov    %eax,%edi
    va_end(args);
/* 如果输出到stdout或stderr，直接调用sys_write即可 */
    if (fd < 3)
    83ad:	83 c4 10             	add    $0x10,%esp
    83b0:	83 fb 02             	cmp    $0x2,%ebx
    83b3:	7f 19                	jg     83ce <fprintk+0x40>
    {
        __asm__("push %%fs\n\t"
    83b5:	0f a0                	push   %fs
    83b7:	1e                   	push   %ds
    83b8:	0f a1                	pop    %fs
    83ba:	57                   	push   %edi
    83bb:	68 40 ed 01 00       	push   $0x1ed40
    83c0:	53                   	push   %ebx
    83c1:	e8 d6 2d 00 00       	call   b19c <sys_write>
    83c6:	83 c4 08             	add    $0x8,%esp
    83c9:	5f                   	pop    %edi
    83ca:	0f a1                	pop    %fs
    83cc:	eb 30                	jmp    83fe <fprintk+0x70>
    }
    else
	/* 假定>=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/
    {
    /* 从进程0的文件描述符表中得到文件句柄 */
        if (!(file=task[0]->filp[fd]))
    83ce:	a1 40 bc 01 00       	mov    0x1bc40,%eax
    83d3:	8b b4 98 80 02 00 00 	mov    0x280(%eax,%ebx,4),%esi
            return 0;
    83da:	b8 00 00 00 00       	mov    $0x0,%eax
        if (!(file=task[0]->filp[fd]))
    83df:	85 f6                	test   %esi,%esi
    83e1:	74 1d                	je     8400 <fprintk+0x72>
        inode=file->f_inode;
    83e3:	8b 5e 08             	mov    0x8(%esi),%ebx

        __asm__("push %%fs\n\t"
    83e6:	0f a0                	push   %fs
    83e8:	1e                   	push   %ds
    83e9:	0f a1                	pop    %fs
    83eb:	57                   	push   %edi
    83ec:	68 40 ed 01 00       	push   $0x1ed40
    83f1:	56                   	push   %esi
    83f2:	53                   	push   %ebx
    83f3:	e8 de 58 00 00       	call   dcd6 <file_write>
    83f8:	83 c4 0c             	add    $0xc,%esp
    83fb:	5f                   	pop    %edi
    83fc:	0f a1                	pop    %fs
            "addl $12,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count),"r" (file),"r" (inode):"ax","cx","dx");
    }
    return count;
    83fe:	89 f8                	mov    %edi,%eax
}
    8400:	5b                   	pop    %ebx
    8401:	5e                   	pop    %esi
    8402:	5f                   	pop    %edi
    8403:	c3                   	ret    

00008404 <number>:
__asm__("divl %4":"=a" (n),"=d" (__res):"0" (n),"1" (0),"r" (base)); \
__res; })

static char * number(char * str, int num, int base, int size, int precision
	,int type)
{
    8404:	55                   	push   %ebp
    8405:	57                   	push   %edi
    8406:	56                   	push   %esi
    8407:	53                   	push   %ebx
    8408:	83 ec 7c             	sub    $0x7c,%esp
    840b:	8b 9c 24 90 00 00 00 	mov    0x90(%esp),%ebx
    8412:	8b ac 24 94 00 00 00 	mov    0x94(%esp),%ebp
    8419:	8b bc 24 9c 00 00 00 	mov    0x9c(%esp),%edi
	char c,sign,tmp[36];
	const char *digits="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    8420:	c7 44 24 1c 00 8b 01 	movl   $0x18b00,0x1c(%esp)
    8427:	00 
	int i;

	if (type&SMALL) digits="0123456789abcdefghijklmnopqrstuvwxyz";
    8428:	f6 84 24 a4 00 00 00 	testb  $0x40,0xa4(%esp)
    842f:	40 
    8430:	74 08                	je     843a <number+0x36>
    8432:	c7 44 24 1c 28 8b 01 	movl   $0x18b28,0x1c(%esp)
    8439:	00 
	if (type&LEFT) type &= ~ZEROPAD;
    843a:	f6 84 24 a4 00 00 00 	testb  $0x10,0xa4(%esp)
    8441:	10 
    8442:	74 08                	je     844c <number+0x48>
    8444:	83 a4 24 a4 00 00 00 	andl   $0xfffffffe,0xa4(%esp)
    844b:	fe 
	if (base<2 || base>36)
    844c:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
    8453:	83 e8 02             	sub    $0x2,%eax
		return 0;
    8456:	ba 00 00 00 00       	mov    $0x0,%edx
	if (base<2 || base>36)
    845b:	83 f8 22             	cmp    $0x22,%eax
    845e:	0f 87 d0 01 00 00    	ja     8634 <number+0x230>
	c = (type & ZEROPAD) ? '0' : ' ' ;
    8464:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
    846b:	83 e0 01             	and    $0x1,%eax
    846e:	83 f8 01             	cmp    $0x1,%eax
    8471:	19 c0                	sbb    %eax,%eax
    8473:	83 e0 f0             	and    $0xfffffff0,%eax
    8476:	83 c0 30             	add    $0x30,%eax
    8479:	88 44 24 30          	mov    %al,0x30(%esp)
	if (type&SIGN && num<0) {
    847d:	f6 84 24 a4 00 00 00 	testb  $0x2,0xa4(%esp)
    8484:	02 
    8485:	74 0d                	je     8494 <number+0x90>
    8487:	85 ed                	test   %ebp,%ebp
    8489:	79 09                	jns    8494 <number+0x90>
		sign='-';
    848b:	c6 44 24 20 2d       	movb   $0x2d,0x20(%esp)
		num = -num;
    8490:	f7 dd                	neg    %ebp
    8492:	eb 27                	jmp    84bb <number+0xb7>
	} else
		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
    8494:	c6 44 24 20 2b       	movb   $0x2b,0x20(%esp)
    8499:	f6 84 24 a4 00 00 00 	testb  $0x4,0xa4(%esp)
    84a0:	04 
    84a1:	75 18                	jne    84bb <number+0xb7>
    84a3:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
    84aa:	83 e0 08             	and    $0x8,%eax
    84ad:	83 f8 01             	cmp    $0x1,%eax
    84b0:	19 d2                	sbb    %edx,%edx
    84b2:	f7 d2                	not    %edx
    84b4:	83 e2 20             	and    $0x20,%edx
    84b7:	88 54 24 20          	mov    %dl,0x20(%esp)
	if (sign) size--;
    84bb:	80 7c 24 20 01       	cmpb   $0x1,0x20(%esp)
    84c0:	83 d7 ff             	adc    $0xffffffff,%edi
	if (type&SPECIAL) {
    84c3:	f6 84 24 a4 00 00 00 	testb  $0x20,0xa4(%esp)
    84ca:	20 
    84cb:	74 1a                	je     84e7 <number+0xe3>
		if (base==16) size -= 2;
    84cd:	83 bc 24 98 00 00 00 	cmpl   $0x10,0x98(%esp)
    84d4:	10 
    84d5:	75 05                	jne    84dc <number+0xd8>
    84d7:	83 ef 02             	sub    $0x2,%edi
    84da:	eb 0b                	jmp    84e7 <number+0xe3>
		else if (base==8) size--;
    84dc:	83 bc 24 98 00 00 00 	cmpl   $0x8,0x98(%esp)
    84e3:	08 
    84e4:	75 01                	jne    84e7 <number+0xe3>
    84e6:	4f                   	dec    %edi
	}
	i=0;
    84e7:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    84ee:	00 
    84ef:	be 00 00 00 00       	mov    $0x0,%esi
	if (num==0)
    84f4:	85 ed                	test   %ebp,%ebp
    84f6:	75 0f                	jne    8507 <number+0x103>
		tmp[i++]='0';
    84f8:	c6 44 24 40 30       	movb   $0x30,0x40(%esp)
    84fd:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    8504:	00 
    8505:	eb 31                	jmp    8538 <number+0x134>
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
    8507:	8d 4c 24 70          	lea    0x70(%esp),%ecx
    850b:	03 4c 24 18          	add    0x18(%esp),%ecx
    850f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    8513:	89 e8                	mov    %ebp,%eax
    8515:	89 f2                	mov    %esi,%edx
    8517:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
    851e:	f7 f1                	div    %ecx
    8520:	89 c5                	mov    %eax,%ebp
    8522:	ff 44 24 18          	incl   0x18(%esp)
    8526:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    852a:	8a 04 0a             	mov    (%edx,%ecx,1),%al
    852d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    8531:	88 42 d0             	mov    %al,-0x30(%edx)
    8534:	85 ed                	test   %ebp,%ebp
    8536:	75 cf                	jne    8507 <number+0x103>
	if (i>precision) precision=i;
    8538:	8b 8c 24 a0 00 00 00 	mov    0xa0(%esp),%ecx
    853f:	39 4c 24 18          	cmp    %ecx,0x18(%esp)
    8543:	7e 0b                	jle    8550 <number+0x14c>
    8545:	8b 44 24 18          	mov    0x18(%esp),%eax
    8549:	89 84 24 a0 00 00 00 	mov    %eax,0xa0(%esp)
	size -= precision;
    8550:	2b bc 24 a0 00 00 00 	sub    0xa0(%esp),%edi
	if (!(type&(ZEROPAD+LEFT)))
    8557:	f6 84 24 a4 00 00 00 	testb  $0x11,0xa4(%esp)
    855e:	11 
    855f:	75 12                	jne    8573 <number+0x16f>
		while(size-->0)
			*str++ = ' ';
    8561:	89 f8                	mov    %edi,%eax
    8563:	4f                   	dec    %edi
    8564:	85 c0                	test   %eax,%eax
    8566:	7e 0b                	jle    8573 <number+0x16f>
    8568:	c6 03 20             	movb   $0x20,(%ebx)
    856b:	43                   	inc    %ebx
    856c:	89 f8                	mov    %edi,%eax
    856e:	4f                   	dec    %edi
    856f:	85 c0                	test   %eax,%eax
    8571:	7f f5                	jg     8568 <number+0x164>
	if (sign)
    8573:	80 7c 24 20 00       	cmpb   $0x0,0x20(%esp)
    8578:	74 07                	je     8581 <number+0x17d>
		*str++ = sign;
    857a:	8a 54 24 20          	mov    0x20(%esp),%dl
    857e:	88 13                	mov    %dl,(%ebx)
    8580:	43                   	inc    %ebx
	if (type&SPECIAL) {
    8581:	f6 84 24 a4 00 00 00 	testb  $0x20,0xa4(%esp)
    8588:	20 
    8589:	74 28                	je     85b3 <number+0x1af>
		if (base==8)
    858b:	83 bc 24 98 00 00 00 	cmpl   $0x8,0x98(%esp)
    8592:	08 
    8593:	75 06                	jne    859b <number+0x197>
			*str++ = '0';
    8595:	c6 03 30             	movb   $0x30,(%ebx)
    8598:	43                   	inc    %ebx
    8599:	eb 18                	jmp    85b3 <number+0x1af>
		else if (base==16) {
    859b:	83 bc 24 98 00 00 00 	cmpl   $0x10,0x98(%esp)
    85a2:	10 
    85a3:	75 0e                	jne    85b3 <number+0x1af>
			*str++ = '0';
    85a5:	c6 03 30             	movb   $0x30,(%ebx)
    85a8:	43                   	inc    %ebx
			*str++ = digits[33];
    85a9:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    85ad:	8a 41 21             	mov    0x21(%ecx),%al
    85b0:	88 03                	mov    %al,(%ebx)
    85b2:	43                   	inc    %ebx
		}
	}
	if (!(type&LEFT))
    85b3:	f6 84 24 a4 00 00 00 	testb  $0x10,0xa4(%esp)
    85ba:	10 
    85bb:	75 15                	jne    85d2 <number+0x1ce>
		while(size-->0)
			*str++ = c;
    85bd:	89 f8                	mov    %edi,%eax
    85bf:	4f                   	dec    %edi
    85c0:	85 c0                	test   %eax,%eax
    85c2:	7e 0e                	jle    85d2 <number+0x1ce>
    85c4:	8a 44 24 30          	mov    0x30(%esp),%al
    85c8:	88 03                	mov    %al,(%ebx)
    85ca:	43                   	inc    %ebx
    85cb:	89 f8                	mov    %edi,%eax
    85cd:	4f                   	dec    %edi
    85ce:	85 c0                	test   %eax,%eax
    85d0:	7f f2                	jg     85c4 <number+0x1c0>
	while(i<precision--)
		*str++ = '0';
    85d2:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
    85d9:	ff 8c 24 a0 00 00 00 	decl   0xa0(%esp)
    85e0:	3b 44 24 18          	cmp    0x18(%esp),%eax
    85e4:	7e 18                	jle    85fe <number+0x1fa>
    85e6:	c6 03 30             	movb   $0x30,(%ebx)
    85e9:	43                   	inc    %ebx
    85ea:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
    85f1:	ff 8c 24 a0 00 00 00 	decl   0xa0(%esp)
    85f8:	3b 44 24 18          	cmp    0x18(%esp),%eax
    85fc:	7f e8                	jg     85e6 <number+0x1e2>
	while(i-->0)
		*str++ = tmp[i];
    85fe:	8b 44 24 18          	mov    0x18(%esp),%eax
    8602:	ff 4c 24 18          	decl   0x18(%esp)
    8606:	85 c0                	test   %eax,%eax
    8608:	7e 16                	jle    8620 <number+0x21c>
    860a:	8b 54 24 18          	mov    0x18(%esp),%edx
    860e:	8a 44 14 40          	mov    0x40(%esp,%edx,1),%al
    8612:	88 03                	mov    %al,(%ebx)
    8614:	43                   	inc    %ebx
    8615:	89 d0                	mov    %edx,%eax
    8617:	4a                   	dec    %edx
    8618:	89 54 24 18          	mov    %edx,0x18(%esp)
    861c:	85 c0                	test   %eax,%eax
    861e:	7f ea                	jg     860a <number+0x206>
	while(size-->0)
		*str++ = ' ';
    8620:	89 f8                	mov    %edi,%eax
    8622:	4f                   	dec    %edi
    8623:	85 c0                	test   %eax,%eax
    8625:	7e 0b                	jle    8632 <number+0x22e>
    8627:	c6 03 20             	movb   $0x20,(%ebx)
    862a:	43                   	inc    %ebx
    862b:	89 f8                	mov    %edi,%eax
    862d:	4f                   	dec    %edi
    862e:	85 c0                	test   %eax,%eax
    8630:	7f f5                	jg     8627 <number+0x223>
	return str;
    8632:	89 da                	mov    %ebx,%edx
}
    8634:	89 d0                	mov    %edx,%eax
    8636:	83 c4 7c             	add    $0x7c,%esp
    8639:	5b                   	pop    %ebx
    863a:	5e                   	pop    %esi
    863b:	5f                   	pop    %edi
    863c:	5d                   	pop    %ebp
    863d:	c3                   	ret    

0000863e <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
    863e:	55                   	push   %ebp
    863f:	57                   	push   %edi
    8640:	56                   	push   %esi
    8641:	53                   	push   %ebx
    8642:	83 ec 0c             	sub    $0xc,%esp
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
    8645:	8b 74 24 20          	mov    0x20(%esp),%esi
    8649:	8b 44 24 24          	mov    0x24(%esp),%eax
    864d:	80 38 00             	cmpb   $0x0,(%eax)
    8650:	0f 84 e9 02 00 00    	je     893f <vsprintf+0x301>
		if (*fmt != '%') {
    8656:	8b 44 24 24          	mov    0x24(%esp),%eax
    865a:	80 38 25             	cmpb   $0x25,(%eax)
    865d:	74 0a                	je     8669 <vsprintf+0x2b>
			*str++ = *fmt;
    865f:	8a 00                	mov    (%eax),%al
    8661:	88 06                	mov    %al,(%esi)
    8663:	46                   	inc    %esi
			continue;
    8664:	e9 c5 02 00 00       	jmp    892e <vsprintf+0x2f0>
		}
			
		/* process flags */
		flags = 0;
    8669:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    8670:	00 
		repeat:
			++fmt;		/* this also skips first '%' */
    8671:	ff 44 24 24          	incl   0x24(%esp)
			switch (*fmt) {
    8675:	8b 44 24 24          	mov    0x24(%esp),%eax
    8679:	0f be 00             	movsbl (%eax),%eax
    867c:	83 e8 20             	sub    $0x20,%eax
    867f:	83 f8 10             	cmp    $0x10,%eax
    8682:	77 2a                	ja     86ae <vsprintf+0x70>
    8684:	ff 24 85 ec 86 01 00 	jmp    *0x186ec(,%eax,4)
				case '-': flags |= LEFT; goto repeat;
    868b:	83 4c 24 08 10       	orl    $0x10,0x8(%esp)
    8690:	eb df                	jmp    8671 <vsprintf+0x33>
				case '+': flags |= PLUS; goto repeat;
    8692:	83 4c 24 08 04       	orl    $0x4,0x8(%esp)
    8697:	eb d8                	jmp    8671 <vsprintf+0x33>
				case ' ': flags |= SPACE; goto repeat;
    8699:	83 4c 24 08 08       	orl    $0x8,0x8(%esp)
    869e:	eb d1                	jmp    8671 <vsprintf+0x33>
				case '#': flags |= SPECIAL; goto repeat;
    86a0:	83 4c 24 08 20       	orl    $0x20,0x8(%esp)
    86a5:	eb ca                	jmp    8671 <vsprintf+0x33>
				case '0': flags |= ZEROPAD; goto repeat;
    86a7:	83 4c 24 08 01       	orl    $0x1,0x8(%esp)
    86ac:	eb c3                	jmp    8671 <vsprintf+0x33>
				}
		
		/* get field width */
		field_width = -1;
    86ae:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
		if (is_digit(*fmt))
    86b3:	8b 44 24 24          	mov    0x24(%esp),%eax
    86b7:	8a 00                	mov    (%eax),%al
    86b9:	83 e8 30             	sub    $0x30,%eax
    86bc:	3c 09                	cmp    $0x9,%al
    86be:	77 28                	ja     86e8 <vsprintf+0xaa>
{
    86c0:	8d 5c 24 24          	lea    0x24(%esp),%ebx
	int i=0;
    86c4:	b9 00 00 00 00       	mov    $0x0,%ecx
		i = i*10 + *((*s)++) - '0';
    86c9:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
    86cc:	8b 13                	mov    (%ebx),%edx
    86ce:	0f be 02             	movsbl (%edx),%eax
    86d1:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
    86d5:	8d 42 01             	lea    0x1(%edx),%eax
    86d8:	89 03                	mov    %eax,(%ebx)
    86da:	8a 42 01             	mov    0x1(%edx),%al
    86dd:	83 e8 30             	sub    $0x30,%eax
    86e0:	3c 09                	cmp    $0x9,%al
    86e2:	76 e5                	jbe    86c9 <vsprintf+0x8b>
{
    86e4:	89 cd                	mov    %ecx,%ebp
    86e6:	eb 20                	jmp    8708 <vsprintf+0xca>
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
    86e8:	8b 44 24 24          	mov    0x24(%esp),%eax
    86ec:	80 38 2a             	cmpb   $0x2a,(%eax)
    86ef:	75 17                	jne    8708 <vsprintf+0xca>
			/* it's the next argument */
			field_width = va_arg(args, int);
    86f1:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
    86f6:	8b 44 24 28          	mov    0x28(%esp),%eax
    86fa:	8b 68 fc             	mov    -0x4(%eax),%ebp
			if (field_width < 0) {
    86fd:	85 ed                	test   %ebp,%ebp
    86ff:	79 07                	jns    8708 <vsprintf+0xca>
				field_width = -field_width;
    8701:	f7 dd                	neg    %ebp
				flags |= LEFT;
    8703:	83 4c 24 08 10       	orl    $0x10,0x8(%esp)
			}
		}

		/* get the precision */
		precision = -1;
    8708:	ba ff ff ff ff       	mov    $0xffffffff,%edx
		if (*fmt == '.') {
    870d:	8b 44 24 24          	mov    0x24(%esp),%eax
    8711:	80 38 2e             	cmpb   $0x2e,(%eax)
    8714:	75 54                	jne    876a <vsprintf+0x12c>
			++fmt;	
    8716:	40                   	inc    %eax
    8717:	89 44 24 24          	mov    %eax,0x24(%esp)
			if (is_digit(*fmt))
    871b:	8a 00                	mov    (%eax),%al
    871d:	83 e8 30             	sub    $0x30,%eax
    8720:	3c 09                	cmp    $0x9,%al
    8722:	77 28                	ja     874c <vsprintf+0x10e>
{
    8724:	8d 5c 24 24          	lea    0x24(%esp),%ebx
	int i=0;
    8728:	b9 00 00 00 00       	mov    $0x0,%ecx
		i = i*10 + *((*s)++) - '0';
    872d:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
    8730:	8b 13                	mov    (%ebx),%edx
    8732:	0f be 02             	movsbl (%edx),%eax
    8735:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
    8739:	8d 42 01             	lea    0x1(%edx),%eax
    873c:	89 03                	mov    %eax,(%ebx)
    873e:	8a 42 01             	mov    0x1(%edx),%al
    8741:	83 e8 30             	sub    $0x30,%eax
    8744:	3c 09                	cmp    $0x9,%al
    8746:	76 e5                	jbe    872d <vsprintf+0xef>
{
    8748:	89 ca                	mov    %ecx,%edx
    874a:	eb 15                	jmp    8761 <vsprintf+0x123>
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
    874c:	8b 44 24 24          	mov    0x24(%esp),%eax
    8750:	80 38 2a             	cmpb   $0x2a,(%eax)
    8753:	75 0c                	jne    8761 <vsprintf+0x123>
				/* it's the next argument */
				precision = va_arg(args, int);
    8755:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
    875a:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    875e:	8b 51 fc             	mov    -0x4(%ecx),%edx
			}
			if (precision < 0)
    8761:	85 d2                	test   %edx,%edx
    8763:	79 05                	jns    876a <vsprintf+0x12c>
				precision = 0;
    8765:	ba 00 00 00 00       	mov    $0x0,%edx
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
    876a:	8b 44 24 24          	mov    0x24(%esp),%eax
    876e:	80 38 68             	cmpb   $0x68,(%eax)
    8771:	74 0a                	je     877d <vsprintf+0x13f>
    8773:	80 38 6c             	cmpb   $0x6c,(%eax)
    8776:	74 05                	je     877d <vsprintf+0x13f>
    8778:	80 38 4c             	cmpb   $0x4c,(%eax)
    877b:	75 04                	jne    8781 <vsprintf+0x143>
			qualifier = *fmt;
			++fmt;
    877d:	ff 44 24 24          	incl   0x24(%esp)
		}

		switch (*fmt) {
    8781:	8b 44 24 24          	mov    0x24(%esp),%eax
    8785:	0f be 00             	movsbl (%eax),%eax
    8788:	83 e8 58             	sub    $0x58,%eax
    878b:	83 f8 20             	cmp    $0x20,%eax
    878e:	0f 87 79 01 00 00    	ja     890d <vsprintf+0x2cf>
    8794:	ff 24 85 30 87 01 00 	jmp    *0x18730(,%eax,4)
		case 'c':
			if (!(flags & LEFT))
    879b:	f6 44 24 08 10       	testb  $0x10,0x8(%esp)
    87a0:	75 0e                	jne    87b0 <vsprintf+0x172>
				while (--field_width > 0)
					*str++ = ' ';
    87a2:	4d                   	dec    %ebp
    87a3:	85 ed                	test   %ebp,%ebp
    87a5:	7e 09                	jle    87b0 <vsprintf+0x172>
    87a7:	c6 06 20             	movb   $0x20,(%esi)
    87aa:	46                   	inc    %esi
    87ab:	4d                   	dec    %ebp
    87ac:	85 ed                	test   %ebp,%ebp
    87ae:	7f f7                	jg     87a7 <vsprintf+0x169>
			*str++ = (unsigned char) va_arg(args, int);
    87b0:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
    87b5:	89 f2                	mov    %esi,%edx
    87b7:	46                   	inc    %esi
    87b8:	8b 7c 24 28          	mov    0x28(%esp),%edi
    87bc:	8b 47 fc             	mov    -0x4(%edi),%eax
    87bf:	88 02                	mov    %al,(%edx)
			while (--field_width > 0)
				*str++ = ' ';
    87c1:	4d                   	dec    %ebp
    87c2:	85 ed                	test   %ebp,%ebp
    87c4:	0f 8e 64 01 00 00    	jle    892e <vsprintf+0x2f0>
    87ca:	c6 06 20             	movb   $0x20,(%esi)
    87cd:	46                   	inc    %esi
    87ce:	4d                   	dec    %ebp
    87cf:	85 ed                	test   %ebp,%ebp
    87d1:	7f f7                	jg     87ca <vsprintf+0x18c>
			break;
    87d3:	e9 56 01 00 00       	jmp    892e <vsprintf+0x2f0>

		case 's':
			s = va_arg(args, char *);
    87d8:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
    87dd:	8b 44 24 28          	mov    0x28(%esp),%eax
    87e1:	8b 58 fc             	mov    -0x4(%eax),%ebx
}

extern inline int strlen(const char * s)
{
register int __res ;
__asm__("cld\n\t"
    87e4:	b8 00 00 00 00       	mov    $0x0,%eax
    87e9:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
{
    87ee:	89 df                	mov    %ebx,%edi
    87f0:	fc                   	cld    
    87f1:	f2 ae                	repnz scas %es:(%edi),%al
    87f3:	f7 d1                	not    %ecx
    87f5:	49                   	dec    %ecx
			len = strlen(s);
			if (precision < 0)
    87f6:	85 d2                	test   %edx,%edx
    87f8:	78 06                	js     8800 <vsprintf+0x1c2>
				precision = len;
			else if (len > precision)
    87fa:	39 d1                	cmp    %edx,%ecx
    87fc:	7e 02                	jle    8800 <vsprintf+0x1c2>
				len = precision;
    87fe:	89 d1                	mov    %edx,%ecx

			if (!(flags & LEFT))
    8800:	f6 44 24 08 10       	testb  $0x10,0x8(%esp)
    8805:	75 12                	jne    8819 <vsprintf+0x1db>
				while (len < field_width--)
					*str++ = ' ';
    8807:	89 e8                	mov    %ebp,%eax
    8809:	4d                   	dec    %ebp
    880a:	39 c8                	cmp    %ecx,%eax
    880c:	7e 0b                	jle    8819 <vsprintf+0x1db>
    880e:	c6 06 20             	movb   $0x20,(%esi)
    8811:	46                   	inc    %esi
    8812:	89 e8                	mov    %ebp,%eax
    8814:	4d                   	dec    %ebp
    8815:	39 c8                	cmp    %ecx,%eax
    8817:	7f f5                	jg     880e <vsprintf+0x1d0>
			for (i = 0; i < len; ++i)
    8819:	ba 00 00 00 00       	mov    $0x0,%edx
    881e:	39 ca                	cmp    %ecx,%edx
    8820:	7d 0b                	jge    882d <vsprintf+0x1ef>
				*str++ = *s++;
    8822:	8a 03                	mov    (%ebx),%al
    8824:	43                   	inc    %ebx
    8825:	88 06                	mov    %al,(%esi)
    8827:	46                   	inc    %esi
			for (i = 0; i < len; ++i)
    8828:	42                   	inc    %edx
    8829:	39 ca                	cmp    %ecx,%edx
    882b:	7c f5                	jl     8822 <vsprintf+0x1e4>
			while (len < field_width--)
				*str++ = ' ';
    882d:	89 e8                	mov    %ebp,%eax
    882f:	4d                   	dec    %ebp
    8830:	39 c8                	cmp    %ecx,%eax
    8832:	0f 8e f6 00 00 00    	jle    892e <vsprintf+0x2f0>
    8838:	c6 06 20             	movb   $0x20,(%esi)
    883b:	46                   	inc    %esi
    883c:	89 e8                	mov    %ebp,%eax
    883e:	4d                   	dec    %ebp
    883f:	39 c8                	cmp    %ecx,%eax
    8841:	7f f5                	jg     8838 <vsprintf+0x1fa>
			break;
    8843:	e9 e6 00 00 00       	jmp    892e <vsprintf+0x2f0>

		case 'o':
			str = number(str, va_arg(args, unsigned long), 8,
    8848:	83 ec 08             	sub    $0x8,%esp
    884b:	ff 74 24 10          	pushl  0x10(%esp)
    884f:	52                   	push   %edx
    8850:	55                   	push   %ebp
    8851:	6a 08                	push   $0x8
    8853:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    8858:	8b 44 24 40          	mov    0x40(%esp),%eax
    885c:	ff 70 fc             	pushl  -0x4(%eax)
    885f:	56                   	push   %esi
    8860:	e8 9f fb ff ff       	call   8404 <number>
    8865:	89 c6                	mov    %eax,%esi
				field_width, precision, flags);
			break;
    8867:	83 c4 20             	add    $0x20,%esp
    886a:	e9 bf 00 00 00       	jmp    892e <vsprintf+0x2f0>

		case 'p':
			if (field_width == -1) {
    886f:	83 fd ff             	cmp    $0xffffffff,%ebp
    8872:	75 0a                	jne    887e <vsprintf+0x240>
				field_width = 8;
    8874:	bd 08 00 00 00       	mov    $0x8,%ebp
				flags |= ZEROPAD;
    8879:	83 4c 24 08 01       	orl    $0x1,0x8(%esp)
			}
			str = number(str,
    887e:	83 ec 08             	sub    $0x8,%esp
    8881:	ff 74 24 10          	pushl  0x10(%esp)
    8885:	52                   	push   %edx
    8886:	55                   	push   %ebp
    8887:	6a 10                	push   $0x10
    8889:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    888e:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    8892:	ff 71 fc             	pushl  -0x4(%ecx)
    8895:	56                   	push   %esi
    8896:	e8 69 fb ff ff       	call   8404 <number>
    889b:	89 c6                	mov    %eax,%esi
				(unsigned long) va_arg(args, void *), 16,
				field_width, precision, flags);
			break;
    889d:	83 c4 20             	add    $0x20,%esp
    88a0:	e9 89 00 00 00       	jmp    892e <vsprintf+0x2f0>

		case 'x':
			flags |= SMALL;
    88a5:	83 4c 24 08 40       	orl    $0x40,0x8(%esp)
		case 'X':
			str = number(str, va_arg(args, unsigned long), 16,
    88aa:	83 ec 08             	sub    $0x8,%esp
    88ad:	ff 74 24 10          	pushl  0x10(%esp)
    88b1:	52                   	push   %edx
    88b2:	55                   	push   %ebp
    88b3:	6a 10                	push   $0x10
    88b5:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    88ba:	8b 7c 24 40          	mov    0x40(%esp),%edi
    88be:	ff 77 fc             	pushl  -0x4(%edi)
    88c1:	56                   	push   %esi
    88c2:	e8 3d fb ff ff       	call   8404 <number>
    88c7:	89 c6                	mov    %eax,%esi
				field_width, precision, flags);
			break;
    88c9:	83 c4 20             	add    $0x20,%esp
    88cc:	eb 60                	jmp    892e <vsprintf+0x2f0>

		case 'd':
		case 'i':
			flags |= SIGN;
    88ce:	83 4c 24 08 02       	orl    $0x2,0x8(%esp)
		case 'u':
			str = number(str, va_arg(args, unsigned long), 10,
    88d3:	83 ec 08             	sub    $0x8,%esp
    88d6:	ff 74 24 10          	pushl  0x10(%esp)
    88da:	52                   	push   %edx
    88db:	55                   	push   %ebp
    88dc:	6a 0a                	push   $0xa
    88de:	83 44 24 40 04       	addl   $0x4,0x40(%esp)
    88e3:	8b 44 24 40          	mov    0x40(%esp),%eax
    88e7:	ff 70 fc             	pushl  -0x4(%eax)
    88ea:	56                   	push   %esi
    88eb:	e8 14 fb ff ff       	call   8404 <number>
    88f0:	89 c6                	mov    %eax,%esi
				field_width, precision, flags);
			break;
    88f2:	83 c4 20             	add    $0x20,%esp
    88f5:	eb 37                	jmp    892e <vsprintf+0x2f0>

		case 'n':
			ip = va_arg(args, int *);
    88f7:	83 44 24 28 04       	addl   $0x4,0x28(%esp)
    88fc:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    8900:	8b 51 fc             	mov    -0x4(%ecx),%edx
			*ip = (str - buf);
    8903:	89 f0                	mov    %esi,%eax
    8905:	2b 44 24 20          	sub    0x20(%esp),%eax
    8909:	89 02                	mov    %eax,(%edx)
			break;
    890b:	eb 21                	jmp    892e <vsprintf+0x2f0>

		default:
			if (*fmt != '%')
    890d:	8b 44 24 24          	mov    0x24(%esp),%eax
    8911:	80 38 25             	cmpb   $0x25,(%eax)
    8914:	74 04                	je     891a <vsprintf+0x2dc>
				*str++ = '%';
    8916:	c6 06 25             	movb   $0x25,(%esi)
    8919:	46                   	inc    %esi
			if (*fmt)
    891a:	8b 44 24 24          	mov    0x24(%esp),%eax
    891e:	80 38 00             	cmpb   $0x0,(%eax)
    8921:	74 07                	je     892a <vsprintf+0x2ec>
				*str++ = *fmt;
    8923:	8a 00                	mov    (%eax),%al
    8925:	88 06                	mov    %al,(%esi)
    8927:	46                   	inc    %esi
    8928:	eb 04                	jmp    892e <vsprintf+0x2f0>
			else
				--fmt;
    892a:	ff 4c 24 24          	decl   0x24(%esp)
	for (str=buf ; *fmt ; ++fmt) {
    892e:	ff 44 24 24          	incl   0x24(%esp)
    8932:	8b 44 24 24          	mov    0x24(%esp),%eax
    8936:	80 38 00             	cmpb   $0x0,(%eax)
    8939:	0f 85 17 fd ff ff    	jne    8656 <vsprintf+0x18>
			break;
		}
	}
	*str = '\0';
    893f:	c6 06 00             	movb   $0x0,(%esi)
	return str-buf;
    8942:	89 f0                	mov    %esi,%eax
    8944:	2b 44 24 20          	sub    0x20(%esp),%eax
}
    8948:	83 c4 0c             	add    $0xc,%esp
    894b:	5b                   	pop    %ebx
    894c:	5e                   	pop    %esi
    894d:	5f                   	pop    %edi
    894e:	5d                   	pop    %ebp
    894f:	c3                   	ret    

00008950 <sys_ftime>:
#include <sys/utsname.h>

int sys_ftime()
{
	return -ENOSYS;
}
    8950:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8955:	c3                   	ret    

00008956 <sys_break>:

int sys_break()
{
	return -ENOSYS;
}
    8956:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    895b:	c3                   	ret    

0000895c <sys_ptrace>:

int sys_ptrace()
{
	return -ENOSYS;
}
    895c:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8961:	c3                   	ret    

00008962 <sys_stty>:

int sys_stty()
{
	return -ENOSYS;
}
    8962:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8967:	c3                   	ret    

00008968 <sys_gtty>:

int sys_gtty()
{
	return -ENOSYS;
}
    8968:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    896d:	c3                   	ret    

0000896e <sys_rename>:

int sys_rename()
{
	return -ENOSYS;
}
    896e:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8973:	c3                   	ret    

00008974 <sys_prof>:

int sys_prof()
{
	return -ENOSYS;
}
    8974:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8979:	c3                   	ret    

0000897a <sys_setregid>:

int sys_setregid(int rgid, int egid)
{
    897a:	53                   	push   %ebx
    897b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    897f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
	if (rgid>0) {
    8983:	85 c9                	test   %ecx,%ecx
    8985:	7e 2c                	jle    89b3 <sys_setregid+0x39>
		if ((current->gid == rgid) || 
    8987:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    898d:	0f b7 82 46 02 00 00 	movzwl 0x246(%edx),%eax
    8994:	39 c8                	cmp    %ecx,%eax
    8996:	74 0f                	je     89a7 <sys_setregid+0x2d>
		    suser())
			current->gid = rgid;
		else
			return(-EPERM);
    8998:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((current->gid == rgid) || 
    899d:	66 83 ba 42 02 00 00 	cmpw   $0x0,0x242(%edx)
    89a4:	00 
    89a5:	75 57                	jne    89fe <sys_setregid+0x84>
			current->gid = rgid;
    89a7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    89ac:	66 89 88 46 02 00 00 	mov    %cx,0x246(%eax)
	}
	if (egid>0) {
    89b3:	85 db                	test   %ebx,%ebx
    89b5:	7e 42                	jle    89f9 <sys_setregid+0x7f>
		if ((current->gid == egid) ||
    89b7:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    89bd:	0f b7 82 46 02 00 00 	movzwl 0x246(%edx),%eax
    89c4:	39 d8                	cmp    %ebx,%eax
    89c6:	74 25                	je     89ed <sys_setregid+0x73>
    89c8:	0f b7 82 48 02 00 00 	movzwl 0x248(%edx),%eax
    89cf:	39 d8                	cmp    %ebx,%eax
    89d1:	74 1a                	je     89ed <sys_setregid+0x73>
    89d3:	0f b7 82 4a 02 00 00 	movzwl 0x24a(%edx),%eax
    89da:	39 d8                	cmp    %ebx,%eax
    89dc:	74 0f                	je     89ed <sys_setregid+0x73>
		    (current->egid == egid) ||
		    (current->sgid == egid) ||
		    suser())
			current->egid = egid;
		else
			return(-EPERM);
    89de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((current->gid == egid) ||
    89e3:	66 83 ba 42 02 00 00 	cmpw   $0x0,0x242(%edx)
    89ea:	00 
    89eb:	75 11                	jne    89fe <sys_setregid+0x84>
			current->egid = egid;
    89ed:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    89f2:	66 89 98 48 02 00 00 	mov    %bx,0x248(%eax)
	}
	return 0;
    89f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89fe:	5b                   	pop    %ebx
    89ff:	c3                   	ret    

00008a00 <sys_setgid>:

int sys_setgid(int gid)
{
    8a00:	53                   	push   %ebx
{
    8a01:	8b 54 24 08          	mov    0x8(%esp),%edx
    8a05:	89 d3                	mov    %edx,%ebx
	if (rgid>0) {
    8a07:	85 d2                	test   %edx,%edx
    8a09:	7e 72                	jle    8a7d <sys_setgid+0x7d>
		if ((current->gid == rgid) || 
    8a0b:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    8a11:	0f b7 81 46 02 00 00 	movzwl 0x246(%ecx),%eax
    8a18:	39 d0                	cmp    %edx,%eax
    8a1a:	74 0f                	je     8a2b <sys_setgid+0x2b>
			current->gid = rgid;
    8a1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((current->gid == rgid) || 
    8a21:	66 83 b9 42 02 00 00 	cmpw   $0x0,0x242(%ecx)
    8a28:	00 
    8a29:	75 57                	jne    8a82 <sys_setgid+0x82>
			current->gid = rgid;
    8a2b:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8a30:	66 89 98 46 02 00 00 	mov    %bx,0x246(%eax)
	if (egid>0) {
    8a37:	85 d2                	test   %edx,%edx
    8a39:	7e 42                	jle    8a7d <sys_setgid+0x7d>
		if ((current->gid == egid) ||
    8a3b:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    8a41:	0f b7 81 46 02 00 00 	movzwl 0x246(%ecx),%eax
    8a48:	39 d0                	cmp    %edx,%eax
    8a4a:	74 25                	je     8a71 <sys_setgid+0x71>
    8a4c:	0f b7 81 48 02 00 00 	movzwl 0x248(%ecx),%eax
    8a53:	39 d0                	cmp    %edx,%eax
    8a55:	74 1a                	je     8a71 <sys_setgid+0x71>
    8a57:	0f b7 81 4a 02 00 00 	movzwl 0x24a(%ecx),%eax
    8a5e:	39 d0                	cmp    %edx,%eax
    8a60:	74 0f                	je     8a71 <sys_setgid+0x71>
			current->egid = egid;
    8a62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((current->gid == egid) ||
    8a67:	66 83 b9 42 02 00 00 	cmpw   $0x0,0x242(%ecx)
    8a6e:	00 
    8a6f:	75 11                	jne    8a82 <sys_setgid+0x82>
			current->egid = egid;
    8a71:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8a76:	66 89 90 48 02 00 00 	mov    %dx,0x248(%eax)
	}
    8a7d:	b8 00 00 00 00       	mov    $0x0,%eax
	return(sys_setregid(gid, gid));
}
    8a82:	5b                   	pop    %ebx
    8a83:	c3                   	ret    

00008a84 <sys_acct>:

int sys_acct()
{
	return -ENOSYS;
}
    8a84:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8a89:	c3                   	ret    

00008a8a <sys_phys>:

int sys_phys()
{
	return -ENOSYS;
}
    8a8a:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8a8f:	c3                   	ret    

00008a90 <sys_lock>:

int sys_lock()
{
	return -ENOSYS;
}
    8a90:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8a95:	c3                   	ret    

00008a96 <sys_mpx>:

int sys_mpx()
{
	return -ENOSYS;
}
    8a96:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8a9b:	c3                   	ret    

00008a9c <sys_ulimit>:

int sys_ulimit()
{
	return -ENOSYS;
}
    8a9c:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8aa1:	c3                   	ret    

00008aa2 <sys_time>:

int sys_time(long * tloc)
{
    8aa2:	56                   	push   %esi
    8aa3:	53                   	push   %ebx
    8aa4:	83 ec 04             	sub    $0x4,%esp
    8aa7:	8b 74 24 10          	mov    0x10(%esp),%esi
	int i;

	i = CURRENT_TIME;
    8aab:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    8ab1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    8ab6:	f7 e9                	imul   %ecx
    8ab8:	89 d0                	mov    %edx,%eax
    8aba:	c1 f8 05             	sar    $0x5,%eax
    8abd:	c1 f9 1f             	sar    $0x1f,%ecx
    8ac0:	89 c3                	mov    %eax,%ebx
    8ac2:	29 cb                	sub    %ecx,%ebx
    8ac4:	03 1d c4 e9 01 00    	add    0x1e9c4,%ebx
	if (tloc) {
    8aca:	85 f6                	test   %esi,%esi
    8acc:	74 11                	je     8adf <sys_time+0x3d>
		verify_area(tloc,4);
    8ace:	83 ec 08             	sub    $0x8,%esp
    8ad1:	6a 04                	push   $0x4
    8ad3:	56                   	push   %esi
    8ad4:	e8 93 f3 ff ff       	call   7e6c <verify_area>
{
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
    8ad9:	83 c4 10             	add    $0x10,%esp
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    8adc:	64 89 1e             	mov    %ebx,%fs:(%esi)
		put_fs_long(i,(unsigned long *)tloc);
	}
	return i;
}
    8adf:	89 d8                	mov    %ebx,%eax
    8ae1:	83 c4 04             	add    $0x4,%esp
    8ae4:	5b                   	pop    %ebx
    8ae5:	5e                   	pop    %esi
    8ae6:	c3                   	ret    

00008ae7 <sys_setreuid>:
/*
 * Unprivileged users may change the real user id to the effective uid
 * or vice versa.
 */
int sys_setreuid(int ruid, int euid)
{
    8ae7:	56                   	push   %esi
    8ae8:	53                   	push   %ebx
    8ae9:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    8aed:	8b 74 24 10          	mov    0x10(%esp),%esi
	int old_ruid = current->uid;
    8af1:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    8af7:	0f b7 9a 40 02 00 00 	movzwl 0x240(%edx),%ebx
	
	if (ruid>0) {
    8afe:	85 c9                	test   %ecx,%ecx
    8b00:	7e 2a                	jle    8b2c <sys_setreuid+0x45>
		if ((current->euid==ruid) ||
    8b02:	0f b7 82 42 02 00 00 	movzwl 0x242(%edx),%eax
    8b09:	39 c8                	cmp    %ecx,%eax
    8b0b:	74 13                	je     8b20 <sys_setreuid+0x39>
    8b0d:	39 cb                	cmp    %ecx,%ebx
    8b0f:	74 0f                	je     8b20 <sys_setreuid+0x39>
                    (old_ruid == ruid) ||
		    suser())
			current->uid = ruid;
		else
			return(-EPERM);
    8b11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((current->euid==ruid) ||
    8b16:	66 83 ba 42 02 00 00 	cmpw   $0x0,0x242(%edx)
    8b1d:	00 
    8b1e:	75 55                	jne    8b75 <sys_setreuid+0x8e>
			current->uid = ruid;
    8b20:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8b25:	66 89 88 40 02 00 00 	mov    %cx,0x240(%eax)
	}
	if (euid>0) {
    8b2c:	85 f6                	test   %esi,%esi
    8b2e:	7e 40                	jle    8b70 <sys_setreuid+0x89>
		if ((old_ruid == euid) ||
    8b30:	39 f3                	cmp    %esi,%ebx
    8b32:	74 1b                	je     8b4f <sys_setreuid+0x68>
    8b34:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    8b3a:	0f b7 82 42 02 00 00 	movzwl 0x242(%edx),%eax
    8b41:	39 f0                	cmp    %esi,%eax
    8b43:	74 0a                	je     8b4f <sys_setreuid+0x68>
    8b45:	66 83 ba 42 02 00 00 	cmpw   $0x0,0x242(%edx)
    8b4c:	00 
    8b4d:	75 0e                	jne    8b5d <sys_setreuid+0x76>
                    (current->euid == euid) ||
		    suser())
			current->euid = euid;
    8b4f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8b54:	66 89 b0 42 02 00 00 	mov    %si,0x242(%eax)
    8b5b:	eb 13                	jmp    8b70 <sys_setreuid+0x89>
		else {
			current->uid = old_ruid;
    8b5d:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8b62:	66 89 98 40 02 00 00 	mov    %bx,0x240(%eax)
			return(-EPERM);
    8b69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    8b6e:	eb 05                	jmp    8b75 <sys_setreuid+0x8e>
		}
	}
	return 0;
    8b70:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b75:	5b                   	pop    %ebx
    8b76:	5e                   	pop    %esi
    8b77:	c3                   	ret    

00008b78 <sys_setuid>:

int sys_setuid(int uid)
{
    8b78:	56                   	push   %esi
    8b79:	53                   	push   %ebx
{
    8b7a:	8b 54 24 0c          	mov    0xc(%esp),%edx
    8b7e:	89 d6                	mov    %edx,%esi
	int old_ruid = current->uid;
    8b80:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    8b86:	0f b7 99 40 02 00 00 	movzwl 0x240(%ecx),%ebx
	if (ruid>0) {
    8b8d:	85 d2                	test   %edx,%edx
    8b8f:	7e 6e                	jle    8bff <sys_setuid+0x87>
		if ((current->euid==ruid) ||
    8b91:	0f b7 81 42 02 00 00 	movzwl 0x242(%ecx),%eax
    8b98:	39 d0                	cmp    %edx,%eax
    8b9a:	74 13                	je     8baf <sys_setuid+0x37>
    8b9c:	39 d3                	cmp    %edx,%ebx
    8b9e:	74 0f                	je     8baf <sys_setuid+0x37>
			current->uid = ruid;
    8ba0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((current->euid==ruid) ||
    8ba5:	66 83 b9 42 02 00 00 	cmpw   $0x0,0x242(%ecx)
    8bac:	00 
    8bad:	75 55                	jne    8c04 <sys_setuid+0x8c>
			current->uid = ruid;
    8baf:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8bb4:	66 89 b0 40 02 00 00 	mov    %si,0x240(%eax)
	if (euid>0) {
    8bbb:	85 d2                	test   %edx,%edx
    8bbd:	7e 40                	jle    8bff <sys_setuid+0x87>
		if ((old_ruid == euid) ||
    8bbf:	39 d3                	cmp    %edx,%ebx
    8bc1:	74 1b                	je     8bde <sys_setuid+0x66>
    8bc3:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    8bc9:	0f b7 81 42 02 00 00 	movzwl 0x242(%ecx),%eax
    8bd0:	39 d0                	cmp    %edx,%eax
    8bd2:	74 0a                	je     8bde <sys_setuid+0x66>
    8bd4:	66 83 b9 42 02 00 00 	cmpw   $0x0,0x242(%ecx)
    8bdb:	00 
    8bdc:	75 0e                	jne    8bec <sys_setuid+0x74>
			current->euid = euid;
    8bde:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8be3:	66 89 90 42 02 00 00 	mov    %dx,0x242(%eax)
    8bea:	eb 13                	jmp    8bff <sys_setuid+0x87>
			current->uid = old_ruid;
    8bec:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8bf1:	66 89 98 40 02 00 00 	mov    %bx,0x240(%eax)
    8bf8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    8bfd:	eb 05                	jmp    8c04 <sys_setuid+0x8c>
	}
    8bff:	b8 00 00 00 00       	mov    $0x0,%eax
	return(sys_setreuid(uid, uid));
}
    8c04:	5b                   	pop    %ebx
    8c05:	5e                   	pop    %esi
    8c06:	c3                   	ret    

00008c07 <sys_stime>:

int sys_stime(long * tptr)
{
    8c07:	53                   	push   %ebx
    8c08:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	if (!suser())
		return -EPERM;
    8c0c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	if (!suser())
    8c11:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8c16:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
    8c1d:	00 
    8c1e:	75 27                	jne    8c47 <sys_stime+0x40>
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
    8c20:	64 8b 19             	mov    %fs:(%ecx),%ebx
{
    8c23:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    8c29:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    8c2e:	f7 e9                	imul   %ecx
    8c30:	89 d0                	mov    %edx,%eax
    8c32:	c1 f8 05             	sar    $0x5,%eax
    8c35:	c1 f9 1f             	sar    $0x1f,%ecx
    8c38:	29 c8                	sub    %ecx,%eax
    8c3a:	29 c3                	sub    %eax,%ebx
    8c3c:	89 1d c4 e9 01 00    	mov    %ebx,0x1e9c4
	startup_time = get_fs_long((unsigned long *)tptr) - jiffies/HZ;
	return 0;
    8c42:	ba 00 00 00 00       	mov    $0x0,%edx
}
    8c47:	89 d0                	mov    %edx,%eax
    8c49:	5b                   	pop    %ebx
    8c4a:	c3                   	ret    

00008c4b <sys_times>:

int sys_times(struct tms * tbuf)
{
    8c4b:	53                   	push   %ebx
    8c4c:	83 ec 08             	sub    $0x8,%esp
    8c4f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	if (tbuf) {
    8c53:	85 db                	test   %ebx,%ebx
    8c55:	74 3b                	je     8c92 <sys_times+0x47>
		verify_area(tbuf,sizeof *tbuf);
    8c57:	83 ec 08             	sub    $0x8,%esp
    8c5a:	6a 10                	push   $0x10
    8c5c:	53                   	push   %ebx
    8c5d:	e8 0a f2 ff ff       	call   7e6c <verify_area>
{
    8c62:	83 c4 10             	add    $0x10,%esp
    8c65:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    8c6b:	8b 82 50 02 00 00    	mov    0x250(%edx),%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    8c71:	64 89 03             	mov    %eax,%fs:(%ebx)
{
    8c74:	8b 82 54 02 00 00    	mov    0x254(%edx),%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    8c7a:	64 89 43 04          	mov    %eax,%fs:0x4(%ebx)
{
    8c7e:	8b 82 58 02 00 00    	mov    0x258(%edx),%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    8c84:	64 89 43 08          	mov    %eax,%fs:0x8(%ebx)
{
    8c88:	8b 82 5c 02 00 00    	mov    0x25c(%edx),%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    8c8e:	64 89 43 0c          	mov    %eax,%fs:0xc(%ebx)
		put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
		put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
		put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
		put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
	}
	return jiffies;
    8c92:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
}
    8c97:	83 c4 08             	add    $0x8,%esp
    8c9a:	5b                   	pop    %ebx
    8c9b:	c3                   	ret    

00008c9c <sys_brk>:

int sys_brk(unsigned long end_data_seg)
{
    8c9c:	8b 4c 24 04          	mov    0x4(%esp),%ecx
	if (end_data_seg >= current->end_code &&
    8ca0:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    8ca6:	39 8a 1c 02 00 00    	cmp    %ecx,0x21c(%edx)
    8cac:	77 15                	ja     8cc3 <sys_brk+0x27>
    8cae:	8b 82 28 02 00 00    	mov    0x228(%edx),%eax
    8cb4:	2d 00 40 00 00       	sub    $0x4000,%eax
    8cb9:	39 c8                	cmp    %ecx,%eax
    8cbb:	76 06                	jbe    8cc3 <sys_brk+0x27>
	    end_data_seg < current->start_stack - 16384)
		current->brk = end_data_seg;
    8cbd:	89 8a 24 02 00 00    	mov    %ecx,0x224(%edx)
	return current->brk;
    8cc3:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8cc8:	8b 80 24 02 00 00    	mov    0x224(%eax),%eax
}
    8cce:	c3                   	ret    

00008ccf <sys_setpgid>:
 * This needs some heave checking ...
 * I just haven't get the stomach for it. I also don't fully
 * understand sessions/pgrp etc. Let somebody who does explain it.
 */
int sys_setpgid(int pid, int pgid)
{
    8ccf:	57                   	push   %edi
    8cd0:	56                   	push   %esi
    8cd1:	53                   	push   %ebx
    8cd2:	8b 54 24 10          	mov    0x10(%esp),%edx
    8cd6:	8b 74 24 14          	mov    0x14(%esp),%esi
	int i;

	if (!pid)
    8cda:	85 d2                	test   %edx,%edx
    8cdc:	75 0b                	jne    8ce9 <sys_setpgid+0x1a>
		pid = current->pid;
    8cde:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8ce3:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
	if (!pgid)
    8ce9:	85 f6                	test   %esi,%esi
    8ceb:	75 0b                	jne    8cf8 <sys_setpgid+0x29>
		pgid = current->pid;
    8ced:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8cf2:	8b b0 2c 02 00 00    	mov    0x22c(%eax),%esi
	for (i=0 ; i<NR_TASKS ; i++)
    8cf8:	b9 00 00 00 00       	mov    $0x0,%ecx
    8cfd:	bb 40 bc 01 00       	mov    $0x1bc40,%ebx
		if (task[i] && task[i]->pid==pid) {
    8d02:	83 3c 8b 00          	cmpl   $0x0,(%ebx,%ecx,4)
    8d06:	74 44                	je     8d4c <sys_setpgid+0x7d>
    8d08:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
    8d0b:	39 90 2c 02 00 00    	cmp    %edx,0x22c(%eax)
    8d11:	75 39                	jne    8d4c <sys_setpgid+0x7d>
			if (task[i]->leader)
				return -EPERM;
    8d13:	bf ff ff ff ff       	mov    $0xffffffff,%edi
			if (task[i]->leader)
    8d18:	83 b8 3c 02 00 00 00 	cmpl   $0x0,0x23c(%eax)
    8d1f:	75 36                	jne    8d57 <sys_setpgid+0x88>
			if (task[i]->session != current->session)
    8d21:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
    8d24:	8b 90 38 02 00 00    	mov    0x238(%eax),%edx
				return -EPERM;
    8d2a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
			if (task[i]->session != current->session)
    8d2f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8d34:	3b 90 38 02 00 00    	cmp    0x238(%eax),%edx
    8d3a:	75 1b                	jne    8d57 <sys_setpgid+0x88>
			task[i]->pgrp = pgid;
    8d3c:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
    8d3f:	89 b0 34 02 00 00    	mov    %esi,0x234(%eax)
			return 0;
    8d45:	bf 00 00 00 00       	mov    $0x0,%edi
    8d4a:	eb 0b                	jmp    8d57 <sys_setpgid+0x88>
	for (i=0 ; i<NR_TASKS ; i++)
    8d4c:	41                   	inc    %ecx
    8d4d:	83 f9 3f             	cmp    $0x3f,%ecx
    8d50:	7e b0                	jle    8d02 <sys_setpgid+0x33>
		}
	return -ESRCH;
    8d52:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
}
    8d57:	89 f8                	mov    %edi,%eax
    8d59:	5b                   	pop    %ebx
    8d5a:	5e                   	pop    %esi
    8d5b:	5f                   	pop    %edi
    8d5c:	c3                   	ret    

00008d5d <sys_getpgrp>:

int sys_getpgrp(void)
{
	return current->pgrp;
    8d5d:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8d62:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
}
    8d68:	c3                   	ret    

00008d69 <sys_setsid>:

int sys_setsid(void)
{
	if (current->leader && !suser())
    8d69:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    8d6f:	83 ba 3c 02 00 00 00 	cmpl   $0x0,0x23c(%edx)
    8d76:	74 0f                	je     8d87 <sys_setsid+0x1e>
		return -EPERM;
    8d78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (current->leader && !suser())
    8d7d:	66 83 ba 42 02 00 00 	cmpw   $0x0,0x242(%edx)
    8d84:	00 
    8d85:	75 40                	jne    8dc7 <sys_setsid+0x5e>
	current->leader = 1;
    8d87:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8d8c:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
    8d93:	00 00 00 
	current->session = current->pgrp = current->pid;
    8d96:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8d9b:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    8da1:	89 90 34 02 00 00    	mov    %edx,0x234(%eax)
    8da7:	89 90 38 02 00 00    	mov    %edx,0x238(%eax)
	current->tty = -1;
    8dad:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8db2:	c7 80 68 02 00 00 ff 	movl   $0xffffffff,0x268(%eax)
    8db9:	ff ff ff 
	return current->pgrp;
    8dbc:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8dc1:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
}
    8dc7:	c3                   	ret    

00008dc8 <sys_uname>:

int sys_uname(struct utsname * name)
{
    8dc8:	53                   	push   %ebx
    8dc9:	83 ec 08             	sub    $0x8,%esp
    8dcc:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	static struct utsname thisname = {
		"linux .0","nodename","release ","version ","machine "
	};
	int i;

	if (!name) return -ERROR;
    8dd0:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    8dd5:	85 db                	test   %ebx,%ebx
    8dd7:	74 28                	je     8e01 <sys_uname+0x39>
	verify_area(name,sizeof *name);
    8dd9:	83 ec 08             	sub    $0x8,%esp
    8ddc:	6a 2d                	push   $0x2d
    8dde:	53                   	push   %ebx
    8ddf:	e8 88 f0 ff ff       	call   7e6c <verify_area>
	for(i=0;i<sizeof *name;i++)
    8de4:	ba 00 00 00 00       	mov    $0x0,%edx
    8de9:	83 c4 10             	add    $0x10,%esp
{
    8dec:	8a 82 60 bd 01 00    	mov    0x1bd60(%edx),%al
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    8df2:	64 88 04 13          	mov    %al,%fs:(%ebx,%edx,1)
    8df6:	42                   	inc    %edx
    8df7:	83 fa 2c             	cmp    $0x2c,%edx
    8dfa:	76 f0                	jbe    8dec <sys_uname+0x24>
		put_fs_byte(((char *) &thisname)[i],i+(char *) name);
	return 0;
    8dfc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e01:	83 c4 08             	add    $0x8,%esp
    8e04:	5b                   	pop    %ebx
    8e05:	c3                   	ret    

00008e06 <sys_umask>:

int sys_umask(int mask)
{
	int old = current->umask;
    8e06:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    8e0c:	0f b7 82 6c 02 00 00 	movzwl 0x26c(%edx),%eax

	current->umask = mask & 0777;
    8e13:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    8e17:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    8e1d:	66 89 8a 6c 02 00 00 	mov    %cx,0x26c(%edx)
	return (old);
}
    8e24:	c3                   	ret    

00008e25 <release>:

int sys_pause(void);
int sys_close(int fd);

void release(struct task_struct * p)
{
    8e25:	83 ec 0c             	sub    $0xc,%esp
    8e28:	8b 54 24 10          	mov    0x10(%esp),%edx
	int i;

	if (!p)
    8e2c:	85 d2                	test   %edx,%edx
    8e2e:	74 3f                	je     8e6f <release+0x4a>
		return;
	for (i=1 ; i<NR_TASKS ; i++)
    8e30:	b8 01 00 00 00       	mov    $0x1,%eax
    8e35:	b9 40 bc 01 00       	mov    $0x1bc40,%ecx
		if (task[i]==p) {
    8e3a:	39 14 81             	cmp    %edx,(%ecx,%eax,4)
    8e3d:	75 1a                	jne    8e59 <release+0x34>
			task[i]=NULL;
    8e3f:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
			free_page((long)p);
    8e46:	83 ec 0c             	sub    $0xc,%esp
    8e49:	52                   	push   %edx
    8e4a:	e8 56 0b 00 00       	call   99a5 <free_page>
			schedule();
    8e4f:	e8 27 dc ff ff       	call   6a7b <schedule>
			return;
    8e54:	83 c4 10             	add    $0x10,%esp
    8e57:	eb 16                	jmp    8e6f <release+0x4a>
	for (i=1 ; i<NR_TASKS ; i++)
    8e59:	40                   	inc    %eax
    8e5a:	83 f8 3f             	cmp    $0x3f,%eax
    8e5d:	7e db                	jle    8e3a <release+0x15>
		}
	panic("trying to release non-existent task");
    8e5f:	83 ec 0c             	sub    $0xc,%esp
    8e62:	68 50 8b 01 00       	push   $0x18b50
    8e67:	e8 ad f4 ff ff       	call   8319 <panic>
    8e6c:	83 c4 10             	add    $0x10,%esp
}
    8e6f:	83 c4 0c             	add    $0xc,%esp
    8e72:	c3                   	ret    

00008e73 <sys_kill>:
/*
 * XXX need to check permissions needed to send signals to process
 * groups, etc. etc.  kill() permissions semantics are tricky!
 */
int sys_kill(int pid,int sig)
{
    8e73:	55                   	push   %ebp
    8e74:	57                   	push   %edi
    8e75:	56                   	push   %esi
    8e76:	53                   	push   %ebx
    8e77:	83 ec 04             	sub    $0x4,%esp
    8e7a:	8b 74 24 18          	mov    0x18(%esp),%esi
    8e7e:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
	struct task_struct **p = NR_TASKS + task;
    8e82:	bb 40 bd 01 00       	mov    $0x1bd40,%ebx
	int err, retval = 0;
    8e87:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)

	if (!pid) while (--p > &FIRST_TASK) {
    8e8e:	85 f6                	test   %esi,%esi
    8e90:	0f 85 9e 00 00 00    	jne    8f34 <sys_kill+0xc1>
		if (*p && (*p)->pgrp == current->pid) 
			if ((err=send_sig(sig,*p,1)))
				retval = err;
    8e96:	bb 3c bd 01 00       	mov    $0x1bd3c,%ebx
    8e9b:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    8ea1:	0f 86 29 02 00 00    	jbe    90d0 <sys_kill+0x25d>
		if (*p && (*p)->pgrp == current->pid) 
    8ea7:	83 3b 00             	cmpl   $0x0,(%ebx)
    8eaa:	74 74                	je     8f20 <sys_kill+0xad>
    8eac:	8b 0b                	mov    (%ebx),%ecx
    8eae:	8b 91 34 02 00 00    	mov    0x234(%ecx),%edx
    8eb4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    8eb9:	3b 90 2c 02 00 00    	cmp    0x22c(%eax),%edx
    8ebf:	75 5f                	jne    8f20 <sys_kill+0xad>
{
    8ec1:	89 fd                	mov    %edi,%ebp
    8ec3:	89 ca                	mov    %ecx,%edx
	if (!p || sig<1 || sig>32)
    8ec5:	85 c9                	test   %ecx,%ecx
    8ec7:	74 09                	je     8ed2 <sys_kill+0x5f>
    8ec9:	85 ff                	test   %edi,%edi
    8ecb:	7e 05                	jle    8ed2 <sys_kill+0x5f>
    8ecd:	83 ff 20             	cmp    $0x20,%edi
    8ed0:	7e 07                	jle    8ed9 <sys_kill+0x66>
    8ed2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    8ed7:	eb 40                	jmp    8f19 <sys_kill+0xa6>
	if (priv || (current->euid==p->euid) || suser())
    8ed9:	b8 01 00 00 00       	mov    $0x1,%eax
    8ede:	85 c0                	test   %eax,%eax
    8ee0:	75 25                	jne    8f07 <sys_kill+0x94>
    8ee2:	8b 35 20 bc 01 00    	mov    0x1bc20,%esi
    8ee8:	66 8b 86 42 02 00 00 	mov    0x242(%esi),%ax
    8eef:	66 3b 81 42 02 00 00 	cmp    0x242(%ecx),%ax
    8ef6:	74 0f                	je     8f07 <sys_kill+0x94>
		p->signal |= (1<<(sig-1));
    8ef8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (priv || (current->euid==p->euid) || suser())
    8efd:	66 83 be 42 02 00 00 	cmpw   $0x0,0x242(%esi)
    8f04:	00 
    8f05:	75 12                	jne    8f19 <sys_kill+0xa6>
		p->signal |= (1<<(sig-1));
    8f07:	8d 4d ff             	lea    -0x1(%ebp),%ecx
    8f0a:	b8 01 00 00 00       	mov    $0x1,%eax
    8f0f:	d3 e0                	shl    %cl,%eax
    8f11:	09 42 0c             	or     %eax,0xc(%edx)
    8f14:	b8 00 00 00 00       	mov    $0x0,%eax
{
    8f19:	85 c0                	test   %eax,%eax
    8f1b:	74 03                	je     8f20 <sys_kill+0xad>
				retval = err;
    8f1d:	89 04 24             	mov    %eax,(%esp)
    8f20:	83 eb 04             	sub    $0x4,%ebx
    8f23:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    8f29:	0f 87 78 ff ff ff    	ja     8ea7 <sys_kill+0x34>
    8f2f:	e9 9c 01 00 00       	jmp    90d0 <sys_kill+0x25d>
	} else if (pid>0) while (--p > &FIRST_TASK) {
    8f34:	85 f6                	test   %esi,%esi
    8f36:	0f 8e 8b 00 00 00    	jle    8fc7 <sys_kill+0x154>
		if (*p && (*p)->pid == pid) 
			if ((err=send_sig(sig,*p,0)))
				retval = err;
    8f3c:	83 eb 04             	sub    $0x4,%ebx
    8f3f:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    8f45:	0f 86 85 01 00 00    	jbe    90d0 <sys_kill+0x25d>
		if (*p && (*p)->pid == pid) 
    8f4b:	83 3b 00             	cmpl   $0x0,(%ebx)
    8f4e:	74 67                	je     8fb7 <sys_kill+0x144>
    8f50:	8b 03                	mov    (%ebx),%eax
    8f52:	39 b0 2c 02 00 00    	cmp    %esi,0x22c(%eax)
    8f58:	75 5d                	jne    8fb7 <sys_kill+0x144>
{
    8f5a:	89 f9                	mov    %edi,%ecx
    8f5c:	89 c2                	mov    %eax,%edx
	if (!p || sig<1 || sig>32)
    8f5e:	85 c0                	test   %eax,%eax
    8f60:	74 09                	je     8f6b <sys_kill+0xf8>
    8f62:	85 ff                	test   %edi,%edi
    8f64:	7e 05                	jle    8f6b <sys_kill+0xf8>
    8f66:	83 ff 20             	cmp    $0x20,%edi
    8f69:	7e 07                	jle    8f72 <sys_kill+0xff>
    8f6b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    8f70:	eb 3e                	jmp    8fb0 <sys_kill+0x13d>
	if (priv || (current->euid==p->euid) || suser())
    8f72:	b8 00 00 00 00       	mov    $0x0,%eax
    8f77:	85 c0                	test   %eax,%eax
    8f79:	75 25                	jne    8fa0 <sys_kill+0x12d>
    8f7b:	8b 2d 20 bc 01 00    	mov    0x1bc20,%ebp
    8f81:	66 8b 85 42 02 00 00 	mov    0x242(%ebp),%ax
    8f88:	66 3b 82 42 02 00 00 	cmp    0x242(%edx),%ax
    8f8f:	74 0f                	je     8fa0 <sys_kill+0x12d>
		p->signal |= (1<<(sig-1));
    8f91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (priv || (current->euid==p->euid) || suser())
    8f96:	66 83 bd 42 02 00 00 	cmpw   $0x0,0x242(%ebp)
    8f9d:	00 
    8f9e:	75 10                	jne    8fb0 <sys_kill+0x13d>
		p->signal |= (1<<(sig-1));
    8fa0:	49                   	dec    %ecx
    8fa1:	b8 01 00 00 00       	mov    $0x1,%eax
    8fa6:	d3 e0                	shl    %cl,%eax
    8fa8:	09 42 0c             	or     %eax,0xc(%edx)
    8fab:	b8 00 00 00 00       	mov    $0x0,%eax
{
    8fb0:	85 c0                	test   %eax,%eax
    8fb2:	74 03                	je     8fb7 <sys_kill+0x144>
				retval = err;
    8fb4:	89 04 24             	mov    %eax,(%esp)
    8fb7:	83 eb 04             	sub    $0x4,%ebx
    8fba:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    8fc0:	77 89                	ja     8f4b <sys_kill+0xd8>
    8fc2:	e9 09 01 00 00       	jmp    90d0 <sys_kill+0x25d>
	} else if (pid == -1) while (--p > &FIRST_TASK) {
    8fc7:	83 fe ff             	cmp    $0xffffffff,%esi
    8fca:	75 7e                	jne    904a <sys_kill+0x1d7>
		if ((err = send_sig(sig,*p,0)))
			retval = err;
    8fcc:	83 eb 04             	sub    $0x4,%ebx
    8fcf:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    8fd5:	0f 86 f5 00 00 00    	jbe    90d0 <sys_kill+0x25d>
    8fdb:	bd 00 00 00 00       	mov    $0x0,%ebp
    8fe0:	8d 4f ff             	lea    -0x1(%edi),%ecx
    8fe3:	b8 01 00 00 00       	mov    $0x1,%eax
    8fe8:	89 c6                	mov    %eax,%esi
    8fea:	d3 e6                	shl    %cl,%esi
{
    8fec:	8b 13                	mov    (%ebx),%edx
	if (!p || sig<1 || sig>32)
    8fee:	85 d2                	test   %edx,%edx
    8ff0:	74 09                	je     8ffb <sys_kill+0x188>
    8ff2:	85 ff                	test   %edi,%edi
    8ff4:	7e 05                	jle    8ffb <sys_kill+0x188>
    8ff6:	83 ff 20             	cmp    $0x20,%edi
    8ff9:	7e 07                	jle    9002 <sys_kill+0x18f>
    8ffb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    9000:	eb 31                	jmp    9033 <sys_kill+0x1c0>
	if (priv || (current->euid==p->euid) || suser())
    9002:	85 ed                	test   %ebp,%ebp
    9004:	75 25                	jne    902b <sys_kill+0x1b8>
    9006:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    900c:	66 8b 81 42 02 00 00 	mov    0x242(%ecx),%ax
    9013:	66 3b 82 42 02 00 00 	cmp    0x242(%edx),%ax
    901a:	74 0f                	je     902b <sys_kill+0x1b8>
		p->signal |= (1<<(sig-1));
    901c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (priv || (current->euid==p->euid) || suser())
    9021:	66 83 b9 42 02 00 00 	cmpw   $0x0,0x242(%ecx)
    9028:	00 
    9029:	75 08                	jne    9033 <sys_kill+0x1c0>
		p->signal |= (1<<(sig-1));
    902b:	09 72 0c             	or     %esi,0xc(%edx)
    902e:	b8 00 00 00 00       	mov    $0x0,%eax
{
    9033:	85 c0                	test   %eax,%eax
    9035:	74 03                	je     903a <sys_kill+0x1c7>
			retval = err;
    9037:	89 04 24             	mov    %eax,(%esp)
    903a:	83 eb 04             	sub    $0x4,%ebx
    903d:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    9043:	77 a7                	ja     8fec <sys_kill+0x179>
    9045:	e9 86 00 00 00       	jmp    90d0 <sys_kill+0x25d>
	} else while (--p > &FIRST_TASK)
		if (*p && (*p)->pgrp == -pid)
			if ((err = send_sig(sig,*p,0)))
				retval = err;
    904a:	83 eb 04             	sub    $0x4,%ebx
    904d:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    9053:	76 7b                	jbe    90d0 <sys_kill+0x25d>
		if (*p && (*p)->pgrp == -pid)
    9055:	83 3b 00             	cmpl   $0x0,(%ebx)
    9058:	74 6b                	je     90c5 <sys_kill+0x252>
    905a:	8b 03                	mov    (%ebx),%eax
    905c:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    9062:	01 f2                	add    %esi,%edx
    9064:	75 5f                	jne    90c5 <sys_kill+0x252>
{
    9066:	89 fa                	mov    %edi,%edx
    9068:	89 c5                	mov    %eax,%ebp
	if (!p || sig<1 || sig>32)
    906a:	85 c0                	test   %eax,%eax
    906c:	74 09                	je     9077 <sys_kill+0x204>
    906e:	85 ff                	test   %edi,%edi
    9070:	7e 05                	jle    9077 <sys_kill+0x204>
    9072:	83 ff 20             	cmp    $0x20,%edi
    9075:	7e 07                	jle    907e <sys_kill+0x20b>
    9077:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    907c:	eb 40                	jmp    90be <sys_kill+0x24b>
	if (priv || (current->euid==p->euid) || suser())
    907e:	b8 00 00 00 00       	mov    $0x0,%eax
    9083:	85 c0                	test   %eax,%eax
    9085:	75 25                	jne    90ac <sys_kill+0x239>
    9087:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    908d:	66 8b 81 42 02 00 00 	mov    0x242(%ecx),%ax
    9094:	66 3b 85 42 02 00 00 	cmp    0x242(%ebp),%ax
    909b:	74 0f                	je     90ac <sys_kill+0x239>
		p->signal |= (1<<(sig-1));
    909d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (priv || (current->euid==p->euid) || suser())
    90a2:	66 83 b9 42 02 00 00 	cmpw   $0x0,0x242(%ecx)
    90a9:	00 
    90aa:	75 12                	jne    90be <sys_kill+0x24b>
		p->signal |= (1<<(sig-1));
    90ac:	8d 4a ff             	lea    -0x1(%edx),%ecx
    90af:	b8 01 00 00 00       	mov    $0x1,%eax
    90b4:	d3 e0                	shl    %cl,%eax
    90b6:	09 45 0c             	or     %eax,0xc(%ebp)
    90b9:	b8 00 00 00 00       	mov    $0x0,%eax
{
    90be:	85 c0                	test   %eax,%eax
    90c0:	74 03                	je     90c5 <sys_kill+0x252>
				retval = err;
    90c2:	89 04 24             	mov    %eax,(%esp)
    90c5:	83 eb 04             	sub    $0x4,%ebx
    90c8:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    90ce:	77 85                	ja     9055 <sys_kill+0x1e2>
	return retval;
}
    90d0:	8b 04 24             	mov    (%esp),%eax
    90d3:	83 c4 04             	add    $0x4,%esp
    90d6:	5b                   	pop    %ebx
    90d7:	5e                   	pop    %esi
    90d8:	5f                   	pop    %edi
    90d9:	5d                   	pop    %ebp
    90da:	c3                   	ret    

000090db <do_exit>:
	printk("BAD BAD - no father found\n\r");
	release(current);
}

int do_exit(long code)
{
    90db:	57                   	push   %edi
    90dc:	56                   	push   %esi
    90dd:	53                   	push   %ebx
	int i;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
    90de:	ba 0f 00 00 00       	mov    $0xf,%edx
    90e3:	0f 03 ca             	lsl    %dx,%ecx
    90e6:	41                   	inc    %ecx
    90e7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    90ec:	05 d8 02 00 00       	add    $0x2d8,%eax
         __asm__("movb %3,%%dh\n\t"
    90f1:	8a 70 07             	mov    0x7(%eax),%dh
    90f4:	8a 50 04             	mov    0x4(%eax),%dl
    90f7:	c1 e2 10             	shl    $0x10,%edx
    90fa:	66 8b 50 02          	mov    0x2(%eax),%dx
{
    90fe:	83 ec 08             	sub    $0x8,%esp
    9101:	51                   	push   %ecx
    9102:	52                   	push   %edx
    9103:	e8 f9 08 00 00       	call   9a01 <free_page_tables>
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
    9108:	83 c4 08             	add    $0x8,%esp
    910b:	ba 17 00 00 00       	mov    $0x17,%edx
    9110:	0f 03 ca             	lsl    %dx,%ecx
    9113:	41                   	inc    %ecx
    9114:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9119:	05 e0 02 00 00       	add    $0x2e0,%eax
         __asm__("movb %3,%%dh\n\t"
    911e:	8a 70 07             	mov    0x7(%eax),%dh
    9121:	8a 50 04             	mov    0x4(%eax),%dl
    9124:	c1 e2 10             	shl    $0x10,%edx
    9127:	66 8b 50 02          	mov    0x2(%eax),%dx
{
    912b:	51                   	push   %ecx
    912c:	52                   	push   %edx
    912d:	e8 cf 08 00 00       	call   9a01 <free_page_tables>
	for (i=0 ; i<NR_TASKS ; i++)
    9132:	bb 00 00 00 00       	mov    $0x0,%ebx
    9137:	83 c4 10             	add    $0x10,%esp
    913a:	be 40 bc 01 00       	mov    $0x1bc40,%esi
    913f:	bf 01 00 00 00       	mov    $0x1,%edi
		if (task[i] && task[i]->father == current->pid) {
    9144:	83 3c 9e 00          	cmpl   $0x0,(%esi,%ebx,4)
    9148:	74 3e                	je     9188 <do_exit+0xad>
    914a:	8b 0c 9e             	mov    (%esi,%ebx,4),%ecx
    914d:	8b 91 30 02 00 00    	mov    0x230(%ecx),%edx
    9153:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9158:	3b 90 2c 02 00 00    	cmp    0x22c(%eax),%edx
    915e:	75 28                	jne    9188 <do_exit+0xad>
			task[i]->father = 1;
    9160:	c7 81 30 02 00 00 01 	movl   $0x1,0x230(%ecx)
    9167:	00 00 00 
			if (task[i]->state == TASK_ZOMBIE)
    916a:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
    916d:	83 38 03             	cmpl   $0x3,(%eax)
    9170:	75 16                	jne    9188 <do_exit+0xad>
{
    9172:	a1 44 bc 01 00       	mov    0x1bc44,%eax
	if (!p || sig<1 || sig>32)
    9177:	85 c0                	test   %eax,%eax
    9179:	74 0d                	je     9188 <do_exit+0xad>
		p->signal |= (1<<(sig-1));
    917b:	b9 11 00 00 00       	mov    $0x11,%ecx
    9180:	49                   	dec    %ecx
    9181:	89 fa                	mov    %edi,%edx
    9183:	d3 e2                	shl    %cl,%edx
    9185:	09 50 0c             	or     %edx,0xc(%eax)
	for (i=0 ; i<NR_TASKS ; i++)
    9188:	43                   	inc    %ebx
    9189:	83 fb 3f             	cmp    $0x3f,%ebx
    918c:	7e b6                	jle    9144 <do_exit+0x69>
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
		}
	for (i=0 ; i<NR_OPEN ; i++)
    918e:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (current->filp[i])
    9193:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9198:	83 bc 98 80 02 00 00 	cmpl   $0x0,0x280(%eax,%ebx,4)
    919f:	00 
    91a0:	74 0c                	je     91ae <do_exit+0xd3>
			sys_close(i);
    91a2:	83 ec 0c             	sub    $0xc,%esp
    91a5:	53                   	push   %ebx
    91a6:	e8 0c 1c 00 00       	call   adb7 <sys_close>
    91ab:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_OPEN ; i++)
    91ae:	43                   	inc    %ebx
    91af:	83 fb 13             	cmp    $0x13,%ebx
    91b2:	7e df                	jle    9193 <do_exit+0xb8>
	iput(current->pwd);
    91b4:	83 ec 0c             	sub    $0xc,%esp
    91b7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    91bc:	ff b0 70 02 00 00    	pushl  0x270(%eax)
    91c2:	e8 86 26 00 00       	call   b84d <iput>
	current->pwd=NULL;
    91c7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    91cc:	c7 80 70 02 00 00 00 	movl   $0x0,0x270(%eax)
    91d3:	00 00 00 
	iput(current->root);
    91d6:	83 c4 04             	add    $0x4,%esp
    91d9:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    91de:	ff b0 74 02 00 00    	pushl  0x274(%eax)
    91e4:	e8 64 26 00 00       	call   b84d <iput>
	current->root=NULL;
    91e9:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    91ee:	c7 80 74 02 00 00 00 	movl   $0x0,0x274(%eax)
    91f5:	00 00 00 
	iput(current->executable);
    91f8:	83 c4 04             	add    $0x4,%esp
    91fb:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9200:	ff b0 78 02 00 00    	pushl  0x278(%eax)
    9206:	e8 42 26 00 00       	call   b84d <iput>
	current->executable=NULL;
    920b:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9210:	c7 80 78 02 00 00 00 	movl   $0x0,0x278(%eax)
    9217:	00 00 00 
	if (current->leader && current->tty >= 0)
    921a:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    921f:	83 c4 10             	add    $0x10,%esp
    9222:	83 b8 3c 02 00 00 00 	cmpl   $0x0,0x23c(%eax)
    9229:	74 27                	je     9252 <do_exit+0x177>
    922b:	83 b8 68 02 00 00 00 	cmpl   $0x0,0x268(%eax)
    9232:	78 1e                	js     9252 <do_exit+0x177>
		tty_table[current->tty].pgrp = 0;
    9234:	8b 90 68 02 00 00    	mov    0x268(%eax),%edx
    923a:	8d 04 92             	lea    (%edx,%edx,4),%eax
    923d:	8d 04 80             	lea    (%eax,%eax,4),%eax
    9240:	c1 e0 02             	shl    $0x2,%eax
    9243:	29 d0                	sub    %edx,%eax
    9245:	c1 e0 05             	shl    $0x5,%eax
    9248:	c7 80 44 bf 01 00 00 	movl   $0x0,0x1bf44(%eax)
    924f:	00 00 00 
	if (last_task_used_math == current)
    9252:	a1 c8 e9 01 00       	mov    0x1e9c8,%eax
    9257:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    925d:	75 0a                	jne    9269 <do_exit+0x18e>
		last_task_used_math = NULL;
    925f:	c7 05 c8 e9 01 00 00 	movl   $0x0,0x1e9c8
    9266:	00 00 00 
	if (current->leader)
    9269:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    926e:	83 b8 3c 02 00 00 00 	cmpl   $0x0,0x23c(%eax)
    9275:	74 36                	je     92ad <do_exit+0x1d2>
			(*p)->signal |= 1<<(SIGHUP-1);
    9277:	bb 3c bd 01 00       	mov    $0x1bd3c,%ebx
    927c:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    9282:	76 29                	jbe    92ad <do_exit+0x1d2>
		if (*p && (*p)->session == current->session)
    9284:	83 3b 00             	cmpl   $0x0,(%ebx)
    9287:	74 19                	je     92a2 <do_exit+0x1c7>
    9289:	8b 0b                	mov    (%ebx),%ecx
    928b:	8b 91 38 02 00 00    	mov    0x238(%ecx),%edx
    9291:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9296:	3b 90 38 02 00 00    	cmp    0x238(%eax),%edx
    929c:	75 04                	jne    92a2 <do_exit+0x1c7>
			(*p)->signal |= 1<<(SIGHUP-1);
    929e:	83 49 0c 01          	orl    $0x1,0xc(%ecx)
    92a2:	83 eb 04             	sub    $0x4,%ebx
    92a5:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    92ab:	77 d7                	ja     9284 <do_exit+0x1a9>
		kill_session();
	current->state = TASK_ZOMBIE;
    92ad:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    92b2:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	current->exit_code = code;
    92b8:	8b 54 24 10          	mov    0x10(%esp),%edx
    92bc:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    92c1:	89 90 14 02 00 00    	mov    %edx,0x214(%eax)
{
    92c7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    92cc:	8b 98 30 02 00 00    	mov    0x230(%eax),%ebx
	if (pid)
    92d2:	85 db                	test   %ebx,%ebx
    92d4:	74 2a                	je     9300 <do_exit+0x225>
		for (i=0;i<NR_TASKS;i++) {
    92d6:	ba 00 00 00 00       	mov    $0x0,%edx
    92db:	b9 40 bc 01 00       	mov    $0x1bc40,%ecx
			if (!task[i])
    92e0:	83 3c 91 00          	cmpl   $0x0,(%ecx,%edx,4)
    92e4:	74 14                	je     92fa <do_exit+0x21f>
			if (task[i]->pid != pid)
    92e6:	8b 04 91             	mov    (%ecx,%edx,4),%eax
    92e9:	39 98 2c 02 00 00    	cmp    %ebx,0x22c(%eax)
    92ef:	75 09                	jne    92fa <do_exit+0x21f>
			task[i]->signal |= (1<<(SIGCHLD-1));
    92f1:	81 48 0c 00 00 01 00 	orl    $0x10000,0xc(%eax)
    92f8:	eb 5f                	jmp    9359 <do_exit+0x27e>
		for (i=0;i<NR_TASKS;i++) {
    92fa:	42                   	inc    %edx
    92fb:	83 fa 3f             	cmp    $0x3f,%edx
    92fe:	7e e0                	jle    92e0 <do_exit+0x205>
	printk("BAD BAD - no father found\n\r");
    9300:	83 ec 0c             	sub    $0xc,%esp
    9303:	68 92 89 01 00       	push   $0x18992
    9308:	e8 46 f0 ff ff       	call   8353 <printk>
    930d:	83 c4 10             	add    $0x10,%esp
{
    9310:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
	if (!p)
    9316:	85 d2                	test   %edx,%edx
    9318:	74 3f                	je     9359 <do_exit+0x27e>
	for (i=1 ; i<NR_TASKS ; i++)
    931a:	b8 01 00 00 00       	mov    $0x1,%eax
    931f:	b9 40 bc 01 00       	mov    $0x1bc40,%ecx
		if (task[i]==p) {
    9324:	39 14 81             	cmp    %edx,(%ecx,%eax,4)
    9327:	75 1a                	jne    9343 <do_exit+0x268>
			task[i]=NULL;
    9329:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
			free_page((long)p);
    9330:	83 ec 0c             	sub    $0xc,%esp
    9333:	52                   	push   %edx
    9334:	e8 6c 06 00 00       	call   99a5 <free_page>
    9339:	83 c4 10             	add    $0x10,%esp
			schedule();
    933c:	e8 3a d7 ff ff       	call   6a7b <schedule>
    9341:	eb 16                	jmp    9359 <do_exit+0x27e>
	for (i=1 ; i<NR_TASKS ; i++)
    9343:	40                   	inc    %eax
    9344:	83 f8 3f             	cmp    $0x3f,%eax
    9347:	7e db                	jle    9324 <do_exit+0x249>
	panic("trying to release non-existent task");
    9349:	83 ec 0c             	sub    $0xc,%esp
    934c:	68 50 8b 01 00       	push   $0x18b50
    9351:	e8 c3 ef ff ff       	call   8319 <panic>
    9356:	83 c4 10             	add    $0x10,%esp
	tell_father(current->father);
	
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'E', jiffies);
    9359:	83 ec 0c             	sub    $0xc,%esp
    935c:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    9361:	50                   	push   %eax
    9362:	6a 45                	push   $0x45
    9364:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9369:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    936f:	68 cb 87 01 00       	push   $0x187cb
    9374:	6a 03                	push   $0x3
    9376:	e8 13 f0 ff ff       	call   838e <fprintk>
	schedule();
    937b:	83 c4 20             	add    $0x20,%esp
    937e:	e8 f8 d6 ff ff       	call   6a7b <schedule>
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'R', jiffies);
    9383:	83 ec 0c             	sub    $0xc,%esp
    9386:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    938b:	50                   	push   %eax
    938c:	6a 52                	push   $0x52
    938e:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9393:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    9399:	68 cb 87 01 00       	push   $0x187cb
    939e:	6a 03                	push   $0x3
    93a0:	e8 e9 ef ff ff       	call   838e <fprintk>
	return (-1);	/* just to suppress warnings */
    93a5:	83 c4 20             	add    $0x20,%esp
}
    93a8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    93ad:	5b                   	pop    %ebx
    93ae:	5e                   	pop    %esi
    93af:	5f                   	pop    %edi
    93b0:	c3                   	ret    

000093b1 <sys_exit>:

int sys_exit(int error_code)
{
    93b1:	83 ec 18             	sub    $0x18,%esp
	
	return do_exit((error_code&0xff)<<8);
    93b4:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
    93b9:	c1 e0 08             	shl    $0x8,%eax
    93bc:	50                   	push   %eax
    93bd:	e8 19 fd ff ff       	call   90db <do_exit>
}
    93c2:	83 c4 1c             	add    $0x1c,%esp
    93c5:	c3                   	ret    

000093c6 <sys_waitpid>:

int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)
{
    93c6:	55                   	push   %ebp
    93c7:	57                   	push   %edi
    93c8:	56                   	push   %esi
    93c9:	53                   	push   %ebx
    93ca:	83 ec 14             	sub    $0x14,%esp
    93cd:	8b 7c 24 28          	mov    0x28(%esp),%edi
    93d1:	8b 6c 24 30          	mov    0x30(%esp),%ebp
	int flag, code;
	struct task_struct ** p;

	verify_area(stat_addr,4);
    93d5:	6a 04                	push   $0x4
    93d7:	ff 74 24 30          	pushl  0x30(%esp)
    93db:	e8 8c ea ff ff       	call   7e6c <verify_area>
    93e0:	83 c4 10             	add    $0x10,%esp
repeat:
	flag=0;
    93e3:	be 00 00 00 00       	mov    $0x0,%esi
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    93e8:	bb 3c bd 01 00       	mov    $0x1bd3c,%ebx
    93ed:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    93f3:	0f 86 4d 01 00 00    	jbe    9546 <sys_waitpid+0x180>
		if (!*p || *p == current)
    93f9:	83 3b 00             	cmpl   $0x0,(%ebx)
    93fc:	0f 84 35 01 00 00    	je     9537 <sys_waitpid+0x171>
    9402:	8b 0b                	mov    (%ebx),%ecx
    9404:	3b 0d 20 bc 01 00    	cmp    0x1bc20,%ecx
    940a:	0f 84 27 01 00 00    	je     9537 <sys_waitpid+0x171>
			continue;
		if ((*p)->father != current->pid)
    9410:	8b 91 30 02 00 00    	mov    0x230(%ecx),%edx
    9416:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    941b:	3b 90 2c 02 00 00    	cmp    0x22c(%eax),%edx
    9421:	0f 85 10 01 00 00    	jne    9537 <sys_waitpid+0x171>
			continue;
		if (pid>0) {
    9427:	85 ff                	test   %edi,%edi
    9429:	7e 0e                	jle    9439 <sys_waitpid+0x73>
			if ((*p)->pid != pid)
    942b:	39 b9 2c 02 00 00    	cmp    %edi,0x22c(%ecx)
    9431:	0f 85 00 01 00 00    	jne    9537 <sys_waitpid+0x171>
				continue;
    9437:	eb 34                	jmp    946d <sys_waitpid+0xa7>
		} else if (!pid) {
    9439:	85 ff                	test   %edi,%edi
    943b:	75 1b                	jne    9458 <sys_waitpid+0x92>
			if ((*p)->pgrp != current->pgrp)
    943d:	8b 03                	mov    (%ebx),%eax
    943f:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
    9445:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    944a:	3b 90 34 02 00 00    	cmp    0x234(%eax),%edx
    9450:	0f 85 e1 00 00 00    	jne    9537 <sys_waitpid+0x171>
				continue;
    9456:	eb 15                	jmp    946d <sys_waitpid+0xa7>
		} else if (pid != -1) {
    9458:	83 ff ff             	cmp    $0xffffffff,%edi
    945b:	74 10                	je     946d <sys_waitpid+0xa7>
			if ((*p)->pgrp != -pid)
    945d:	8b 03                	mov    (%ebx),%eax
    945f:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    9465:	01 f8                	add    %edi,%eax
    9467:	0f 85 ca 00 00 00    	jne    9537 <sys_waitpid+0x171>
				continue;
		}
		switch ((*p)->state) {
    946d:	8b 13                	mov    (%ebx),%edx
    946f:	8b 02                	mov    (%edx),%eax
    9471:	83 f8 03             	cmp    $0x3,%eax
    9474:	74 43                	je     94b9 <sys_waitpid+0xf3>
    9476:	83 f8 04             	cmp    $0x4,%eax
    9479:	0f 85 b3 00 00 00    	jne    9532 <sys_waitpid+0x16c>
			case TASK_STOPPED:
				if (!(options & WUNTRACED))
    947f:	f7 c5 02 00 00 00    	test   $0x2,%ebp
    9485:	0f 84 ac 00 00 00    	je     9537 <sys_waitpid+0x171>
{
    948b:	b0 7f                	mov    $0x7f,%al
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    948d:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    9491:	64 89 01             	mov    %eax,%fs:(%ecx)
					continue;
				put_fs_long(0x7f,stat_addr);
				return (*p)->pid;
    9494:	8b 82 2c 02 00 00    	mov    0x22c(%edx),%eax
    949a:	e9 3d 01 00 00       	jmp    95dc <sys_waitpid+0x216>
			task[i]=NULL;
    949f:	c7 04 8a 00 00 00 00 	movl   $0x0,(%edx,%ecx,4)
			free_page((long)p);
    94a6:	83 ec 0c             	sub    $0xc,%esp
    94a9:	50                   	push   %eax
    94aa:	e8 f6 04 00 00       	call   99a5 <free_page>
    94af:	83 c4 10             	add    $0x10,%esp
			schedule();
    94b2:	e8 c4 d5 ff ff       	call   6a7b <schedule>
    94b7:	eb 6b                	jmp    9524 <sys_waitpid+0x15e>
			case TASK_ZOMBIE:
				current->cutime += (*p)->utime;
    94b9:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    94bf:	8b 13                	mov    (%ebx),%edx
    94c1:	8b 81 58 02 00 00    	mov    0x258(%ecx),%eax
    94c7:	03 82 50 02 00 00    	add    0x250(%edx),%eax
    94cd:	89 81 58 02 00 00    	mov    %eax,0x258(%ecx)
				current->cstime += (*p)->stime;
    94d3:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    94d9:	8b 13                	mov    (%ebx),%edx
    94db:	8b 81 5c 02 00 00    	mov    0x25c(%ecx),%eax
    94e1:	03 82 54 02 00 00    	add    0x254(%edx),%eax
    94e7:	89 81 5c 02 00 00    	mov    %eax,0x25c(%ecx)
				flag = (*p)->pid;
    94ed:	8b 03                	mov    (%ebx),%eax
    94ef:	8b b0 2c 02 00 00    	mov    0x22c(%eax),%esi
				code = (*p)->exit_code;
    94f5:	8b 98 14 02 00 00    	mov    0x214(%eax),%ebx
	if (!p)
    94fb:	85 c0                	test   %eax,%eax
    94fd:	74 25                	je     9524 <sys_waitpid+0x15e>
	for (i=1 ; i<NR_TASKS ; i++)
    94ff:	b9 01 00 00 00       	mov    $0x1,%ecx
    9504:	ba 40 bc 01 00       	mov    $0x1bc40,%edx
		if (task[i]==p) {
    9509:	39 04 8a             	cmp    %eax,(%edx,%ecx,4)
    950c:	74 91                	je     949f <sys_waitpid+0xd9>
	for (i=1 ; i<NR_TASKS ; i++)
    950e:	41                   	inc    %ecx
    950f:	83 f9 3f             	cmp    $0x3f,%ecx
    9512:	7e f5                	jle    9509 <sys_waitpid+0x143>
	panic("trying to release non-existent task");
    9514:	83 ec 0c             	sub    $0xc,%esp
    9517:	68 50 8b 01 00       	push   $0x18b50
    951c:	e8 f8 ed ff ff       	call   8319 <panic>
    9521:	83 c4 10             	add    $0x10,%esp
    9524:	8b 44 24 24          	mov    0x24(%esp),%eax
    9528:	64 89 18             	mov    %ebx,%fs:(%eax)
				release(*p);
				put_fs_long(code,stat_addr);
				return flag;
    952b:	89 f0                	mov    %esi,%eax
    952d:	e9 aa 00 00 00       	jmp    95dc <sys_waitpid+0x216>
			default:
				flag=1;
    9532:	be 01 00 00 00       	mov    $0x1,%esi
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    9537:	83 eb 04             	sub    $0x4,%ebx
    953a:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    9540:	0f 87 b3 fe ff ff    	ja     93f9 <sys_waitpid+0x33>
				continue;
		}
	}
	if (flag) {
    9546:	85 f6                	test   %esi,%esi
    9548:	0f 84 89 00 00 00    	je     95d7 <sys_waitpid+0x211>
		if (options & WNOHANG)
    954e:	f7 c5 01 00 00 00    	test   $0x1,%ebp
    9554:	74 07                	je     955d <sys_waitpid+0x197>
			return 0;
    9556:	b8 00 00 00 00       	mov    $0x0,%eax
    955b:	eb 7f                	jmp    95dc <sys_waitpid+0x216>

		current->state=TASK_INTERRUPTIBLE;
    955d:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9562:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
    9568:	83 ec 0c             	sub    $0xc,%esp
    956b:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    9570:	50                   	push   %eax
    9571:	6a 57                	push   $0x57
    9573:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    9578:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    957e:	68 cb 87 01 00       	push   $0x187cb
    9583:	6a 03                	push   $0x3
    9585:	e8 04 ee ff ff       	call   838e <fprintk>
		schedule();
    958a:	83 c4 20             	add    $0x20,%esp
    958d:	e8 e9 d4 ff ff       	call   6a7b <schedule>
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'R', jiffies);
    9592:	83 ec 0c             	sub    $0xc,%esp
    9595:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
    959a:	50                   	push   %eax
    959b:	6a 52                	push   $0x52
    959d:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    95a2:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    95a8:	68 cb 87 01 00       	push   $0x187cb
    95ad:	6a 03                	push   $0x3
    95af:	e8 da ed ff ff       	call   838e <fprintk>


		if (!(current->signal &= ~(1<<(SIGCHLD-1))))
    95b4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    95b9:	8b 50 0c             	mov    0xc(%eax),%edx
    95bc:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
    95c2:	89 50 0c             	mov    %edx,0xc(%eax)
    95c5:	83 c4 20             	add    $0x20,%esp
    95c8:	85 d2                	test   %edx,%edx
    95ca:	0f 84 13 fe ff ff    	je     93e3 <sys_waitpid+0x1d>
			goto repeat;
		else
			return -EINTR;
    95d0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    95d5:	eb 05                	jmp    95dc <sys_waitpid+0x216>
	}
	return -ECHILD;
    95d7:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
    95dc:	83 c4 0c             	add    $0xc,%esp
    95df:	5b                   	pop    %ebx
    95e0:	5e                   	pop    %esi
    95e1:	5f                   	pop    %edi
    95e2:	5d                   	pop    %ebp
    95e3:	c3                   	ret    

000095e4 <sys_sgetmask>:

volatile void do_exit(int error_code);

int sys_sgetmask()
{
	return current->blocked;
    95e4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    95e9:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
}
    95ef:	c3                   	ret    

000095f0 <sys_ssetmask>:

int sys_ssetmask(int newmask)
{
	int old=current->blocked;
    95f0:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    95f6:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax

	current->blocked = newmask & ~(1<<(SIGKILL-1));
    95fc:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    9600:	80 e5 fe             	and    $0xfe,%ch
    9603:	89 8a 10 02 00 00    	mov    %ecx,0x210(%edx)
	return old;
}
    9609:	c3                   	ret    

0000960a <sys_signal>:
	for (i=0 ; i< sizeof(struct sigaction) ; i++)
		*(to++) = get_fs_byte(from++);
}

int sys_signal(int signum, long handler, long restorer)
{
    960a:	53                   	push   %ebx
    960b:	83 ec 18             	sub    $0x18,%esp
    960e:	8b 54 24 20          	mov    0x20(%esp),%edx
    9612:	8b 5c 24 24          	mov    0x24(%esp),%ebx
	struct sigaction tmp;

	if (signum<1 || signum>32 || signum==SIGKILL)
    9616:	8d 42 ff             	lea    -0x1(%edx),%eax
    9619:	83 f8 1f             	cmp    $0x1f,%eax
    961c:	77 05                	ja     9623 <sys_signal+0x19>
    961e:	83 fa 09             	cmp    $0x9,%edx
    9621:	75 07                	jne    962a <sys_signal+0x20>
		return -1;
    9623:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9628:	eb 47                	jmp    9671 <sys_signal+0x67>
	tmp.sa_handler = (void (*)(int)) handler;
    962a:	89 1c 24             	mov    %ebx,(%esp)
	tmp.sa_mask = 0;
    962d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    9634:	00 
	tmp.sa_flags = SA_ONESHOT | SA_NOMASK;
    9635:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
    963c:	c0 
	tmp.sa_restorer = (void (*)(void)) restorer;
    963d:	8b 44 24 28          	mov    0x28(%esp),%eax
    9641:	89 44 24 0c          	mov    %eax,0xc(%esp)
	handler = (long) current->sigaction[signum-1].sa_handler;
    9645:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    964b:	c1 e2 04             	shl    $0x4,%edx
    964e:	8b 1c 0a             	mov    (%edx,%ecx,1),%ebx
	current->sigaction[signum-1] = tmp;
    9651:	8b 04 24             	mov    (%esp),%eax
    9654:	89 04 0a             	mov    %eax,(%edx,%ecx,1)
    9657:	8b 44 24 04          	mov    0x4(%esp),%eax
    965b:	89 44 0a 04          	mov    %eax,0x4(%edx,%ecx,1)
    965f:	8b 44 24 08          	mov    0x8(%esp),%eax
    9663:	89 44 0a 08          	mov    %eax,0x8(%edx,%ecx,1)
    9667:	8b 44 24 0c          	mov    0xc(%esp),%eax
    966b:	89 44 0a 0c          	mov    %eax,0xc(%edx,%ecx,1)
	return handler;
    966f:	89 d8                	mov    %ebx,%eax
}
    9671:	83 c4 18             	add    $0x18,%esp
    9674:	5b                   	pop    %ebx
    9675:	c3                   	ret    

00009676 <sys_sigaction>:

int sys_sigaction(int signum, const struct sigaction * action,
	struct sigaction * oldaction)
{
    9676:	55                   	push   %ebp
    9677:	57                   	push   %edi
    9678:	56                   	push   %esi
    9679:	53                   	push   %ebx
    967a:	83 ec 1c             	sub    $0x1c,%esp
    967d:	8b 7c 24 30          	mov    0x30(%esp),%edi
    9681:	8b 6c 24 38          	mov    0x38(%esp),%ebp
	struct sigaction tmp;

	if (signum<1 || signum>32 || signum==SIGKILL)
    9685:	8d 47 ff             	lea    -0x1(%edi),%eax
    9688:	83 f8 1f             	cmp    $0x1f,%eax
    968b:	77 05                	ja     9692 <sys_sigaction+0x1c>
    968d:	83 ff 09             	cmp    $0x9,%edi
    9690:	75 0a                	jne    969c <sys_sigaction+0x26>
		return -1;
    9692:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9697:	e9 9f 00 00 00       	jmp    973b <sys_sigaction+0xc5>
	tmp = current->sigaction[signum-1];
    969c:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    96a2:	89 fa                	mov    %edi,%edx
    96a4:	c1 e2 04             	shl    $0x4,%edx
    96a7:	8b 04 0a             	mov    (%edx,%ecx,1),%eax
    96aa:	89 04 24             	mov    %eax,(%esp)
    96ad:	8b 44 0a 04          	mov    0x4(%edx,%ecx,1),%eax
    96b1:	89 44 24 04          	mov    %eax,0x4(%esp)
    96b5:	8b 44 0a 08          	mov    0x8(%edx,%ecx,1),%eax
    96b9:	89 44 24 08          	mov    %eax,0x8(%esp)
    96bd:	8b 44 0a 0c          	mov    0xc(%edx,%ecx,1),%eax
    96c1:	89 44 24 0c          	mov    %eax,0xc(%esp)
{
    96c5:	8b 5c 24 34          	mov    0x34(%esp),%ebx
    96c9:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
    96cc:	be 0f 00 00 00       	mov    $0xf,%esi
{
    96d1:	89 d8                	mov    %ebx,%eax
    96d3:	43                   	inc    %ebx
    96d4:	89 ca                	mov    %ecx,%edx
    96d6:	41                   	inc    %ecx
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    96d7:	64 8a 00             	mov    %fs:(%eax),%al
{
    96da:	88 02                	mov    %al,(%edx)
    96dc:	4e                   	dec    %esi
    96dd:	79 f2                	jns    96d1 <sys_sigaction+0x5b>
	get_new((char *) action,
		(char *) (signum-1+current->sigaction));
	if (oldaction)
    96df:	85 ed                	test   %ebp,%ebp
    96e1:	74 21                	je     9704 <sys_sigaction+0x8e>
{
    96e3:	89 e6                	mov    %esp,%esi
    96e5:	89 eb                	mov    %ebp,%ebx
	verify_area(to, sizeof(struct sigaction));
    96e7:	83 ec 08             	sub    $0x8,%esp
    96ea:	6a 10                	push   $0x10
    96ec:	55                   	push   %ebp
    96ed:	e8 7a e7 ff ff       	call   7e6c <verify_area>
    96f2:	83 c4 10             	add    $0x10,%esp
    96f5:	ba 0f 00 00 00       	mov    $0xf,%edx
{
    96fa:	8a 06                	mov    (%esi),%al
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    96fc:	64 88 03             	mov    %al,%fs:(%ebx)
		from++;
    96ff:	46                   	inc    %esi
		to++;
    9700:	43                   	inc    %ebx
    9701:	4a                   	dec    %edx
    9702:	79 f6                	jns    96fa <sys_sigaction+0x84>
		save_old((char *) &tmp,(char *) oldaction);
	if (current->sigaction[signum-1].sa_flags & SA_NOMASK)
    9704:	89 f8                	mov    %edi,%eax
    9706:	c1 e0 04             	shl    $0x4,%eax
    9709:	03 05 20 bc 01 00    	add    0x1bc20,%eax
    970f:	f6 40 0b 40          	testb  $0x40,0xb(%eax)
    9713:	74 09                	je     971e <sys_sigaction+0xa8>
		current->sigaction[signum-1].sa_mask = 0;
    9715:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    971c:	eb 18                	jmp    9736 <sys_sigaction+0xc0>
	else
		current->sigaction[signum-1].sa_mask |= (1<<(signum-1));
    971e:	89 f8                	mov    %edi,%eax
    9720:	c1 e0 04             	shl    $0x4,%eax
    9723:	03 05 20 bc 01 00    	add    0x1bc20,%eax
    9729:	8d 4f ff             	lea    -0x1(%edi),%ecx
    972c:	ba 01 00 00 00       	mov    $0x1,%edx
    9731:	d3 e2                	shl    %cl,%edx
    9733:	09 50 04             	or     %edx,0x4(%eax)
	return 0;
    9736:	b8 00 00 00 00       	mov    $0x0,%eax
}
    973b:	83 c4 1c             	add    $0x1c,%esp
    973e:	5b                   	pop    %ebx
    973f:	5e                   	pop    %esi
    9740:	5f                   	pop    %edi
    9741:	5d                   	pop    %ebp
    9742:	c3                   	ret    

00009743 <do_signal>:

void do_signal(long signr,long eax, long ebx, long ecx, long edx,
	long fs, long es, long ds,
	long eip, long cs, long eflags,
	unsigned long * esp, long ss)
{
    9743:	55                   	push   %ebp
    9744:	57                   	push   %edi
    9745:	56                   	push   %esi
    9746:	53                   	push   %ebx
    9747:	83 ec 0c             	sub    $0xc,%esp
    974a:	8b 7c 24 20          	mov    0x20(%esp),%edi
    974e:	8b 74 24 4c          	mov    0x4c(%esp),%esi
	unsigned long sa_handler;
	long old_eip=eip;
    9752:	8b 6c 24 40          	mov    0x40(%esp),%ebp
	struct sigaction * sa = current->sigaction + signr - 1;
    9756:	89 f8                	mov    %edi,%eax
    9758:	c1 e0 04             	shl    $0x4,%eax
    975b:	89 c3                	mov    %eax,%ebx
    975d:	03 1d 20 bc 01 00    	add    0x1bc20,%ebx
	int longs;
	unsigned long * tmp_esp;

	sa_handler = (unsigned long) sa->sa_handler;
    9763:	8b 03                	mov    (%ebx),%eax
	if (sa_handler==1)
    9765:	83 f8 01             	cmp    $0x1,%eax
    9768:	0f 84 c5 00 00 00    	je     9833 <do_signal+0xf0>
		return;
	if (!sa_handler) {
    976e:	85 c0                	test   %eax,%eax
    9770:	75 1c                	jne    978e <do_signal+0x4b>
		if (signr==SIGCHLD)
    9772:	83 ff 11             	cmp    $0x11,%edi
    9775:	0f 84 b8 00 00 00    	je     9833 <do_signal+0xf0>
			return;
		else
			do_exit(1<<(signr-1));
    977b:	83 ec 0c             	sub    $0xc,%esp
    977e:	8d 4f ff             	lea    -0x1(%edi),%ecx
    9781:	b0 01                	mov    $0x1,%al
    9783:	d3 e0                	shl    %cl,%eax
    9785:	50                   	push   %eax
    9786:	e8 50 f9 ff ff       	call   90db <do_exit>
    978b:	83 c4 10             	add    $0x10,%esp
	}
	if (sa->sa_flags & SA_ONESHOT)
    978e:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    9792:	79 06                	jns    979a <do_signal+0x57>
		sa->sa_handler = NULL;
    9794:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	*(&eip) = sa_handler;
	longs = (sa->sa_flags & SA_NOMASK)?7:8;
    979a:	8b 43 08             	mov    0x8(%ebx),%eax
    979d:	25 00 00 00 40       	and    $0x40000000,%eax
    97a2:	83 f8 01             	cmp    $0x1,%eax
    97a5:	19 c0                	sbb    %eax,%eax
    97a7:	f7 d0                	not    %eax
	*(&esp) -= longs;
    97a9:	8d 04 85 20 00 00 00 	lea    0x20(,%eax,4),%eax
    97b0:	29 c6                	sub    %eax,%esi
	verify_area(esp,longs*4);
    97b2:	83 ec 08             	sub    $0x8,%esp
    97b5:	50                   	push   %eax
    97b6:	56                   	push   %esi
    97b7:	e8 b0 e6 ff ff       	call   7e6c <verify_area>
	tmp_esp=esp;
    97bc:	89 f1                	mov    %esi,%ecx
{
    97be:	83 c4 10             	add    $0x10,%esp
    97c1:	8b 53 0c             	mov    0xc(%ebx),%edx
    97c4:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    97c7:	64 89 16             	mov    %edx,%fs:(%esi)
{
    97ca:	89 c8                	mov    %ecx,%eax
    97cc:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    97cf:	64 89 38             	mov    %edi,%fs:(%eax)
	put_fs_long((long) sa->sa_restorer,tmp_esp++);
	put_fs_long(signr,tmp_esp++);
	if (!(sa->sa_flags & SA_NOMASK))
    97d2:	f6 43 0b 40          	testb  $0x40,0xb(%ebx)
    97d6:	75 13                	jne    97eb <do_signal+0xa8>
{
    97d8:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    97dd:	8b 90 10 02 00 00    	mov    0x210(%eax),%edx
    97e3:	89 c8                	mov    %ecx,%eax
    97e5:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    97e8:	64 89 10             	mov    %edx,%fs:(%eax)
{
    97eb:	89 c8                	mov    %ecx,%eax
    97ed:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    97f0:	8b 54 24 24          	mov    0x24(%esp),%edx
    97f4:	64 89 10             	mov    %edx,%fs:(%eax)
{
    97f7:	89 c8                	mov    %ecx,%eax
    97f9:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    97fc:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    9800:	64 89 10             	mov    %edx,%fs:(%eax)
{
    9803:	89 c8                	mov    %ecx,%eax
    9805:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    9808:	8b 54 24 30          	mov    0x30(%esp),%edx
    980c:	64 89 10             	mov    %edx,%fs:(%eax)
{
    980f:	89 c8                	mov    %ecx,%eax
    9811:	83 c1 04             	add    $0x4,%ecx
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    9814:	8b 54 24 48          	mov    0x48(%esp),%edx
    9818:	64 89 10             	mov    %edx,%fs:(%eax)
    981b:	64 89 29             	mov    %ebp,%fs:(%ecx)
	put_fs_long(eax,tmp_esp++);
	put_fs_long(ecx,tmp_esp++);
	put_fs_long(edx,tmp_esp++);
	put_fs_long(eflags,tmp_esp++);
	put_fs_long(old_eip,tmp_esp++);
	current->blocked |= sa->sa_mask;
    981e:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    9824:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    982a:	0b 43 04             	or     0x4(%ebx),%eax
    982d:	89 82 10 02 00 00    	mov    %eax,0x210(%edx)
}
    9833:	83 c4 0c             	add    $0xc,%esp
    9836:	5b                   	pop    %ebx
    9837:	5e                   	pop    %esi
    9838:	5f                   	pop    %edi
    9839:	5d                   	pop    %ebp
    983a:	c3                   	ret    

0000983b <kernel_mktime>:
	DAY*(31+29+31+30+31+30+31+31+30+31),
	DAY*(31+29+31+30+31+30+31+31+30+31+30)
};

long kernel_mktime(struct tm * tm)
{
    983b:	57                   	push   %edi
    983c:	56                   	push   %esi
    983d:	53                   	push   %ebx
    983e:	8b 74 24 10          	mov    0x10(%esp),%esi
	long res;
	int year;

	year = tm->tm_year - 70;
    9842:	8b 4e 14             	mov    0x14(%esi),%ecx
    9845:	8d 59 ba             	lea    -0x46(%ecx),%ebx
/* magic offsets (y+1) needed to get leapyears right.*/
	res = YEAR*year + DAY*((year+1)/4);
    9848:	89 d8                	mov    %ebx,%eax
    984a:	c1 e0 09             	shl    $0x9,%eax
    984d:	01 d8                	add    %ebx,%eax
    984f:	8d 04 83             	lea    (%ebx,%eax,4),%eax
    9852:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
    9855:	89 c2                	mov    %eax,%edx
    9857:	c1 e2 04             	shl    $0x4,%edx
    985a:	29 c2                	sub    %eax,%edx
    985c:	89 d7                	mov    %edx,%edi
    985e:	c1 e7 07             	shl    $0x7,%edi
    9861:	89 c8                	mov    %ecx,%eax
    9863:	83 e8 45             	sub    $0x45,%eax
    9866:	79 03                	jns    986b <kernel_mktime+0x30>
    9868:	8d 41 be             	lea    -0x42(%ecx),%eax
    986b:	c1 f8 02             	sar    $0x2,%eax
    986e:	8d 14 80             	lea    (%eax,%eax,4),%edx
    9871:	8d 14 90             	lea    (%eax,%edx,4),%edx
    9874:	8d 14 d0             	lea    (%eax,%edx,8),%edx
    9877:	c1 e2 02             	shl    $0x2,%edx
    987a:	29 c2                	sub    %eax,%edx
    987c:	c1 e2 07             	shl    $0x7,%edx
    987f:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
	res += month[tm->tm_mon];
    9882:	8b 46 10             	mov    0x10(%esi),%eax
    9885:	03 0c 85 a0 bd 01 00 	add    0x1bda0(,%eax,4),%ecx
/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	if (tm->tm_mon>1 && ((year+2)%4))
    988c:	83 f8 01             	cmp    $0x1,%eax
    988f:	7e 0d                	jle    989e <kernel_mktime+0x63>
    9891:	8d 43 02             	lea    0x2(%ebx),%eax
    9894:	a8 03                	test   $0x3,%al
    9896:	74 06                	je     989e <kernel_mktime+0x63>
		res -= DAY;
    9898:	81 e9 80 51 01 00    	sub    $0x15180,%ecx
	res += DAY*(tm->tm_mday-1);
    989e:	8b 56 0c             	mov    0xc(%esi),%edx
    98a1:	8d 04 92             	lea    (%edx,%edx,4),%eax
    98a4:	8d 04 82             	lea    (%edx,%eax,4),%eax
    98a7:	8d 04 c2             	lea    (%edx,%eax,8),%eax
    98aa:	c1 e0 02             	shl    $0x2,%eax
    98ad:	29 d0                	sub    %edx,%eax
    98af:	c1 e0 07             	shl    $0x7,%eax
    98b2:	8d 8c 01 80 ae fe ff 	lea    -0x15180(%ecx,%eax,1),%ecx
	res += HOUR*tm->tm_hour;
    98b9:	8b 56 08             	mov    0x8(%esi),%edx
    98bc:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
    98c3:	29 d0                	sub    %edx,%eax
    98c5:	c1 e0 05             	shl    $0x5,%eax
    98c8:	01 d0                	add    %edx,%eax
    98ca:	c1 e0 04             	shl    $0x4,%eax
    98cd:	01 c1                	add    %eax,%ecx
	res += MINUTE*tm->tm_min;
    98cf:	8b 46 04             	mov    0x4(%esi),%eax
    98d2:	8d 04 40             	lea    (%eax,%eax,2),%eax
    98d5:	8d 04 80             	lea    (%eax,%eax,4),%eax
    98d8:	8d 0c 81             	lea    (%ecx,%eax,4),%ecx
	res += tm->tm_sec;
    98db:	03 0e                	add    (%esi),%ecx
	return res;
}
    98dd:	89 c8                	mov    %ecx,%eax
    98df:	5b                   	pop    %ebx
    98e0:	5e                   	pop    %esi
    98e1:	5f                   	pop    %edi
    98e2:	c3                   	ret    

000098e3 <sys_iam>:
#include <linux/kernel.h>
#include <asm/segment.h>

char buffer[20];

int sys_iam(const char* name){
    98e3:	53                   	push   %ebx
    98e4:	83 ec 14             	sub    $0x14,%esp
    98e7:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	printk("my name is:");
    98eb:	68 ae 89 01 00       	push   $0x189ae
    98f0:	e8 5e ea ff ff       	call   8353 <printk>
	char rs;
	int i=0;
    98f5:	ba 00 00 00 00       	mov    $0x0,%edx
	while(rs=get_fs_byte(name++)){
    98fa:	83 c4 10             	add    $0x10,%esp
{
    98fd:	89 d8                	mov    %ebx,%eax
    98ff:	43                   	inc    %ebx
    9900:	64 8a 00             	mov    %fs:(%eax),%al
    9903:	84 c0                	test   %al,%al
    9905:	74 11                	je     9918 <sys_iam+0x35>
			buffer[i++]=rs;
    9907:	88 82 80 0d 02 00    	mov    %al,0x20d80(%edx)
    990d:	42                   	inc    %edx
    990e:	89 d8                	mov    %ebx,%eax
    9910:	43                   	inc    %ebx
    9911:	64 8a 00             	mov    %fs:(%eax),%al
    9914:	84 c0                	test   %al,%al
    9916:	75 ef                	jne    9907 <sys_iam+0x24>
	}
	printk(buffer);
    9918:	83 ec 0c             	sub    $0xc,%esp
    991b:	68 80 0d 02 00       	push   $0x20d80
    9920:	e8 2e ea ff ff       	call   8353 <printk>
	return 0;
}
    9925:	b8 00 00 00 00       	mov    $0x0,%eax
    992a:	83 c4 18             	add    $0x18,%esp
    992d:	5b                   	pop    %ebx
    992e:	c3                   	ret    

0000992f <sys_whoami>:
int sys_whoami(char *name,unsigned int size){
    992f:	53                   	push   %ebx
    9930:	83 ec 14             	sub    $0x14,%esp
	printk("get buffer from kernel\n");
    9933:	68 ba 89 01 00       	push   $0x189ba
    9938:	e8 16 ea ff ff       	call   8353 <printk>
	int i=0;
	char c;
	char *temp=name;
    993d:	8b 4c 24 20          	mov    0x20(%esp),%ecx
	while(c=buffer[i++]){
    9941:	83 c4 10             	add    $0x10,%esp
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    9944:	bb 01 00 00 00       	mov    $0x1,%ebx
    9949:	8a 15 80 0d 02 00    	mov    0x20d80,%dl
    994f:	84 d2                	test   %dl,%dl
    9951:	74 13                	je     9966 <sys_whoami+0x37>
{
    9953:	89 c8                	mov    %ecx,%eax
    9955:	41                   	inc    %ecx
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    9956:	64 88 10             	mov    %dl,%fs:(%eax)
    9959:	89 d8                	mov    %ebx,%eax
    995b:	43                   	inc    %ebx
    995c:	8a 90 80 0d 02 00    	mov    0x20d80(%eax),%dl
    9962:	84 d2                	test   %dl,%dl
    9964:	75 ed                	jne    9953 <sys_whoami+0x24>
		put_fs_byte(c,temp++);
	}
	return 0;
    9966:	b8 00 00 00 00       	mov    $0x0,%eax
    996b:	83 c4 08             	add    $0x8,%esp
    996e:	5b                   	pop    %ebx
    996f:	c3                   	ret    

00009970 <get_free_page>:
/*
 * Get physical address of first (actually last :-) free page, and mark it
 * used. If no free pages left, return 0.
 */
unsigned long get_free_page(void)
{
    9970:	57                   	push   %edi
register unsigned long __res asm("ax");

__asm__("std ; repne ; scasb\n\t"
    9971:	b8 00 00 00 00       	mov    $0x0,%eax
    9976:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    997b:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    9980:	fd                   	std    
    9981:	f2 ae                	repnz scas %es:(%edi),%al
    9983:	75 1e                	jne    99a3 <get_free_page+0x33>
    9985:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    9989:	c1 e1 0c             	shl    $0xc,%ecx
    998c:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    9992:	89 ca                	mov    %ecx,%edx
    9994:	b9 00 04 00 00       	mov    $0x400,%ecx
    9999:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    999f:	f3 ab                	rep stos %eax,%es:(%edi)
    99a1:	89 d0                	mov    %edx,%eax
	:"=a" (__res)
	:"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
	"D" (mem_map+PAGING_PAGES-1)
	);
return __res;
}
    99a3:	5f                   	pop    %edi
    99a4:	c3                   	ret    

000099a5 <free_page>:
/*
 * Free a page of memory at physical address 'addr'. Used by
 * 'free_page_tables()'
 */
void free_page(unsigned long addr)
{
    99a5:	53                   	push   %ebx
    99a6:	83 ec 08             	sub    $0x8,%esp
    99a9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	if (addr < LOW_MEM) return;
    99ad:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
    99b3:	76 47                	jbe    99fc <free_page+0x57>
	if (addr >= HIGH_MEMORY)
    99b5:	39 1d 40 f5 01 00    	cmp    %ebx,0x1f540
    99bb:	77 10                	ja     99cd <free_page+0x28>
		panic("trying to free nonexistent page");
    99bd:	83 ec 0c             	sub    $0xc,%esp
    99c0:	68 74 8b 01 00       	push   $0x18b74
    99c5:	e8 4f e9 ff ff       	call   8319 <panic>
    99ca:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    99cd:	81 eb 00 00 10 00    	sub    $0x100000,%ebx
	addr >>= 12;
    99d3:	c1 eb 0c             	shr    $0xc,%ebx
	if (mem_map[addr]--) return;
    99d6:	fe 8b 60 f5 01 00    	decb   0x1f560(%ebx)
    99dc:	80 bb 60 f5 01 00 ff 	cmpb   $0xff,0x1f560(%ebx)
    99e3:	75 17                	jne    99fc <free_page+0x57>
	mem_map[addr]=0;
    99e5:	c6 83 60 f5 01 00 00 	movb   $0x0,0x1f560(%ebx)
	panic("trying to free free page");
    99ec:	83 ec 0c             	sub    $0xc,%esp
    99ef:	68 85 8c 01 00       	push   $0x18c85
    99f4:	e8 20 e9 ff ff       	call   8319 <panic>
    99f9:	83 c4 10             	add    $0x10,%esp
}
    99fc:	83 c4 08             	add    $0x8,%esp
    99ff:	5b                   	pop    %ebx
    9a00:	c3                   	ret    

00009a01 <free_page_tables>:
/*
 * This function frees a continuos block of page tables, as needed
 * by 'exit()'. As does copy_page_tables(), this handles only 4Mb blocks.
 */
int free_page_tables(unsigned long from,unsigned long size)
{
    9a01:	55                   	push   %ebp
    9a02:	57                   	push   %edi
    9a03:	56                   	push   %esi
    9a04:	53                   	push   %ebx
    9a05:	83 ec 0c             	sub    $0xc,%esp
    9a08:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    9a0c:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	unsigned long *pg_table;
	unsigned long * dir, nr;

	if (from & 0x3fffff)
    9a10:	f7 c3 ff ff 3f 00    	test   $0x3fffff,%ebx
    9a16:	74 10                	je     9a28 <free_page_tables+0x27>
		panic("free_page_tables called with wrong alignment");
    9a18:	83 ec 0c             	sub    $0xc,%esp
    9a1b:	68 94 8b 01 00       	push   $0x18b94
    9a20:	e8 f4 e8 ff ff       	call   8319 <panic>
    9a25:	83 c4 10             	add    $0x10,%esp
	if (!from)
    9a28:	85 db                	test   %ebx,%ebx
    9a2a:	75 10                	jne    9a3c <free_page_tables+0x3b>
		panic("Trying to free up swapper memory space");
    9a2c:	83 ec 0c             	sub    $0xc,%esp
    9a2f:	68 c4 8b 01 00       	push   $0x18bc4
    9a34:	e8 e0 e8 ff ff       	call   8319 <panic>
    9a39:	83 c4 10             	add    $0x10,%esp
	size = (size + 0x3fffff) >> 22;
    9a3c:	81 c5 ff ff 3f 00    	add    $0x3fffff,%ebp
    9a42:	c1 ed 16             	shr    $0x16,%ebp
	dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
    9a45:	c1 eb 14             	shr    $0x14,%ebx
    9a48:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    9a4c:	81 64 24 08 fc 0f 00 	andl   $0xffc,0x8(%esp)
    9a53:	00 
	for ( ; size-->0 ; dir++) {
    9a54:	4d                   	dec    %ebp
    9a55:	83 fd ff             	cmp    $0xffffffff,%ebp
    9a58:	0f 84 f8 00 00 00    	je     9b56 <free_page_tables+0x155>
		if (!(1 & *dir))
    9a5e:	8b 54 24 08          	mov    0x8(%esp),%edx
    9a62:	8b 02                	mov    (%edx),%eax
    9a64:	a8 01                	test   $0x1,%al
    9a66:	0f 84 db 00 00 00    	je     9b47 <free_page_tables+0x146>
			continue;
		pg_table = (unsigned long *) (0xfffff000 & *dir);
    9a6c:	89 c6                	mov    %eax,%esi
    9a6e:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    9a74:	bf ff 03 00 00       	mov    $0x3ff,%edi
		for (nr=0 ; nr<1024 ; nr++) {
			if (1 & *pg_table)
    9a79:	8b 06                	mov    (%esi),%eax
    9a7b:	a8 01                	test   $0x1,%al
    9a7d:	74 57                	je     9ad6 <free_page_tables+0xd5>
{
    9a7f:	89 c3                	mov    %eax,%ebx
    9a81:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	if (addr < LOW_MEM) return;
    9a87:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
    9a8d:	76 47                	jbe    9ad6 <free_page_tables+0xd5>
	if (addr >= HIGH_MEMORY)
    9a8f:	39 1d 40 f5 01 00    	cmp    %ebx,0x1f540
    9a95:	77 10                	ja     9aa7 <free_page_tables+0xa6>
		panic("trying to free nonexistent page");
    9a97:	83 ec 0c             	sub    $0xc,%esp
    9a9a:	68 74 8b 01 00       	push   $0x18b74
    9a9f:	e8 75 e8 ff ff       	call   8319 <panic>
    9aa4:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    9aa7:	81 eb 00 00 10 00    	sub    $0x100000,%ebx
	addr >>= 12;
    9aad:	c1 eb 0c             	shr    $0xc,%ebx
	if (mem_map[addr]--) return;
    9ab0:	fe 8b 60 f5 01 00    	decb   0x1f560(%ebx)
    9ab6:	80 bb 60 f5 01 00 ff 	cmpb   $0xff,0x1f560(%ebx)
    9abd:	75 17                	jne    9ad6 <free_page_tables+0xd5>
	mem_map[addr]=0;
    9abf:	c6 83 60 f5 01 00 00 	movb   $0x0,0x1f560(%ebx)
	panic("trying to free free page");
    9ac6:	83 ec 0c             	sub    $0xc,%esp
    9ac9:	68 85 8c 01 00       	push   $0x18c85
    9ace:	e8 46 e8 ff ff       	call   8319 <panic>
    9ad3:	83 c4 10             	add    $0x10,%esp
				free_page(0xfffff000 & *pg_table);
			*pg_table = 0;
    9ad6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
			pg_table++;
    9adc:	83 c6 04             	add    $0x4,%esi
    9adf:	4f                   	dec    %edi
    9ae0:	79 97                	jns    9a79 <free_page_tables+0x78>
{
    9ae2:	8b 44 24 08          	mov    0x8(%esp),%eax
    9ae6:	8b 18                	mov    (%eax),%ebx
    9ae8:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	if (addr < LOW_MEM) return;
    9aee:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
    9af4:	76 47                	jbe    9b3d <free_page_tables+0x13c>
	if (addr >= HIGH_MEMORY)
    9af6:	39 1d 40 f5 01 00    	cmp    %ebx,0x1f540
    9afc:	77 10                	ja     9b0e <free_page_tables+0x10d>
		panic("trying to free nonexistent page");
    9afe:	83 ec 0c             	sub    $0xc,%esp
    9b01:	68 74 8b 01 00       	push   $0x18b74
    9b06:	e8 0e e8 ff ff       	call   8319 <panic>
    9b0b:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    9b0e:	81 eb 00 00 10 00    	sub    $0x100000,%ebx
	addr >>= 12;
    9b14:	c1 eb 0c             	shr    $0xc,%ebx
	if (mem_map[addr]--) return;
    9b17:	fe 8b 60 f5 01 00    	decb   0x1f560(%ebx)
    9b1d:	80 bb 60 f5 01 00 ff 	cmpb   $0xff,0x1f560(%ebx)
    9b24:	75 17                	jne    9b3d <free_page_tables+0x13c>
	mem_map[addr]=0;
    9b26:	c6 83 60 f5 01 00 00 	movb   $0x0,0x1f560(%ebx)
	panic("trying to free free page");
    9b2d:	83 ec 0c             	sub    $0xc,%esp
    9b30:	68 85 8c 01 00       	push   $0x18c85
    9b35:	e8 df e7 ff ff       	call   8319 <panic>
    9b3a:	83 c4 10             	add    $0x10,%esp
		}
		free_page(0xfffff000 & *dir);
		*dir = 0;
    9b3d:	8b 54 24 08          	mov    0x8(%esp),%edx
    9b41:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for ( ; size-->0 ; dir++) {
    9b47:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
    9b4c:	4d                   	dec    %ebp
    9b4d:	83 fd ff             	cmp    $0xffffffff,%ebp
    9b50:	0f 85 08 ff ff ff    	jne    9a5e <free_page_tables+0x5d>
	}
	invalidate();
    9b56:	b8 00 00 00 00       	mov    $0x0,%eax
    9b5b:	0f 22 d8             	mov    %eax,%cr3
	return 0;
}
    9b5e:	83 c4 0c             	add    $0xc,%esp
    9b61:	5b                   	pop    %ebx
    9b62:	5e                   	pop    %esi
    9b63:	5f                   	pop    %edi
    9b64:	5d                   	pop    %ebp
    9b65:	c3                   	ret    

00009b66 <copy_page_tables>:
 * doesn't take any more memory - we don't copy-on-write in the low
 * 1 Mb-range, so the pages can be shared with the kernel. Thus the
 * special case for nr=xxxx.
 */
int copy_page_tables(unsigned long from,unsigned long to,long size)
{
    9b66:	55                   	push   %ebp
    9b67:	57                   	push   %edi
    9b68:	56                   	push   %esi
    9b69:	53                   	push   %ebx
    9b6a:	83 ec 0c             	sub    $0xc,%esp
    9b6d:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    9b71:	8b 74 24 28          	mov    0x28(%esp),%esi
	unsigned long * to_page_table;
	unsigned long this_page;
	unsigned long * from_dir, * to_dir;
	unsigned long nr;

	if ((from&0x3fffff) || (to&0x3fffff))
    9b75:	f7 44 24 20 ff ff 3f 	testl  $0x3fffff,0x20(%esp)
    9b7c:	00 
    9b7d:	75 08                	jne    9b87 <copy_page_tables+0x21>
    9b7f:	f7 c3 ff ff 3f 00    	test   $0x3fffff,%ebx
    9b85:	74 10                	je     9b97 <copy_page_tables+0x31>
		panic("copy_page_tables called with wrong alignment");
    9b87:	83 ec 0c             	sub    $0xc,%esp
    9b8a:	68 ec 8b 01 00       	push   $0x18bec
    9b8f:	e8 85 e7 ff ff       	call   8319 <panic>
    9b94:	83 c4 10             	add    $0x10,%esp
	from_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
    9b97:	8b 44 24 20          	mov    0x20(%esp),%eax
    9b9b:	c1 e8 14             	shr    $0x14,%eax
    9b9e:	25 fc 0f 00 00       	and    $0xffc,%eax
    9ba3:	89 44 24 08          	mov    %eax,0x8(%esp)
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
    9ba7:	89 dd                	mov    %ebx,%ebp
    9ba9:	c1 ed 14             	shr    $0x14,%ebp
    9bac:	81 e5 fc 0f 00 00    	and    $0xffc,%ebp
	size = ((unsigned) (size+0x3fffff)) >> 22;
    9bb2:	81 c6 ff ff 3f 00    	add    $0x3fffff,%esi
    9bb8:	c1 ee 16             	shr    $0x16,%esi
	for( ; size-->0 ; from_dir++,to_dir++) {
    9bbb:	89 f0                	mov    %esi,%eax
    9bbd:	4e                   	dec    %esi
    9bbe:	85 c0                	test   %eax,%eax
    9bc0:	0f 8e ca 00 00 00    	jle    9c90 <copy_page_tables+0x12a>
		if (1 & *to_dir)
    9bc6:	f6 45 00 01          	testb  $0x1,0x0(%ebp)
    9bca:	74 10                	je     9bdc <copy_page_tables+0x76>
			panic("copy_page_tables: already exist");
    9bcc:	83 ec 0c             	sub    $0xc,%esp
    9bcf:	68 1c 8c 01 00       	push   $0x18c1c
    9bd4:	e8 40 e7 ff ff       	call   8319 <panic>
    9bd9:	83 c4 10             	add    $0x10,%esp
		if (!(1 & *from_dir))
    9bdc:	8b 54 24 08          	mov    0x8(%esp),%edx
    9be0:	8b 02                	mov    (%edx),%eax
    9be2:	a8 01                	test   $0x1,%al
    9be4:	0f 84 93 00 00 00    	je     9c7d <copy_page_tables+0x117>
			continue;
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
    9bea:	89 c3                	mov    %eax,%ebx
    9bec:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
__asm__("std ; repne ; scasb\n\t"
    9bf2:	b8 00 00 00 00       	mov    $0x0,%eax
    9bf7:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    9bfc:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    9c01:	fd                   	std    
    9c02:	f2 ae                	repnz scas %es:(%edi),%al
    9c04:	75 1e                	jne    9c24 <copy_page_tables+0xbe>
    9c06:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    9c0a:	c1 e1 0c             	shl    $0xc,%ecx
    9c0d:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    9c13:	89 ca                	mov    %ecx,%edx
    9c15:	b9 00 04 00 00       	mov    $0x400,%ecx
    9c1a:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    9c20:	f3 ab                	rep stos %eax,%es:(%edi)
    9c22:	89 d0                	mov    %edx,%eax
    9c24:	89 c1                	mov    %eax,%ecx
{
    9c26:	85 c0                	test   %eax,%eax
    9c28:	75 07                	jne    9c31 <copy_page_tables+0xcb>
		if (!(to_page_table = (unsigned long *) get_free_page()))
			return -1;	/* Out of memory, see freeing */
    9c2a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9c2f:	eb 67                	jmp    9c98 <copy_page_tables+0x132>
		*to_dir = ((unsigned long) to_page_table) | 7;
    9c31:	83 c8 07             	or     $0x7,%eax
    9c34:	89 45 00             	mov    %eax,0x0(%ebp)
		nr = (from==0)?0xA0:1024;
    9c37:	83 7c 24 20 01       	cmpl   $0x1,0x20(%esp)
    9c3c:	19 d2                	sbb    %edx,%edx
    9c3e:	81 e2 a0 fc ff ff    	and    $0xfffffca0,%edx
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
    9c44:	81 c2 ff 03 00 00    	add    $0x3ff,%edx
    9c4a:	83 fa ff             	cmp    $0xffffffff,%edx
    9c4d:	74 2e                	je     9c7d <copy_page_tables+0x117>
			this_page = *from_page_table;
    9c4f:	8b 03                	mov    (%ebx),%eax
			if (!(1 & this_page))
    9c51:	a8 01                	test   $0x1,%al
    9c53:	74 1c                	je     9c71 <copy_page_tables+0x10b>
				continue;
			this_page &= ~2;
    9c55:	83 e0 fd             	and    $0xfffffffd,%eax
			*to_page_table = this_page;
    9c58:	89 01                	mov    %eax,(%ecx)
			if (this_page > LOW_MEM) {
    9c5a:	3d 00 00 10 00       	cmp    $0x100000,%eax
    9c5f:	76 10                	jbe    9c71 <copy_page_tables+0x10b>
				*from_page_table = this_page;
    9c61:	89 03                	mov    %eax,(%ebx)
				this_page -= LOW_MEM;
    9c63:	2d 00 00 10 00       	sub    $0x100000,%eax
				this_page >>= 12;
    9c68:	c1 e8 0c             	shr    $0xc,%eax
				mem_map[this_page]++;
    9c6b:	fe 80 60 f5 01 00    	incb   0x1f560(%eax)
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
    9c71:	83 c3 04             	add    $0x4,%ebx
    9c74:	83 c1 04             	add    $0x4,%ecx
    9c77:	4a                   	dec    %edx
    9c78:	83 fa ff             	cmp    $0xffffffff,%edx
    9c7b:	75 d2                	jne    9c4f <copy_page_tables+0xe9>
	for( ; size-->0 ; from_dir++,to_dir++) {
    9c7d:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
    9c82:	83 c5 04             	add    $0x4,%ebp
    9c85:	89 f0                	mov    %esi,%eax
    9c87:	4e                   	dec    %esi
    9c88:	85 c0                	test   %eax,%eax
    9c8a:	0f 8f 36 ff ff ff    	jg     9bc6 <copy_page_tables+0x60>
			}
		}
	}
	invalidate();
    9c90:	b8 00 00 00 00       	mov    $0x0,%eax
    9c95:	0f 22 d8             	mov    %eax,%cr3
	return 0;
}
    9c98:	83 c4 0c             	add    $0xc,%esp
    9c9b:	5b                   	pop    %ebx
    9c9c:	5e                   	pop    %esi
    9c9d:	5f                   	pop    %edi
    9c9e:	5d                   	pop    %ebp
    9c9f:	c3                   	ret    

00009ca0 <put_page>:
 * It returns the physical address of the page gotten, 0 if
 * out of memory (either when trying to access page-table or
 * page.)
 */
unsigned long put_page(unsigned long page,unsigned long address)
{
    9ca0:	55                   	push   %ebp
    9ca1:	57                   	push   %edi
    9ca2:	56                   	push   %esi
    9ca3:	53                   	push   %ebx
    9ca4:	83 ec 0c             	sub    $0xc,%esp
    9ca7:	8b 74 24 20          	mov    0x20(%esp),%esi
    9cab:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	unsigned long tmp, *page_table;

/* NOTE !!! This uses the fact that _pg_dir=0 */

	if (page < LOW_MEM || page >= HIGH_MEMORY)
    9caf:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9cb5:	76 08                	jbe    9cbf <put_page+0x1f>
    9cb7:	39 35 40 f5 01 00    	cmp    %esi,0x1f540
    9cbd:	77 12                	ja     9cd1 <put_page+0x31>
		printk("Trying to put page %p at %p\n",page,address);
    9cbf:	83 ec 04             	sub    $0x4,%esp
    9cc2:	55                   	push   %ebp
    9cc3:	56                   	push   %esi
    9cc4:	68 9e 8c 01 00       	push   $0x18c9e
    9cc9:	e8 85 e6 ff ff       	call   8353 <printk>
    9cce:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page-LOW_MEM)>>12] != 1)
    9cd1:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9cd7:	c1 e8 0c             	shr    $0xc,%eax
    9cda:	80 b8 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%eax)
    9ce1:	74 12                	je     9cf5 <put_page+0x55>
		printk("mem_map disagrees with %p at %p\n",page,address);
    9ce3:	83 ec 04             	sub    $0x4,%esp
    9ce6:	55                   	push   %ebp
    9ce7:	56                   	push   %esi
    9ce8:	68 3c 8c 01 00       	push   $0x18c3c
    9ced:	e8 61 e6 ff ff       	call   8353 <printk>
    9cf2:	83 c4 10             	add    $0x10,%esp
	page_table = (unsigned long *) ((address>>20) & 0xffc);
    9cf5:	89 eb                	mov    %ebp,%ebx
    9cf7:	c1 eb 14             	shr    $0x14,%ebx
    9cfa:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
	if ((*page_table)&1)
    9d00:	8b 03                	mov    (%ebx),%eax
    9d02:	a8 01                	test   $0x1,%al
    9d04:	74 0a                	je     9d10 <put_page+0x70>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    9d06:	89 c3                	mov    %eax,%ebx
    9d08:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
    9d0e:	eb 46                	jmp    9d56 <put_page+0xb6>
__asm__("std ; repne ; scasb\n\t"
    9d10:	b8 00 00 00 00       	mov    $0x0,%eax
    9d15:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    9d1a:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    9d1f:	fd                   	std    
    9d20:	f2 ae                	repnz scas %es:(%edi),%al
    9d22:	75 1e                	jne    9d42 <put_page+0xa2>
    9d24:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    9d28:	c1 e1 0c             	shl    $0xc,%ecx
    9d2b:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    9d31:	89 ca                	mov    %ecx,%edx
    9d33:	b9 00 04 00 00       	mov    $0x400,%ecx
    9d38:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    9d3e:	f3 ab                	rep stos %eax,%es:(%edi)
    9d40:	89 d0                	mov    %edx,%eax
    9d42:	89 c2                	mov    %eax,%edx
	else {
		if (!(tmp=get_free_page()))
			return 0;
    9d44:	b8 00 00 00 00       	mov    $0x0,%eax
{
    9d49:	85 d2                	test   %edx,%edx
    9d4b:	74 1d                	je     9d6a <put_page+0xca>
		*page_table = tmp|7;
    9d4d:	89 d0                	mov    %edx,%eax
    9d4f:	83 c8 07             	or     $0x7,%eax
    9d52:	89 03                	mov    %eax,(%ebx)
		page_table = (unsigned long *) tmp;
    9d54:	89 d3                	mov    %edx,%ebx
	}
	page_table[(address>>12) & 0x3ff] = page | 7;
    9d56:	89 e8                	mov    %ebp,%eax
    9d58:	c1 e8 0c             	shr    $0xc,%eax
    9d5b:	25 ff 03 00 00       	and    $0x3ff,%eax
    9d60:	89 f2                	mov    %esi,%edx
    9d62:	83 ca 07             	or     $0x7,%edx
    9d65:	89 14 83             	mov    %edx,(%ebx,%eax,4)
/* no need for invalidate */
	return page;
    9d68:	89 f0                	mov    %esi,%eax
}
    9d6a:	83 c4 0c             	add    $0xc,%esp
    9d6d:	5b                   	pop    %ebx
    9d6e:	5e                   	pop    %esi
    9d6f:	5f                   	pop    %edi
    9d70:	5d                   	pop    %ebp
    9d71:	c3                   	ret    

00009d72 <un_wp_page>:

void un_wp_page(unsigned long * table_entry)
{
    9d72:	57                   	push   %edi
    9d73:	56                   	push   %esi
    9d74:	53                   	push   %ebx
    9d75:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	unsigned long old_page,new_page;

	old_page = 0xfffff000 & *table_entry;
    9d79:	8b 13                	mov    (%ebx),%edx
    9d7b:	89 d6                	mov    %edx,%esi
    9d7d:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
    9d83:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9d89:	76 26                	jbe    9db1 <un_wp_page+0x3f>
    9d8b:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9d91:	c1 e8 0c             	shr    $0xc,%eax
    9d94:	80 b8 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%eax)
    9d9b:	75 14                	jne    9db1 <un_wp_page+0x3f>
		*table_entry |= 2;
    9d9d:	89 d0                	mov    %edx,%eax
    9d9f:	83 c8 02             	or     $0x2,%eax
    9da2:	89 03                	mov    %eax,(%ebx)
		invalidate();
    9da4:	b8 00 00 00 00       	mov    $0x0,%eax
    9da9:	0f 22 d8             	mov    %eax,%cr3
		return;
    9dac:	e9 82 00 00 00       	jmp    9e33 <un_wp_page+0xc1>
__asm__("std ; repne ; scasb\n\t"
    9db1:	b8 00 00 00 00       	mov    $0x0,%eax
    9db6:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    9dbb:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    9dc0:	fd                   	std    
    9dc1:	f2 ae                	repnz scas %es:(%edi),%al
    9dc3:	75 1e                	jne    9de3 <un_wp_page+0x71>
    9dc5:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    9dc9:	c1 e1 0c             	shl    $0xc,%ecx
    9dcc:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    9dd2:	89 ca                	mov    %ecx,%edx
    9dd4:	b9 00 04 00 00       	mov    $0x400,%ecx
    9dd9:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    9ddf:	f3 ab                	rep stos %eax,%es:(%edi)
    9de1:	89 d0                	mov    %edx,%eax
    9de3:	89 c7                	mov    %eax,%edi
{
    9de5:	85 c0                	test   %eax,%eax
    9de7:	75 1c                	jne    9e05 <un_wp_page+0x93>
	printk("out of memory\n\r");
    9de9:	83 ec 0c             	sub    $0xc,%esp
    9dec:	68 bb 8c 01 00       	push   $0x18cbb
    9df1:	e8 5d e5 ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    9df6:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    9dfd:	e8 d9 f2 ff ff       	call   90db <do_exit>
    9e02:	83 c4 10             	add    $0x10,%esp
	}
	if (!(new_page=get_free_page()))
		oom();
	if (old_page >= LOW_MEM)
    9e05:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9e0b:	76 0f                	jbe    9e1c <un_wp_page+0xaa>
		mem_map[MAP_NR(old_page)]--;
    9e0d:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9e13:	c1 e8 0c             	shr    $0xc,%eax
    9e16:	fe 88 60 f5 01 00    	decb   0x1f560(%eax)
	*table_entry = new_page | 7;
    9e1c:	89 f8                	mov    %edi,%eax
    9e1e:	83 c8 07             	or     $0x7,%eax
    9e21:	89 03                	mov    %eax,(%ebx)
	invalidate();
    9e23:	b8 00 00 00 00       	mov    $0x0,%eax
    9e28:	0f 22 d8             	mov    %eax,%cr3
	copy_page(old_page,new_page);
    9e2b:	b9 00 04 00 00       	mov    $0x400,%ecx
    9e30:	fc                   	cld    
    9e31:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}	
    9e33:	5b                   	pop    %ebx
    9e34:	5e                   	pop    %esi
    9e35:	5f                   	pop    %edi
    9e36:	c3                   	ret    

00009e37 <do_wp_page>:
 * and decrementing the shared-page counter for the old page.
 *
 * If it's in code space we exit with a segment error.
 */
void do_wp_page(unsigned long error_code,unsigned long address)
{
    9e37:	57                   	push   %edi
    9e38:	56                   	push   %esi
    9e39:	53                   	push   %ebx
    9e3a:	8b 44 24 14          	mov    0x14(%esp),%eax
{
    9e3e:	89 c3                	mov    %eax,%ebx
    9e40:	c1 eb 0a             	shr    $0xa,%ebx
    9e43:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
    9e49:	c1 e8 14             	shr    $0x14,%eax
    9e4c:	25 fc 0f 00 00       	and    $0xffc,%eax
    9e51:	8b 00                	mov    (%eax),%eax
    9e53:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    9e58:	01 c3                	add    %eax,%ebx
	old_page = 0xfffff000 & *table_entry;
    9e5a:	8b 13                	mov    (%ebx),%edx
    9e5c:	89 d6                	mov    %edx,%esi
    9e5e:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
    9e64:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9e6a:	76 26                	jbe    9e92 <do_wp_page+0x5b>
    9e6c:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9e72:	c1 e8 0c             	shr    $0xc,%eax
    9e75:	80 b8 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%eax)
    9e7c:	75 14                	jne    9e92 <do_wp_page+0x5b>
		*table_entry |= 2;
    9e7e:	89 d0                	mov    %edx,%eax
    9e80:	83 c8 02             	or     $0x2,%eax
    9e83:	89 03                	mov    %eax,(%ebx)
		invalidate();
    9e85:	b8 00 00 00 00       	mov    $0x0,%eax
    9e8a:	0f 22 d8             	mov    %eax,%cr3
    9e8d:	e9 82 00 00 00       	jmp    9f14 <do_wp_page+0xdd>
__asm__("std ; repne ; scasb\n\t"
    9e92:	b8 00 00 00 00       	mov    $0x0,%eax
    9e97:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    9e9c:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    9ea1:	fd                   	std    
    9ea2:	f2 ae                	repnz scas %es:(%edi),%al
    9ea4:	75 1e                	jne    9ec4 <do_wp_page+0x8d>
    9ea6:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    9eaa:	c1 e1 0c             	shl    $0xc,%ecx
    9ead:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    9eb3:	89 ca                	mov    %ecx,%edx
    9eb5:	b9 00 04 00 00       	mov    $0x400,%ecx
    9eba:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    9ec0:	f3 ab                	rep stos %eax,%es:(%edi)
    9ec2:	89 d0                	mov    %edx,%eax
    9ec4:	89 c7                	mov    %eax,%edi
{
    9ec6:	85 c0                	test   %eax,%eax
    9ec8:	75 1c                	jne    9ee6 <do_wp_page+0xaf>
	printk("out of memory\n\r");
    9eca:	83 ec 0c             	sub    $0xc,%esp
    9ecd:	68 bb 8c 01 00       	push   $0x18cbb
    9ed2:	e8 7c e4 ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    9ed7:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    9ede:	e8 f8 f1 ff ff       	call   90db <do_exit>
    9ee3:	83 c4 10             	add    $0x10,%esp
	if (old_page >= LOW_MEM)
    9ee6:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9eec:	76 0f                	jbe    9efd <do_wp_page+0xc6>
		mem_map[MAP_NR(old_page)]--;
    9eee:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9ef4:	c1 e8 0c             	shr    $0xc,%eax
    9ef7:	fe 88 60 f5 01 00    	decb   0x1f560(%eax)
	*table_entry = new_page | 7;
    9efd:	89 f8                	mov    %edi,%eax
    9eff:	83 c8 07             	or     $0x7,%eax
    9f02:	89 03                	mov    %eax,(%ebx)
	invalidate();
    9f04:	b8 00 00 00 00       	mov    $0x0,%eax
    9f09:	0f 22 d8             	mov    %eax,%cr3
	copy_page(old_page,new_page);
    9f0c:	b9 00 04 00 00       	mov    $0x400,%ecx
    9f11:	fc                   	cld    
    9f12:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
#endif
	un_wp_page((unsigned long *)
		(((address>>10) & 0xffc) + (0xfffff000 &
		*((unsigned long *) ((address>>20) &0xffc)))));

}
    9f14:	5b                   	pop    %ebx
    9f15:	5e                   	pop    %esi
    9f16:	5f                   	pop    %edi
    9f17:	c3                   	ret    

00009f18 <write_verify>:

void write_verify(unsigned long address)
{
    9f18:	57                   	push   %edi
    9f19:	56                   	push   %esi
    9f1a:	53                   	push   %ebx
    9f1b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	unsigned long page;

	if (!( (page = *((unsigned long *) ((address>>20) & 0xffc)) )&1))
    9f1f:	89 c8                	mov    %ecx,%eax
    9f21:	c1 e8 14             	shr    $0x14,%eax
    9f24:	25 fc 0f 00 00       	and    $0xffc,%eax
    9f29:	8b 10                	mov    (%eax),%edx
    9f2b:	f6 c2 01             	test   $0x1,%dl
    9f2e:	0f 84 dc 00 00 00    	je     a010 <write_verify+0xf8>
		return;
	page &= 0xfffff000;
    9f34:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
	page += ((address>>10) & 0xffc);
    9f3a:	89 c8                	mov    %ecx,%eax
    9f3c:	c1 e8 0a             	shr    $0xa,%eax
    9f3f:	25 fc 0f 00 00       	and    $0xffc,%eax
    9f44:	01 c2                	add    %eax,%edx
	if ((3 & *(unsigned long *) page) == 1)  /* non-writeable, present */
    9f46:	8b 0a                	mov    (%edx),%ecx
    9f48:	89 c8                	mov    %ecx,%eax
    9f4a:	83 e0 03             	and    $0x3,%eax
    9f4d:	83 f8 01             	cmp    $0x1,%eax
    9f50:	0f 85 ba 00 00 00    	jne    a010 <write_verify+0xf8>
{
    9f56:	89 d3                	mov    %edx,%ebx
	old_page = 0xfffff000 & *table_entry;
    9f58:	89 ce                	mov    %ecx,%esi
    9f5a:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
    9f60:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9f66:	76 26                	jbe    9f8e <write_verify+0x76>
    9f68:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9f6e:	c1 e8 0c             	shr    $0xc,%eax
    9f71:	80 b8 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%eax)
    9f78:	75 14                	jne    9f8e <write_verify+0x76>
		*table_entry |= 2;
    9f7a:	89 c8                	mov    %ecx,%eax
    9f7c:	83 c8 02             	or     $0x2,%eax
    9f7f:	89 02                	mov    %eax,(%edx)
		invalidate();
    9f81:	b8 00 00 00 00       	mov    $0x0,%eax
    9f86:	0f 22 d8             	mov    %eax,%cr3
    9f89:	e9 82 00 00 00       	jmp    a010 <write_verify+0xf8>
__asm__("std ; repne ; scasb\n\t"
    9f8e:	b8 00 00 00 00       	mov    $0x0,%eax
    9f93:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    9f98:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    9f9d:	fd                   	std    
    9f9e:	f2 ae                	repnz scas %es:(%edi),%al
    9fa0:	75 1e                	jne    9fc0 <write_verify+0xa8>
    9fa2:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    9fa6:	c1 e1 0c             	shl    $0xc,%ecx
    9fa9:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    9faf:	89 ca                	mov    %ecx,%edx
    9fb1:	b9 00 04 00 00       	mov    $0x400,%ecx
    9fb6:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    9fbc:	f3 ab                	rep stos %eax,%es:(%edi)
    9fbe:	89 d0                	mov    %edx,%eax
    9fc0:	89 c7                	mov    %eax,%edi
{
    9fc2:	85 c0                	test   %eax,%eax
    9fc4:	75 1c                	jne    9fe2 <write_verify+0xca>
	printk("out of memory\n\r");
    9fc6:	83 ec 0c             	sub    $0xc,%esp
    9fc9:	68 bb 8c 01 00       	push   $0x18cbb
    9fce:	e8 80 e3 ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    9fd3:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    9fda:	e8 fc f0 ff ff       	call   90db <do_exit>
    9fdf:	83 c4 10             	add    $0x10,%esp
	if (old_page >= LOW_MEM)
    9fe2:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9fe8:	76 0f                	jbe    9ff9 <write_verify+0xe1>
		mem_map[MAP_NR(old_page)]--;
    9fea:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    9ff0:	c1 e8 0c             	shr    $0xc,%eax
    9ff3:	fe 88 60 f5 01 00    	decb   0x1f560(%eax)
	*table_entry = new_page | 7;
    9ff9:	89 f8                	mov    %edi,%eax
    9ffb:	83 c8 07             	or     $0x7,%eax
    9ffe:	89 03                	mov    %eax,(%ebx)
	invalidate();
    a000:	b8 00 00 00 00       	mov    $0x0,%eax
    a005:	0f 22 d8             	mov    %eax,%cr3
	copy_page(old_page,new_page);
    a008:	b9 00 04 00 00       	mov    $0x400,%ecx
    a00d:	fc                   	cld    
    a00e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		un_wp_page((unsigned long *) page);
	return;
}
    a010:	5b                   	pop    %ebx
    a011:	5e                   	pop    %esi
    a012:	5f                   	pop    %edi
    a013:	c3                   	ret    

0000a014 <get_empty_page>:

void get_empty_page(unsigned long address)
{
    a014:	55                   	push   %ebp
    a015:	57                   	push   %edi
    a016:	56                   	push   %esi
    a017:	53                   	push   %ebx
    a018:	83 ec 0c             	sub    $0xc,%esp
__asm__("std ; repne ; scasb\n\t"
    a01b:	b8 00 00 00 00       	mov    $0x0,%eax
    a020:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    a025:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    a02a:	fd                   	std    
    a02b:	f2 ae                	repnz scas %es:(%edi),%al
    a02d:	75 1e                	jne    a04d <get_empty_page+0x39>
    a02f:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    a033:	c1 e1 0c             	shl    $0xc,%ecx
    a036:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    a03c:	89 ca                	mov    %ecx,%edx
    a03e:	b9 00 04 00 00       	mov    $0x400,%ecx
    a043:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    a049:	f3 ab                	rep stos %eax,%es:(%edi)
    a04b:	89 d0                	mov    %edx,%eax
    a04d:	89 c6                	mov    %eax,%esi
{
    a04f:	85 c0                	test   %eax,%eax
    a051:	0f 84 d3 00 00 00    	je     a12a <get_empty_page+0x116>
{
    a057:	89 c5                	mov    %eax,%ebp
    a059:	8b 44 24 20          	mov    0x20(%esp),%eax
    a05d:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (page < LOW_MEM || page >= HIGH_MEMORY)
    a061:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    a067:	76 08                	jbe    a071 <get_empty_page+0x5d>
    a069:	39 35 40 f5 01 00    	cmp    %esi,0x1f540
    a06f:	77 15                	ja     a086 <get_empty_page+0x72>
		printk("Trying to put page %p at %p\n",page,address);
    a071:	83 ec 04             	sub    $0x4,%esp
    a074:	ff 74 24 0c          	pushl  0xc(%esp)
    a078:	55                   	push   %ebp
    a079:	68 9e 8c 01 00       	push   $0x18c9e
    a07e:	e8 d0 e2 ff ff       	call   8353 <printk>
    a083:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page-LOW_MEM)>>12] != 1)
    a086:	8d 85 00 00 f0 ff    	lea    -0x100000(%ebp),%eax
    a08c:	c1 e8 0c             	shr    $0xc,%eax
    a08f:	80 b8 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%eax)
    a096:	74 15                	je     a0ad <get_empty_page+0x99>
		printk("mem_map disagrees with %p at %p\n",page,address);
    a098:	83 ec 04             	sub    $0x4,%esp
    a09b:	ff 74 24 0c          	pushl  0xc(%esp)
    a09f:	55                   	push   %ebp
    a0a0:	68 3c 8c 01 00       	push   $0x18c3c
    a0a5:	e8 a9 e2 ff ff       	call   8353 <printk>
    a0aa:	83 c4 10             	add    $0x10,%esp
	page_table = (unsigned long *) ((address>>20) & 0xffc);
    a0ad:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    a0b1:	c1 eb 14             	shr    $0x14,%ebx
    a0b4:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
	if ((*page_table)&1)
    a0ba:	8b 03                	mov    (%ebx),%eax
    a0bc:	a8 01                	test   $0x1,%al
    a0be:	74 0a                	je     a0ca <get_empty_page+0xb6>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    a0c0:	89 c3                	mov    %eax,%ebx
    a0c2:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
    a0c8:	eb 46                	jmp    a110 <get_empty_page+0xfc>
__asm__("std ; repne ; scasb\n\t"
    a0ca:	b8 00 00 00 00       	mov    $0x0,%eax
    a0cf:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    a0d4:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    a0d9:	fd                   	std    
    a0da:	f2 ae                	repnz scas %es:(%edi),%al
    a0dc:	75 1e                	jne    a0fc <get_empty_page+0xe8>
    a0de:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    a0e2:	c1 e1 0c             	shl    $0xc,%ecx
    a0e5:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    a0eb:	89 ca                	mov    %ecx,%edx
    a0ed:	b9 00 04 00 00       	mov    $0x400,%ecx
    a0f2:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    a0f8:	f3 ab                	rep stos %eax,%es:(%edi)
    a0fa:	89 d0                	mov    %edx,%eax
    a0fc:	89 c2                	mov    %eax,%edx
}
    a0fe:	b8 00 00 00 00       	mov    $0x0,%eax
{
    a103:	85 d2                	test   %edx,%edx
    a105:	74 1f                	je     a126 <get_empty_page+0x112>
		*page_table = tmp|7;
    a107:	89 d0                	mov    %edx,%eax
    a109:	83 c8 07             	or     $0x7,%eax
    a10c:	89 03                	mov    %eax,(%ebx)
		page_table = (unsigned long *) tmp;
    a10e:	89 d3                	mov    %edx,%ebx
	page_table[(address>>12) & 0x3ff] = page | 7;
    a110:	8b 44 24 08          	mov    0x8(%esp),%eax
    a114:	c1 e8 0c             	shr    $0xc,%eax
    a117:	25 ff 03 00 00       	and    $0x3ff,%eax
    a11c:	89 ea                	mov    %ebp,%edx
    a11e:	83 ca 07             	or     $0x7,%edx
    a121:	89 14 83             	mov    %edx,(%ebx,%eax,4)
    a124:	89 e8                	mov    %ebp,%eax
{
    a126:	85 c0                	test   %eax,%eax
    a128:	75 6d                	jne    a197 <get_empty_page+0x183>
{
    a12a:	89 f7                	mov    %esi,%edi
	if (addr < LOW_MEM) return;
    a12c:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    a132:	76 47                	jbe    a17b <get_empty_page+0x167>
	if (addr >= HIGH_MEMORY)
    a134:	39 35 40 f5 01 00    	cmp    %esi,0x1f540
    a13a:	77 10                	ja     a14c <get_empty_page+0x138>
		panic("trying to free nonexistent page");
    a13c:	83 ec 0c             	sub    $0xc,%esp
    a13f:	68 74 8b 01 00       	push   $0x18b74
    a144:	e8 d0 e1 ff ff       	call   8319 <panic>
    a149:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    a14c:	81 ef 00 00 10 00    	sub    $0x100000,%edi
	addr >>= 12;
    a152:	c1 ef 0c             	shr    $0xc,%edi
	if (mem_map[addr]--) return;
    a155:	fe 8f 60 f5 01 00    	decb   0x1f560(%edi)
    a15b:	80 bf 60 f5 01 00 ff 	cmpb   $0xff,0x1f560(%edi)
    a162:	75 17                	jne    a17b <get_empty_page+0x167>
	mem_map[addr]=0;
    a164:	c6 87 60 f5 01 00 00 	movb   $0x0,0x1f560(%edi)
	panic("trying to free free page");
    a16b:	83 ec 0c             	sub    $0xc,%esp
    a16e:	68 85 8c 01 00       	push   $0x18c85
    a173:	e8 a1 e1 ff ff       	call   8319 <panic>
    a178:	83 c4 10             	add    $0x10,%esp
	printk("out of memory\n\r");
    a17b:	83 ec 0c             	sub    $0xc,%esp
    a17e:	68 bb 8c 01 00       	push   $0x18cbb
    a183:	e8 cb e1 ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    a188:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    a18f:	e8 47 ef ff ff       	call   90db <do_exit>
    a194:	83 c4 10             	add    $0x10,%esp

	if (!(tmp=get_free_page()) || !put_page(tmp,address)) {
		free_page(tmp);		/* 0 is ok - ignored */
		oom();
	}
}
    a197:	83 c4 0c             	add    $0xc,%esp
    a19a:	5b                   	pop    %ebx
    a19b:	5e                   	pop    %esi
    a19c:	5f                   	pop    %edi
    a19d:	5d                   	pop    %ebp
    a19e:	c3                   	ret    

0000a19f <try_to_share>:
 *
 * NOTE! This assumes we have checked that p != current, and that they
 * share the same executable.
 */
static int try_to_share(unsigned long address, struct task_struct * p)
{
    a19f:	55                   	push   %ebp
    a1a0:	57                   	push   %edi
    a1a1:	56                   	push   %esi
    a1a2:	53                   	push   %ebx
    a1a3:	83 ec 0c             	sub    $0xc,%esp
	unsigned long to;
	unsigned long from_page;
	unsigned long to_page;
	unsigned long phys_addr;

	from_page = to_page = ((address>>20) & 0xffc);
    a1a6:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    a1aa:	c1 eb 14             	shr    $0x14,%ebx
    a1ad:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
	from_page += ((p->start_code>>20) & 0xffc);
    a1b3:	8b 44 24 24          	mov    0x24(%esp),%eax
    a1b7:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    a1bd:	c1 e8 14             	shr    $0x14,%eax
    a1c0:	25 fc 0f 00 00       	and    $0xffc,%eax
    a1c5:	8d 34 03             	lea    (%ebx,%eax,1),%esi
	to_page += ((current->start_code>>20) & 0xffc);
    a1c8:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a1cd:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
    a1d3:	c1 e8 14             	shr    $0x14,%eax
    a1d6:	25 fc 0f 00 00       	and    $0xffc,%eax
    a1db:	01 c3                	add    %eax,%ebx
/* is there a page-directory at from? */
	from = *(unsigned long *) from_page;
    a1dd:	8b 06                	mov    (%esi),%eax
	if (!(from & 1))
		return 0;
    a1df:	ba 00 00 00 00       	mov    $0x0,%edx
	if (!(from & 1))
    a1e4:	a8 01                	test   $0x1,%al
    a1e6:	0f 84 01 01 00 00    	je     a2ed <try_to_share+0x14e>
	from &= 0xfffff000;
    a1ec:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	from_page = from + ((address>>10) & 0xffc);
    a1f1:	8b 74 24 20          	mov    0x20(%esp),%esi
    a1f5:	c1 ee 0a             	shr    $0xa,%esi
    a1f8:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
    a1fe:	01 c6                	add    %eax,%esi
	phys_addr = *(unsigned long *) from_page;
    a200:	8b 2e                	mov    (%esi),%ebp
/* is the page clean and present? */
	if ((phys_addr & 0x41) != 0x01)
    a202:	89 e8                	mov    %ebp,%eax
    a204:	83 e0 41             	and    $0x41,%eax
		return 0;
    a207:	ba 00 00 00 00       	mov    $0x0,%edx
	if ((phys_addr & 0x41) != 0x01)
    a20c:	83 f8 01             	cmp    $0x1,%eax
    a20f:	0f 85 d8 00 00 00    	jne    a2ed <try_to_share+0x14e>
	phys_addr &= 0xfffff000;
    a215:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
    a21b:	39 2d 40 f5 01 00    	cmp    %ebp,0x1f540
    a221:	76 08                	jbe    a22b <try_to_share+0x8c>
    a223:	81 fd ff ff 0f 00    	cmp    $0xfffff,%ebp
    a229:	77 0a                	ja     a235 <try_to_share+0x96>
		return 0;
    a22b:	ba 00 00 00 00       	mov    $0x0,%edx
    a230:	e9 b8 00 00 00       	jmp    a2ed <try_to_share+0x14e>
	to = *(unsigned long *) to_page;
    a235:	8b 03                	mov    (%ebx),%eax
    a237:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (!(to & 1)) {
    a23b:	83 e0 01             	and    $0x1,%eax
    a23e:	75 5a                	jne    a29a <try_to_share+0xfb>
__asm__("std ; repne ; scasb\n\t"
    a240:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    a245:	ba 5f 04 02 00       	mov    $0x2045f,%edx
    a24a:	89 d7                	mov    %edx,%edi
    a24c:	fd                   	std    
    a24d:	f2 ae                	repnz scas %es:(%edi),%al
    a24f:	75 1e                	jne    a26f <try_to_share+0xd0>
    a251:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    a255:	c1 e1 0c             	shl    $0xc,%ecx
    a258:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    a25e:	89 ca                	mov    %ecx,%edx
    a260:	b9 00 04 00 00       	mov    $0x400,%ecx
    a265:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    a26b:	f3 ab                	rep stos %eax,%es:(%edi)
    a26d:	89 d0                	mov    %edx,%eax
    a26f:	89 44 24 08          	mov    %eax,0x8(%esp)
{
    a273:	85 c0                	test   %eax,%eax
    a275:	74 07                	je     a27e <try_to_share+0xdf>
		if ((to = get_free_page()))
			*(unsigned long *) to_page = to | 7;
    a277:	83 c8 07             	or     $0x7,%eax
    a27a:	89 03                	mov    %eax,(%ebx)
    a27c:	eb 1c                	jmp    a29a <try_to_share+0xfb>
	printk("out of memory\n\r");
    a27e:	83 ec 0c             	sub    $0xc,%esp
    a281:	68 bb 8c 01 00       	push   $0x18cbb
    a286:	e8 c8 e0 ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    a28b:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    a292:	e8 44 ee ff ff       	call   90db <do_exit>
    a297:	83 c4 10             	add    $0x10,%esp
		else
			oom();
	}
	to &= 0xfffff000;
    a29a:	81 64 24 08 00 f0 ff 	andl   $0xfffff000,0x8(%esp)
    a2a1:	ff 
	to_page = to + ((address>>10) & 0xffc);
    a2a2:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    a2a6:	c1 eb 0a             	shr    $0xa,%ebx
    a2a9:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
    a2af:	03 5c 24 08          	add    0x8(%esp),%ebx
	if (1 & *(unsigned long *) to_page)
    a2b3:	f6 03 01             	testb  $0x1,(%ebx)
    a2b6:	74 10                	je     a2c8 <try_to_share+0x129>
		panic("try_to_share: to_page already exists");
    a2b8:	83 ec 0c             	sub    $0xc,%esp
    a2bb:	68 60 8c 01 00       	push   $0x18c60
    a2c0:	e8 54 e0 ff ff       	call   8319 <panic>
    a2c5:	83 c4 10             	add    $0x10,%esp
/* share them: write-protect */
	*(unsigned long *) from_page &= ~2;
    a2c8:	8b 06                	mov    (%esi),%eax
    a2ca:	83 e0 fd             	and    $0xfffffffd,%eax
    a2cd:	89 06                	mov    %eax,(%esi)
	*(unsigned long *) to_page = *(unsigned long *) from_page;
    a2cf:	89 03                	mov    %eax,(%ebx)
	invalidate();
    a2d1:	b8 00 00 00 00       	mov    $0x0,%eax
    a2d6:	0f 22 d8             	mov    %eax,%cr3
	phys_addr -= LOW_MEM;
    a2d9:	81 ed 00 00 10 00    	sub    $0x100000,%ebp
	phys_addr >>= 12;
    a2df:	c1 ed 0c             	shr    $0xc,%ebp
	mem_map[phys_addr]++;
    a2e2:	fe 85 60 f5 01 00    	incb   0x1f560(%ebp)
	return 1;
    a2e8:	ba 01 00 00 00       	mov    $0x1,%edx
}
    a2ed:	89 d0                	mov    %edx,%eax
    a2ef:	83 c4 0c             	add    $0xc,%esp
    a2f2:	5b                   	pop    %ebx
    a2f3:	5e                   	pop    %esi
    a2f4:	5f                   	pop    %edi
    a2f5:	5d                   	pop    %ebp
    a2f6:	c3                   	ret    

0000a2f7 <do_no_page>:
	}
	return 0;
}

void do_no_page(unsigned long error_code,unsigned long address)
{
    a2f7:	55                   	push   %ebp
    a2f8:	57                   	push   %edi
    a2f9:	56                   	push   %esi
    a2fa:	53                   	push   %ebx
    a2fb:	83 ec 2c             	sub    $0x2c,%esp
	int nr[4];
	unsigned long tmp;
	unsigned long page;
	int block,i;

	address &= 0xfffff000;
    a2fe:	8b 6c 24 44          	mov    0x44(%esp),%ebp
    a302:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
	tmp = address - current->start_code;
    a308:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a30d:	89 ee                	mov    %ebp,%esi
    a30f:	2b b0 18 02 00 00    	sub    0x218(%eax),%esi
	if (!current->executable || tmp >= current->end_data) {
    a315:	83 b8 78 02 00 00 00 	cmpl   $0x0,0x278(%eax)
    a31c:	74 08                	je     a326 <do_no_page+0x2f>
    a31e:	39 b0 20 02 00 00    	cmp    %esi,0x220(%eax)
    a324:	77 11                	ja     a337 <do_no_page+0x40>
		get_empty_page(address);
    a326:	83 ec 0c             	sub    $0xc,%esp
    a329:	55                   	push   %ebp
    a32a:	e8 e5 fc ff ff       	call   a014 <get_empty_page>
		return;
    a32f:	83 c4 10             	add    $0x10,%esp
    a332:	e9 92 02 00 00       	jmp    a5c9 <do_no_page+0x2d2>
{
    a337:	89 f7                	mov    %esi,%edi
	if (!current->executable)
    a339:	ba 00 00 00 00       	mov    $0x0,%edx
    a33e:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a343:	83 b8 78 02 00 00 00 	cmpl   $0x0,0x278(%eax)
    a34a:	74 70                	je     a3bc <do_no_page+0xc5>
	if (current->executable->i_count < 2)
    a34c:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a351:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    a357:	ba 00 00 00 00       	mov    $0x0,%edx
    a35c:	66 83 78 30 01       	cmpw   $0x1,0x30(%eax)
    a361:	76 59                	jbe    a3bc <do_no_page+0xc5>
    a363:	eb 07                	jmp    a36c <do_no_page+0x75>
		if (try_to_share(address,*p))
    a365:	ba 01 00 00 00       	mov    $0x1,%edx
    a36a:	eb 50                	jmp    a3bc <do_no_page+0xc5>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    a36c:	bb 3c bd 01 00       	mov    $0x1bd3c,%ebx
    a371:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    a377:	76 3e                	jbe    a3b7 <do_no_page+0xc0>
		if (!*p)
    a379:	83 3b 00             	cmpl   $0x0,(%ebx)
    a37c:	74 2e                	je     a3ac <do_no_page+0xb5>
		if (current == *p)
    a37e:	8b 0b                	mov    (%ebx),%ecx
    a380:	3b 0d 20 bc 01 00    	cmp    0x1bc20,%ecx
    a386:	74 24                	je     a3ac <do_no_page+0xb5>
		if ((*p)->executable != current->executable)
    a388:	8b 91 78 02 00 00    	mov    0x278(%ecx),%edx
    a38e:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a393:	3b 90 78 02 00 00    	cmp    0x278(%eax),%edx
    a399:	75 11                	jne    a3ac <do_no_page+0xb5>
		if (try_to_share(address,*p))
    a39b:	83 ec 08             	sub    $0x8,%esp
    a39e:	51                   	push   %ecx
    a39f:	57                   	push   %edi
    a3a0:	e8 fa fd ff ff       	call   a19f <try_to_share>
    a3a5:	83 c4 10             	add    $0x10,%esp
    a3a8:	85 c0                	test   %eax,%eax
    a3aa:	75 b9                	jne    a365 <do_no_page+0x6e>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    a3ac:	83 eb 04             	sub    $0x4,%ebx
    a3af:	81 fb 40 bc 01 00    	cmp    $0x1bc40,%ebx
    a3b5:	77 c2                	ja     a379 <do_no_page+0x82>
	}
    a3b7:	ba 00 00 00 00       	mov    $0x0,%edx
{
    a3bc:	85 d2                	test   %edx,%edx
    a3be:	0f 85 05 02 00 00    	jne    a5c9 <do_no_page+0x2d2>
__asm__("std ; repne ; scasb\n\t"
    a3c4:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    a3c9:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    a3ce:	89 d0                	mov    %edx,%eax
    a3d0:	fd                   	std    
    a3d1:	f2 ae                	repnz scas %es:(%edi),%al
    a3d3:	75 1e                	jne    a3f3 <do_no_page+0xfc>
    a3d5:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    a3d9:	c1 e1 0c             	shl    $0xc,%ecx
    a3dc:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    a3e2:	89 ca                	mov    %ecx,%edx
    a3e4:	b9 00 04 00 00       	mov    $0x400,%ecx
    a3e9:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    a3ef:	f3 ab                	rep stos %eax,%es:(%edi)
    a3f1:	89 d0                	mov    %edx,%eax
    a3f3:	89 44 24 0c          	mov    %eax,0xc(%esp)
{
    a3f7:	85 c0                	test   %eax,%eax
    a3f9:	75 1c                	jne    a417 <do_no_page+0x120>
	printk("out of memory\n\r");
    a3fb:	83 ec 0c             	sub    $0xc,%esp
    a3fe:	68 bb 8c 01 00       	push   $0x18cbb
    a403:	e8 4b df ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    a408:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    a40f:	e8 c7 ec ff ff       	call   90db <do_exit>
    a414:	83 c4 10             	add    $0x10,%esp
	if (share_page(tmp))
		return;
	if (!(page = get_free_page()))
		oom();
/* remember that 1 block is used for header */
	block = 1 + tmp/BLOCK_SIZE;
    a417:	89 f3                	mov    %esi,%ebx
    a419:	c1 eb 0a             	shr    $0xa,%ebx
    a41c:	43                   	inc    %ebx
	for (i=0 ; i<4 ; block++,i++)
    a41d:	bf 00 00 00 00       	mov    $0x0,%edi
		nr[i] = bmap(current->executable,block);
    a422:	83 ec 08             	sub    $0x8,%esp
    a425:	53                   	push   %ebx
    a426:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a42b:	ff b0 78 02 00 00    	pushl  0x278(%eax)
    a431:	e8 df 13 00 00       	call   b815 <bmap>
    a436:	89 44 bc 20          	mov    %eax,0x20(%esp,%edi,4)
	for (i=0 ; i<4 ; block++,i++)
    a43a:	83 c4 10             	add    $0x10,%esp
    a43d:	43                   	inc    %ebx
    a43e:	47                   	inc    %edi
    a43f:	83 ff 03             	cmp    $0x3,%edi
    a442:	7e de                	jle    a422 <do_no_page+0x12b>
	bread_page(page,current->executable->i_dev,nr);
    a444:	83 ec 04             	sub    $0x4,%esp
    a447:	8d 44 24 14          	lea    0x14(%esp),%eax
    a44b:	50                   	push   %eax
    a44c:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a451:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
    a457:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    a45b:	50                   	push   %eax
    a45c:	ff 74 24 18          	pushl  0x18(%esp)
    a460:	e8 36 23 00 00       	call   c79b <bread_page>
	i = tmp + 4096 - current->end_data;
    a465:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a46a:	89 f7                	mov    %esi,%edi
    a46c:	2b b8 20 02 00 00    	sub    0x220(%eax),%edi
    a472:	81 c7 00 10 00 00    	add    $0x1000,%edi
	tmp = page + 4096;
    a478:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    a47c:	81 c6 00 10 00 00    	add    $0x1000,%esi
	while (i-- > 0) {
    a482:	83 c4 10             	add    $0x10,%esp
		tmp--;
		*(char *)tmp = 0;
    a485:	89 f8                	mov    %edi,%eax
    a487:	4f                   	dec    %edi
    a488:	85 c0                	test   %eax,%eax
    a48a:	7e 0b                	jle    a497 <do_no_page+0x1a0>
		tmp--;
    a48c:	4e                   	dec    %esi
		*(char *)tmp = 0;
    a48d:	c6 06 00             	movb   $0x0,(%esi)
    a490:	89 f8                	mov    %edi,%eax
    a492:	4f                   	dec    %edi
    a493:	85 c0                	test   %eax,%eax
    a495:	7f f5                	jg     a48c <do_no_page+0x195>
{
    a497:	8b 74 24 0c          	mov    0xc(%esp),%esi
	if (page < LOW_MEM || page >= HIGH_MEMORY)
    a49b:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    a4a1:	76 08                	jbe    a4ab <do_no_page+0x1b4>
    a4a3:	39 35 40 f5 01 00    	cmp    %esi,0x1f540
    a4a9:	77 12                	ja     a4bd <do_no_page+0x1c6>
		printk("Trying to put page %p at %p\n",page,address);
    a4ab:	83 ec 04             	sub    $0x4,%esp
    a4ae:	55                   	push   %ebp
    a4af:	56                   	push   %esi
    a4b0:	68 9e 8c 01 00       	push   $0x18c9e
    a4b5:	e8 99 de ff ff       	call   8353 <printk>
    a4ba:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page-LOW_MEM)>>12] != 1)
    a4bd:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    a4c3:	c1 e8 0c             	shr    $0xc,%eax
    a4c6:	80 b8 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%eax)
    a4cd:	74 12                	je     a4e1 <do_no_page+0x1ea>
		printk("mem_map disagrees with %p at %p\n",page,address);
    a4cf:	83 ec 04             	sub    $0x4,%esp
    a4d2:	55                   	push   %ebp
    a4d3:	56                   	push   %esi
    a4d4:	68 3c 8c 01 00       	push   $0x18c3c
    a4d9:	e8 75 de ff ff       	call   8353 <printk>
    a4de:	83 c4 10             	add    $0x10,%esp
	page_table = (unsigned long *) ((address>>20) & 0xffc);
    a4e1:	89 eb                	mov    %ebp,%ebx
    a4e3:	c1 eb 14             	shr    $0x14,%ebx
    a4e6:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
	if ((*page_table)&1)
    a4ec:	8b 03                	mov    (%ebx),%eax
    a4ee:	a8 01                	test   $0x1,%al
    a4f0:	74 0a                	je     a4fc <do_no_page+0x205>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    a4f2:	89 c3                	mov    %eax,%ebx
    a4f4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
    a4fa:	eb 46                	jmp    a542 <do_no_page+0x24b>
__asm__("std ; repne ; scasb\n\t"
    a4fc:	b8 00 00 00 00       	mov    $0x0,%eax
    a501:	b9 00 0f 00 00       	mov    $0xf00,%ecx
    a506:	bf 5f 04 02 00       	mov    $0x2045f,%edi
    a50b:	fd                   	std    
    a50c:	f2 ae                	repnz scas %es:(%edi),%al
    a50e:	75 1e                	jne    a52e <do_no_page+0x237>
    a510:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    a514:	c1 e1 0c             	shl    $0xc,%ecx
    a517:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    a51d:	89 ca                	mov    %ecx,%edx
    a51f:	b9 00 04 00 00       	mov    $0x400,%ecx
    a524:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    a52a:	f3 ab                	rep stos %eax,%es:(%edi)
    a52c:	89 d0                	mov    %edx,%eax
    a52e:	89 c2                	mov    %eax,%edx
}
    a530:	b8 00 00 00 00       	mov    $0x0,%eax
{
    a535:	85 d2                	test   %edx,%edx
    a537:	74 1d                	je     a556 <do_no_page+0x25f>
		*page_table = tmp|7;
    a539:	89 d0                	mov    %edx,%eax
    a53b:	83 c8 07             	or     $0x7,%eax
    a53e:	89 03                	mov    %eax,(%ebx)
		page_table = (unsigned long *) tmp;
    a540:	89 d3                	mov    %edx,%ebx
	page_table[(address>>12) & 0x3ff] = page | 7;
    a542:	89 e8                	mov    %ebp,%eax
    a544:	c1 e8 0c             	shr    $0xc,%eax
    a547:	25 ff 03 00 00       	and    $0x3ff,%eax
    a54c:	89 f2                	mov    %esi,%edx
    a54e:	83 ca 07             	or     $0x7,%edx
    a551:	89 14 83             	mov    %edx,(%ebx,%eax,4)
    a554:	89 f0                	mov    %esi,%eax
{
    a556:	85 c0                	test   %eax,%eax
    a558:	75 6f                	jne    a5c9 <do_no_page+0x2d2>
{
    a55a:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
	if (addr < LOW_MEM) return;
    a55e:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
    a564:	76 47                	jbe    a5ad <do_no_page+0x2b6>
	if (addr >= HIGH_MEMORY)
    a566:	39 1d 40 f5 01 00    	cmp    %ebx,0x1f540
    a56c:	77 10                	ja     a57e <do_no_page+0x287>
		panic("trying to free nonexistent page");
    a56e:	83 ec 0c             	sub    $0xc,%esp
    a571:	68 74 8b 01 00       	push   $0x18b74
    a576:	e8 9e dd ff ff       	call   8319 <panic>
    a57b:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    a57e:	81 eb 00 00 10 00    	sub    $0x100000,%ebx
	addr >>= 12;
    a584:	c1 eb 0c             	shr    $0xc,%ebx
	if (mem_map[addr]--) return;
    a587:	fe 8b 60 f5 01 00    	decb   0x1f560(%ebx)
    a58d:	80 bb 60 f5 01 00 ff 	cmpb   $0xff,0x1f560(%ebx)
    a594:	75 17                	jne    a5ad <do_no_page+0x2b6>
	mem_map[addr]=0;
    a596:	c6 83 60 f5 01 00 00 	movb   $0x0,0x1f560(%ebx)
	panic("trying to free free page");
    a59d:	83 ec 0c             	sub    $0xc,%esp
    a5a0:	68 85 8c 01 00       	push   $0x18c85
    a5a5:	e8 6f dd ff ff       	call   8319 <panic>
    a5aa:	83 c4 10             	add    $0x10,%esp
	printk("out of memory\n\r");
    a5ad:	83 ec 0c             	sub    $0xc,%esp
    a5b0:	68 bb 8c 01 00       	push   $0x18cbb
    a5b5:	e8 99 dd ff ff       	call   8353 <printk>
	do_exit(SIGSEGV);
    a5ba:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    a5c1:	e8 15 eb ff ff       	call   90db <do_exit>
    a5c6:	83 c4 10             	add    $0x10,%esp
	}
	if (put_page(page,address))
		return;
	free_page(page);
	oom();
}
    a5c9:	83 c4 2c             	add    $0x2c,%esp
    a5cc:	5b                   	pop    %ebx
    a5cd:	5e                   	pop    %esi
    a5ce:	5f                   	pop    %edi
    a5cf:	5d                   	pop    %ebp
    a5d0:	c3                   	ret    

0000a5d1 <mem_init>:

void mem_init(long start_mem, long end_mem)
{
    a5d1:	8b 44 24 04          	mov    0x4(%esp),%eax
    a5d5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	int i;

	HIGH_MEMORY = end_mem;
    a5d9:	89 0d 40 f5 01 00    	mov    %ecx,0x1f540
	for (i=0 ; i<PAGING_PAGES ; i++)
    a5df:	ba 00 00 00 00       	mov    $0x0,%edx
		mem_map[i] = USED;
    a5e4:	c6 82 60 f5 01 00 64 	movb   $0x64,0x1f560(%edx)
	for (i=0 ; i<PAGING_PAGES ; i++)
    a5eb:	42                   	inc    %edx
    a5ec:	81 fa ff 0e 00 00    	cmp    $0xeff,%edx
    a5f2:	7e f0                	jle    a5e4 <mem_init+0x13>
	i = MAP_NR(start_mem);
    a5f4:	8d 90 00 00 f0 ff    	lea    -0x100000(%eax),%edx
    a5fa:	c1 fa 0c             	sar    $0xc,%edx
	end_mem -= start_mem;
    a5fd:	29 c1                	sub    %eax,%ecx
	end_mem >>= 12;
    a5ff:	c1 f9 0c             	sar    $0xc,%ecx
	while (end_mem-->0)
		mem_map[i++]=0;
    a602:	89 c8                	mov    %ecx,%eax
    a604:	49                   	dec    %ecx
    a605:	85 c0                	test   %eax,%eax
    a607:	7e 0f                	jle    a618 <mem_init+0x47>
    a609:	c6 82 60 f5 01 00 00 	movb   $0x0,0x1f560(%edx)
    a610:	42                   	inc    %edx
    a611:	89 c8                	mov    %ecx,%eax
    a613:	49                   	dec    %ecx
    a614:	85 c0                	test   %eax,%eax
    a616:	7f f1                	jg     a609 <mem_init+0x38>
    a618:	c3                   	ret    

0000a619 <calc_mem>:
}

void calc_mem(void)
{
    a619:	56                   	push   %esi
    a61a:	53                   	push   %ebx
    a61b:	83 ec 04             	sub    $0x4,%esp
	int i,j,k,free=0;
    a61e:	b8 00 00 00 00       	mov    $0x0,%eax
	long * pg_tbl;

	for(i=0 ; i<PAGING_PAGES ; i++)
    a623:	be 00 00 00 00       	mov    $0x0,%esi
		if (!mem_map[i]) free++;
    a628:	80 be 60 f5 01 00 01 	cmpb   $0x1,0x1f560(%esi)
    a62f:	83 d0 00             	adc    $0x0,%eax
	for(i=0 ; i<PAGING_PAGES ; i++)
    a632:	46                   	inc    %esi
    a633:	81 fe ff 0e 00 00    	cmp    $0xeff,%esi
    a639:	7e ed                	jle    a628 <calc_mem+0xf>
	printk("%d pages free (of %d)\n\r",free,PAGING_PAGES);
    a63b:	83 ec 04             	sub    $0x4,%esp
    a63e:	68 00 0f 00 00       	push   $0xf00
    a643:	50                   	push   %eax
    a644:	68 cb 8c 01 00       	push   $0x18ccb
    a649:	e8 05 dd ff ff       	call   8353 <printk>
	for(i=2 ; i<1024 ; i++) {
    a64e:	be 02 00 00 00       	mov    $0x2,%esi
    a653:	83 c4 10             	add    $0x10,%esp
		if (1&pg_dir[i]) {
    a656:	8b 04 b5 00 00 00 00 	mov    0x0(,%esi,4),%eax
    a65d:	a8 01                	test   $0x1,%al
    a65f:	74 39                	je     a69a <calc_mem+0x81>
			pg_tbl=(long *) (0xfffff000 & pg_dir[i]);
    a661:	89 c3                	mov    %eax,%ebx
    a663:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
			for(j=k=0 ; j<1024 ; j++)
    a669:	b9 00 00 00 00       	mov    $0x0,%ecx
    a66e:	ba 00 00 00 00       	mov    $0x0,%edx
				if (pg_tbl[j]&1)
    a673:	8b 04 93             	mov    (%ebx,%edx,4),%eax
    a676:	83 e0 01             	and    $0x1,%eax
					k++;
    a679:	83 f8 01             	cmp    $0x1,%eax
    a67c:	83 d9 ff             	sbb    $0xffffffff,%ecx
			for(j=k=0 ; j<1024 ; j++)
    a67f:	42                   	inc    %edx
    a680:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
    a686:	7e eb                	jle    a673 <calc_mem+0x5a>
			printk("Pg-dir[%d] uses %d pages\n",i,k);
    a688:	83 ec 04             	sub    $0x4,%esp
    a68b:	51                   	push   %ecx
    a68c:	56                   	push   %esi
    a68d:	68 e3 8c 01 00       	push   $0x18ce3
    a692:	e8 bc dc ff ff       	call   8353 <printk>
    a697:	83 c4 10             	add    $0x10,%esp
	for(i=2 ; i<1024 ; i++) {
    a69a:	46                   	inc    %esi
    a69b:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
    a6a1:	7e b3                	jle    a656 <calc_mem+0x3d>
		}
	}
}
    a6a3:	83 c4 04             	add    $0x4,%esp
    a6a6:	5b                   	pop    %ebx
    a6a7:	5e                   	pop    %esi
    a6a8:	c3                   	ret    

0000a6a9 <page_fault>:
    a6a9:	87 04 24             	xchg   %eax,(%esp)
    a6ac:	51                   	push   %ecx
    a6ad:	52                   	push   %edx
    a6ae:	1e                   	push   %ds
    a6af:	06                   	push   %es
    a6b0:	0f a0                	push   %fs
    a6b2:	ba 10 00 00 00       	mov    $0x10,%edx
    a6b7:	8e da                	mov    %edx,%ds
    a6b9:	8e c2                	mov    %edx,%es
    a6bb:	8e e2                	mov    %edx,%fs
    a6bd:	0f 20 d2             	mov    %cr2,%edx
    a6c0:	52                   	push   %edx
    a6c1:	50                   	push   %eax
    a6c2:	a9 01 00 00 00       	test   $0x1,%eax
    a6c7:	75 07                	jne    a6d0 <page_fault+0x27>
    a6c9:	e8 29 fc ff ff       	call   a2f7 <do_no_page>
    a6ce:	eb 05                	jmp    a6d5 <page_fault+0x2c>
    a6d0:	e8 62 f7 ff ff       	call   9e37 <do_wp_page>
    a6d5:	83 c4 08             	add    $0x8,%esp
    a6d8:	0f a1                	pop    %fs
    a6da:	07                   	pop    %es
    a6db:	1f                   	pop    %ds
    a6dc:	5a                   	pop    %edx
    a6dd:	59                   	pop    %ecx
    a6de:	58                   	pop    %eax
    a6df:	cf                   	iret   

0000a6e0 <sys_ustat>:
#include <linux/kernel.h>
#include <asm/segment.h>

int sys_ustat(int dev, struct ustat * ubuf)
{
	return -ENOSYS;
    a6e0:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
    a6e5:	c3                   	ret    

0000a6e6 <sys_utime>:

int sys_utime(char * filename, struct utimbuf * times)
{
    a6e6:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	long actime,modtime;

	if (!(inode=namei(filename)))
    a6e9:	83 ec 0c             	sub    $0xc,%esp
    a6ec:	ff 74 24 2c          	pushl  0x2c(%esp)
    a6f0:	e8 93 56 00 00       	call   fd88 <namei>
    a6f5:	83 c4 10             	add    $0x10,%esp
    a6f8:	89 44 24 18          	mov    %eax,0x18(%esp)
    a6fc:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    a701:	75 0d                	jne    a710 <sys_utime+0x2a>
		return -ENOENT;
    a703:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
    a70a:	ff 
    a70b:	e9 93 00 00 00       	jmp    a7a3 <sys_utime+0xbd>
	if (times) {
    a710:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    a715:	74 2c                	je     a743 <sys_utime+0x5d>
		actime = get_fs_long((unsigned long *) &times->actime);
    a717:	83 ec 0c             	sub    $0xc,%esp
    a71a:	ff 74 24 30          	pushl  0x30(%esp)
    a71e:	e8 88 00 00 00       	call   a7ab <get_fs_long>
    a723:	83 c4 10             	add    $0x10,%esp
    a726:	89 44 24 14          	mov    %eax,0x14(%esp)
		modtime = get_fs_long((unsigned long *) &times->modtime);
    a72a:	83 ec 0c             	sub    $0xc,%esp
    a72d:	8b 44 24 30          	mov    0x30(%esp),%eax
    a731:	83 c0 04             	add    $0x4,%eax
    a734:	50                   	push   %eax
    a735:	e8 71 00 00 00       	call   a7ab <get_fs_long>
    a73a:	83 c4 10             	add    $0x10,%esp
    a73d:	89 44 24 10          	mov    %eax,0x10(%esp)
    a741:	eb 2b                	jmp    a76e <sys_utime+0x88>
	} else
		actime = modtime = CURRENT_TIME;
    a743:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    a749:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    a74e:	f7 e9                	imul   %ecx
    a750:	c1 fa 05             	sar    $0x5,%edx
    a753:	89 c8                	mov    %ecx,%eax
    a755:	c1 f8 1f             	sar    $0x1f,%eax
    a758:	29 c2                	sub    %eax,%edx
    a75a:	89 d0                	mov    %edx,%eax
    a75c:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    a762:	89 44 24 10          	mov    %eax,0x10(%esp)
    a766:	8b 44 24 10          	mov    0x10(%esp),%eax
    a76a:	89 44 24 14          	mov    %eax,0x14(%esp)
	inode->i_atime = actime;
    a76e:	8b 54 24 18          	mov    0x18(%esp),%edx
    a772:	8b 44 24 14          	mov    0x14(%esp),%eax
    a776:	89 42 24             	mov    %eax,0x24(%edx)
	inode->i_mtime = modtime;
    a779:	8b 54 24 18          	mov    0x18(%esp),%edx
    a77d:	8b 44 24 10          	mov    0x10(%esp),%eax
    a781:	89 42 08             	mov    %eax,0x8(%edx)
	inode->i_dirt = 1;
    a784:	8b 44 24 18          	mov    0x18(%esp),%eax
    a788:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(inode);
    a78c:	83 ec 0c             	sub    $0xc,%esp
    a78f:	ff 74 24 24          	pushl  0x24(%esp)
    a793:	e8 b5 10 00 00       	call   b84d <iput>
    a798:	83 c4 10             	add    $0x10,%esp
	return 0;
    a79b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a7a2:	00 
}
    a7a3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a7a7:	83 c4 1c             	add    $0x1c,%esp
    a7aa:	c3                   	ret    

0000a7ab <get_fs_long>:
	__asm__ ("movw %%fs:%1,%0":"=r" (_v):"m" (*addr));
	return _v;
}

static inline unsigned long get_fs_long(const unsigned long *addr)
{
    a7ab:	83 ec 04             	sub    $0x4,%esp
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
    a7ae:	8b 44 24 08          	mov    0x8(%esp),%eax
    a7b2:	64 8b 00             	mov    %fs:(%eax),%eax
    a7b5:	89 04 24             	mov    %eax,(%esp)
    a7b8:	8b 04 24             	mov    (%esp),%eax
	return _v;
}
    a7bb:	83 c4 04             	add    $0x4,%esp
    a7be:	c3                   	ret    

0000a7bf <sys_access>:
/*
 * XXX should we use the real or effective uid?  BSD uses the real uid,
 * so as to make this call useful to setuid programs.
 */
int sys_access(const char * filename,int mode)
{
    a7bf:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	int res, i_mode;

	mode &= 0007;
    a7c2:	8d 44 24 24          	lea    0x24(%esp),%eax
    a7c6:	83 20 07             	andl   $0x7,(%eax)
	if (!(inode=namei(filename)))
    a7c9:	83 ec 0c             	sub    $0xc,%esp
    a7cc:	ff 74 24 2c          	pushl  0x2c(%esp)
    a7d0:	e8 b3 55 00 00       	call   fd88 <namei>
    a7d5:	83 c4 10             	add    $0x10,%esp
    a7d8:	89 44 24 18          	mov    %eax,0x18(%esp)
    a7dc:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    a7e1:	75 0d                	jne    a7f0 <sys_access+0x31>
		return -EACCES;
    a7e3:	c7 44 24 0c f3 ff ff 	movl   $0xfffffff3,0xc(%esp)
    a7ea:	ff 
    a7eb:	e9 b8 00 00 00       	jmp    a8a8 <sys_access+0xe9>
	i_mode = res = inode->i_mode & 0777;
    a7f0:	8b 44 24 18          	mov    0x18(%esp),%eax
    a7f4:	0f b7 00             	movzwl (%eax),%eax
    a7f7:	25 ff 01 00 00       	and    $0x1ff,%eax
    a7fc:	89 44 24 14          	mov    %eax,0x14(%esp)
    a800:	8b 44 24 14          	mov    0x14(%esp),%eax
    a804:	89 44 24 10          	mov    %eax,0x10(%esp)
	iput(inode);
    a808:	83 ec 0c             	sub    $0xc,%esp
    a80b:	ff 74 24 24          	pushl  0x24(%esp)
    a80f:	e8 39 10 00 00       	call   b84d <iput>
    a814:	83 c4 10             	add    $0x10,%esp
	if (current->uid == inode->i_uid)
    a817:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a81c:	8b 54 24 18          	mov    0x18(%esp),%edx
    a820:	66 8b 80 40 02 00 00 	mov    0x240(%eax),%ax
    a827:	66 3b 42 02          	cmp    0x2(%edx),%ax
    a82b:	75 09                	jne    a836 <sys_access+0x77>
		res >>= 6;
    a82d:	8d 44 24 14          	lea    0x14(%esp),%eax
    a831:	c1 38 06             	sarl   $0x6,(%eax)
    a834:	eb 1e                	jmp    a854 <sys_access+0x95>
	else if (current->gid == inode->i_gid)
    a836:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a83b:	8b 54 24 18          	mov    0x18(%esp),%edx
    a83f:	66 0f b6 52 0c       	movzbw 0xc(%edx),%dx
    a844:	66 39 90 46 02 00 00 	cmp    %dx,0x246(%eax)
    a84b:	75 07                	jne    a854 <sys_access+0x95>
		res >>= 6;
    a84d:	8d 44 24 14          	lea    0x14(%esp),%eax
    a851:	c1 38 06             	sarl   $0x6,(%eax)
	if ((res & 0007 & mode) == mode)
    a854:	8b 44 24 24          	mov    0x24(%esp),%eax
    a858:	23 44 24 14          	and    0x14(%esp),%eax
    a85c:	83 e0 07             	and    $0x7,%eax
    a85f:	3b 44 24 24          	cmp    0x24(%esp),%eax
    a863:	75 0a                	jne    a86f <sys_access+0xb0>
		return 0;
    a865:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a86c:	00 
    a86d:	eb 39                	jmp    a8a8 <sys_access+0xe9>
	 * XXX we are doing this test last because we really should be
	 * swapping the effective with the real user id (temporarily),
	 * and then calling suser() routine.  If we do call the
	 * suser() routine, it needs to be called last. 
	 */
	if ((!current->uid) &&
    a86f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a874:	66 83 b8 40 02 00 00 	cmpw   $0x0,0x240(%eax)
    a87b:	00 
    a87c:	75 22                	jne    a8a0 <sys_access+0xe1>
    a87e:	8b 44 24 24          	mov    0x24(%esp),%eax
    a882:	83 e0 01             	and    $0x1,%eax
    a885:	85 c0                	test   %eax,%eax
    a887:	74 0d                	je     a896 <sys_access+0xd7>
    a889:	8b 44 24 10          	mov    0x10(%esp),%eax
    a88d:	83 e0 49             	and    $0x49,%eax
    a890:	85 c0                	test   %eax,%eax
    a892:	75 02                	jne    a896 <sys_access+0xd7>
    a894:	eb 0a                	jmp    a8a0 <sys_access+0xe1>
	    (!(mode & 1) || (i_mode & 0111)))
		return 0;
    a896:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a89d:	00 
    a89e:	eb 08                	jmp    a8a8 <sys_access+0xe9>
	return -EACCES;
    a8a0:	c7 44 24 0c f3 ff ff 	movl   $0xfffffff3,0xc(%esp)
    a8a7:	ff 
}
    a8a8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a8ac:	83 c4 1c             	add    $0x1c,%esp
    a8af:	c3                   	ret    

0000a8b0 <sys_chdir>:

int sys_chdir(const char * filename)
{
    a8b0:	83 ec 0c             	sub    $0xc,%esp
	struct m_inode * inode;

	if (!(inode = namei(filename)))
    a8b3:	83 ec 0c             	sub    $0xc,%esp
    a8b6:	ff 74 24 1c          	pushl  0x1c(%esp)
    a8ba:	e8 c9 54 00 00       	call   fd88 <namei>
    a8bf:	83 c4 10             	add    $0x10,%esp
    a8c2:	89 44 24 08          	mov    %eax,0x8(%esp)
    a8c6:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    a8cb:	75 0a                	jne    a8d7 <sys_chdir+0x27>
		return -ENOENT;
    a8cd:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    a8d4:	ff 
    a8d5:	eb 5a                	jmp    a931 <sys_chdir+0x81>
	if (!S_ISDIR(inode->i_mode)) {
    a8d7:	8b 44 24 08          	mov    0x8(%esp),%eax
    a8db:	0f b7 00             	movzwl (%eax),%eax
    a8de:	25 00 f0 00 00       	and    $0xf000,%eax
    a8e3:	3d 00 40 00 00       	cmp    $0x4000,%eax
    a8e8:	74 19                	je     a903 <sys_chdir+0x53>
		iput(inode);
    a8ea:	83 ec 0c             	sub    $0xc,%esp
    a8ed:	ff 74 24 14          	pushl  0x14(%esp)
    a8f1:	e8 57 0f 00 00       	call   b84d <iput>
    a8f6:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    a8f9:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
    a900:	ff 
    a901:	eb 2e                	jmp    a931 <sys_chdir+0x81>
	}
	iput(current->pwd);
    a903:	83 ec 0c             	sub    $0xc,%esp
    a906:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a90b:	ff b0 70 02 00 00    	pushl  0x270(%eax)
    a911:	e8 37 0f 00 00       	call   b84d <iput>
    a916:	83 c4 10             	add    $0x10,%esp
	current->pwd = inode;
    a919:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    a91f:	8b 44 24 08          	mov    0x8(%esp),%eax
    a923:	89 82 70 02 00 00    	mov    %eax,0x270(%edx)
	return (0);
    a929:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    a930:	00 
}
    a931:	8b 44 24 04          	mov    0x4(%esp),%eax
    a935:	83 c4 0c             	add    $0xc,%esp
    a938:	c3                   	ret    

0000a939 <sys_chroot>:

int sys_chroot(const char * filename)
{
    a939:	83 ec 0c             	sub    $0xc,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    a93c:	83 ec 0c             	sub    $0xc,%esp
    a93f:	ff 74 24 1c          	pushl  0x1c(%esp)
    a943:	e8 40 54 00 00       	call   fd88 <namei>
    a948:	83 c4 10             	add    $0x10,%esp
    a94b:	89 44 24 08          	mov    %eax,0x8(%esp)
    a94f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    a954:	75 0a                	jne    a960 <sys_chroot+0x27>
		return -ENOENT;
    a956:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    a95d:	ff 
    a95e:	eb 5a                	jmp    a9ba <sys_chroot+0x81>
	if (!S_ISDIR(inode->i_mode)) {
    a960:	8b 44 24 08          	mov    0x8(%esp),%eax
    a964:	0f b7 00             	movzwl (%eax),%eax
    a967:	25 00 f0 00 00       	and    $0xf000,%eax
    a96c:	3d 00 40 00 00       	cmp    $0x4000,%eax
    a971:	74 19                	je     a98c <sys_chroot+0x53>
		iput(inode);
    a973:	83 ec 0c             	sub    $0xc,%esp
    a976:	ff 74 24 14          	pushl  0x14(%esp)
    a97a:	e8 ce 0e 00 00       	call   b84d <iput>
    a97f:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    a982:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
    a989:	ff 
    a98a:	eb 2e                	jmp    a9ba <sys_chroot+0x81>
	}
	iput(current->root);
    a98c:	83 ec 0c             	sub    $0xc,%esp
    a98f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a994:	ff b0 74 02 00 00    	pushl  0x274(%eax)
    a99a:	e8 ae 0e 00 00       	call   b84d <iput>
    a99f:	83 c4 10             	add    $0x10,%esp
	current->root = inode;
    a9a2:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    a9a8:	8b 44 24 08          	mov    0x8(%esp),%eax
    a9ac:	89 82 74 02 00 00    	mov    %eax,0x274(%edx)
	return (0);
    a9b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    a9b9:	00 
}
    a9ba:	8b 44 24 04          	mov    0x4(%esp),%eax
    a9be:	83 c4 0c             	add    $0xc,%esp
    a9c1:	c3                   	ret    

0000a9c2 <sys_chmod>:

int sys_chmod(const char * filename,int mode)
{
    a9c2:	83 ec 0c             	sub    $0xc,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    a9c5:	83 ec 0c             	sub    $0xc,%esp
    a9c8:	ff 74 24 1c          	pushl  0x1c(%esp)
    a9cc:	e8 b7 53 00 00       	call   fd88 <namei>
    a9d1:	83 c4 10             	add    $0x10,%esp
    a9d4:	89 44 24 08          	mov    %eax,0x8(%esp)
    a9d8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    a9dd:	75 0a                	jne    a9e9 <sys_chmod+0x27>
		return -ENOENT;
    a9df:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    a9e6:	ff 
    a9e7:	eb 7e                	jmp    aa67 <sys_chmod+0xa5>
	if ((current->euid != inode->i_uid) && !suser()) {
    a9e9:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    a9ee:	8b 54 24 08          	mov    0x8(%esp),%edx
    a9f2:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
    a9f9:	66 3b 42 02          	cmp    0x2(%edx),%ax
    a9fd:	74 28                	je     aa27 <sys_chmod+0x65>
    a9ff:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    aa04:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
    aa0b:	00 
    aa0c:	74 19                	je     aa27 <sys_chmod+0x65>
		iput(inode);
    aa0e:	83 ec 0c             	sub    $0xc,%esp
    aa11:	ff 74 24 14          	pushl  0x14(%esp)
    aa15:	e8 33 0e 00 00       	call   b84d <iput>
    aa1a:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    aa1d:	c7 44 24 04 f3 ff ff 	movl   $0xfffffff3,0x4(%esp)
    aa24:	ff 
    aa25:	eb 40                	jmp    aa67 <sys_chmod+0xa5>
	}
	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
    aa27:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    aa2b:	8b 44 24 14          	mov    0x14(%esp),%eax
    aa2f:	89 c2                	mov    %eax,%edx
    aa31:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
    aa37:	8b 44 24 08          	mov    0x8(%esp),%eax
    aa3b:	66 8b 00             	mov    (%eax),%ax
    aa3e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    aa43:	09 d0                	or     %edx,%eax
    aa45:	66 89 01             	mov    %ax,(%ecx)
	inode->i_dirt = 1;
    aa48:	8b 44 24 08          	mov    0x8(%esp),%eax
    aa4c:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(inode);
    aa50:	83 ec 0c             	sub    $0xc,%esp
    aa53:	ff 74 24 14          	pushl  0x14(%esp)
    aa57:	e8 f1 0d 00 00       	call   b84d <iput>
    aa5c:	83 c4 10             	add    $0x10,%esp
	return 0;
    aa5f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    aa66:	00 
}
    aa67:	8b 44 24 04          	mov    0x4(%esp),%eax
    aa6b:	83 c4 0c             	add    $0xc,%esp
    aa6e:	c3                   	ret    

0000aa6f <sys_chown>:

int sys_chown(const char * filename,int uid,int gid)
{
    aa6f:	83 ec 0c             	sub    $0xc,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    aa72:	83 ec 0c             	sub    $0xc,%esp
    aa75:	ff 74 24 1c          	pushl  0x1c(%esp)
    aa79:	e8 0a 53 00 00       	call   fd88 <namei>
    aa7e:	83 c4 10             	add    $0x10,%esp
    aa81:	89 44 24 08          	mov    %eax,0x8(%esp)
    aa85:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    aa8a:	75 0a                	jne    aa96 <sys_chown+0x27>
		return -ENOENT;
    aa8c:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    aa93:	ff 
    aa94:	eb 5e                	jmp    aaf4 <sys_chown+0x85>
	if (!suser()) {
    aa96:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    aa9b:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
    aaa2:	00 
    aaa3:	74 19                	je     aabe <sys_chown+0x4f>
		iput(inode);
    aaa5:	83 ec 0c             	sub    $0xc,%esp
    aaa8:	ff 74 24 14          	pushl  0x14(%esp)
    aaac:	e8 9c 0d 00 00       	call   b84d <iput>
    aab1:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    aab4:	c7 44 24 04 f3 ff ff 	movl   $0xfffffff3,0x4(%esp)
    aabb:	ff 
    aabc:	eb 36                	jmp    aaf4 <sys_chown+0x85>
	}
	inode->i_uid=uid;
    aabe:	8b 54 24 08          	mov    0x8(%esp),%edx
    aac2:	8b 44 24 14          	mov    0x14(%esp),%eax
    aac6:	66 89 42 02          	mov    %ax,0x2(%edx)
	inode->i_gid=gid;
    aaca:	8b 54 24 08          	mov    0x8(%esp),%edx
    aace:	8b 44 24 18          	mov    0x18(%esp),%eax
    aad2:	88 42 0c             	mov    %al,0xc(%edx)
	inode->i_dirt=1;
    aad5:	8b 44 24 08          	mov    0x8(%esp),%eax
    aad9:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(inode);
    aadd:	83 ec 0c             	sub    $0xc,%esp
    aae0:	ff 74 24 14          	pushl  0x14(%esp)
    aae4:	e8 64 0d 00 00       	call   b84d <iput>
    aae9:	83 c4 10             	add    $0x10,%esp
	return 0;
    aaec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    aaf3:	00 
}
    aaf4:	8b 44 24 04          	mov    0x4(%esp),%eax
    aaf8:	83 c4 0c             	add    $0xc,%esp
    aafb:	c3                   	ret    

0000aafc <sys_open>:

int sys_open(const char * filename,int flag,int mode)
{
    aafc:	53                   	push   %ebx
    aafd:	83 ec 18             	sub    $0x18,%esp
	struct m_inode * inode;
	struct file * f;
	int i,fd;

	mode &= 0777 & ~current->umask;
    ab00:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ab05:	0f b7 80 6c 02 00 00 	movzwl 0x26c(%eax),%eax
    ab0c:	f7 d0                	not    %eax
    ab0e:	23 44 24 28          	and    0x28(%esp),%eax
    ab12:	25 ff 01 00 00       	and    $0x1ff,%eax
    ab17:	89 44 24 28          	mov    %eax,0x28(%esp)
	for(fd=0 ; fd<NR_OPEN ; fd++)
    ab1b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    ab22:	00 
    ab23:	83 7c 24 08 13       	cmpl   $0x13,0x8(%esp)
    ab28:	7f 1e                	jg     ab48 <sys_open+0x4c>
		if (!current->filp[fd])
    ab2a:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ab30:	8b 44 24 08          	mov    0x8(%esp),%eax
    ab34:	83 bc 82 80 02 00 00 	cmpl   $0x0,0x280(%edx,%eax,4)
    ab3b:	00 
    ab3c:	75 02                	jne    ab40 <sys_open+0x44>
			break;
    ab3e:	eb 08                	jmp    ab48 <sys_open+0x4c>
	for(fd=0 ; fd<NR_OPEN ; fd++)
    ab40:	8d 44 24 08          	lea    0x8(%esp),%eax
    ab44:	ff 00                	incl   (%eax)
    ab46:	eb db                	jmp    ab23 <sys_open+0x27>
	if (fd>=NR_OPEN)
    ab48:	83 7c 24 08 13       	cmpl   $0x13,0x8(%esp)
    ab4d:	7e 0d                	jle    ab5c <sys_open+0x60>
		return -EINVAL;
    ab4f:	c7 44 24 04 ea ff ff 	movl   $0xffffffea,0x4(%esp)
    ab56:	ff 
    ab57:	e9 33 02 00 00       	jmp    ad8f <sys_open+0x293>
	current->close_on_exec &= ~(1<<fd);
    ab5c:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    ab62:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ab68:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    ab6c:	b8 01 00 00 00       	mov    $0x1,%eax
    ab71:	d3 e0                	shl    %cl,%eax
    ab73:	f7 d0                	not    %eax
    ab75:	23 82 7c 02 00 00    	and    0x27c(%edx),%eax
    ab7b:	89 83 7c 02 00 00    	mov    %eax,0x27c(%ebx)
	f=0+file_table;
    ab81:	c7 44 24 10 e0 25 02 	movl   $0x225e0,0x10(%esp)
    ab88:	00 
	for (i=0 ; i<NR_FILE ; i++,f++)
    ab89:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    ab90:	00 
    ab91:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    ab96:	7f 1c                	jg     abb4 <sys_open+0xb8>
		if (!f->f_count) break;
    ab98:	8b 44 24 10          	mov    0x10(%esp),%eax
    ab9c:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
    aba1:	75 02                	jne    aba5 <sys_open+0xa9>
    aba3:	eb 0f                	jmp    abb4 <sys_open+0xb8>
	for (i=0 ; i<NR_FILE ; i++,f++)
    aba5:	8d 44 24 0c          	lea    0xc(%esp),%eax
    aba9:	ff 00                	incl   (%eax)
    abab:	8d 44 24 10          	lea    0x10(%esp),%eax
    abaf:	83 00 10             	addl   $0x10,(%eax)
    abb2:	eb dd                	jmp    ab91 <sys_open+0x95>
	if (i>=NR_FILE)
    abb4:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    abb9:	7e 0d                	jle    abc8 <sys_open+0xcc>
		return -EINVAL;
    abbb:	c7 44 24 04 ea ff ff 	movl   $0xffffffea,0x4(%esp)
    abc2:	ff 
    abc3:	e9 c7 01 00 00       	jmp    ad8f <sys_open+0x293>
	(current->filp[fd]=f)->f_count++;
    abc8:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    abce:	8b 54 24 08          	mov    0x8(%esp),%edx
    abd2:	8b 44 24 10          	mov    0x10(%esp),%eax
    abd6:	89 84 91 80 02 00 00 	mov    %eax,0x280(%ecx,%edx,4)
    abdd:	66 ff 40 04          	incw   0x4(%eax)
	if ((i=open_namei(filename,flag,mode,&inode))<0) {
    abe1:	8d 44 24 14          	lea    0x14(%esp),%eax
    abe5:	50                   	push   %eax
    abe6:	ff 74 24 2c          	pushl  0x2c(%esp)
    abea:	ff 74 24 2c          	pushl  0x2c(%esp)
    abee:	ff 74 24 2c          	pushl  0x2c(%esp)
    abf2:	e8 ad 52 00 00       	call   fea4 <open_namei>
    abf7:	83 c4 10             	add    $0x10,%esp
    abfa:	89 44 24 0c          	mov    %eax,0xc(%esp)
    abfe:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    ac03:	79 2c                	jns    ac31 <sys_open+0x135>
		current->filp[fd]=NULL;
    ac05:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ac0b:	8b 44 24 08          	mov    0x8(%esp),%eax
    ac0f:	c7 84 82 80 02 00 00 	movl   $0x0,0x280(%edx,%eax,4)
    ac16:	00 00 00 00 
		f->f_count=0;
    ac1a:	8b 44 24 10          	mov    0x10(%esp),%eax
    ac1e:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		return i;
    ac24:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ac28:	89 44 24 04          	mov    %eax,0x4(%esp)
    ac2c:	e9 5e 01 00 00       	jmp    ad8f <sys_open+0x293>
	}
/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode)) {
    ac31:	8b 44 24 14          	mov    0x14(%esp),%eax
    ac35:	0f b7 00             	movzwl (%eax),%eax
    ac38:	25 00 f0 00 00       	and    $0xf000,%eax
    ac3d:	3d 00 20 00 00       	cmp    $0x2000,%eax
    ac42:	0f 85 de 00 00 00    	jne    ad26 <sys_open+0x22a>
		if (MAJOR(inode->i_zone[0])==4) {
    ac48:	8b 44 24 14          	mov    0x14(%esp),%eax
    ac4c:	66 8b 40 0e          	mov    0xe(%eax),%ax
    ac50:	66 c1 e8 08          	shr    $0x8,%ax
    ac54:	66 83 f8 04          	cmp    $0x4,%ax
    ac58:	75 75                	jne    accf <sys_open+0x1d3>
			if (current->leader && current->tty<0) {
    ac5a:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ac5f:	83 b8 3c 02 00 00 00 	cmpl   $0x0,0x23c(%eax)
    ac66:	0f 84 ba 00 00 00    	je     ad26 <sys_open+0x22a>
    ac6c:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ac71:	83 b8 68 02 00 00 00 	cmpl   $0x0,0x268(%eax)
    ac78:	0f 89 a8 00 00 00    	jns    ad26 <sys_open+0x22a>
				current->tty = MINOR(inode->i_zone[0]);
    ac7e:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ac84:	8b 44 24 14          	mov    0x14(%esp),%eax
    ac88:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ac8c:	25 ff 00 00 00       	and    $0xff,%eax
    ac91:	89 82 68 02 00 00    	mov    %eax,0x268(%edx)
				tty_table[current->tty].pgrp = current->pgrp;
    ac97:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ac9c:	8b 88 68 02 00 00    	mov    0x268(%eax),%ecx
    aca2:	89 c8                	mov    %ecx,%eax
    aca4:	c1 e0 02             	shl    $0x2,%eax
    aca7:	01 c8                	add    %ecx,%eax
    aca9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    acb0:	01 d0                	add    %edx,%eax
    acb2:	c1 e0 02             	shl    $0x2,%eax
    acb5:	29 c8                	sub    %ecx,%eax
    acb7:	89 c2                	mov    %eax,%edx
    acb9:	c1 e2 05             	shl    $0x5,%edx
    acbc:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    acc1:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    acc7:	89 82 44 bf 01 00    	mov    %eax,0x1bf44(%edx)
    accd:	eb 57                	jmp    ad26 <sys_open+0x22a>
			}
		} else if (MAJOR(inode->i_zone[0])==5)
    accf:	8b 44 24 14          	mov    0x14(%esp),%eax
    acd3:	66 8b 40 0e          	mov    0xe(%eax),%ax
    acd7:	66 c1 e8 08          	shr    $0x8,%ax
    acdb:	66 83 f8 05          	cmp    $0x5,%ax
    acdf:	75 45                	jne    ad26 <sys_open+0x22a>
			if (current->tty<0) {
    ace1:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ace6:	83 b8 68 02 00 00 00 	cmpl   $0x0,0x268(%eax)
    aced:	79 37                	jns    ad26 <sys_open+0x22a>
				iput(inode);
    acef:	83 ec 0c             	sub    $0xc,%esp
    acf2:	ff 74 24 20          	pushl  0x20(%esp)
    acf6:	e8 52 0b 00 00       	call   b84d <iput>
    acfb:	83 c4 10             	add    $0x10,%esp
				current->filp[fd]=NULL;
    acfe:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ad03:	8b 54 24 08          	mov    0x8(%esp),%edx
    ad07:	c7 84 90 80 02 00 00 	movl   $0x0,0x280(%eax,%edx,4)
    ad0e:	00 00 00 00 
				f->f_count=0;
    ad12:	8b 44 24 10          	mov    0x10(%esp),%eax
    ad16:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
				return -EPERM;
    ad1c:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
    ad23:	ff 
    ad24:	eb 69                	jmp    ad8f <sys_open+0x293>
			}
	}
/* Likewise with block-devices: check for floppy_change */
	if (S_ISBLK(inode->i_mode))
    ad26:	8b 44 24 14          	mov    0x14(%esp),%eax
    ad2a:	0f b7 00             	movzwl (%eax),%eax
    ad2d:	25 00 f0 00 00       	and    $0xf000,%eax
    ad32:	3d 00 60 00 00       	cmp    $0x6000,%eax
    ad37:	75 14                	jne    ad4d <sys_open+0x251>
		check_disk_change(inode->i_zone[0]);
    ad39:	83 ec 0c             	sub    $0xc,%esp
    ad3c:	8b 44 24 20          	mov    0x20(%esp),%eax
    ad40:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    ad44:	50                   	push   %eax
    ad45:	e8 73 14 00 00       	call   c1bd <check_disk_change>
    ad4a:	83 c4 10             	add    $0x10,%esp
	f->f_mode = inode->i_mode;
    ad4d:	8b 54 24 10          	mov    0x10(%esp),%edx
    ad51:	8b 44 24 14          	mov    0x14(%esp),%eax
    ad55:	66 8b 00             	mov    (%eax),%ax
    ad58:	66 89 02             	mov    %ax,(%edx)
	f->f_flags = flag;
    ad5b:	8b 54 24 10          	mov    0x10(%esp),%edx
    ad5f:	8b 44 24 24          	mov    0x24(%esp),%eax
    ad63:	66 89 42 02          	mov    %ax,0x2(%edx)
	f->f_count = 1;
    ad67:	8b 44 24 10          	mov    0x10(%esp),%eax
    ad6b:	66 c7 40 04 01 00    	movw   $0x1,0x4(%eax)
	f->f_inode = inode;
    ad71:	8b 54 24 10          	mov    0x10(%esp),%edx
    ad75:	8b 44 24 14          	mov    0x14(%esp),%eax
    ad79:	89 42 08             	mov    %eax,0x8(%edx)
	f->f_pos = 0;
    ad7c:	8b 44 24 10          	mov    0x10(%esp),%eax
    ad80:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return (fd);
    ad87:	8b 44 24 08          	mov    0x8(%esp),%eax
    ad8b:	89 44 24 04          	mov    %eax,0x4(%esp)
}
    ad8f:	8b 44 24 04          	mov    0x4(%esp),%eax
    ad93:	83 c4 18             	add    $0x18,%esp
    ad96:	5b                   	pop    %ebx
    ad97:	c3                   	ret    

0000ad98 <sys_creat>:

int sys_creat(const char * pathname, int mode)
{
    ad98:	83 ec 0c             	sub    $0xc,%esp
	return sys_open(pathname, O_CREAT | O_TRUNC, mode);
    ad9b:	83 ec 04             	sub    $0x4,%esp
    ad9e:	ff 74 24 18          	pushl  0x18(%esp)
    ada2:	68 40 02 00 00       	push   $0x240
    ada7:	ff 74 24 1c          	pushl  0x1c(%esp)
    adab:	e8 4c fd ff ff       	call   aafc <sys_open>
    adb0:	83 c4 10             	add    $0x10,%esp
}
    adb3:	83 c4 0c             	add    $0xc,%esp
    adb6:	c3                   	ret    

0000adb7 <sys_close>:

int sys_close(unsigned int fd)
{	
    adb7:	53                   	push   %ebx
    adb8:	83 ec 08             	sub    $0x8,%esp
	struct file * filp;

	if (fd >= NR_OPEN)
    adbb:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
    adc0:	76 0c                	jbe    adce <sys_close+0x17>
		return -EINVAL;
    adc2:	c7 04 24 ea ff ff ff 	movl   $0xffffffea,(%esp)
    adc9:	e9 a7 00 00 00       	jmp    ae75 <sys_close+0xbe>
	current->close_on_exec &= ~(1<<fd);
    adce:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    add4:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    adda:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    adde:	b8 01 00 00 00       	mov    $0x1,%eax
    ade3:	d3 e0                	shl    %cl,%eax
    ade5:	f7 d0                	not    %eax
    ade7:	23 82 7c 02 00 00    	and    0x27c(%edx),%eax
    aded:	89 83 7c 02 00 00    	mov    %eax,0x27c(%ebx)
	if (!(filp = current->filp[fd]))
    adf3:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    adf9:	8b 44 24 10          	mov    0x10(%esp),%eax
    adfd:	8b 84 82 80 02 00 00 	mov    0x280(%edx,%eax,4),%eax
    ae04:	89 44 24 04          	mov    %eax,0x4(%esp)
    ae08:	85 c0                	test   %eax,%eax
    ae0a:	75 09                	jne    ae15 <sys_close+0x5e>
		return -EINVAL;
    ae0c:	c7 04 24 ea ff ff ff 	movl   $0xffffffea,(%esp)
    ae13:	eb 60                	jmp    ae75 <sys_close+0xbe>
	current->filp[fd] = NULL;
    ae15:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ae1a:	8b 54 24 10          	mov    0x10(%esp),%edx
    ae1e:	c7 84 90 80 02 00 00 	movl   $0x0,0x280(%eax,%edx,4)
    ae25:	00 00 00 00 
	if (filp->f_count == 0)
    ae29:	8b 44 24 04          	mov    0x4(%esp),%eax
    ae2d:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
    ae32:	75 10                	jne    ae44 <sys_close+0x8d>
		panic("Close: file count is 0");
    ae34:	83 ec 0c             	sub    $0xc,%esp
    ae37:	68 00 8d 01 00       	push   $0x18d00
    ae3c:	e8 d8 d4 ff ff       	call   8319 <panic>
    ae41:	83 c4 10             	add    $0x10,%esp
	if (--filp->f_count)
    ae44:	8b 44 24 04          	mov    0x4(%esp),%eax
    ae48:	66 ff 48 04          	decw   0x4(%eax)
    ae4c:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
    ae51:	74 09                	je     ae5c <sys_close+0xa5>
		return (0);
    ae53:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    ae5a:	eb 19                	jmp    ae75 <sys_close+0xbe>
	iput(filp->f_inode);
    ae5c:	83 ec 0c             	sub    $0xc,%esp
    ae5f:	8b 44 24 10          	mov    0x10(%esp),%eax
    ae63:	ff 70 08             	pushl  0x8(%eax)
    ae66:	e8 e2 09 00 00       	call   b84d <iput>
    ae6b:	83 c4 10             	add    $0x10,%esp
	return (0);
    ae6e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
}
    ae75:	8b 04 24             	mov    (%esp),%eax
    ae78:	83 c4 08             	add    $0x8,%esp
    ae7b:	5b                   	pop    %ebx
    ae7c:	c3                   	ret    

0000ae7d <sys_lseek>:
		char * buf, int count);
extern int file_write(struct m_inode * inode, struct file * filp,
		char * buf, int count);

int sys_lseek(unsigned int fd,off_t offset, int origin)
{
    ae7d:	83 ec 10             	sub    $0x10,%esp
	struct file * file;
	int tmp;

	if (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)
    ae80:	83 7c 24 14 13       	cmpl   $0x13,0x14(%esp)
    ae85:	77 4d                	ja     aed4 <sys_lseek+0x57>
    ae87:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ae8c:	8b 54 24 14          	mov    0x14(%esp),%edx
    ae90:	8b 84 90 80 02 00 00 	mov    0x280(%eax,%edx,4),%eax
    ae97:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ae9b:	85 c0                	test   %eax,%eax
    ae9d:	74 35                	je     aed4 <sys_lseek+0x57>
    ae9f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    aea3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    aea7:	74 2b                	je     aed4 <sys_lseek+0x57>
    aea9:	8b 44 24 0c          	mov    0xc(%esp),%eax
    aead:	8b 40 08             	mov    0x8(%eax),%eax
    aeb0:	66 8b 40 2c          	mov    0x2c(%eax),%ax
    aeb4:	66 c1 e8 08          	shr    $0x8,%ax
    aeb8:	66 85 c0             	test   %ax,%ax
    aebb:	74 17                	je     aed4 <sys_lseek+0x57>
    aebd:	8b 44 24 0c          	mov    0xc(%esp),%eax
    aec1:	8b 40 08             	mov    0x8(%eax),%eax
    aec4:	66 8b 40 2c          	mov    0x2c(%eax),%ax
    aec8:	66 c1 e8 08          	shr    $0x8,%ax
    aecc:	66 83 f8 03          	cmp    $0x3,%ax
    aed0:	77 02                	ja     aed4 <sys_lseek+0x57>
    aed2:	eb 0d                	jmp    aee1 <sys_lseek+0x64>
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
		return -EBADF;
    aed4:	c7 44 24 04 f7 ff ff 	movl   $0xfffffff7,0x4(%esp)
    aedb:	ff 
    aedc:	e9 d9 00 00 00       	jmp    afba <sys_lseek+0x13d>
	if (file->f_inode->i_pipe)
    aee1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    aee5:	8b 40 08             	mov    0x8(%eax),%eax
    aee8:	80 78 34 00          	cmpb   $0x0,0x34(%eax)
    aeec:	74 0d                	je     aefb <sys_lseek+0x7e>
		return -ESPIPE;
    aeee:	c7 44 24 04 e3 ff ff 	movl   $0xffffffe3,0x4(%esp)
    aef5:	ff 
    aef6:	e9 bf 00 00 00       	jmp    afba <sys_lseek+0x13d>
	switch (origin) {
    aefb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    aeff:	89 04 24             	mov    %eax,(%esp)
    af02:	83 3c 24 01          	cmpl   $0x1,(%esp)
    af06:	74 3d                	je     af45 <sys_lseek+0xc8>
    af08:	83 3c 24 01          	cmpl   $0x1,(%esp)
    af0c:	7f 0b                	jg     af19 <sys_lseek+0x9c>
    af0e:	83 3c 24 00          	cmpl   $0x0,(%esp)
    af12:	74 10                	je     af24 <sys_lseek+0xa7>
    af14:	e9 8c 00 00 00       	jmp    afa5 <sys_lseek+0x128>
    af19:	83 3c 24 02          	cmpl   $0x2,(%esp)
    af1d:	74 55                	je     af74 <sys_lseek+0xf7>
    af1f:	e9 81 00 00 00       	jmp    afa5 <sys_lseek+0x128>
		case 0:
			if (offset<0) return -EINVAL;
    af24:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    af29:	79 0d                	jns    af38 <sys_lseek+0xbb>
    af2b:	c7 44 24 04 ea ff ff 	movl   $0xffffffea,0x4(%esp)
    af32:	ff 
    af33:	e9 82 00 00 00       	jmp    afba <sys_lseek+0x13d>
			file->f_pos=offset;
    af38:	8b 54 24 0c          	mov    0xc(%esp),%edx
    af3c:	8b 44 24 18          	mov    0x18(%esp),%eax
    af40:	89 42 0c             	mov    %eax,0xc(%edx)
			break;
    af43:	eb 6a                	jmp    afaf <sys_lseek+0x132>
		case 1:
			if (file->f_pos+offset<0) return -EINVAL;
    af45:	8b 44 24 0c          	mov    0xc(%esp),%eax
    af49:	8b 54 24 18          	mov    0x18(%esp),%edx
    af4d:	8b 40 0c             	mov    0xc(%eax),%eax
    af50:	01 d0                	add    %edx,%eax
    af52:	85 c0                	test   %eax,%eax
    af54:	79 0a                	jns    af60 <sys_lseek+0xe3>
    af56:	c7 44 24 04 ea ff ff 	movl   $0xffffffea,0x4(%esp)
    af5d:	ff 
    af5e:	eb 5a                	jmp    afba <sys_lseek+0x13d>
			file->f_pos += offset;
    af60:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    af64:	8b 54 24 0c          	mov    0xc(%esp),%edx
    af68:	8b 44 24 18          	mov    0x18(%esp),%eax
    af6c:	03 42 0c             	add    0xc(%edx),%eax
    af6f:	89 41 0c             	mov    %eax,0xc(%ecx)
			break;
    af72:	eb 3b                	jmp    afaf <sys_lseek+0x132>
		case 2:
			if ((tmp=file->f_inode->i_size+offset) < 0)
    af74:	8b 44 24 0c          	mov    0xc(%esp),%eax
    af78:	8b 50 08             	mov    0x8(%eax),%edx
    af7b:	8b 44 24 18          	mov    0x18(%esp),%eax
    af7f:	03 42 04             	add    0x4(%edx),%eax
    af82:	89 44 24 08          	mov    %eax,0x8(%esp)
    af86:	8b 44 24 08          	mov    0x8(%esp),%eax
    af8a:	85 c0                	test   %eax,%eax
    af8c:	79 0a                	jns    af98 <sys_lseek+0x11b>
				return -EINVAL;
    af8e:	c7 44 24 04 ea ff ff 	movl   $0xffffffea,0x4(%esp)
    af95:	ff 
    af96:	eb 22                	jmp    afba <sys_lseek+0x13d>
			file->f_pos = tmp;
    af98:	8b 54 24 0c          	mov    0xc(%esp),%edx
    af9c:	8b 44 24 08          	mov    0x8(%esp),%eax
    afa0:	89 42 0c             	mov    %eax,0xc(%edx)
			break;
    afa3:	eb 0a                	jmp    afaf <sys_lseek+0x132>
		default:
			return -EINVAL;
    afa5:	c7 44 24 04 ea ff ff 	movl   $0xffffffea,0x4(%esp)
    afac:	ff 
    afad:	eb 0b                	jmp    afba <sys_lseek+0x13d>
	}
	return file->f_pos;
    afaf:	8b 44 24 0c          	mov    0xc(%esp),%eax
    afb3:	8b 40 0c             	mov    0xc(%eax),%eax
    afb6:	89 44 24 04          	mov    %eax,0x4(%esp)
}
    afba:	8b 44 24 04          	mov    0x4(%esp),%eax
    afbe:	83 c4 10             	add    $0x10,%esp
    afc1:	c3                   	ret    

0000afc2 <sys_read>:

int sys_read(unsigned int fd,char * buf,int count)
{
    afc2:	83 ec 1c             	sub    $0x1c,%esp
	struct file * file;
	struct m_inode * inode;

	if (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))
    afc5:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    afca:	77 1f                	ja     afeb <sys_read+0x29>
    afcc:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    afd1:	78 18                	js     afeb <sys_read+0x29>
    afd3:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    afd8:	8b 54 24 20          	mov    0x20(%esp),%edx
    afdc:	8b 84 90 80 02 00 00 	mov    0x280(%eax,%edx,4),%eax
    afe3:	89 44 24 18          	mov    %eax,0x18(%esp)
    afe7:	85 c0                	test   %eax,%eax
    afe9:	75 0d                	jne    aff8 <sys_read+0x36>
		return -EINVAL;
    afeb:	c7 44 24 10 ea ff ff 	movl   $0xffffffea,0x10(%esp)
    aff2:	ff 
    aff3:	e9 9c 01 00 00       	jmp    b194 <sys_read+0x1d2>
	if (!count)
    aff8:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    affd:	75 0d                	jne    b00c <sys_read+0x4a>
		return 0;
    afff:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    b006:	00 
    b007:	e9 88 01 00 00       	jmp    b194 <sys_read+0x1d2>
	verify_area(buf,count);
    b00c:	83 ec 08             	sub    $0x8,%esp
    b00f:	ff 74 24 30          	pushl  0x30(%esp)
    b013:	ff 74 24 30          	pushl  0x30(%esp)
    b017:	e8 50 ce ff ff       	call   7e6c <verify_area>
    b01c:	83 c4 10             	add    $0x10,%esp
	inode = file->f_inode;
    b01f:	8b 44 24 18          	mov    0x18(%esp),%eax
    b023:	8b 40 08             	mov    0x8(%eax),%eax
    b026:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (inode->i_pipe)
    b02a:	8b 44 24 14          	mov    0x14(%esp),%eax
    b02e:	80 78 34 00          	cmpb   $0x0,0x34(%eax)
    b032:	74 40                	je     b074 <sys_read+0xb2>
		return (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;
    b034:	8b 44 24 18          	mov    0x18(%esp),%eax
    b038:	0f b7 00             	movzwl (%eax),%eax
    b03b:	83 e0 01             	and    $0x1,%eax
    b03e:	85 c0                	test   %eax,%eax
    b040:	74 1d                	je     b05f <sys_read+0x9d>
    b042:	83 ec 04             	sub    $0x4,%esp
    b045:	ff 74 24 2c          	pushl  0x2c(%esp)
    b049:	ff 74 24 2c          	pushl  0x2c(%esp)
    b04d:	ff 74 24 20          	pushl  0x20(%esp)
    b051:	e8 02 40 00 00       	call   f058 <read_pipe>
    b056:	83 c4 10             	add    $0x10,%esp
    b059:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b05d:	eb 08                	jmp    b067 <sys_read+0xa5>
    b05f:	c7 44 24 0c fb ff ff 	movl   $0xfffffffb,0xc(%esp)
    b066:	ff 
    b067:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b06b:	89 44 24 10          	mov    %eax,0x10(%esp)
    b06f:	e9 20 01 00 00       	jmp    b194 <sys_read+0x1d2>
	if (S_ISCHR(inode->i_mode))
    b074:	8b 44 24 14          	mov    0x14(%esp),%eax
    b078:	0f b7 00             	movzwl (%eax),%eax
    b07b:	25 00 f0 00 00       	and    $0xf000,%eax
    b080:	3d 00 20 00 00       	cmp    $0x2000,%eax
    b085:	75 2f                	jne    b0b6 <sys_read+0xf4>
		return rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);
    b087:	83 ec 0c             	sub    $0xc,%esp
    b08a:	8b 44 24 24          	mov    0x24(%esp),%eax
    b08e:	83 c0 0c             	add    $0xc,%eax
    b091:	50                   	push   %eax
    b092:	ff 74 24 38          	pushl  0x38(%esp)
    b096:	ff 74 24 38          	pushl  0x38(%esp)
    b09a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b09e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b0a2:	50                   	push   %eax
    b0a3:	6a 00                	push   $0x0
    b0a5:	e8 a8 29 00 00       	call   da52 <rw_char>
    b0aa:	83 c4 20             	add    $0x20,%esp
    b0ad:	89 44 24 10          	mov    %eax,0x10(%esp)
    b0b1:	e9 de 00 00 00       	jmp    b194 <sys_read+0x1d2>
	if (S_ISBLK(inode->i_mode))
    b0b6:	8b 44 24 14          	mov    0x14(%esp),%eax
    b0ba:	0f b7 00             	movzwl (%eax),%eax
    b0bd:	25 00 f0 00 00       	and    $0xf000,%eax
    b0c2:	3d 00 60 00 00       	cmp    $0x6000,%eax
    b0c7:	75 2a                	jne    b0f3 <sys_read+0x131>
		return block_read(inode->i_zone[0],&file->f_pos,buf,count);
    b0c9:	ff 74 24 28          	pushl  0x28(%esp)
    b0cd:	ff 74 24 28          	pushl  0x28(%esp)
    b0d1:	8b 44 24 20          	mov    0x20(%esp),%eax
    b0d5:	83 c0 0c             	add    $0xc,%eax
    b0d8:	50                   	push   %eax
    b0d9:	8b 44 24 20          	mov    0x20(%esp),%eax
    b0dd:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b0e1:	50                   	push   %eax
    b0e2:	e8 e1 25 00 00       	call   d6c8 <block_read>
    b0e7:	83 c4 10             	add    $0x10,%esp
    b0ea:	89 44 24 10          	mov    %eax,0x10(%esp)
    b0ee:	e9 a1 00 00 00       	jmp    b194 <sys_read+0x1d2>
	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
    b0f3:	8b 44 24 14          	mov    0x14(%esp),%eax
    b0f7:	0f b7 00             	movzwl (%eax),%eax
    b0fa:	25 00 f0 00 00       	and    $0xf000,%eax
    b0ff:	3d 00 40 00 00       	cmp    $0x4000,%eax
    b104:	74 15                	je     b11b <sys_read+0x159>
    b106:	8b 44 24 14          	mov    0x14(%esp),%eax
    b10a:	0f b7 00             	movzwl (%eax),%eax
    b10d:	25 00 f0 00 00       	and    $0xf000,%eax
    b112:	3d 00 80 00 00       	cmp    $0x8000,%eax
    b117:	74 02                	je     b11b <sys_read+0x159>
    b119:	eb 59                	jmp    b174 <sys_read+0x1b2>
		if (count+file->f_pos > inode->i_size)
    b11b:	8b 54 24 18          	mov    0x18(%esp),%edx
    b11f:	8b 44 24 28          	mov    0x28(%esp),%eax
    b123:	8b 52 0c             	mov    0xc(%edx),%edx
    b126:	01 c2                	add    %eax,%edx
    b128:	8b 44 24 14          	mov    0x14(%esp),%eax
    b12c:	3b 50 04             	cmp    0x4(%eax),%edx
    b12f:	76 14                	jbe    b145 <sys_read+0x183>
			count = inode->i_size - file->f_pos;
    b131:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    b135:	8b 44 24 18          	mov    0x18(%esp),%eax
    b139:	8b 50 0c             	mov    0xc(%eax),%edx
    b13c:	8b 41 04             	mov    0x4(%ecx),%eax
    b13f:	29 d0                	sub    %edx,%eax
    b141:	89 44 24 28          	mov    %eax,0x28(%esp)
		if (count<=0)
    b145:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b14a:	7f 0a                	jg     b156 <sys_read+0x194>
			return 0;
    b14c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    b153:	00 
    b154:	eb 3e                	jmp    b194 <sys_read+0x1d2>
		return file_read(inode,file,buf,count);
    b156:	ff 74 24 28          	pushl  0x28(%esp)
    b15a:	ff 74 24 28          	pushl  0x28(%esp)
    b15e:	ff 74 24 20          	pushl  0x20(%esp)
    b162:	ff 74 24 20          	pushl  0x20(%esp)
    b166:	e8 4e 29 00 00       	call   dab9 <file_read>
    b16b:	83 c4 10             	add    $0x10,%esp
    b16e:	89 44 24 10          	mov    %eax,0x10(%esp)
    b172:	eb 20                	jmp    b194 <sys_read+0x1d2>
	}
	printk("(Read)inode->i_mode=%06o\n\r",inode->i_mode);
    b174:	83 ec 08             	sub    $0x8,%esp
    b177:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b17b:	0f b7 00             	movzwl (%eax),%eax
    b17e:	50                   	push   %eax
    b17f:	68 17 8d 01 00       	push   $0x18d17
    b184:	e8 ca d1 ff ff       	call   8353 <printk>
    b189:	83 c4 10             	add    $0x10,%esp
	return -EINVAL;
    b18c:	c7 44 24 10 ea ff ff 	movl   $0xffffffea,0x10(%esp)
    b193:	ff 
}
    b194:	8b 44 24 10          	mov    0x10(%esp),%eax
    b198:	83 c4 1c             	add    $0x1c,%esp
    b19b:	c3                   	ret    

0000b19c <sys_write>:

int sys_write(unsigned int fd,char * buf,int count)
{
    b19c:	83 ec 1c             	sub    $0x1c,%esp
	struct file * file;
	struct m_inode * inode;
	
	if (fd>=NR_OPEN || count <0 || !(file=current->filp[fd]))
    b19f:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
    b1a4:	77 1f                	ja     b1c5 <sys_write+0x29>
    b1a6:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b1ab:	78 18                	js     b1c5 <sys_write+0x29>
    b1ad:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    b1b2:	8b 54 24 20          	mov    0x20(%esp),%edx
    b1b6:	8b 84 90 80 02 00 00 	mov    0x280(%eax,%edx,4),%eax
    b1bd:	89 44 24 18          	mov    %eax,0x18(%esp)
    b1c1:	85 c0                	test   %eax,%eax
    b1c3:	75 0d                	jne    b1d2 <sys_write+0x36>
		return -EINVAL;
    b1c5:	c7 44 24 10 ea ff ff 	movl   $0xffffffea,0x10(%esp)
    b1cc:	ff 
    b1cd:	e9 36 01 00 00       	jmp    b308 <sys_write+0x16c>
	if (!count)
    b1d2:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b1d7:	75 0d                	jne    b1e6 <sys_write+0x4a>
		return 0;
    b1d9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    b1e0:	00 
    b1e1:	e9 22 01 00 00       	jmp    b308 <sys_write+0x16c>
	inode=file->f_inode;
    b1e6:	8b 44 24 18          	mov    0x18(%esp),%eax
    b1ea:	8b 40 08             	mov    0x8(%eax),%eax
    b1ed:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (inode->i_pipe)
    b1f1:	8b 44 24 14          	mov    0x14(%esp),%eax
    b1f5:	80 78 34 00          	cmpb   $0x0,0x34(%eax)
    b1f9:	74 40                	je     b23b <sys_write+0x9f>
		return (file->f_mode&2)?write_pipe(inode,buf,count):-EIO;
    b1fb:	8b 44 24 18          	mov    0x18(%esp),%eax
    b1ff:	0f b7 00             	movzwl (%eax),%eax
    b202:	83 e0 02             	and    $0x2,%eax
    b205:	85 c0                	test   %eax,%eax
    b207:	74 1d                	je     b226 <sys_write+0x8a>
    b209:	83 ec 04             	sub    $0x4,%esp
    b20c:	ff 74 24 2c          	pushl  0x2c(%esp)
    b210:	ff 74 24 2c          	pushl  0x2c(%esp)
    b214:	ff 74 24 20          	pushl  0x20(%esp)
    b218:	e8 b2 3f 00 00       	call   f1cf <write_pipe>
    b21d:	83 c4 10             	add    $0x10,%esp
    b220:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b224:	eb 08                	jmp    b22e <sys_write+0x92>
    b226:	c7 44 24 0c fb ff ff 	movl   $0xfffffffb,0xc(%esp)
    b22d:	ff 
    b22e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b232:	89 44 24 10          	mov    %eax,0x10(%esp)
    b236:	e9 cd 00 00 00       	jmp    b308 <sys_write+0x16c>
	if (S_ISCHR(inode->i_mode))
    b23b:	8b 44 24 14          	mov    0x14(%esp),%eax
    b23f:	0f b7 00             	movzwl (%eax),%eax
    b242:	25 00 f0 00 00       	and    $0xf000,%eax
    b247:	3d 00 20 00 00       	cmp    $0x2000,%eax
    b24c:	75 2f                	jne    b27d <sys_write+0xe1>
		return rw_char(WRITE,inode->i_zone[0],buf,count,&file->f_pos);
    b24e:	83 ec 0c             	sub    $0xc,%esp
    b251:	8b 44 24 24          	mov    0x24(%esp),%eax
    b255:	83 c0 0c             	add    $0xc,%eax
    b258:	50                   	push   %eax
    b259:	ff 74 24 38          	pushl  0x38(%esp)
    b25d:	ff 74 24 38          	pushl  0x38(%esp)
    b261:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b265:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b269:	50                   	push   %eax
    b26a:	6a 01                	push   $0x1
    b26c:	e8 e1 27 00 00       	call   da52 <rw_char>
    b271:	83 c4 20             	add    $0x20,%esp
    b274:	89 44 24 10          	mov    %eax,0x10(%esp)
    b278:	e9 8b 00 00 00       	jmp    b308 <sys_write+0x16c>
	if (S_ISBLK(inode->i_mode))
    b27d:	8b 44 24 14          	mov    0x14(%esp),%eax
    b281:	0f b7 00             	movzwl (%eax),%eax
    b284:	25 00 f0 00 00       	and    $0xf000,%eax
    b289:	3d 00 60 00 00       	cmp    $0x6000,%eax
    b28e:	75 27                	jne    b2b7 <sys_write+0x11b>
		return block_write(inode->i_zone[0],&file->f_pos,buf,count);
    b290:	ff 74 24 28          	pushl  0x28(%esp)
    b294:	ff 74 24 28          	pushl  0x28(%esp)
    b298:	8b 44 24 20          	mov    0x20(%esp),%eax
    b29c:	83 c0 0c             	add    $0xc,%eax
    b29f:	50                   	push   %eax
    b2a0:	8b 44 24 20          	mov    0x20(%esp),%eax
    b2a4:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b2a8:	50                   	push   %eax
    b2a9:	e8 a9 22 00 00       	call   d557 <block_write>
    b2ae:	83 c4 10             	add    $0x10,%esp
    b2b1:	89 44 24 10          	mov    %eax,0x10(%esp)
    b2b5:	eb 51                	jmp    b308 <sys_write+0x16c>
	if (S_ISREG(inode->i_mode))
    b2b7:	8b 44 24 14          	mov    0x14(%esp),%eax
    b2bb:	0f b7 00             	movzwl (%eax),%eax
    b2be:	25 00 f0 00 00       	and    $0xf000,%eax
    b2c3:	3d 00 80 00 00       	cmp    $0x8000,%eax
    b2c8:	75 1e                	jne    b2e8 <sys_write+0x14c>
		return file_write(inode,file,buf,count);
    b2ca:	ff 74 24 28          	pushl  0x28(%esp)
    b2ce:	ff 74 24 28          	pushl  0x28(%esp)
    b2d2:	ff 74 24 20          	pushl  0x20(%esp)
    b2d6:	ff 74 24 20          	pushl  0x20(%esp)
    b2da:	e8 f7 29 00 00       	call   dcd6 <file_write>
    b2df:	83 c4 10             	add    $0x10,%esp
    b2e2:	89 44 24 10          	mov    %eax,0x10(%esp)
    b2e6:	eb 20                	jmp    b308 <sys_write+0x16c>
	printk("(Write)inode->i_mode=%06o\n\r",inode->i_mode);
    b2e8:	83 ec 08             	sub    $0x8,%esp
    b2eb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b2ef:	0f b7 00             	movzwl (%eax),%eax
    b2f2:	50                   	push   %eax
    b2f3:	68 32 8d 01 00       	push   $0x18d32
    b2f8:	e8 56 d0 ff ff       	call   8353 <printk>
    b2fd:	83 c4 10             	add    $0x10,%esp
	return -EINVAL;
    b300:	c7 44 24 10 ea ff ff 	movl   $0xffffffea,0x10(%esp)
    b307:	ff 
}
    b308:	8b 44 24 10          	mov    0x10(%esp),%eax
    b30c:	83 c4 1c             	add    $0x1c,%esp
    b30f:	c3                   	ret    

0000b310 <invalidate_inodes>:
	inode->i_lock=0;
	wake_up(&inode->i_wait);
}

void invalidate_inodes(int dev)
{
    b310:	83 ec 0c             	sub    $0xc,%esp
	int i;
	struct m_inode * inode;

	inode = 0+inode_table;
    b313:	c7 44 24 04 60 04 02 	movl   $0x20460,0x4(%esp)
    b31a:	00 
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    b31b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b322:	00 
    b323:	83 7c 24 08 1f       	cmpl   $0x1f,0x8(%esp)
    b328:	7f 59                	jg     b383 <invalidate_inodes+0x73>
		wait_on_inode(inode);
    b32a:	83 ec 0c             	sub    $0xc,%esp
    b32d:	ff 74 24 10          	pushl  0x10(%esp)
    b331:	e8 51 00 00 00       	call   b387 <wait_on_inode>
    b336:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dev == dev) {
    b339:	8b 44 24 04          	mov    0x4(%esp),%eax
    b33d:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b341:	3b 44 24 10          	cmp    0x10(%esp),%eax
    b345:	75 2d                	jne    b374 <invalidate_inodes+0x64>
			if (inode->i_count)
    b347:	8b 44 24 04          	mov    0x4(%esp),%eax
    b34b:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    b350:	74 10                	je     b362 <invalidate_inodes+0x52>
				printk("inode in use on removed disk\n\r");
    b352:	83 ec 0c             	sub    $0xc,%esp
    b355:	68 50 8d 01 00       	push   $0x18d50
    b35a:	e8 f4 cf ff ff       	call   8353 <printk>
    b35f:	83 c4 10             	add    $0x10,%esp
			inode->i_dev = inode->i_dirt = 0;
    b362:	8b 54 24 04          	mov    0x4(%esp),%edx
    b366:	8b 44 24 04          	mov    0x4(%esp),%eax
    b36a:	c6 40 33 00          	movb   $0x0,0x33(%eax)
    b36e:	66 c7 42 2c 00 00    	movw   $0x0,0x2c(%edx)
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    b374:	8d 44 24 08          	lea    0x8(%esp),%eax
    b378:	ff 00                	incl   (%eax)
    b37a:	8d 44 24 04          	lea    0x4(%esp),%eax
    b37e:	83 00 38             	addl   $0x38,(%eax)
    b381:	eb a0                	jmp    b323 <invalidate_inodes+0x13>
		}
	}
}
    b383:	83 c4 0c             	add    $0xc,%esp
    b386:	c3                   	ret    

0000b387 <wait_on_inode>:
{
    b387:	83 ec 0c             	sub    $0xc,%esp
	cli();
    b38a:	fa                   	cli    
	while (inode->i_lock)
    b38b:	8b 44 24 10          	mov    0x10(%esp),%eax
    b38f:	80 78 32 00          	cmpb   $0x0,0x32(%eax)
    b393:	74 15                	je     b3aa <wait_on_inode+0x23>
		sleep_on(&inode->i_wait);
    b395:	83 ec 0c             	sub    $0xc,%esp
    b398:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b39c:	83 c0 20             	add    $0x20,%eax
    b39f:	50                   	push   %eax
    b3a0:	e8 e0 b8 ff ff       	call   6c85 <sleep_on>
    b3a5:	83 c4 10             	add    $0x10,%esp
    b3a8:	eb e1                	jmp    b38b <wait_on_inode+0x4>
	sti();
    b3aa:	fb                   	sti    
}
    b3ab:	83 c4 0c             	add    $0xc,%esp
    b3ae:	c3                   	ret    

0000b3af <sync_inodes>:

void sync_inodes(void)
{
    b3af:	83 ec 0c             	sub    $0xc,%esp
	int i;
	struct m_inode * inode;

	inode = 0+inode_table;
    b3b2:	c7 44 24 04 60 04 02 	movl   $0x20460,0x4(%esp)
    b3b9:	00 
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    b3ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b3c1:	00 
    b3c2:	83 7c 24 08 1f       	cmpl   $0x1f,0x8(%esp)
    b3c7:	7f 41                	jg     b40a <sync_inodes+0x5b>
		wait_on_inode(inode);
    b3c9:	83 ec 0c             	sub    $0xc,%esp
    b3cc:	ff 74 24 10          	pushl  0x10(%esp)
    b3d0:	e8 b2 ff ff ff       	call   b387 <wait_on_inode>
    b3d5:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dirt && !inode->i_pipe)
    b3d8:	8b 44 24 04          	mov    0x4(%esp),%eax
    b3dc:	80 78 33 00          	cmpb   $0x0,0x33(%eax)
    b3e0:	74 19                	je     b3fb <sync_inodes+0x4c>
    b3e2:	8b 44 24 04          	mov    0x4(%esp),%eax
    b3e6:	80 78 34 00          	cmpb   $0x0,0x34(%eax)
    b3ea:	75 0f                	jne    b3fb <sync_inodes+0x4c>
			write_inode(inode);
    b3ec:	83 ec 0c             	sub    $0xc,%esp
    b3ef:	ff 74 24 10          	pushl  0x10(%esp)
    b3f3:	e8 a8 0a 00 00       	call   bea0 <write_inode>
    b3f8:	83 c4 10             	add    $0x10,%esp
	for(i=0 ; i<NR_INODE ; i++,inode++) {
    b3fb:	8d 44 24 08          	lea    0x8(%esp),%eax
    b3ff:	ff 00                	incl   (%eax)
    b401:	8d 44 24 04          	lea    0x4(%esp),%eax
    b405:	83 00 38             	addl   $0x38,(%eax)
    b408:	eb b8                	jmp    b3c2 <sync_inodes+0x13>
	}
}
    b40a:	83 c4 0c             	add    $0xc,%esp
    b40d:	c3                   	ret    

0000b40e <_bmap>:

static int _bmap(struct m_inode * inode,int block,int create)
{
    b40e:	56                   	push   %esi
    b40f:	53                   	push   %ebx
    b410:	83 ec 14             	sub    $0x14,%esp
	struct buffer_head * bh;
	int i;

	if (block<0)
    b413:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    b418:	79 10                	jns    b42a <_bmap+0x1c>
		panic("_bmap: block<0");
    b41a:	83 ec 0c             	sub    $0xc,%esp
    b41d:	68 6f 8d 01 00       	push   $0x18d6f
    b422:	e8 f2 ce ff ff       	call   8319 <panic>
    b427:	83 c4 10             	add    $0x10,%esp
	if (block >= 7+512+512*512)
    b42a:	81 7c 24 24 06 02 04 	cmpl   $0x40206,0x24(%esp)
    b431:	00 
    b432:	7e 10                	jle    b444 <_bmap+0x36>
		panic("_bmap: block>big");
    b434:	83 ec 0c             	sub    $0xc,%esp
    b437:	68 7e 8d 01 00       	push   $0x18d7e
    b43c:	e8 d8 ce ff ff       	call   8319 <panic>
    b441:	83 c4 10             	add    $0x10,%esp
	if (block<7) {
    b444:	83 7c 24 24 06       	cmpl   $0x6,0x24(%esp)
    b449:	0f 8f 86 00 00 00    	jg     b4d5 <_bmap+0xc7>
		if (create && !inode->i_zone[block])
    b44f:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b454:	74 69                	je     b4bf <_bmap+0xb1>
    b456:	8b 54 24 20          	mov    0x20(%esp),%edx
    b45a:	8b 44 24 24          	mov    0x24(%esp),%eax
    b45e:	66 83 7c 42 0e 00    	cmpw   $0x0,0xe(%edx,%eax,2)
    b464:	75 59                	jne    b4bf <_bmap+0xb1>
			if ((inode->i_zone[block]=new_block(inode->i_dev))) {
    b466:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    b46a:	8b 74 24 24          	mov    0x24(%esp),%esi
    b46e:	83 ec 0c             	sub    $0xc,%esp
    b471:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b475:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b479:	50                   	push   %eax
    b47a:	e8 fb 5f 00 00       	call   1147a <new_block>
    b47f:	83 c4 10             	add    $0x10,%esp
    b482:	66 89 44 73 0e       	mov    %ax,0xe(%ebx,%esi,2)
    b487:	66 8b 44 73 0e       	mov    0xe(%ebx,%esi,2),%ax
    b48c:	66 85 c0             	test   %ax,%ax
    b48f:	74 2e                	je     b4bf <_bmap+0xb1>
				inode->i_ctime=CURRENT_TIME;
    b491:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    b495:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    b49b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    b4a0:	f7 e9                	imul   %ecx
    b4a2:	c1 fa 05             	sar    $0x5,%edx
    b4a5:	89 c8                	mov    %ecx,%eax
    b4a7:	c1 f8 1f             	sar    $0x1f,%eax
    b4aa:	29 c2                	sub    %eax,%edx
    b4ac:	89 d0                	mov    %edx,%eax
    b4ae:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    b4b4:	89 43 28             	mov    %eax,0x28(%ebx)
				inode->i_dirt=1;
    b4b7:	8b 44 24 20          	mov    0x20(%esp),%eax
    b4bb:	c6 40 33 01          	movb   $0x1,0x33(%eax)
			}
		return inode->i_zone[block];
    b4bf:	8b 44 24 20          	mov    0x20(%esp),%eax
    b4c3:	8b 54 24 24          	mov    0x24(%esp),%edx
    b4c7:	0f b7 44 50 0e       	movzwl 0xe(%eax,%edx,2),%eax
    b4cc:	89 44 24 08          	mov    %eax,0x8(%esp)
    b4d0:	e9 36 03 00 00       	jmp    b80b <_bmap+0x3fd>
	}
	block -= 7;
    b4d5:	8d 44 24 24          	lea    0x24(%esp),%eax
    b4d9:	83 28 07             	subl   $0x7,(%eax)
	if (block<512) {
    b4dc:	81 7c 24 24 ff 01 00 	cmpl   $0x1ff,0x24(%esp)
    b4e3:	00 
    b4e4:	0f 8f 2d 01 00 00    	jg     b617 <_bmap+0x209>
		if (create && !inode->i_zone[7])
    b4ea:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b4ef:	74 5e                	je     b54f <_bmap+0x141>
    b4f1:	8b 44 24 20          	mov    0x20(%esp),%eax
    b4f5:	66 83 78 1c 00       	cmpw   $0x0,0x1c(%eax)
    b4fa:	75 53                	jne    b54f <_bmap+0x141>
			if ((inode->i_zone[7]=new_block(inode->i_dev))) {
    b4fc:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    b500:	83 ec 0c             	sub    $0xc,%esp
    b503:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b507:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b50b:	50                   	push   %eax
    b50c:	e8 69 5f 00 00       	call   1147a <new_block>
    b511:	83 c4 10             	add    $0x10,%esp
    b514:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    b518:	66 8b 43 1c          	mov    0x1c(%ebx),%ax
    b51c:	66 85 c0             	test   %ax,%ax
    b51f:	74 2e                	je     b54f <_bmap+0x141>
				inode->i_dirt=1;
    b521:	8b 44 24 20          	mov    0x20(%esp),%eax
    b525:	c6 40 33 01          	movb   $0x1,0x33(%eax)
				inode->i_ctime=CURRENT_TIME;
    b529:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    b52d:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    b533:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    b538:	f7 e9                	imul   %ecx
    b53a:	c1 fa 05             	sar    $0x5,%edx
    b53d:	89 c8                	mov    %ecx,%eax
    b53f:	c1 f8 1f             	sar    $0x1f,%eax
    b542:	29 c2                	sub    %eax,%edx
    b544:	89 d0                	mov    %edx,%eax
    b546:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    b54c:	89 43 28             	mov    %eax,0x28(%ebx)
			}
		if (!inode->i_zone[7])
    b54f:	8b 44 24 20          	mov    0x20(%esp),%eax
    b553:	66 83 78 1c 00       	cmpw   $0x0,0x1c(%eax)
    b558:	75 0d                	jne    b567 <_bmap+0x159>
			return 0;
    b55a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b561:	00 
    b562:	e9 a4 02 00 00       	jmp    b80b <_bmap+0x3fd>
		if (!(bh = bread(inode->i_dev,inode->i_zone[7])))
    b567:	83 ec 08             	sub    $0x8,%esp
    b56a:	8b 44 24 28          	mov    0x28(%esp),%eax
    b56e:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
    b572:	50                   	push   %eax
    b573:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b577:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b57b:	50                   	push   %eax
    b57c:	e8 82 11 00 00       	call   c703 <bread>
    b581:	83 c4 10             	add    $0x10,%esp
    b584:	89 44 24 10          	mov    %eax,0x10(%esp)
    b588:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    b58d:	75 0d                	jne    b59c <_bmap+0x18e>
			return 0;
    b58f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b596:	00 
    b597:	e9 6f 02 00 00       	jmp    b80b <_bmap+0x3fd>
		i = ((unsigned short *) (bh->b_data))[block];
    b59c:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    b5a0:	8b 44 24 24          	mov    0x24(%esp),%eax
    b5a4:	8d 14 00             	lea    (%eax,%eax,1),%edx
    b5a7:	8b 01                	mov    (%ecx),%eax
    b5a9:	0f b7 04 02          	movzwl (%edx,%eax,1),%eax
    b5ad:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (create && !i)
    b5b1:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b5b6:	74 43                	je     b5fb <_bmap+0x1ed>
    b5b8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b5bd:	75 3c                	jne    b5fb <_bmap+0x1ed>
			if ((i=new_block(inode->i_dev))) {
    b5bf:	83 ec 0c             	sub    $0xc,%esp
    b5c2:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b5c6:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b5ca:	50                   	push   %eax
    b5cb:	e8 aa 5e 00 00       	call   1147a <new_block>
    b5d0:	83 c4 10             	add    $0x10,%esp
    b5d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b5d7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b5dc:	74 1d                	je     b5fb <_bmap+0x1ed>
				((unsigned short *) (bh->b_data))[block]=i;
    b5de:	8b 54 24 10          	mov    0x10(%esp),%edx
    b5e2:	8b 44 24 24          	mov    0x24(%esp),%eax
    b5e6:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
    b5e9:	8b 12                	mov    (%edx),%edx
    b5eb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b5ef:	66 89 04 11          	mov    %ax,(%ecx,%edx,1)
				bh->b_dirt=1;
    b5f3:	8b 44 24 10          	mov    0x10(%esp),%eax
    b5f7:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
			}
		brelse(bh);
    b5fb:	83 ec 0c             	sub    $0xc,%esp
    b5fe:	ff 74 24 1c          	pushl  0x1c(%esp)
    b602:	e8 b0 10 00 00       	call   c6b7 <brelse>
    b607:	83 c4 10             	add    $0x10,%esp
		return i;
    b60a:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b60e:	89 44 24 08          	mov    %eax,0x8(%esp)
    b612:	e9 f4 01 00 00       	jmp    b80b <_bmap+0x3fd>
	}
	block -= 512;
    b617:	8d 44 24 24          	lea    0x24(%esp),%eax
    b61b:	81 28 00 02 00 00    	subl   $0x200,(%eax)
	if (create && !inode->i_zone[8])
    b621:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b626:	74 5e                	je     b686 <_bmap+0x278>
    b628:	8b 44 24 20          	mov    0x20(%esp),%eax
    b62c:	66 83 78 1e 00       	cmpw   $0x0,0x1e(%eax)
    b631:	75 53                	jne    b686 <_bmap+0x278>
		if ((inode->i_zone[8]=new_block(inode->i_dev))) {
    b633:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    b637:	83 ec 0c             	sub    $0xc,%esp
    b63a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b63e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b642:	50                   	push   %eax
    b643:	e8 32 5e 00 00       	call   1147a <new_block>
    b648:	83 c4 10             	add    $0x10,%esp
    b64b:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    b64f:	66 8b 43 1e          	mov    0x1e(%ebx),%ax
    b653:	66 85 c0             	test   %ax,%ax
    b656:	74 2e                	je     b686 <_bmap+0x278>
			inode->i_dirt=1;
    b658:	8b 44 24 20          	mov    0x20(%esp),%eax
    b65c:	c6 40 33 01          	movb   $0x1,0x33(%eax)
			inode->i_ctime=CURRENT_TIME;
    b660:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    b664:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    b66a:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    b66f:	f7 e9                	imul   %ecx
    b671:	c1 fa 05             	sar    $0x5,%edx
    b674:	89 c8                	mov    %ecx,%eax
    b676:	c1 f8 1f             	sar    $0x1f,%eax
    b679:	29 c2                	sub    %eax,%edx
    b67b:	89 d0                	mov    %edx,%eax
    b67d:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    b683:	89 43 28             	mov    %eax,0x28(%ebx)
		}
	if (!inode->i_zone[8])
    b686:	8b 44 24 20          	mov    0x20(%esp),%eax
    b68a:	66 83 78 1e 00       	cmpw   $0x0,0x1e(%eax)
    b68f:	75 0d                	jne    b69e <_bmap+0x290>
		return 0;
    b691:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b698:	00 
    b699:	e9 6d 01 00 00       	jmp    b80b <_bmap+0x3fd>
	if (!(bh=bread(inode->i_dev,inode->i_zone[8])))
    b69e:	83 ec 08             	sub    $0x8,%esp
    b6a1:	8b 44 24 28          	mov    0x28(%esp),%eax
    b6a5:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    b6a9:	50                   	push   %eax
    b6aa:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b6ae:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b6b2:	50                   	push   %eax
    b6b3:	e8 4b 10 00 00       	call   c703 <bread>
    b6b8:	83 c4 10             	add    $0x10,%esp
    b6bb:	89 44 24 10          	mov    %eax,0x10(%esp)
    b6bf:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    b6c4:	75 0d                	jne    b6d3 <_bmap+0x2c5>
		return 0;
    b6c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b6cd:	00 
    b6ce:	e9 38 01 00 00       	jmp    b80b <_bmap+0x3fd>
	i = ((unsigned short *)bh->b_data)[block>>9];
    b6d3:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    b6d7:	8b 44 24 24          	mov    0x24(%esp),%eax
    b6db:	c1 f8 09             	sar    $0x9,%eax
    b6de:	8d 14 00             	lea    (%eax,%eax,1),%edx
    b6e1:	8b 01                	mov    (%ecx),%eax
    b6e3:	0f b7 04 02          	movzwl (%edx,%eax,1),%eax
    b6e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (create && !i)
    b6eb:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b6f0:	74 46                	je     b738 <_bmap+0x32a>
    b6f2:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b6f7:	75 3f                	jne    b738 <_bmap+0x32a>
		if ((i=new_block(inode->i_dev))) {
    b6f9:	83 ec 0c             	sub    $0xc,%esp
    b6fc:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b700:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b704:	50                   	push   %eax
    b705:	e8 70 5d 00 00       	call   1147a <new_block>
    b70a:	83 c4 10             	add    $0x10,%esp
    b70d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b711:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b716:	74 20                	je     b738 <_bmap+0x32a>
			((unsigned short *) (bh->b_data))[block>>9]=i;
    b718:	8b 54 24 10          	mov    0x10(%esp),%edx
    b71c:	8b 44 24 24          	mov    0x24(%esp),%eax
    b720:	c1 f8 09             	sar    $0x9,%eax
    b723:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
    b726:	8b 12                	mov    (%edx),%edx
    b728:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b72c:	66 89 04 11          	mov    %ax,(%ecx,%edx,1)
			bh->b_dirt=1;
    b730:	8b 44 24 10          	mov    0x10(%esp),%eax
    b734:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		}
	brelse(bh);
    b738:	83 ec 0c             	sub    $0xc,%esp
    b73b:	ff 74 24 1c          	pushl  0x1c(%esp)
    b73f:	e8 73 0f 00 00       	call   c6b7 <brelse>
    b744:	83 c4 10             	add    $0x10,%esp
	if (!i)
    b747:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b74c:	75 0d                	jne    b75b <_bmap+0x34d>
		return 0;
    b74e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b755:	00 
    b756:	e9 b0 00 00 00       	jmp    b80b <_bmap+0x3fd>
	if (!(bh=bread(inode->i_dev,i)))
    b75b:	83 ec 08             	sub    $0x8,%esp
    b75e:	ff 74 24 14          	pushl  0x14(%esp)
    b762:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b766:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b76a:	50                   	push   %eax
    b76b:	e8 93 0f 00 00       	call   c703 <bread>
    b770:	83 c4 10             	add    $0x10,%esp
    b773:	89 44 24 10          	mov    %eax,0x10(%esp)
    b777:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    b77c:	75 0d                	jne    b78b <_bmap+0x37d>
		return 0;
    b77e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b785:	00 
    b786:	e9 80 00 00 00       	jmp    b80b <_bmap+0x3fd>
	i = ((unsigned short *)bh->b_data)[block&511];
    b78b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    b78f:	8b 44 24 24          	mov    0x24(%esp),%eax
    b793:	25 ff 01 00 00       	and    $0x1ff,%eax
    b798:	8d 14 00             	lea    (%eax,%eax,1),%edx
    b79b:	8b 01                	mov    (%ecx),%eax
    b79d:	0f b7 04 02          	movzwl (%edx,%eax,1),%eax
    b7a1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (create && !i)
    b7a5:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    b7aa:	74 48                	je     b7f4 <_bmap+0x3e6>
    b7ac:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b7b1:	75 41                	jne    b7f4 <_bmap+0x3e6>
		if ((i=new_block(inode->i_dev))) {
    b7b3:	83 ec 0c             	sub    $0xc,%esp
    b7b6:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    b7ba:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    b7be:	50                   	push   %eax
    b7bf:	e8 b6 5c 00 00       	call   1147a <new_block>
    b7c4:	83 c4 10             	add    $0x10,%esp
    b7c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
    b7cb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    b7d0:	74 22                	je     b7f4 <_bmap+0x3e6>
			((unsigned short *) (bh->b_data))[block&511]=i;
    b7d2:	8b 54 24 10          	mov    0x10(%esp),%edx
    b7d6:	8b 44 24 24          	mov    0x24(%esp),%eax
    b7da:	25 ff 01 00 00       	and    $0x1ff,%eax
    b7df:	8d 0c 00             	lea    (%eax,%eax,1),%ecx
    b7e2:	8b 12                	mov    (%edx),%edx
    b7e4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b7e8:	66 89 04 11          	mov    %ax,(%ecx,%edx,1)
			bh->b_dirt=1;
    b7ec:	8b 44 24 10          	mov    0x10(%esp),%eax
    b7f0:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		}
	brelse(bh);
    b7f4:	83 ec 0c             	sub    $0xc,%esp
    b7f7:	ff 74 24 1c          	pushl  0x1c(%esp)
    b7fb:	e8 b7 0e 00 00       	call   c6b7 <brelse>
    b800:	83 c4 10             	add    $0x10,%esp
	return i;
    b803:	8b 44 24 0c          	mov    0xc(%esp),%eax
    b807:	89 44 24 08          	mov    %eax,0x8(%esp)
}
    b80b:	8b 44 24 08          	mov    0x8(%esp),%eax
    b80f:	83 c4 14             	add    $0x14,%esp
    b812:	5b                   	pop    %ebx
    b813:	5e                   	pop    %esi
    b814:	c3                   	ret    

0000b815 <bmap>:

int bmap(struct m_inode * inode,int block)
{
    b815:	83 ec 0c             	sub    $0xc,%esp
	return _bmap(inode,block,0);
    b818:	83 ec 04             	sub    $0x4,%esp
    b81b:	6a 00                	push   $0x0
    b81d:	ff 74 24 1c          	pushl  0x1c(%esp)
    b821:	ff 74 24 1c          	pushl  0x1c(%esp)
    b825:	e8 e4 fb ff ff       	call   b40e <_bmap>
    b82a:	83 c4 10             	add    $0x10,%esp
}
    b82d:	83 c4 0c             	add    $0xc,%esp
    b830:	c3                   	ret    

0000b831 <create_block>:

int create_block(struct m_inode * inode, int block)
{
    b831:	83 ec 0c             	sub    $0xc,%esp
	return _bmap(inode,block,1);
    b834:	83 ec 04             	sub    $0x4,%esp
    b837:	6a 01                	push   $0x1
    b839:	ff 74 24 1c          	pushl  0x1c(%esp)
    b83d:	ff 74 24 1c          	pushl  0x1c(%esp)
    b841:	e8 c8 fb ff ff       	call   b40e <_bmap>
    b846:	83 c4 10             	add    $0x10,%esp
}
    b849:	83 c4 0c             	add    $0xc,%esp
    b84c:	c3                   	ret    

0000b84d <iput>:
		
void iput(struct m_inode * inode)
{
    b84d:	83 ec 0c             	sub    $0xc,%esp
	if (!inode)
    b850:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    b855:	75 05                	jne    b85c <iput+0xf>
		return;
    b857:	e9 4b 01 00 00       	jmp    b9a7 <iput+0x15a>
	wait_on_inode(inode);
    b85c:	83 ec 0c             	sub    $0xc,%esp
    b85f:	ff 74 24 1c          	pushl  0x1c(%esp)
    b863:	e8 1f fb ff ff       	call   b387 <wait_on_inode>
    b868:	83 c4 10             	add    $0x10,%esp
	if (!inode->i_count)
    b86b:	8b 44 24 10          	mov    0x10(%esp),%eax
    b86f:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    b874:	75 10                	jne    b886 <iput+0x39>
		panic("iput: trying to free free inode");
    b876:	83 ec 0c             	sub    $0xc,%esp
    b879:	68 90 8d 01 00       	push   $0x18d90
    b87e:	e8 96 ca ff ff       	call   8319 <panic>
    b883:	83 c4 10             	add    $0x10,%esp
	if (inode->i_pipe) {
    b886:	8b 44 24 10          	mov    0x10(%esp),%eax
    b88a:	80 78 34 00          	cmpb   $0x0,0x34(%eax)
    b88e:	74 58                	je     b8e8 <iput+0x9b>
		wake_up(&inode->i_wait);
    b890:	83 ec 0c             	sub    $0xc,%esp
    b893:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b897:	83 c0 20             	add    $0x20,%eax
    b89a:	50                   	push   %eax
    b89b:	e8 03 b7 ff ff       	call   6fa3 <wake_up>
    b8a0:	83 c4 10             	add    $0x10,%esp
		if (--inode->i_count)
    b8a3:	8b 44 24 10          	mov    0x10(%esp),%eax
    b8a7:	66 ff 48 30          	decw   0x30(%eax)
    b8ab:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    b8b0:	74 05                	je     b8b7 <iput+0x6a>
			return;
    b8b2:	e9 f0 00 00 00       	jmp    b9a7 <iput+0x15a>
		free_page(inode->i_size);
    b8b7:	83 ec 0c             	sub    $0xc,%esp
    b8ba:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b8be:	ff 70 04             	pushl  0x4(%eax)
    b8c1:	e8 df e0 ff ff       	call   99a5 <free_page>
    b8c6:	83 c4 10             	add    $0x10,%esp
		inode->i_count=0;
    b8c9:	8b 44 24 10          	mov    0x10(%esp),%eax
    b8cd:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)
		inode->i_dirt=0;
    b8d3:	8b 44 24 10          	mov    0x10(%esp),%eax
    b8d7:	c6 40 33 00          	movb   $0x0,0x33(%eax)
		inode->i_pipe=0;
    b8db:	8b 44 24 10          	mov    0x10(%esp),%eax
    b8df:	c6 40 34 00          	movb   $0x0,0x34(%eax)
		return;
    b8e3:	e9 bf 00 00 00       	jmp    b9a7 <iput+0x15a>
	}
	if (!inode->i_dev) {
    b8e8:	8b 44 24 10          	mov    0x10(%esp),%eax
    b8ec:	66 83 78 2c 00       	cmpw   $0x0,0x2c(%eax)
    b8f1:	75 0d                	jne    b900 <iput+0xb3>
		inode->i_count--;
    b8f3:	8b 44 24 10          	mov    0x10(%esp),%eax
    b8f7:	66 ff 48 30          	decw   0x30(%eax)
		return;
    b8fb:	e9 a7 00 00 00       	jmp    b9a7 <iput+0x15a>
	}
	if (S_ISBLK(inode->i_mode)) {
    b900:	8b 44 24 10          	mov    0x10(%esp),%eax
    b904:	0f b7 00             	movzwl (%eax),%eax
    b907:	25 00 f0 00 00       	and    $0xf000,%eax
    b90c:	3d 00 60 00 00       	cmp    $0x6000,%eax
    b911:	75 23                	jne    b936 <iput+0xe9>
		sync_dev(inode->i_zone[0]);
    b913:	83 ec 0c             	sub    $0xc,%esp
    b916:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    b91a:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    b91e:	50                   	push   %eax
    b91f:	e8 30 07 00 00       	call   c054 <sync_dev>
    b924:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);
    b927:	83 ec 0c             	sub    $0xc,%esp
    b92a:	ff 74 24 1c          	pushl  0x1c(%esp)
    b92e:	e8 54 fa ff ff       	call   b387 <wait_on_inode>
    b933:	83 c4 10             	add    $0x10,%esp
	}
repeat:
	if (inode->i_count>1) {
    b936:	8b 44 24 10          	mov    0x10(%esp),%eax
    b93a:	66 83 78 30 01       	cmpw   $0x1,0x30(%eax)
    b93f:	76 0a                	jbe    b94b <iput+0xfe>
		inode->i_count--;
    b941:	8b 44 24 10          	mov    0x10(%esp),%eax
    b945:	66 ff 48 30          	decw   0x30(%eax)
		return;
    b949:	eb 5c                	jmp    b9a7 <iput+0x15a>
	}
	if (!inode->i_nlinks) {
    b94b:	8b 44 24 10          	mov    0x10(%esp),%eax
    b94f:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
    b953:	75 20                	jne    b975 <iput+0x128>
		truncate(inode);
    b955:	83 ec 0c             	sub    $0xc,%esp
    b958:	ff 74 24 1c          	pushl  0x1c(%esp)
    b95c:	e8 ab 64 00 00       	call   11e0c <truncate>
    b961:	83 c4 10             	add    $0x10,%esp
		free_inode(inode);
    b964:	83 ec 0c             	sub    $0xc,%esp
    b967:	ff 74 24 1c          	pushl  0x1c(%esp)
    b96b:	e8 d7 5c 00 00       	call   11647 <free_inode>
    b970:	83 c4 10             	add    $0x10,%esp
		return;
    b973:	eb 32                	jmp    b9a7 <iput+0x15a>
	}
	if (inode->i_dirt) {
    b975:	8b 44 24 10          	mov    0x10(%esp),%eax
    b979:	80 78 33 00          	cmpb   $0x0,0x33(%eax)
    b97d:	74 20                	je     b99f <iput+0x152>
		write_inode(inode);	/* we can sleep - so do again */
    b97f:	83 ec 0c             	sub    $0xc,%esp
    b982:	ff 74 24 1c          	pushl  0x1c(%esp)
    b986:	e8 15 05 00 00       	call   bea0 <write_inode>
    b98b:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);
    b98e:	83 ec 0c             	sub    $0xc,%esp
    b991:	ff 74 24 1c          	pushl  0x1c(%esp)
    b995:	e8 ed f9 ff ff       	call   b387 <wait_on_inode>
    b99a:	83 c4 10             	add    $0x10,%esp
		goto repeat;
    b99d:	eb 97                	jmp    b936 <iput+0xe9>
	}
	inode->i_count--;
    b99f:	8b 44 24 10          	mov    0x10(%esp),%eax
    b9a3:	66 ff 48 30          	decw   0x30(%eax)
	return;
}
    b9a7:	83 c4 0c             	add    $0xc,%esp
    b9aa:	c3                   	ret    

0000b9ab <get_empty_inode>:

struct m_inode * get_empty_inode(void)
{
    b9ab:	83 ec 0c             	sub    $0xc,%esp
	struct m_inode * inode;
	static struct m_inode * last_inode = inode_table;
	int i;

	do {
		inode = NULL;
    b9ae:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    b9b5:	00 
		for (i = NR_INODE; i ; i--) {
    b9b6:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
    b9bd:	00 
    b9be:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    b9c3:	74 50                	je     ba15 <get_empty_inode+0x6a>
			if (++last_inode >= inode_table + NR_INODE)
    b9c5:	83 05 e0 bd 01 00 38 	addl   $0x38,0x1bde0
    b9cc:	81 3d e0 bd 01 00 60 	cmpl   $0x20b60,0x1bde0
    b9d3:	0b 02 00 
    b9d6:	72 0a                	jb     b9e2 <get_empty_inode+0x37>
				last_inode = inode_table;
    b9d8:	c7 05 e0 bd 01 00 60 	movl   $0x20460,0x1bde0
    b9df:	04 02 00 
			if (!last_inode->i_count) {
    b9e2:	a1 e0 bd 01 00       	mov    0x1bde0,%eax
    b9e7:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    b9ec:	75 1f                	jne    ba0d <get_empty_inode+0x62>
				inode = last_inode;
    b9ee:	a1 e0 bd 01 00       	mov    0x1bde0,%eax
    b9f3:	89 44 24 08          	mov    %eax,0x8(%esp)
				if (!inode->i_dirt && !inode->i_lock)
    b9f7:	8b 44 24 08          	mov    0x8(%esp),%eax
    b9fb:	80 78 33 00          	cmpb   $0x0,0x33(%eax)
    b9ff:	75 0c                	jne    ba0d <get_empty_inode+0x62>
    ba01:	8b 44 24 08          	mov    0x8(%esp),%eax
    ba05:	80 78 32 00          	cmpb   $0x0,0x32(%eax)
    ba09:	75 02                	jne    ba0d <get_empty_inode+0x62>
					break;
    ba0b:	eb 08                	jmp    ba15 <get_empty_inode+0x6a>
		for (i = NR_INODE; i ; i--) {
    ba0d:	8d 44 24 04          	lea    0x4(%esp),%eax
    ba11:	ff 08                	decl   (%eax)
    ba13:	eb a9                	jmp    b9be <get_empty_inode+0x13>
			}
		}
		if (!inode) {
    ba15:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    ba1a:	75 63                	jne    ba7f <get_empty_inode+0xd4>
			for (i=0 ; i<NR_INODE ; i++)
    ba1c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    ba23:	00 
    ba24:	83 7c 24 04 1f       	cmpl   $0x1f,0x4(%esp)
    ba29:	7f 44                	jg     ba6f <get_empty_inode+0xc4>
				printk("%04x: %6d\t",inode_table[i].i_dev,
    ba2b:	83 ec 04             	sub    $0x4,%esp
    ba2e:	8b 54 24 08          	mov    0x8(%esp),%edx
    ba32:	89 d0                	mov    %edx,%eax
    ba34:	c1 e0 03             	shl    $0x3,%eax
    ba37:	29 d0                	sub    %edx,%eax
    ba39:	c1 e0 03             	shl    $0x3,%eax
    ba3c:	0f b7 80 8e 04 02 00 	movzwl 0x2048e(%eax),%eax
    ba43:	50                   	push   %eax
    ba44:	8b 54 24 0c          	mov    0xc(%esp),%edx
    ba48:	89 d0                	mov    %edx,%eax
    ba4a:	c1 e0 03             	shl    $0x3,%eax
    ba4d:	29 d0                	sub    %edx,%eax
    ba4f:	c1 e0 03             	shl    $0x3,%eax
    ba52:	0f b7 80 8c 04 02 00 	movzwl 0x2048c(%eax),%eax
    ba59:	50                   	push   %eax
    ba5a:	68 b0 8d 01 00       	push   $0x18db0
    ba5f:	e8 ef c8 ff ff       	call   8353 <printk>
    ba64:	83 c4 10             	add    $0x10,%esp
			for (i=0 ; i<NR_INODE ; i++)
    ba67:	8d 44 24 04          	lea    0x4(%esp),%eax
    ba6b:	ff 00                	incl   (%eax)
    ba6d:	eb b5                	jmp    ba24 <get_empty_inode+0x79>
					inode_table[i].i_num);
			panic("No free inodes in mem");
    ba6f:	83 ec 0c             	sub    $0xc,%esp
    ba72:	68 bb 8d 01 00       	push   $0x18dbb
    ba77:	e8 9d c8 ff ff       	call   8319 <panic>
    ba7c:	83 c4 10             	add    $0x10,%esp
		}
		wait_on_inode(inode);
    ba7f:	83 ec 0c             	sub    $0xc,%esp
    ba82:	ff 74 24 14          	pushl  0x14(%esp)
    ba86:	e8 fc f8 ff ff       	call   b387 <wait_on_inode>
    ba8b:	83 c4 10             	add    $0x10,%esp
		while (inode->i_dirt) {
    ba8e:	8b 44 24 08          	mov    0x8(%esp),%eax
    ba92:	80 78 33 00          	cmpb   $0x0,0x33(%eax)
    ba96:	74 20                	je     bab8 <get_empty_inode+0x10d>
			write_inode(inode);
    ba98:	83 ec 0c             	sub    $0xc,%esp
    ba9b:	ff 74 24 14          	pushl  0x14(%esp)
    ba9f:	e8 fc 03 00 00       	call   bea0 <write_inode>
    baa4:	83 c4 10             	add    $0x10,%esp
			wait_on_inode(inode);
    baa7:	83 ec 0c             	sub    $0xc,%esp
    baaa:	ff 74 24 14          	pushl  0x14(%esp)
    baae:	e8 d4 f8 ff ff       	call   b387 <wait_on_inode>
    bab3:	83 c4 10             	add    $0x10,%esp
    bab6:	eb d6                	jmp    ba8e <get_empty_inode+0xe3>
		}
	} while (inode->i_count);
    bab8:	8b 44 24 08          	mov    0x8(%esp),%eax
    babc:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    bac1:	74 05                	je     bac8 <get_empty_inode+0x11d>
    bac3:	e9 e6 fe ff ff       	jmp    b9ae <get_empty_inode+0x3>
	memset(inode,0,sizeof(*inode));
    bac8:	83 ec 04             	sub    $0x4,%esp
    bacb:	6a 38                	push   $0x38
    bacd:	6a 00                	push   $0x0
    bacf:	ff 74 24 14          	pushl  0x14(%esp)
    bad3:	e8 15 00 00 00       	call   baed <memset>
    bad8:	83 c4 10             	add    $0x10,%esp
	inode->i_count = 1;
    badb:	8b 44 24 08          	mov    0x8(%esp),%eax
    badf:	66 c7 40 30 01 00    	movw   $0x1,0x30(%eax)
	return inode;
    bae5:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    bae9:	83 c4 0c             	add    $0xc,%esp
    baec:	c3                   	ret    

0000baed <memset>:
	);
return __res;
}

static inline void * memset(void * s,char c,int count)
{
    baed:	57                   	push   %edi
    baee:	83 ec 04             	sub    $0x4,%esp
    baf1:	8b 44 24 10          	mov    0x10(%esp),%eax
    baf5:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__("cld\n\t"
    baf9:	8a 44 24 03          	mov    0x3(%esp),%al
    bafd:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    bb01:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    bb05:	fc                   	cld    
    bb06:	f3 aa                	rep stos %al,%es:(%edi)
	"rep\n\t"
	"stosb"
	::"a" (c),"D" (s),"c" (count)
	);
return s;
    bb08:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    bb0c:	83 c4 04             	add    $0x4,%esp
    bb0f:	5f                   	pop    %edi
    bb10:	c3                   	ret    

0000bb11 <get_pipe_inode>:

struct m_inode * get_pipe_inode(void)
{
    bb11:	53                   	push   %ebx
    bb12:	83 ec 08             	sub    $0x8,%esp
	struct m_inode * inode;

	if (!(inode = get_empty_inode()))
    bb15:	e8 91 fe ff ff       	call   b9ab <get_empty_inode>
    bb1a:	89 44 24 04          	mov    %eax,0x4(%esp)
    bb1e:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    bb23:	75 09                	jne    bb2e <get_pipe_inode+0x1d>
		return NULL;
    bb25:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    bb2c:	eb 53                	jmp    bb81 <get_pipe_inode+0x70>
	if (!(inode->i_size=get_free_page())) {
    bb2e:	8b 5c 24 04          	mov    0x4(%esp),%ebx
    bb32:	e8 39 de ff ff       	call   9970 <get_free_page>
    bb37:	89 43 04             	mov    %eax,0x4(%ebx)
    bb3a:	8b 43 04             	mov    0x4(%ebx),%eax
    bb3d:	85 c0                	test   %eax,%eax
    bb3f:	75 13                	jne    bb54 <get_pipe_inode+0x43>
		inode->i_count = 0;
    bb41:	8b 44 24 04          	mov    0x4(%esp),%eax
    bb45:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)
		return NULL;
    bb4b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    bb52:	eb 2d                	jmp    bb81 <get_pipe_inode+0x70>
	}
	inode->i_count = 2;	/* sum of readers/writers */
    bb54:	8b 44 24 04          	mov    0x4(%esp),%eax
    bb58:	66 c7 40 30 02 00    	movw   $0x2,0x30(%eax)
	PIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0;
    bb5e:	8b 54 24 04          	mov    0x4(%esp),%edx
    bb62:	8b 44 24 04          	mov    0x4(%esp),%eax
    bb66:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    bb6c:	66 c7 42 0e 00 00    	movw   $0x0,0xe(%edx)
	inode->i_pipe = 1;
    bb72:	8b 44 24 04          	mov    0x4(%esp),%eax
    bb76:	c6 40 34 01          	movb   $0x1,0x34(%eax)
	return inode;
    bb7a:	8b 44 24 04          	mov    0x4(%esp),%eax
    bb7e:	89 04 24             	mov    %eax,(%esp)
}
    bb81:	8b 04 24             	mov    (%esp),%eax
    bb84:	83 c4 08             	add    $0x8,%esp
    bb87:	5b                   	pop    %ebx
    bb88:	c3                   	ret    

0000bb89 <iget>:

struct m_inode * iget(int dev,int nr)
{
    bb89:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode, * empty;

	if (!dev)
    bb8c:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    bb91:	75 10                	jne    bba3 <iget+0x1a>
		panic("iget with dev==0");
    bb93:	83 ec 0c             	sub    $0xc,%esp
    bb96:	68 d1 8d 01 00       	push   $0x18dd1
    bb9b:	e8 79 c7 ff ff       	call   8319 <panic>
    bba0:	83 c4 10             	add    $0x10,%esp
	empty = get_empty_inode();
    bba3:	e8 03 fe ff ff       	call   b9ab <get_empty_inode>
    bba8:	89 44 24 14          	mov    %eax,0x14(%esp)
	inode = inode_table;
    bbac:	c7 44 24 18 60 04 02 	movl   $0x20460,0x18(%esp)
    bbb3:	00 
	while (inode < NR_INODE+inode_table) {
    bbb4:	81 7c 24 18 60 0b 02 	cmpl   $0x20b60,0x18(%esp)
    bbbb:	00 
    bbbc:	0f 83 4e 01 00 00    	jae    bd10 <iget+0x187>
		if (inode->i_dev != dev || inode->i_num != nr) {
    bbc2:	8b 44 24 18          	mov    0x18(%esp),%eax
    bbc6:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bbca:	3b 44 24 20          	cmp    0x20(%esp),%eax
    bbce:	75 10                	jne    bbe0 <iget+0x57>
    bbd0:	8b 44 24 18          	mov    0x18(%esp),%eax
    bbd4:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    bbd8:	3b 44 24 24          	cmp    0x24(%esp),%eax
    bbdc:	75 02                	jne    bbe0 <iget+0x57>
    bbde:	eb 09                	jmp    bbe9 <iget+0x60>
			inode++;
    bbe0:	8d 44 24 18          	lea    0x18(%esp),%eax
    bbe4:	83 00 38             	addl   $0x38,(%eax)
			continue;
    bbe7:	eb cb                	jmp    bbb4 <iget+0x2b>
		}
		wait_on_inode(inode);
    bbe9:	83 ec 0c             	sub    $0xc,%esp
    bbec:	ff 74 24 24          	pushl  0x24(%esp)
    bbf0:	e8 92 f7 ff ff       	call   b387 <wait_on_inode>
    bbf5:	83 c4 10             	add    $0x10,%esp
		if (inode->i_dev != dev || inode->i_num != nr) {
    bbf8:	8b 44 24 18          	mov    0x18(%esp),%eax
    bbfc:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bc00:	3b 44 24 20          	cmp    0x20(%esp),%eax
    bc04:	75 10                	jne    bc16 <iget+0x8d>
    bc06:	8b 44 24 18          	mov    0x18(%esp),%eax
    bc0a:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    bc0e:	3b 44 24 24          	cmp    0x24(%esp),%eax
    bc12:	75 02                	jne    bc16 <iget+0x8d>
    bc14:	eb 0a                	jmp    bc20 <iget+0x97>
			inode = inode_table;
    bc16:	c7 44 24 18 60 04 02 	movl   $0x20460,0x18(%esp)
    bc1d:	00 
			continue;
    bc1e:	eb 94                	jmp    bbb4 <iget+0x2b>
		}
		inode->i_count++;
    bc20:	8b 44 24 18          	mov    0x18(%esp),%eax
    bc24:	66 ff 40 30          	incw   0x30(%eax)
		if (inode->i_mount) {
    bc28:	8b 44 24 18          	mov    0x18(%esp),%eax
    bc2c:	80 78 35 00          	cmpb   $0x0,0x35(%eax)
    bc30:	0f 84 ba 00 00 00    	je     bcf0 <iget+0x167>
			int i;

			for (i = 0 ; i<NR_SUPER ; i++)
    bc36:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    bc3d:	00 
    bc3e:	83 7c 24 10 07       	cmpl   $0x7,0x10(%esp)
    bc43:	7f 2c                	jg     bc71 <iget+0xe8>
				if (super_block[i].s_imount==inode)
    bc45:	8b 54 24 10          	mov    0x10(%esp),%edx
    bc49:	89 d0                	mov    %edx,%eax
    bc4b:	d1 e0                	shl    %eax
    bc4d:	01 d0                	add    %edx,%eax
    bc4f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    bc56:	01 d0                	add    %edx,%eax
    bc58:	c1 e0 02             	shl    $0x2,%eax
    bc5b:	8b 80 dc 22 02 00    	mov    0x222dc(%eax),%eax
    bc61:	3b 44 24 18          	cmp    0x18(%esp),%eax
    bc65:	75 02                	jne    bc69 <iget+0xe0>
					break;
    bc67:	eb 08                	jmp    bc71 <iget+0xe8>
			for (i = 0 ; i<NR_SUPER ; i++)
    bc69:	8d 44 24 10          	lea    0x10(%esp),%eax
    bc6d:	ff 00                	incl   (%eax)
    bc6f:	eb cd                	jmp    bc3e <iget+0xb5>
			if (i >= NR_SUPER) {
    bc71:	83 7c 24 10 07       	cmpl   $0x7,0x10(%esp)
    bc76:	7e 33                	jle    bcab <iget+0x122>
				printk("Mounted inode hasn't got sb\n");
    bc78:	83 ec 0c             	sub    $0xc,%esp
    bc7b:	68 e2 8d 01 00       	push   $0x18de2
    bc80:	e8 ce c6 ff ff       	call   8353 <printk>
    bc85:	83 c4 10             	add    $0x10,%esp
				if (empty)
    bc88:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    bc8d:	74 0f                	je     bc9e <iget+0x115>
					iput(empty);
    bc8f:	83 ec 0c             	sub    $0xc,%esp
    bc92:	ff 74 24 20          	pushl  0x20(%esp)
    bc96:	e8 b2 fb ff ff       	call   b84d <iput>
    bc9b:	83 c4 10             	add    $0x10,%esp
				return inode;
    bc9e:	8b 44 24 18          	mov    0x18(%esp),%eax
    bca2:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bca6:	e9 ad 00 00 00       	jmp    bd58 <iget+0x1cf>
			}
			iput(inode);
    bcab:	83 ec 0c             	sub    $0xc,%esp
    bcae:	ff 74 24 24          	pushl  0x24(%esp)
    bcb2:	e8 96 fb ff ff       	call   b84d <iput>
    bcb7:	83 c4 10             	add    $0x10,%esp
			dev = super_block[i].s_dev;
    bcba:	8b 54 24 10          	mov    0x10(%esp),%edx
    bcbe:	89 d0                	mov    %edx,%eax
    bcc0:	d1 e0                	shl    %eax
    bcc2:	01 d0                	add    %edx,%eax
    bcc4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    bccb:	01 d0                	add    %edx,%eax
    bccd:	c1 e0 02             	shl    $0x2,%eax
    bcd0:	0f b7 80 d4 22 02 00 	movzwl 0x222d4(%eax),%eax
    bcd7:	89 44 24 20          	mov    %eax,0x20(%esp)
			nr = ROOT_INO;
    bcdb:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
    bce2:	00 
			inode = inode_table;
    bce3:	c7 44 24 18 60 04 02 	movl   $0x20460,0x18(%esp)
    bcea:	00 
			continue;
    bceb:	e9 c4 fe ff ff       	jmp    bbb4 <iget+0x2b>
		}
		if (empty)
    bcf0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    bcf5:	74 0f                	je     bd06 <iget+0x17d>
			iput(empty);
    bcf7:	83 ec 0c             	sub    $0xc,%esp
    bcfa:	ff 74 24 20          	pushl  0x20(%esp)
    bcfe:	e8 4a fb ff ff       	call   b84d <iput>
    bd03:	83 c4 10             	add    $0x10,%esp
		return inode;
    bd06:	8b 44 24 18          	mov    0x18(%esp),%eax
    bd0a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bd0e:	eb 48                	jmp    bd58 <iget+0x1cf>
	}
	if (!empty)
    bd10:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    bd15:	75 0a                	jne    bd21 <iget+0x198>
		return (NULL);
    bd17:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    bd1e:	00 
    bd1f:	eb 37                	jmp    bd58 <iget+0x1cf>
	inode=empty;
    bd21:	8b 44 24 14          	mov    0x14(%esp),%eax
    bd25:	89 44 24 18          	mov    %eax,0x18(%esp)
	inode->i_dev = dev;
    bd29:	8b 54 24 18          	mov    0x18(%esp),%edx
    bd2d:	8b 44 24 20          	mov    0x20(%esp),%eax
    bd31:	66 89 42 2c          	mov    %ax,0x2c(%edx)
	inode->i_num = nr;
    bd35:	8b 54 24 18          	mov    0x18(%esp),%edx
    bd39:	8b 44 24 24          	mov    0x24(%esp),%eax
    bd3d:	66 89 42 2e          	mov    %ax,0x2e(%edx)
	read_inode(inode);
    bd41:	83 ec 0c             	sub    $0xc,%esp
    bd44:	ff 74 24 24          	pushl  0x24(%esp)
    bd48:	e8 13 00 00 00       	call   bd60 <read_inode>
    bd4d:	83 c4 10             	add    $0x10,%esp
	return inode;
    bd50:	8b 44 24 18          	mov    0x18(%esp),%eax
    bd54:	89 44 24 0c          	mov    %eax,0xc(%esp)
}
    bd58:	8b 44 24 0c          	mov    0xc(%esp),%eax
    bd5c:	83 c4 1c             	add    $0x1c,%esp
    bd5f:	c3                   	ret    

0000bd60 <read_inode>:

static void read_inode(struct m_inode * inode)
{
    bd60:	57                   	push   %edi
    bd61:	56                   	push   %esi
    bd62:	53                   	push   %ebx
    bd63:	83 ec 10             	sub    $0x10,%esp
	struct super_block * sb;
	struct buffer_head * bh;
	int block;

	lock_inode(inode);
    bd66:	83 ec 0c             	sub    $0xc,%esp
    bd69:	ff 74 24 2c          	pushl  0x2c(%esp)
    bd6d:	e8 fe 00 00 00       	call   be70 <lock_inode>
    bd72:	83 c4 10             	add    $0x10,%esp
	if (!(sb=get_super(inode->i_dev)))
    bd75:	83 ec 0c             	sub    $0xc,%esp
    bd78:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    bd7c:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bd80:	50                   	push   %eax
    bd81:	e8 ca 0d 00 00       	call   cb50 <get_super>
    bd86:	83 c4 10             	add    $0x10,%esp
    bd89:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bd8d:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bd92:	75 10                	jne    bda4 <read_inode+0x44>
		panic("trying to read inode without dev");
    bd94:	83 ec 0c             	sub    $0xc,%esp
    bd97:	68 00 8e 01 00       	push   $0x18e00
    bd9c:	e8 78 c5 ff ff       	call   8319 <panic>
    bda1:	83 c4 10             	add    $0x10,%esp
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    bda4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    bda8:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    bdac:	8b 44 24 0c          	mov    0xc(%esp),%eax
    bdb0:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    bdb4:	01 c2                	add    %eax,%edx
    bdb6:	8b 44 24 20          	mov    0x20(%esp),%eax
    bdba:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    bdbe:	48                   	dec    %eax
    bdbf:	c1 e8 05             	shr    $0x5,%eax
    bdc2:	8d 04 02             	lea    (%edx,%eax,1),%eax
    bdc5:	83 c0 02             	add    $0x2,%eax
    bdc8:	89 44 24 04          	mov    %eax,0x4(%esp)
		(inode->i_num-1)/INODES_PER_BLOCK;
	if (!(bh=bread(inode->i_dev,block)))
    bdcc:	83 ec 08             	sub    $0x8,%esp
    bdcf:	ff 74 24 0c          	pushl  0xc(%esp)
    bdd3:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    bdd7:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bddb:	50                   	push   %eax
    bddc:	e8 22 09 00 00       	call   c703 <bread>
    bde1:	83 c4 10             	add    $0x10,%esp
    bde4:	89 44 24 08          	mov    %eax,0x8(%esp)
    bde8:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    bded:	75 10                	jne    bdff <read_inode+0x9f>
		panic("unable to read i-node block");
    bdef:	83 ec 0c             	sub    $0xc,%esp
    bdf2:	68 21 8e 01 00       	push   $0x18e21
    bdf7:	e8 1d c5 ff ff       	call   8319 <panic>
    bdfc:	83 c4 10             	add    $0x10,%esp
	*(struct d_inode *)inode =
    bdff:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    be03:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    be07:	8b 44 24 20          	mov    0x20(%esp),%eax
    be0b:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    be0f:	48                   	dec    %eax
    be10:	83 e0 1f             	and    $0x1f,%eax
    be13:	89 c2                	mov    %eax,%edx
    be15:	c1 e2 05             	shl    $0x5,%edx
    be18:	8b 03                	mov    (%ebx),%eax
    be1a:	89 cf                	mov    %ecx,%edi
    be1c:	8d 34 02             	lea    (%edx,%eax,1),%esi
    be1f:	fc                   	cld    
    be20:	b8 08 00 00 00       	mov    $0x8,%eax
    be25:	89 c1                	mov    %eax,%ecx
    be27:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		((struct d_inode *)bh->b_data)
			[(inode->i_num-1)%INODES_PER_BLOCK];
	brelse(bh);
    be29:	83 ec 0c             	sub    $0xc,%esp
    be2c:	ff 74 24 14          	pushl  0x14(%esp)
    be30:	e8 82 08 00 00       	call   c6b7 <brelse>
    be35:	83 c4 10             	add    $0x10,%esp
	unlock_inode(inode);
    be38:	83 ec 0c             	sub    $0xc,%esp
    be3b:	ff 74 24 2c          	pushl  0x2c(%esp)
    be3f:	e8 0a 00 00 00       	call   be4e <unlock_inode>
    be44:	83 c4 10             	add    $0x10,%esp
}
    be47:	83 c4 10             	add    $0x10,%esp
    be4a:	5b                   	pop    %ebx
    be4b:	5e                   	pop    %esi
    be4c:	5f                   	pop    %edi
    be4d:	c3                   	ret    

0000be4e <unlock_inode>:
{
    be4e:	83 ec 0c             	sub    $0xc,%esp
	inode->i_lock=0;
    be51:	8b 44 24 10          	mov    0x10(%esp),%eax
    be55:	c6 40 32 00          	movb   $0x0,0x32(%eax)
	wake_up(&inode->i_wait);
    be59:	83 ec 0c             	sub    $0xc,%esp
    be5c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    be60:	83 c0 20             	add    $0x20,%eax
    be63:	50                   	push   %eax
    be64:	e8 3a b1 ff ff       	call   6fa3 <wake_up>
    be69:	83 c4 10             	add    $0x10,%esp
}
    be6c:	83 c4 0c             	add    $0xc,%esp
    be6f:	c3                   	ret    

0000be70 <lock_inode>:
{
    be70:	83 ec 0c             	sub    $0xc,%esp
	cli();
    be73:	fa                   	cli    
	while (inode->i_lock)
    be74:	8b 44 24 10          	mov    0x10(%esp),%eax
    be78:	80 78 32 00          	cmpb   $0x0,0x32(%eax)
    be7c:	74 15                	je     be93 <lock_inode+0x23>
		sleep_on(&inode->i_wait);
    be7e:	83 ec 0c             	sub    $0xc,%esp
    be81:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    be85:	83 c0 20             	add    $0x20,%eax
    be88:	50                   	push   %eax
    be89:	e8 f7 ad ff ff       	call   6c85 <sleep_on>
    be8e:	83 c4 10             	add    $0x10,%esp
    be91:	eb e1                	jmp    be74 <lock_inode+0x4>
	inode->i_lock=1;
    be93:	8b 44 24 10          	mov    0x10(%esp),%eax
    be97:	c6 40 32 01          	movb   $0x1,0x32(%eax)
	sti();
    be9b:	fb                   	sti    
}
    be9c:	83 c4 0c             	add    $0xc,%esp
    be9f:	c3                   	ret    

0000bea0 <write_inode>:

static void write_inode(struct m_inode * inode)
{
    bea0:	57                   	push   %edi
    bea1:	56                   	push   %esi
    bea2:	83 ec 14             	sub    $0x14,%esp
	struct super_block * sb;
	struct buffer_head * bh;
	int block;

	lock_inode(inode);
    bea5:	83 ec 0c             	sub    $0xc,%esp
    bea8:	ff 74 24 2c          	pushl  0x2c(%esp)
    beac:	e8 bf ff ff ff       	call   be70 <lock_inode>
    beb1:	83 c4 10             	add    $0x10,%esp
	if (!inode->i_dirt || !inode->i_dev) {
    beb4:	8b 44 24 20          	mov    0x20(%esp),%eax
    beb8:	80 78 33 00          	cmpb   $0x0,0x33(%eax)
    bebc:	74 0b                	je     bec9 <write_inode+0x29>
    bebe:	8b 44 24 20          	mov    0x20(%esp),%eax
    bec2:	66 83 78 2c 00       	cmpw   $0x0,0x2c(%eax)
    bec7:	75 14                	jne    bedd <write_inode+0x3d>
		unlock_inode(inode);
    bec9:	83 ec 0c             	sub    $0xc,%esp
    becc:	ff 74 24 2c          	pushl  0x2c(%esp)
    bed0:	e8 79 ff ff ff       	call   be4e <unlock_inode>
    bed5:	83 c4 10             	add    $0x10,%esp
		return;
    bed8:	e9 e2 00 00 00       	jmp    bfbf <write_inode+0x11f>
	}
	if (!(sb=get_super(inode->i_dev)))
    bedd:	83 ec 0c             	sub    $0xc,%esp
    bee0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    bee4:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bee8:	50                   	push   %eax
    bee9:	e8 62 0c 00 00       	call   cb50 <get_super>
    beee:	83 c4 10             	add    $0x10,%esp
    bef1:	89 44 24 10          	mov    %eax,0x10(%esp)
    bef5:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    befa:	75 10                	jne    bf0c <write_inode+0x6c>
		panic("trying to write inode without device");
    befc:	83 ec 0c             	sub    $0xc,%esp
    beff:	68 40 8e 01 00       	push   $0x18e40
    bf04:	e8 10 c4 ff ff       	call   8319 <panic>
    bf09:	83 c4 10             	add    $0x10,%esp
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    bf0c:	8b 44 24 10          	mov    0x10(%esp),%eax
    bf10:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    bf14:	8b 44 24 10          	mov    0x10(%esp),%eax
    bf18:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    bf1c:	01 c2                	add    %eax,%edx
    bf1e:	8b 44 24 20          	mov    0x20(%esp),%eax
    bf22:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    bf26:	48                   	dec    %eax
    bf27:	c1 e8 05             	shr    $0x5,%eax
    bf2a:	8d 04 02             	lea    (%edx,%eax,1),%eax
    bf2d:	83 c0 02             	add    $0x2,%eax
    bf30:	89 44 24 08          	mov    %eax,0x8(%esp)
		(inode->i_num-1)/INODES_PER_BLOCK;
	if (!(bh=bread(inode->i_dev,block)))
    bf34:	83 ec 08             	sub    $0x8,%esp
    bf37:	ff 74 24 10          	pushl  0x10(%esp)
    bf3b:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    bf3f:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    bf43:	50                   	push   %eax
    bf44:	e8 ba 07 00 00       	call   c703 <bread>
    bf49:	83 c4 10             	add    $0x10,%esp
    bf4c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bf50:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    bf55:	75 10                	jne    bf67 <write_inode+0xc7>
		panic("unable to read i-node block");
    bf57:	83 ec 0c             	sub    $0xc,%esp
    bf5a:	68 21 8e 01 00       	push   $0x18e21
    bf5f:	e8 b5 c3 ff ff       	call   8319 <panic>
    bf64:	83 c4 10             	add    $0x10,%esp
	((struct d_inode *)bh->b_data)
    bf67:	8b 54 24 0c          	mov    0xc(%esp),%edx
    bf6b:	8b 44 24 20          	mov    0x20(%esp),%eax
    bf6f:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
    bf73:	48                   	dec    %eax
    bf74:	83 e0 1f             	and    $0x1f,%eax
    bf77:	89 c1                	mov    %eax,%ecx
    bf79:	c1 e1 05             	shl    $0x5,%ecx
    bf7c:	8b 02                	mov    (%edx),%eax
    bf7e:	8b 54 24 20          	mov    0x20(%esp),%edx
    bf82:	8d 3c 01             	lea    (%ecx,%eax,1),%edi
    bf85:	89 d6                	mov    %edx,%esi
    bf87:	fc                   	cld    
    bf88:	b8 08 00 00 00       	mov    $0x8,%eax
    bf8d:	89 c1                	mov    %eax,%ecx
    bf8f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		[(inode->i_num-1)%INODES_PER_BLOCK] =
			*(struct d_inode *)inode;
	bh->b_dirt=1;
    bf91:	8b 44 24 0c          	mov    0xc(%esp),%eax
    bf95:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	inode->i_dirt=0;
    bf99:	8b 44 24 20          	mov    0x20(%esp),%eax
    bf9d:	c6 40 33 00          	movb   $0x0,0x33(%eax)
	brelse(bh);
    bfa1:	83 ec 0c             	sub    $0xc,%esp
    bfa4:	ff 74 24 18          	pushl  0x18(%esp)
    bfa8:	e8 0a 07 00 00       	call   c6b7 <brelse>
    bfad:	83 c4 10             	add    $0x10,%esp
	unlock_inode(inode);
    bfb0:	83 ec 0c             	sub    $0xc,%esp
    bfb3:	ff 74 24 2c          	pushl  0x2c(%esp)
    bfb7:	e8 92 fe ff ff       	call   be4e <unlock_inode>
    bfbc:	83 c4 10             	add    $0x10,%esp
}
    bfbf:	83 c4 14             	add    $0x14,%esp
    bfc2:	5e                   	pop    %esi
    bfc3:	5f                   	pop    %edi
    bfc4:	c3                   	ret    

0000bfc5 <sys_sync>:
		sleep_on(&bh->b_wait);
	sti();
}

int sys_sync(void)
{
    bfc5:	83 ec 0c             	sub    $0xc,%esp
	int i;
	struct buffer_head * bh;

	sync_inodes();		/* write out inodes into buffers */
    bfc8:	e8 e2 f3 ff ff       	call   b3af <sync_inodes>
	bh = start_buffer;
    bfcd:	a1 e4 bd 01 00       	mov    0x1bde4,%eax
    bfd2:	89 44 24 04          	mov    %eax,0x4(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    bfd6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    bfdd:	00 
    bfde:	8b 44 24 08          	mov    0x8(%esp),%eax
    bfe2:	3b 05 60 0b 02 00    	cmp    0x20b60,%eax
    bfe8:	7d 39                	jge    c023 <sys_sync+0x5e>
		wait_on_buffer(bh);
    bfea:	83 ec 0c             	sub    $0xc,%esp
    bfed:	ff 74 24 10          	pushl  0x10(%esp)
    bff1:	e8 36 00 00 00       	call   c02c <wait_on_buffer>
    bff6:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dirt)
    bff9:	8b 44 24 04          	mov    0x4(%esp),%eax
    bffd:	80 78 0b 00          	cmpb   $0x0,0xb(%eax)
    c001:	74 11                	je     c014 <sys_sync+0x4f>
			ll_rw_block(WRITE,bh);
    c003:	83 ec 08             	sub    $0x8,%esp
    c006:	ff 74 24 0c          	pushl  0xc(%esp)
    c00a:	6a 01                	push   $0x1
    c00c:	e8 2c 61 00 00       	call   1213d <ll_rw_block>
    c011:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c014:	8d 44 24 08          	lea    0x8(%esp),%eax
    c018:	ff 00                	incl   (%eax)
    c01a:	8d 44 24 04          	lea    0x4(%esp),%eax
    c01e:	83 00 24             	addl   $0x24,(%eax)
    c021:	eb bb                	jmp    bfde <sys_sync+0x19>
	}
	return 0;
    c023:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c028:	83 c4 0c             	add    $0xc,%esp
    c02b:	c3                   	ret    

0000c02c <wait_on_buffer>:
{
    c02c:	83 ec 0c             	sub    $0xc,%esp
	cli();
    c02f:	fa                   	cli    
	while (bh->b_lock)
    c030:	8b 44 24 10          	mov    0x10(%esp),%eax
    c034:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
    c038:	74 15                	je     c04f <wait_on_buffer+0x23>
		sleep_on(&bh->b_wait);
    c03a:	83 ec 0c             	sub    $0xc,%esp
    c03d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    c041:	83 c0 10             	add    $0x10,%eax
    c044:	50                   	push   %eax
    c045:	e8 3b ac ff ff       	call   6c85 <sleep_on>
    c04a:	83 c4 10             	add    $0x10,%esp
    c04d:	eb e1                	jmp    c030 <wait_on_buffer+0x4>
	sti();
    c04f:	fb                   	sti    
}
    c050:	83 c4 0c             	add    $0xc,%esp
    c053:	c3                   	ret    

0000c054 <sync_dev>:

int sync_dev(int dev)
{
    c054:	83 ec 0c             	sub    $0xc,%esp
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
    c057:	a1 e4 bd 01 00       	mov    0x1bde4,%eax
    c05c:	89 44 24 04          	mov    %eax,0x4(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c060:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c067:	00 
    c068:	8b 44 24 08          	mov    0x8(%esp),%eax
    c06c:	3b 05 60 0b 02 00    	cmp    0x20b60,%eax
    c072:	7d 57                	jge    c0cb <sync_dev+0x77>
		if (bh->b_dev != dev)
    c074:	8b 44 24 04          	mov    0x4(%esp),%eax
    c078:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c07c:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c080:	74 02                	je     c084 <sync_dev+0x30>
			continue;
    c082:	eb 38                	jmp    c0bc <sync_dev+0x68>
		wait_on_buffer(bh);
    c084:	83 ec 0c             	sub    $0xc,%esp
    c087:	ff 74 24 10          	pushl  0x10(%esp)
    c08b:	e8 9c ff ff ff       	call   c02c <wait_on_buffer>
    c090:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_dirt)
    c093:	8b 44 24 04          	mov    0x4(%esp),%eax
    c097:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c09b:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c09f:	75 1b                	jne    c0bc <sync_dev+0x68>
    c0a1:	8b 44 24 04          	mov    0x4(%esp),%eax
    c0a5:	80 78 0b 00          	cmpb   $0x0,0xb(%eax)
    c0a9:	74 11                	je     c0bc <sync_dev+0x68>
			ll_rw_block(WRITE,bh);
    c0ab:	83 ec 08             	sub    $0x8,%esp
    c0ae:	ff 74 24 0c          	pushl  0xc(%esp)
    c0b2:	6a 01                	push   $0x1
    c0b4:	e8 84 60 00 00       	call   1213d <ll_rw_block>
    c0b9:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c0bc:	8d 44 24 08          	lea    0x8(%esp),%eax
    c0c0:	ff 00                	incl   (%eax)
    c0c2:	8d 44 24 04          	lea    0x4(%esp),%eax
    c0c6:	83 00 24             	addl   $0x24,(%eax)
    c0c9:	eb 9d                	jmp    c068 <sync_dev+0x14>
	}
	sync_inodes();
    c0cb:	e8 df f2 ff ff       	call   b3af <sync_inodes>
	bh = start_buffer;
    c0d0:	a1 e4 bd 01 00       	mov    0x1bde4,%eax
    c0d5:	89 44 24 04          	mov    %eax,0x4(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c0d9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c0e0:	00 
    c0e1:	8b 44 24 08          	mov    0x8(%esp),%eax
    c0e5:	3b 05 60 0b 02 00    	cmp    0x20b60,%eax
    c0eb:	7d 57                	jge    c144 <sync_dev+0xf0>
		if (bh->b_dev != dev)
    c0ed:	8b 44 24 04          	mov    0x4(%esp),%eax
    c0f1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c0f5:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c0f9:	74 02                	je     c0fd <sync_dev+0xa9>
			continue;
    c0fb:	eb 38                	jmp    c135 <sync_dev+0xe1>
		wait_on_buffer(bh);
    c0fd:	83 ec 0c             	sub    $0xc,%esp
    c100:	ff 74 24 10          	pushl  0x10(%esp)
    c104:	e8 23 ff ff ff       	call   c02c <wait_on_buffer>
    c109:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_dirt)
    c10c:	8b 44 24 04          	mov    0x4(%esp),%eax
    c110:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c114:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c118:	75 1b                	jne    c135 <sync_dev+0xe1>
    c11a:	8b 44 24 04          	mov    0x4(%esp),%eax
    c11e:	80 78 0b 00          	cmpb   $0x0,0xb(%eax)
    c122:	74 11                	je     c135 <sync_dev+0xe1>
			ll_rw_block(WRITE,bh);
    c124:	83 ec 08             	sub    $0x8,%esp
    c127:	ff 74 24 0c          	pushl  0xc(%esp)
    c12b:	6a 01                	push   $0x1
    c12d:	e8 0b 60 00 00       	call   1213d <ll_rw_block>
    c132:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c135:	8d 44 24 08          	lea    0x8(%esp),%eax
    c139:	ff 00                	incl   (%eax)
    c13b:	8d 44 24 04          	lea    0x4(%esp),%eax
    c13f:	83 00 24             	addl   $0x24,(%eax)
    c142:	eb 9d                	jmp    c0e1 <sync_dev+0x8d>
	}
	return 0;
    c144:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c149:	83 c4 0c             	add    $0xc,%esp
    c14c:	c3                   	ret    

0000c14d <invalidate_buffers>:

void inline invalidate_buffers(int dev)
{
    c14d:	83 ec 0c             	sub    $0xc,%esp
	int i;
	struct buffer_head * bh;

	bh = start_buffer;
    c150:	a1 e4 bd 01 00       	mov    0x1bde4,%eax
    c155:	89 44 24 04          	mov    %eax,0x4(%esp)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c159:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c160:	00 
    c161:	8b 44 24 08          	mov    0x8(%esp),%eax
    c165:	3b 05 60 0b 02 00    	cmp    0x20b60,%eax
    c16b:	7d 4c                	jge    c1b9 <invalidate_buffers+0x6c>
		if (bh->b_dev != dev)
    c16d:	8b 44 24 04          	mov    0x4(%esp),%eax
    c171:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c175:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c179:	74 02                	je     c17d <invalidate_buffers+0x30>
			continue;
    c17b:	eb 2d                	jmp    c1aa <invalidate_buffers+0x5d>
		wait_on_buffer(bh);
    c17d:	83 ec 0c             	sub    $0xc,%esp
    c180:	ff 74 24 10          	pushl  0x10(%esp)
    c184:	e8 a3 fe ff ff       	call   c02c <wait_on_buffer>
    c189:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev)
    c18c:	8b 44 24 04          	mov    0x4(%esp),%eax
    c190:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c194:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c198:	75 10                	jne    c1aa <invalidate_buffers+0x5d>
			bh->b_uptodate = bh->b_dirt = 0;
    c19a:	8b 54 24 04          	mov    0x4(%esp),%edx
    c19e:	8b 44 24 04          	mov    0x4(%esp),%eax
    c1a2:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
    c1a6:	c6 42 0a 00          	movb   $0x0,0xa(%edx)
	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
    c1aa:	8d 44 24 08          	lea    0x8(%esp),%eax
    c1ae:	ff 00                	incl   (%eax)
    c1b0:	8d 44 24 04          	lea    0x4(%esp),%eax
    c1b4:	83 00 24             	addl   $0x24,(%eax)
    c1b7:	eb a8                	jmp    c161 <invalidate_buffers+0x14>
	}
}
    c1b9:	83 c4 0c             	add    $0xc,%esp
    c1bc:	c3                   	ret    

0000c1bd <check_disk_change>:
 * that any additional removable block-device will use this routine,
 * and that mount/open needn't know that floppies/whatever are
 * special.
 */
void check_disk_change(int dev)
{
    c1bd:	83 ec 0c             	sub    $0xc,%esp
	int i;

	if (MAJOR(dev) != 2)
    c1c0:	8b 44 24 10          	mov    0x10(%esp),%eax
    c1c4:	c1 e8 08             	shr    $0x8,%eax
    c1c7:	83 f8 02             	cmp    $0x2,%eax
    c1ca:	74 05                	je     c1d1 <check_disk_change+0x14>
		return;
    c1cc:	e9 9d 00 00 00       	jmp    c26e <check_disk_change+0xb1>
	if (!floppy_change(dev & 0x03))
    c1d1:	83 ec 0c             	sub    $0xc,%esp
    c1d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    c1d8:	83 e0 03             	and    $0x3,%eax
    c1db:	50                   	push   %eax
    c1dc:	e8 00 60 00 00       	call   121e1 <floppy_change>
    c1e1:	83 c4 10             	add    $0x10,%esp
    c1e4:	85 c0                	test   %eax,%eax
    c1e6:	75 05                	jne    c1ed <check_disk_change+0x30>
		return;
    c1e8:	e9 81 00 00 00       	jmp    c26e <check_disk_change+0xb1>
	for (i=0 ; i<NR_SUPER ; i++)
    c1ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c1f4:	00 
    c1f5:	83 7c 24 08 07       	cmpl   $0x7,0x8(%esp)
    c1fa:	7f 54                	jg     c250 <check_disk_change+0x93>
		if (super_block[i].s_dev == dev)
    c1fc:	8b 54 24 08          	mov    0x8(%esp),%edx
    c200:	89 d0                	mov    %edx,%eax
    c202:	d1 e0                	shl    %eax
    c204:	01 d0                	add    %edx,%eax
    c206:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    c20d:	01 d0                	add    %edx,%eax
    c20f:	c1 e0 02             	shl    $0x2,%eax
    c212:	0f b7 80 d4 22 02 00 	movzwl 0x222d4(%eax),%eax
    c219:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c21d:	75 29                	jne    c248 <check_disk_change+0x8b>
			put_super(super_block[i].s_dev);
    c21f:	83 ec 0c             	sub    $0xc,%esp
    c222:	8b 54 24 14          	mov    0x14(%esp),%edx
    c226:	89 d0                	mov    %edx,%eax
    c228:	d1 e0                	shl    %eax
    c22a:	01 d0                	add    %edx,%eax
    c22c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    c233:	01 d0                	add    %edx,%eax
    c235:	c1 e0 02             	shl    $0x2,%eax
    c238:	0f b7 80 d4 22 02 00 	movzwl 0x222d4(%eax),%eax
    c23f:	50                   	push   %eax
    c240:	e8 89 09 00 00       	call   cbce <put_super>
    c245:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_SUPER ; i++)
    c248:	8d 44 24 08          	lea    0x8(%esp),%eax
    c24c:	ff 00                	incl   (%eax)
    c24e:	eb a5                	jmp    c1f5 <check_disk_change+0x38>
	invalidate_inodes(dev);
    c250:	83 ec 0c             	sub    $0xc,%esp
    c253:	ff 74 24 1c          	pushl  0x1c(%esp)
    c257:	e8 b4 f0 ff ff       	call   b310 <invalidate_inodes>
    c25c:	83 c4 10             	add    $0x10,%esp
	invalidate_buffers(dev);
    c25f:	83 ec 0c             	sub    $0xc,%esp
    c262:	ff 74 24 1c          	pushl  0x1c(%esp)
    c266:	e8 e2 fe ff ff       	call   c14d <invalidate_buffers>
    c26b:	83 c4 10             	add    $0x10,%esp
}
    c26e:	83 c4 0c             	add    $0xc,%esp
    c271:	c3                   	ret    

0000c272 <find_buffer>:
	hash(bh->b_dev,bh->b_blocknr) = bh;
	bh->b_next->b_prev = bh;
}

static struct buffer_head * find_buffer(int dev, int block)
{		
    c272:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * tmp;

	for (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)
    c275:	8b 44 24 14          	mov    0x14(%esp),%eax
    c279:	8b 54 24 10          	mov    0x10(%esp),%edx
    c27d:	31 c2                	xor    %eax,%edx
    c27f:	c7 04 24 33 01 00 00 	movl   $0x133,(%esp)
    c286:	89 d0                	mov    %edx,%eax
    c288:	ba 00 00 00 00       	mov    $0x0,%edx
    c28d:	f7 34 24             	divl   (%esp)
    c290:	8b 04 95 a0 1d 02 00 	mov    0x21da0(,%edx,4),%eax
    c297:	89 44 24 08          	mov    %eax,0x8(%esp)
    c29b:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    c2a0:	74 32                	je     c2d4 <find_buffer+0x62>
		if (tmp->b_dev==dev && tmp->b_blocknr==block)
    c2a2:	8b 44 24 08          	mov    0x8(%esp),%eax
    c2a6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c2aa:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c2ae:	75 17                	jne    c2c7 <find_buffer+0x55>
    c2b0:	8b 44 24 08          	mov    0x8(%esp),%eax
    c2b4:	8b 40 04             	mov    0x4(%eax),%eax
    c2b7:	3b 44 24 14          	cmp    0x14(%esp),%eax
    c2bb:	75 0a                	jne    c2c7 <find_buffer+0x55>
			return tmp;
    c2bd:	8b 44 24 08          	mov    0x8(%esp),%eax
    c2c1:	89 44 24 04          	mov    %eax,0x4(%esp)
    c2c5:	eb 15                	jmp    c2dc <find_buffer+0x6a>
	for (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)
    c2c7:	8b 44 24 08          	mov    0x8(%esp),%eax
    c2cb:	8b 40 18             	mov    0x18(%eax),%eax
    c2ce:	89 44 24 08          	mov    %eax,0x8(%esp)
    c2d2:	eb c7                	jmp    c29b <find_buffer+0x29>
	return NULL;
    c2d4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    c2db:	00 
}
    c2dc:	8b 44 24 04          	mov    0x4(%esp),%eax
    c2e0:	83 c4 0c             	add    $0xc,%esp
    c2e3:	c3                   	ret    

0000c2e4 <get_hash_table>:
 * something might happen to it while we sleep (ie a read-error
 * will force it bad). This shouldn't really happen currently, but
 * the code is ready.
 */
struct buffer_head * get_hash_table(int dev, int block)
{
    c2e4:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * bh;

	for (;;) {
		if (!(bh=find_buffer(dev,block)))
    c2e7:	ff 74 24 14          	pushl  0x14(%esp)
    c2eb:	ff 74 24 14          	pushl  0x14(%esp)
    c2ef:	e8 7e ff ff ff       	call   c272 <find_buffer>
    c2f4:	83 c4 08             	add    $0x8,%esp
    c2f7:	89 44 24 08          	mov    %eax,0x8(%esp)
    c2fb:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    c300:	75 0a                	jne    c30c <get_hash_table+0x28>
			return NULL;
    c302:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    c309:	00 
    c30a:	eb 44                	jmp    c350 <get_hash_table+0x6c>
		bh->b_count++;
    c30c:	8b 44 24 08          	mov    0x8(%esp),%eax
    c310:	fe 40 0c             	incb   0xc(%eax)
		wait_on_buffer(bh);
    c313:	83 ec 0c             	sub    $0xc,%esp
    c316:	ff 74 24 14          	pushl  0x14(%esp)
    c31a:	e8 0d fd ff ff       	call   c02c <wait_on_buffer>
    c31f:	83 c4 10             	add    $0x10,%esp
		if (bh->b_dev == dev && bh->b_blocknr == block)
    c322:	8b 44 24 08          	mov    0x8(%esp),%eax
    c326:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c32a:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c32e:	75 17                	jne    c347 <get_hash_table+0x63>
    c330:	8b 44 24 08          	mov    0x8(%esp),%eax
    c334:	8b 40 04             	mov    0x4(%eax),%eax
    c337:	3b 44 24 14          	cmp    0x14(%esp),%eax
    c33b:	75 0a                	jne    c347 <get_hash_table+0x63>
			return bh;
    c33d:	8b 44 24 08          	mov    0x8(%esp),%eax
    c341:	89 44 24 04          	mov    %eax,0x4(%esp)
    c345:	eb 09                	jmp    c350 <get_hash_table+0x6c>
		bh->b_count--;
    c347:	8b 44 24 08          	mov    0x8(%esp),%eax
    c34b:	fe 48 0c             	decb   0xc(%eax)
	for (;;) {
    c34e:	eb 97                	jmp    c2e7 <get_hash_table+0x3>
	}
}
    c350:	8b 44 24 04          	mov    0x4(%esp),%eax
    c354:	83 c4 0c             	add    $0xc,%esp
    c357:	c3                   	ret    

0000c358 <getblk>:
 *
 * The algoritm is changed: hopefully better, and an elusive bug removed.
 */
#define BADNESS(bh) (((bh)->b_dirt<<1)+(bh)->b_lock)
struct buffer_head * getblk(int dev,int block)
{
    c358:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * tmp, * bh;

repeat:
	if ((bh = get_hash_table(dev,block)))
    c35b:	83 ec 08             	sub    $0x8,%esp
    c35e:	ff 74 24 1c          	pushl  0x1c(%esp)
    c362:	ff 74 24 1c          	pushl  0x1c(%esp)
    c366:	e8 79 ff ff ff       	call   c2e4 <get_hash_table>
    c36b:	83 c4 10             	add    $0x10,%esp
    c36e:	89 44 24 04          	mov    %eax,0x4(%esp)
    c372:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c377:	74 0c                	je     c385 <getblk+0x2d>
		return bh;
    c379:	8b 44 24 04          	mov    0x4(%esp),%eax
    c37d:	89 04 24             	mov    %eax,(%esp)
    c380:	e9 6a 01 00 00       	jmp    c4ef <getblk+0x197>
	tmp = free_list;
    c385:	a1 68 0b 02 00       	mov    0x20b68,%eax
    c38a:	89 44 24 08          	mov    %eax,0x8(%esp)
	do {
		if (tmp->b_count)
    c38e:	8b 44 24 08          	mov    0x8(%esp),%eax
    c392:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
    c396:	74 02                	je     c39a <getblk+0x42>
			continue;
    c398:	eb 5d                	jmp    c3f7 <getblk+0x9f>
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
    c39a:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c39f:	74 32                	je     c3d3 <getblk+0x7b>
    c3a1:	8b 44 24 08          	mov    0x8(%esp),%eax
    c3a5:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    c3a9:	8d 14 00             	lea    (%eax,%eax,1),%edx
    c3ac:	8b 44 24 08          	mov    0x8(%esp),%eax
    c3b0:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    c3b4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    c3b7:	8b 44 24 04          	mov    0x4(%esp),%eax
    c3bb:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    c3bf:	8d 14 00             	lea    (%eax,%eax,1),%edx
    c3c2:	8b 44 24 04          	mov    0x4(%esp),%eax
    c3c6:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    c3ca:	8d 04 02             	lea    (%edx,%eax,1),%eax
    c3cd:	39 c1                	cmp    %eax,%ecx
    c3cf:	7c 02                	jl     c3d3 <getblk+0x7b>
    c3d1:	eb 24                	jmp    c3f7 <getblk+0x9f>
			bh = tmp;
    c3d3:	8b 44 24 08          	mov    0x8(%esp),%eax
    c3d7:	89 44 24 04          	mov    %eax,0x4(%esp)
			if (!BADNESS(tmp))
    c3db:	8b 44 24 08          	mov    0x8(%esp),%eax
    c3df:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
    c3e3:	8d 14 00             	lea    (%eax,%eax,1),%edx
    c3e6:	8b 44 24 08          	mov    0x8(%esp),%eax
    c3ea:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
    c3ee:	8d 04 02             	lea    (%edx,%eax,1),%eax
    c3f1:	85 c0                	test   %eax,%eax
    c3f3:	75 02                	jne    c3f7 <getblk+0x9f>
				break;
    c3f5:	eb 15                	jmp    c40c <getblk+0xb4>
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list);
    c3f7:	8b 44 24 08          	mov    0x8(%esp),%eax
    c3fb:	8b 40 20             	mov    0x20(%eax),%eax
    c3fe:	89 44 24 08          	mov    %eax,0x8(%esp)
    c402:	3b 05 68 0b 02 00    	cmp    0x20b68,%eax
    c408:	74 02                	je     c40c <getblk+0xb4>
    c40a:	eb 82                	jmp    c38e <getblk+0x36>
	if (!bh) {
    c40c:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    c411:	75 15                	jne    c428 <getblk+0xd0>
		sleep_on(&buffer_wait);
    c413:	83 ec 0c             	sub    $0xc,%esp
    c416:	68 64 0b 02 00       	push   $0x20b64
    c41b:	e8 65 a8 ff ff       	call   6c85 <sleep_on>
    c420:	83 c4 10             	add    $0x10,%esp
		goto repeat;
    c423:	e9 33 ff ff ff       	jmp    c35b <getblk+0x3>
	}
	wait_on_buffer(bh);
    c428:	83 ec 0c             	sub    $0xc,%esp
    c42b:	ff 74 24 10          	pushl  0x10(%esp)
    c42f:	e8 f8 fb ff ff       	call   c02c <wait_on_buffer>
    c434:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count)
    c437:	8b 44 24 04          	mov    0x4(%esp),%eax
    c43b:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
    c43f:	74 05                	je     c446 <getblk+0xee>
		goto repeat;
    c441:	e9 15 ff ff ff       	jmp    c35b <getblk+0x3>
	while (bh->b_dirt) {
    c446:	8b 44 24 04          	mov    0x4(%esp),%eax
    c44a:	80 78 0b 00          	cmpb   $0x0,0xb(%eax)
    c44e:	74 32                	je     c482 <getblk+0x12a>
		sync_dev(bh->b_dev);
    c450:	83 ec 0c             	sub    $0xc,%esp
    c453:	8b 44 24 10          	mov    0x10(%esp),%eax
    c457:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c45b:	50                   	push   %eax
    c45c:	e8 f3 fb ff ff       	call   c054 <sync_dev>
    c461:	83 c4 10             	add    $0x10,%esp
		wait_on_buffer(bh);
    c464:	83 ec 0c             	sub    $0xc,%esp
    c467:	ff 74 24 10          	pushl  0x10(%esp)
    c46b:	e8 bc fb ff ff       	call   c02c <wait_on_buffer>
    c470:	83 c4 10             	add    $0x10,%esp
		if (bh->b_count)
    c473:	8b 44 24 04          	mov    0x4(%esp),%eax
    c477:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
    c47b:	74 c9                	je     c446 <getblk+0xee>
			goto repeat;
    c47d:	e9 d9 fe ff ff       	jmp    c35b <getblk+0x3>
	}
/* NOTE!! While we slept waiting for this block, somebody else might */
/* already have added "this" block to the cache. check it */
	if (find_buffer(dev,block))
    c482:	ff 74 24 14          	pushl  0x14(%esp)
    c486:	ff 74 24 14          	pushl  0x14(%esp)
    c48a:	e8 e3 fd ff ff       	call   c272 <find_buffer>
    c48f:	83 c4 08             	add    $0x8,%esp
    c492:	85 c0                	test   %eax,%eax
    c494:	74 05                	je     c49b <getblk+0x143>
		goto repeat;
    c496:	e9 c0 fe ff ff       	jmp    c35b <getblk+0x3>
/* OK, FINALLY we know that this buffer is the only one of it's kind, */
/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	bh->b_count=1;
    c49b:	8b 44 24 04          	mov    0x4(%esp),%eax
    c49f:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
	bh->b_dirt=0;
    c4a3:	8b 44 24 04          	mov    0x4(%esp),%eax
    c4a7:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	bh->b_uptodate=0;
    c4ab:	8b 44 24 04          	mov    0x4(%esp),%eax
    c4af:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
	remove_from_queues(bh);
    c4b3:	83 ec 0c             	sub    $0xc,%esp
    c4b6:	ff 74 24 10          	pushl  0x10(%esp)
    c4ba:	e8 ff 00 00 00       	call   c5be <remove_from_queues>
    c4bf:	83 c4 10             	add    $0x10,%esp
	bh->b_dev=dev;
    c4c2:	8b 54 24 04          	mov    0x4(%esp),%edx
    c4c6:	8b 44 24 10          	mov    0x10(%esp),%eax
    c4ca:	66 89 42 08          	mov    %ax,0x8(%edx)
	bh->b_blocknr=block;
    c4ce:	8b 54 24 04          	mov    0x4(%esp),%edx
    c4d2:	8b 44 24 14          	mov    0x14(%esp),%eax
    c4d6:	89 42 04             	mov    %eax,0x4(%edx)
	insert_into_queues(bh);
    c4d9:	83 ec 0c             	sub    $0xc,%esp
    c4dc:	ff 74 24 10          	pushl  0x10(%esp)
    c4e0:	e8 11 00 00 00       	call   c4f6 <insert_into_queues>
    c4e5:	83 c4 10             	add    $0x10,%esp
	return bh;
    c4e8:	8b 44 24 04          	mov    0x4(%esp),%eax
    c4ec:	89 04 24             	mov    %eax,(%esp)
}
    c4ef:	8b 04 24             	mov    (%esp),%eax
    c4f2:	83 c4 0c             	add    $0xc,%esp
    c4f5:	c3                   	ret    

0000c4f6 <insert_into_queues>:
{
    c4f6:	83 ec 04             	sub    $0x4,%esp
	bh->b_next_free = free_list;
    c4f9:	8b 54 24 08          	mov    0x8(%esp),%edx
    c4fd:	a1 68 0b 02 00       	mov    0x20b68,%eax
    c502:	89 42 20             	mov    %eax,0x20(%edx)
	bh->b_prev_free = free_list->b_prev_free;
    c505:	8b 54 24 08          	mov    0x8(%esp),%edx
    c509:	a1 68 0b 02 00       	mov    0x20b68,%eax
    c50e:	8b 40 1c             	mov    0x1c(%eax),%eax
    c511:	89 42 1c             	mov    %eax,0x1c(%edx)
	free_list->b_prev_free->b_next_free = bh;
    c514:	a1 68 0b 02 00       	mov    0x20b68,%eax
    c519:	8b 50 1c             	mov    0x1c(%eax),%edx
    c51c:	8b 44 24 08          	mov    0x8(%esp),%eax
    c520:	89 42 20             	mov    %eax,0x20(%edx)
	free_list->b_prev_free = bh;
    c523:	8b 15 68 0b 02 00    	mov    0x20b68,%edx
    c529:	8b 44 24 08          	mov    0x8(%esp),%eax
    c52d:	89 42 1c             	mov    %eax,0x1c(%edx)
	bh->b_prev = NULL;
    c530:	8b 44 24 08          	mov    0x8(%esp),%eax
    c534:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	bh->b_next = NULL;
    c53b:	8b 44 24 08          	mov    0x8(%esp),%eax
    c53f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	if (!bh->b_dev)
    c546:	8b 44 24 08          	mov    0x8(%esp),%eax
    c54a:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
    c54f:	75 02                	jne    c553 <insert_into_queues+0x5d>
		return;
    c551:	eb 67                	jmp    c5ba <insert_into_queues+0xc4>
	bh->b_next = hash(bh->b_dev,bh->b_blocknr);
    c553:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    c557:	8b 44 24 08          	mov    0x8(%esp),%eax
    c55b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c55f:	8b 44 24 08          	mov    0x8(%esp),%eax
    c563:	33 50 04             	xor    0x4(%eax),%edx
    c566:	c7 04 24 33 01 00 00 	movl   $0x133,(%esp)
    c56d:	89 d0                	mov    %edx,%eax
    c56f:	ba 00 00 00 00       	mov    $0x0,%edx
    c574:	f7 34 24             	divl   (%esp)
    c577:	8b 04 95 a0 1d 02 00 	mov    0x21da0(,%edx,4),%eax
    c57e:	89 41 18             	mov    %eax,0x18(%ecx)
	hash(bh->b_dev,bh->b_blocknr) = bh;
    c581:	8b 44 24 08          	mov    0x8(%esp),%eax
    c585:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c589:	8b 44 24 08          	mov    0x8(%esp),%eax
    c58d:	33 50 04             	xor    0x4(%eax),%edx
    c590:	c7 04 24 33 01 00 00 	movl   $0x133,(%esp)
    c597:	89 d0                	mov    %edx,%eax
    c599:	ba 00 00 00 00       	mov    $0x0,%edx
    c59e:	f7 34 24             	divl   (%esp)
    c5a1:	8b 44 24 08          	mov    0x8(%esp),%eax
    c5a5:	89 04 95 a0 1d 02 00 	mov    %eax,0x21da0(,%edx,4)
	bh->b_next->b_prev = bh;
    c5ac:	8b 44 24 08          	mov    0x8(%esp),%eax
    c5b0:	8b 50 18             	mov    0x18(%eax),%edx
    c5b3:	8b 44 24 08          	mov    0x8(%esp),%eax
    c5b7:	89 42 14             	mov    %eax,0x14(%edx)
}
    c5ba:	83 c4 04             	add    $0x4,%esp
    c5bd:	c3                   	ret    

0000c5be <remove_from_queues>:
{
    c5be:	83 ec 0c             	sub    $0xc,%esp
	if (bh->b_next)
    c5c1:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5c5:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
    c5c9:	74 11                	je     c5dc <remove_from_queues+0x1e>
		bh->b_next->b_prev = bh->b_prev;
    c5cb:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5cf:	8b 50 18             	mov    0x18(%eax),%edx
    c5d2:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5d6:	8b 40 14             	mov    0x14(%eax),%eax
    c5d9:	89 42 14             	mov    %eax,0x14(%edx)
	if (bh->b_prev)
    c5dc:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5e0:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
    c5e4:	74 11                	je     c5f7 <remove_from_queues+0x39>
		bh->b_prev->b_next = bh->b_next;
    c5e6:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5ea:	8b 50 14             	mov    0x14(%eax),%edx
    c5ed:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5f1:	8b 40 18             	mov    0x18(%eax),%eax
    c5f4:	89 42 18             	mov    %eax,0x18(%edx)
	if (hash(bh->b_dev,bh->b_blocknr) == bh)
    c5f7:	8b 44 24 10          	mov    0x10(%esp),%eax
    c5fb:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c5ff:	8b 44 24 10          	mov    0x10(%esp),%eax
    c603:	33 50 04             	xor    0x4(%eax),%edx
    c606:	c7 44 24 08 33 01 00 	movl   $0x133,0x8(%esp)
    c60d:	00 
    c60e:	89 d0                	mov    %edx,%eax
    c610:	ba 00 00 00 00       	mov    $0x0,%edx
    c615:	f7 74 24 08          	divl   0x8(%esp)
    c619:	8b 04 95 a0 1d 02 00 	mov    0x21da0(,%edx,4),%eax
    c620:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c624:	75 30                	jne    c656 <remove_from_queues+0x98>
		hash(bh->b_dev,bh->b_blocknr) = bh->b_next;
    c626:	8b 44 24 10          	mov    0x10(%esp),%eax
    c62a:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c62e:	8b 44 24 10          	mov    0x10(%esp),%eax
    c632:	33 50 04             	xor    0x4(%eax),%edx
    c635:	c7 44 24 08 33 01 00 	movl   $0x133,0x8(%esp)
    c63c:	00 
    c63d:	89 d0                	mov    %edx,%eax
    c63f:	ba 00 00 00 00       	mov    $0x0,%edx
    c644:	f7 74 24 08          	divl   0x8(%esp)
    c648:	8b 44 24 10          	mov    0x10(%esp),%eax
    c64c:	8b 40 18             	mov    0x18(%eax),%eax
    c64f:	89 04 95 a0 1d 02 00 	mov    %eax,0x21da0(,%edx,4)
	if (!(bh->b_prev_free) || !(bh->b_next_free))
    c656:	8b 44 24 10          	mov    0x10(%esp),%eax
    c65a:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
    c65e:	74 0a                	je     c66a <remove_from_queues+0xac>
    c660:	8b 44 24 10          	mov    0x10(%esp),%eax
    c664:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
    c668:	75 10                	jne    c67a <remove_from_queues+0xbc>
		panic("Free block list corrupted");
    c66a:	83 ec 0c             	sub    $0xc,%esp
    c66d:	68 65 8e 01 00       	push   $0x18e65
    c672:	e8 a2 bc ff ff       	call   8319 <panic>
    c677:	83 c4 10             	add    $0x10,%esp
	bh->b_prev_free->b_next_free = bh->b_next_free;
    c67a:	8b 44 24 10          	mov    0x10(%esp),%eax
    c67e:	8b 50 1c             	mov    0x1c(%eax),%edx
    c681:	8b 44 24 10          	mov    0x10(%esp),%eax
    c685:	8b 40 20             	mov    0x20(%eax),%eax
    c688:	89 42 20             	mov    %eax,0x20(%edx)
	bh->b_next_free->b_prev_free = bh->b_prev_free;
    c68b:	8b 44 24 10          	mov    0x10(%esp),%eax
    c68f:	8b 50 20             	mov    0x20(%eax),%edx
    c692:	8b 44 24 10          	mov    0x10(%esp),%eax
    c696:	8b 40 1c             	mov    0x1c(%eax),%eax
    c699:	89 42 1c             	mov    %eax,0x1c(%edx)
	if (free_list == bh)
    c69c:	a1 68 0b 02 00       	mov    0x20b68,%eax
    c6a1:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c6a5:	75 0c                	jne    c6b3 <remove_from_queues+0xf5>
		free_list = bh->b_next_free;
    c6a7:	8b 44 24 10          	mov    0x10(%esp),%eax
    c6ab:	8b 40 20             	mov    0x20(%eax),%eax
    c6ae:	a3 68 0b 02 00       	mov    %eax,0x20b68
}
    c6b3:	83 c4 0c             	add    $0xc,%esp
    c6b6:	c3                   	ret    

0000c6b7 <brelse>:

void brelse(struct buffer_head * buf)
{
    c6b7:	83 ec 0c             	sub    $0xc,%esp
	if (!buf)
    c6ba:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    c6bf:	75 02                	jne    c6c3 <brelse+0xc>
		return;
    c6c1:	eb 3c                	jmp    c6ff <brelse+0x48>
	wait_on_buffer(buf);
    c6c3:	83 ec 0c             	sub    $0xc,%esp
    c6c6:	ff 74 24 1c          	pushl  0x1c(%esp)
    c6ca:	e8 5d f9 ff ff       	call   c02c <wait_on_buffer>
    c6cf:	83 c4 10             	add    $0x10,%esp
	if (!(buf->b_count--))
    c6d2:	8b 44 24 10          	mov    0x10(%esp),%eax
    c6d6:	fe 48 0c             	decb   0xc(%eax)
    c6d9:	80 78 0c ff          	cmpb   $0xff,0xc(%eax)
    c6dd:	75 10                	jne    c6ef <brelse+0x38>
		panic("Trying to free free buffer");
    c6df:	83 ec 0c             	sub    $0xc,%esp
    c6e2:	68 7f 8e 01 00       	push   $0x18e7f
    c6e7:	e8 2d bc ff ff       	call   8319 <panic>
    c6ec:	83 c4 10             	add    $0x10,%esp
	wake_up(&buffer_wait);
    c6ef:	83 ec 0c             	sub    $0xc,%esp
    c6f2:	68 64 0b 02 00       	push   $0x20b64
    c6f7:	e8 a7 a8 ff ff       	call   6fa3 <wake_up>
    c6fc:	83 c4 10             	add    $0x10,%esp
}
    c6ff:	83 c4 0c             	add    $0xc,%esp
    c702:	c3                   	ret    

0000c703 <bread>:
/*
 * bread() reads a specified block and returns the buffer that contains
 * it. It returns NULL if the block was unreadable.
 */
struct buffer_head * bread(int dev,int block)
{
    c703:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))
    c706:	83 ec 08             	sub    $0x8,%esp
    c709:	ff 74 24 1c          	pushl  0x1c(%esp)
    c70d:	ff 74 24 1c          	pushl  0x1c(%esp)
    c711:	e8 42 fc ff ff       	call   c358 <getblk>
    c716:	83 c4 10             	add    $0x10,%esp
    c719:	89 44 24 08          	mov    %eax,0x8(%esp)
    c71d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    c722:	75 10                	jne    c734 <bread+0x31>
		panic("bread: getblk returned NULL\n");
    c724:	83 ec 0c             	sub    $0xc,%esp
    c727:	68 9a 8e 01 00       	push   $0x18e9a
    c72c:	e8 e8 bb ff ff       	call   8319 <panic>
    c731:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
    c734:	8b 44 24 08          	mov    0x8(%esp),%eax
    c738:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c73c:	74 0a                	je     c748 <bread+0x45>
		return bh;
    c73e:	8b 44 24 08          	mov    0x8(%esp),%eax
    c742:	89 44 24 04          	mov    %eax,0x4(%esp)
    c746:	eb 4b                	jmp    c793 <bread+0x90>
	ll_rw_block(READ,bh);
    c748:	83 ec 08             	sub    $0x8,%esp
    c74b:	ff 74 24 10          	pushl  0x10(%esp)
    c74f:	6a 00                	push   $0x0
    c751:	e8 e7 59 00 00       	call   1213d <ll_rw_block>
    c756:	83 c4 10             	add    $0x10,%esp
	wait_on_buffer(bh);
    c759:	83 ec 0c             	sub    $0xc,%esp
    c75c:	ff 74 24 14          	pushl  0x14(%esp)
    c760:	e8 c7 f8 ff ff       	call   c02c <wait_on_buffer>
    c765:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
    c768:	8b 44 24 08          	mov    0x8(%esp),%eax
    c76c:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c770:	74 0a                	je     c77c <bread+0x79>
		return bh;
    c772:	8b 44 24 08          	mov    0x8(%esp),%eax
    c776:	89 44 24 04          	mov    %eax,0x4(%esp)
    c77a:	eb 17                	jmp    c793 <bread+0x90>
	brelse(bh);
    c77c:	83 ec 0c             	sub    $0xc,%esp
    c77f:	ff 74 24 14          	pushl  0x14(%esp)
    c783:	e8 2f ff ff ff       	call   c6b7 <brelse>
    c788:	83 c4 10             	add    $0x10,%esp
	return NULL;
    c78b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    c792:	00 
}
    c793:	8b 44 24 04          	mov    0x4(%esp),%eax
    c797:	83 c4 0c             	add    $0xc,%esp
    c79a:	c3                   	ret    

0000c79b <bread_page>:
 * a function of its own, as there is some speed to be got by reading them
 * all at the same time, not waiting for one to be read, and then another
 * etc.
 */
void bread_page(unsigned long address,int dev,int b[4])
{
    c79b:	57                   	push   %edi
    c79c:	56                   	push   %esi
    c79d:	53                   	push   %ebx
    c79e:	83 ec 20             	sub    $0x20,%esp
	struct buffer_head * bh[4];
	int i;

	for (i=0 ; i<4 ; i++)
    c7a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c7a8:	00 
    c7a9:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
    c7ae:	0f 8f 82 00 00 00    	jg     c836 <bread_page+0x9b>
		if (b[i]) {
    c7b4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c7b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c7bf:	8b 44 24 38          	mov    0x38(%esp),%eax
    c7c3:	83 3c 02 00          	cmpl   $0x0,(%edx,%eax,1)
    c7c7:	74 56                	je     c81f <bread_page+0x84>
			if ((bh[i] = getblk(dev,b[i])))
    c7c9:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
    c7cd:	83 ec 08             	sub    $0x8,%esp
    c7d0:	8b 44 24 14          	mov    0x14(%esp),%eax
    c7d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c7db:	8b 44 24 40          	mov    0x40(%esp),%eax
    c7df:	ff 34 02             	pushl  (%edx,%eax,1)
    c7e2:	ff 74 24 40          	pushl  0x40(%esp)
    c7e6:	e8 6d fb ff ff       	call   c358 <getblk>
    c7eb:	83 c4 10             	add    $0x10,%esp
    c7ee:	89 44 9c 10          	mov    %eax,0x10(%esp,%ebx,4)
    c7f2:	8b 44 9c 10          	mov    0x10(%esp,%ebx,4),%eax
    c7f6:	85 c0                	test   %eax,%eax
    c7f8:	74 31                	je     c82b <bread_page+0x90>
				if (!bh[i]->b_uptodate)
    c7fa:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c7fe:	8b 44 84 10          	mov    0x10(%esp,%eax,4),%eax
    c802:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c806:	75 23                	jne    c82b <bread_page+0x90>
					ll_rw_block(READ,bh[i]);
    c808:	83 ec 08             	sub    $0x8,%esp
    c80b:	8b 44 24 14          	mov    0x14(%esp),%eax
    c80f:	ff 74 84 18          	pushl  0x18(%esp,%eax,4)
    c813:	6a 00                	push   $0x0
    c815:	e8 23 59 00 00       	call   1213d <ll_rw_block>
    c81a:	83 c4 10             	add    $0x10,%esp
    c81d:	eb 0c                	jmp    c82b <bread_page+0x90>
		} else
			bh[i] = NULL;
    c81f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c823:	c7 44 84 10 00 00 00 	movl   $0x0,0x10(%esp,%eax,4)
    c82a:	00 
	for (i=0 ; i<4 ; i++)
    c82b:	8d 44 24 0c          	lea    0xc(%esp),%eax
    c82f:	ff 00                	incl   (%eax)
    c831:	e9 73 ff ff ff       	jmp    c7a9 <bread_page+0xe>
	for (i=0 ; i<4 ; i++,address += BLOCK_SIZE)
    c836:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c83d:	00 
    c83e:	83 7c 24 0c 03       	cmpl   $0x3,0xc(%esp)
    c843:	7f 65                	jg     c8aa <bread_page+0x10f>
		if (bh[i]) {
    c845:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c849:	83 7c 84 10 00       	cmpl   $0x0,0x10(%esp,%eax,4)
    c84e:	74 4a                	je     c89a <bread_page+0xff>
			wait_on_buffer(bh[i]);
    c850:	83 ec 0c             	sub    $0xc,%esp
    c853:	8b 44 24 18          	mov    0x18(%esp),%eax
    c857:	ff 74 84 1c          	pushl  0x1c(%esp,%eax,4)
    c85b:	e8 cc f7 ff ff       	call   c02c <wait_on_buffer>
    c860:	83 c4 10             	add    $0x10,%esp
			if (bh[i]->b_uptodate)
    c863:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c867:	8b 44 84 10          	mov    0x10(%esp,%eax,4),%eax
    c86b:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c86f:	74 16                	je     c887 <bread_page+0xec>
				COPYBLK((unsigned long) bh[i]->b_data,address);
    c871:	b9 00 01 00 00       	mov    $0x100,%ecx
    c876:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c87a:	8b 44 84 10          	mov    0x10(%esp,%eax,4),%eax
    c87e:	8b 30                	mov    (%eax),%esi
    c880:	8b 7c 24 30          	mov    0x30(%esp),%edi
    c884:	fc                   	cld    
    c885:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			brelse(bh[i]);
    c887:	83 ec 0c             	sub    $0xc,%esp
    c88a:	8b 44 24 18          	mov    0x18(%esp),%eax
    c88e:	ff 74 84 1c          	pushl  0x1c(%esp,%eax,4)
    c892:	e8 20 fe ff ff       	call   c6b7 <brelse>
    c897:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<4 ; i++,address += BLOCK_SIZE)
    c89a:	8d 44 24 0c          	lea    0xc(%esp),%eax
    c89e:	ff 00                	incl   (%eax)
    c8a0:	81 44 24 30 00 04 00 	addl   $0x400,0x30(%esp)
    c8a7:	00 
    c8a8:	eb 94                	jmp    c83e <bread_page+0xa3>
		}
}
    c8aa:	83 c4 20             	add    $0x20,%esp
    c8ad:	5b                   	pop    %ebx
    c8ae:	5e                   	pop    %esi
    c8af:	5f                   	pop    %edi
    c8b0:	c3                   	ret    

0000c8b1 <breada>:
 * Ok, breada can be used as bread, but additionally to mark other
 * blocks for reading as well. End the argument list with a negative
 * number.
 */
struct buffer_head * breada(int dev,int first, ...)
{
    c8b1:	83 ec 1c             	sub    $0x1c,%esp
	va_list args;
	struct buffer_head * bh, *tmp;

	va_start(args,first);
    c8b4:	8d 44 24 24          	lea    0x24(%esp),%eax
    c8b8:	83 c0 04             	add    $0x4,%eax
    c8bb:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!(bh=getblk(dev,first)))
    c8bf:	83 ec 08             	sub    $0x8,%esp
    c8c2:	ff 74 24 2c          	pushl  0x2c(%esp)
    c8c6:	ff 74 24 2c          	pushl  0x2c(%esp)
    c8ca:	e8 89 fa ff ff       	call   c358 <getblk>
    c8cf:	83 c4 10             	add    $0x10,%esp
    c8d2:	89 44 24 14          	mov    %eax,0x14(%esp)
    c8d6:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    c8db:	75 10                	jne    c8ed <breada+0x3c>
		panic("bread: getblk returned NULL\n");
    c8dd:	83 ec 0c             	sub    $0xc,%esp
    c8e0:	68 9a 8e 01 00       	push   $0x18e9a
    c8e5:	e8 2f ba ff ff       	call   8319 <panic>
    c8ea:	83 c4 10             	add    $0x10,%esp
	if (!bh->b_uptodate)
    c8ed:	8b 44 24 14          	mov    0x14(%esp),%eax
    c8f1:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c8f5:	75 11                	jne    c908 <breada+0x57>
		ll_rw_block(READ,bh);
    c8f7:	83 ec 08             	sub    $0x8,%esp
    c8fa:	ff 74 24 1c          	pushl  0x1c(%esp)
    c8fe:	6a 00                	push   $0x0
    c900:	e8 38 58 00 00       	call   1213d <ll_rw_block>
    c905:	83 c4 10             	add    $0x10,%esp
	while ((first=va_arg(args,int))>=0) {
    c908:	8d 44 24 18          	lea    0x18(%esp),%eax
    c90c:	83 00 04             	addl   $0x4,(%eax)
    c90f:	8b 44 24 18          	mov    0x18(%esp),%eax
    c913:	83 e8 04             	sub    $0x4,%eax
    c916:	8b 00                	mov    (%eax),%eax
    c918:	89 44 24 24          	mov    %eax,0x24(%esp)
    c91c:	85 c0                	test   %eax,%eax
    c91e:	78 42                	js     c962 <breada+0xb1>
		tmp=getblk(dev,first);
    c920:	83 ec 08             	sub    $0x8,%esp
    c923:	ff 74 24 2c          	pushl  0x2c(%esp)
    c927:	ff 74 24 2c          	pushl  0x2c(%esp)
    c92b:	e8 28 fa ff ff       	call   c358 <getblk>
    c930:	83 c4 10             	add    $0x10,%esp
    c933:	89 44 24 10          	mov    %eax,0x10(%esp)
		if (tmp) {
    c937:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    c93c:	74 ca                	je     c908 <breada+0x57>
			if (!tmp->b_uptodate)
    c93e:	8b 44 24 10          	mov    0x10(%esp),%eax
    c942:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c946:	75 11                	jne    c959 <breada+0xa8>
				ll_rw_block(READA,bh);
    c948:	83 ec 08             	sub    $0x8,%esp
    c94b:	ff 74 24 1c          	pushl  0x1c(%esp)
    c94f:	6a 02                	push   $0x2
    c951:	e8 e7 57 00 00       	call   1213d <ll_rw_block>
    c956:	83 c4 10             	add    $0x10,%esp
			tmp->b_count--;
    c959:	8b 44 24 10          	mov    0x10(%esp),%eax
    c95d:	fe 48 0c             	decb   0xc(%eax)
    c960:	eb a6                	jmp    c908 <breada+0x57>
		}
	}
	va_end(args);
	wait_on_buffer(bh);
    c962:	83 ec 0c             	sub    $0xc,%esp
    c965:	ff 74 24 20          	pushl  0x20(%esp)
    c969:	e8 be f6 ff ff       	call   c02c <wait_on_buffer>
    c96e:	83 c4 10             	add    $0x10,%esp
	if (bh->b_uptodate)
    c971:	8b 44 24 14          	mov    0x14(%esp),%eax
    c975:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c979:	74 0a                	je     c985 <breada+0xd4>
		return bh;
    c97b:	8b 44 24 14          	mov    0x14(%esp),%eax
    c97f:	89 44 24 0c          	mov    %eax,0xc(%esp)
    c983:	eb 17                	jmp    c99c <breada+0xeb>
	brelse(bh);
    c985:	83 ec 0c             	sub    $0xc,%esp
    c988:	ff 74 24 20          	pushl  0x20(%esp)
    c98c:	e8 26 fd ff ff       	call   c6b7 <brelse>
    c991:	83 c4 10             	add    $0x10,%esp
	return (NULL);
    c994:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    c99b:	00 
}
    c99c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    c9a0:	83 c4 1c             	add    $0x1c,%esp
    c9a3:	c3                   	ret    

0000c9a4 <buffer_init>:

void buffer_init(long buffer_end)
{
    c9a4:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * h = start_buffer;
    c9a7:	a1 e4 bd 01 00       	mov    0x1bde4,%eax
    c9ac:	89 44 24 08          	mov    %eax,0x8(%esp)
	void * b;
	int i;

	if (buffer_end == 1<<20)
    c9b0:	81 7c 24 10 00 00 10 	cmpl   $0x100000,0x10(%esp)
    c9b7:	00 
    c9b8:	75 0a                	jne    c9c4 <buffer_init+0x20>
		b = (void *) (640*1024);
    c9ba:	c7 44 24 04 00 00 0a 	movl   $0xa0000,0x4(%esp)
    c9c1:	00 
    c9c2:	eb 08                	jmp    c9cc <buffer_init+0x28>
	else
		b = (void *) buffer_end;
    c9c4:	8b 44 24 10          	mov    0x10(%esp),%eax
    c9c8:	89 44 24 04          	mov    %eax,0x4(%esp)
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
    c9cc:	8d 44 24 04          	lea    0x4(%esp),%eax
    c9d0:	81 28 00 04 00 00    	subl   $0x400,(%eax)
    c9d6:	8b 54 24 04          	mov    0x4(%esp),%edx
    c9da:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9de:	83 c0 24             	add    $0x24,%eax
    c9e1:	39 c2                	cmp    %eax,%edx
    c9e3:	0f 82 99 00 00 00    	jb     ca82 <buffer_init+0xde>
		h->b_dev = 0;
    c9e9:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9ed:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		h->b_dirt = 0;
    c9f3:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9f7:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
		h->b_count = 0;
    c9fb:	8b 44 24 08          	mov    0x8(%esp),%eax
    c9ff:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
		h->b_lock = 0;
    ca03:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca07:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		h->b_uptodate = 0;
    ca0b:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca0f:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
		h->b_wait = NULL;
    ca13:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca17:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		h->b_next = NULL;
    ca1e:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca22:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		h->b_prev = NULL;
    ca29:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca2d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
		h->b_data = (char *) b;
    ca34:	8b 54 24 08          	mov    0x8(%esp),%edx
    ca38:	8b 44 24 04          	mov    0x4(%esp),%eax
    ca3c:	89 02                	mov    %eax,(%edx)
		h->b_prev_free = h-1;
    ca3e:	8b 54 24 08          	mov    0x8(%esp),%edx
    ca42:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca46:	83 e8 24             	sub    $0x24,%eax
    ca49:	89 42 1c             	mov    %eax,0x1c(%edx)
		h->b_next_free = h+1;
    ca4c:	8b 54 24 08          	mov    0x8(%esp),%edx
    ca50:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca54:	83 c0 24             	add    $0x24,%eax
    ca57:	89 42 20             	mov    %eax,0x20(%edx)
		h++;
    ca5a:	8d 44 24 08          	lea    0x8(%esp),%eax
    ca5e:	83 00 24             	addl   $0x24,(%eax)
		NR_BUFFERS++;
    ca61:	ff 05 60 0b 02 00    	incl   0x20b60
		if (b == (void *) 0x100000)
    ca67:	81 7c 24 04 00 00 10 	cmpl   $0x100000,0x4(%esp)
    ca6e:	00 
    ca6f:	0f 85 57 ff ff ff    	jne    c9cc <buffer_init+0x28>
			b = (void *) 0xA0000;
    ca75:	c7 44 24 04 00 00 0a 	movl   $0xa0000,0x4(%esp)
    ca7c:	00 
    ca7d:	e9 4a ff ff ff       	jmp    c9cc <buffer_init+0x28>
	}
	h--;
    ca82:	8d 44 24 08          	lea    0x8(%esp),%eax
    ca86:	83 28 24             	subl   $0x24,(%eax)
	free_list = start_buffer;
    ca89:	a1 e4 bd 01 00       	mov    0x1bde4,%eax
    ca8e:	a3 68 0b 02 00       	mov    %eax,0x20b68
	free_list->b_prev_free = h;
    ca93:	8b 15 68 0b 02 00    	mov    0x20b68,%edx
    ca99:	8b 44 24 08          	mov    0x8(%esp),%eax
    ca9d:	89 42 1c             	mov    %eax,0x1c(%edx)
	h->b_next_free = free_list;
    caa0:	8b 54 24 08          	mov    0x8(%esp),%edx
    caa4:	a1 68 0b 02 00       	mov    0x20b68,%eax
    caa9:	89 42 20             	mov    %eax,0x20(%edx)
	for (i=0;i<NR_HASH;i++)
    caac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    cab3:	81 3c 24 32 01 00 00 	cmpl   $0x132,(%esp)
    caba:	7f 14                	jg     cad0 <buffer_init+0x12c>
		hash_table[i]=NULL;
    cabc:	8b 04 24             	mov    (%esp),%eax
    cabf:	c7 04 85 a0 1d 02 00 	movl   $0x0,0x21da0(,%eax,4)
    cac6:	00 00 00 00 
	for (i=0;i<NR_HASH;i++)
    caca:	89 e0                	mov    %esp,%eax
    cacc:	ff 00                	incl   (%eax)
    cace:	eb e3                	jmp    cab3 <buffer_init+0x10f>
}	
    cad0:	83 c4 0c             	add    $0xc,%esp
    cad3:	c3                   	ret    

0000cad4 <lock_super>:
struct super_block super_block[NR_SUPER];
/* this is initialized in init/main.c */
int ROOT_DEV = 0;

static void lock_super(struct super_block * sb)
{
    cad4:	83 ec 0c             	sub    $0xc,%esp
	cli();
    cad7:	fa                   	cli    
	while (sb->s_lock)
    cad8:	8b 44 24 10          	mov    0x10(%esp),%eax
    cadc:	80 78 68 00          	cmpb   $0x0,0x68(%eax)
    cae0:	74 15                	je     caf7 <lock_super+0x23>
		sleep_on(&(sb->s_wait));
    cae2:	83 ec 0c             	sub    $0xc,%esp
    cae5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cae9:	83 c0 64             	add    $0x64,%eax
    caec:	50                   	push   %eax
    caed:	e8 93 a1 ff ff       	call   6c85 <sleep_on>
    caf2:	83 c4 10             	add    $0x10,%esp
    caf5:	eb e1                	jmp    cad8 <lock_super+0x4>
	sb->s_lock = 1;
    caf7:	8b 44 24 10          	mov    0x10(%esp),%eax
    cafb:	c6 40 68 01          	movb   $0x1,0x68(%eax)
	sti();
    caff:	fb                   	sti    
}
    cb00:	83 c4 0c             	add    $0xc,%esp
    cb03:	c3                   	ret    

0000cb04 <free_super>:

static void free_super(struct super_block * sb)
{
    cb04:	83 ec 0c             	sub    $0xc,%esp
	cli();
    cb07:	fa                   	cli    
	sb->s_lock = 0;
    cb08:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb0c:	c6 40 68 00          	movb   $0x0,0x68(%eax)
	wake_up(&(sb->s_wait));
    cb10:	83 ec 0c             	sub    $0xc,%esp
    cb13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cb17:	83 c0 64             	add    $0x64,%eax
    cb1a:	50                   	push   %eax
    cb1b:	e8 83 a4 ff ff       	call   6fa3 <wake_up>
    cb20:	83 c4 10             	add    $0x10,%esp
	sti();
    cb23:	fb                   	sti    
}
    cb24:	83 c4 0c             	add    $0xc,%esp
    cb27:	c3                   	ret    

0000cb28 <wait_on_super>:

static void wait_on_super(struct super_block * sb)
{
    cb28:	83 ec 0c             	sub    $0xc,%esp
	cli();
    cb2b:	fa                   	cli    
	while (sb->s_lock)
    cb2c:	8b 44 24 10          	mov    0x10(%esp),%eax
    cb30:	80 78 68 00          	cmpb   $0x0,0x68(%eax)
    cb34:	74 15                	je     cb4b <wait_on_super+0x23>
		sleep_on(&(sb->s_wait));
    cb36:	83 ec 0c             	sub    $0xc,%esp
    cb39:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cb3d:	83 c0 64             	add    $0x64,%eax
    cb40:	50                   	push   %eax
    cb41:	e8 3f a1 ff ff       	call   6c85 <sleep_on>
    cb46:	83 c4 10             	add    $0x10,%esp
    cb49:	eb e1                	jmp    cb2c <wait_on_super+0x4>
	sti();
    cb4b:	fb                   	sti    
}
    cb4c:	83 c4 0c             	add    $0xc,%esp
    cb4f:	c3                   	ret    

0000cb50 <get_super>:

struct super_block * get_super(int dev)
{
    cb50:	83 ec 0c             	sub    $0xc,%esp
	struct super_block * s;

	if (!dev)
    cb53:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    cb58:	75 0a                	jne    cb64 <get_super+0x14>
		return NULL;
    cb5a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    cb61:	00 
    cb62:	eb 62                	jmp    cbc6 <get_super+0x76>
	s = 0+super_block;
    cb64:	c7 44 24 08 80 22 02 	movl   $0x22280,0x8(%esp)
    cb6b:	00 
	while (s < NR_SUPER+super_block)
    cb6c:	81 7c 24 08 e0 25 02 	cmpl   $0x225e0,0x8(%esp)
    cb73:	00 
    cb74:	73 48                	jae    cbbe <get_super+0x6e>
		if (s->s_dev == dev) {
    cb76:	8b 44 24 08          	mov    0x8(%esp),%eax
    cb7a:	0f b7 40 54          	movzwl 0x54(%eax),%eax
    cb7e:	3b 44 24 10          	cmp    0x10(%esp),%eax
    cb82:	75 31                	jne    cbb5 <get_super+0x65>
			wait_on_super(s);
    cb84:	83 ec 0c             	sub    $0xc,%esp
    cb87:	ff 74 24 14          	pushl  0x14(%esp)
    cb8b:	e8 98 ff ff ff       	call   cb28 <wait_on_super>
    cb90:	83 c4 10             	add    $0x10,%esp
			if (s->s_dev == dev)
    cb93:	8b 44 24 08          	mov    0x8(%esp),%eax
    cb97:	0f b7 40 54          	movzwl 0x54(%eax),%eax
    cb9b:	3b 44 24 10          	cmp    0x10(%esp),%eax
    cb9f:	75 0a                	jne    cbab <get_super+0x5b>
				return s;
    cba1:	8b 44 24 08          	mov    0x8(%esp),%eax
    cba5:	89 44 24 04          	mov    %eax,0x4(%esp)
    cba9:	eb 1b                	jmp    cbc6 <get_super+0x76>
			s = 0+super_block;
    cbab:	c7 44 24 08 80 22 02 	movl   $0x22280,0x8(%esp)
    cbb2:	00 
    cbb3:	eb b7                	jmp    cb6c <get_super+0x1c>
		} else
			s++;
    cbb5:	8d 44 24 08          	lea    0x8(%esp),%eax
    cbb9:	83 00 6c             	addl   $0x6c,(%eax)
    cbbc:	eb ae                	jmp    cb6c <get_super+0x1c>
	return NULL;
    cbbe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    cbc5:	00 
}
    cbc6:	8b 44 24 04          	mov    0x4(%esp),%eax
    cbca:	83 c4 0c             	add    $0xc,%esp
    cbcd:	c3                   	ret    

0000cbce <put_super>:

void put_super(int dev)
{
    cbce:	83 ec 0c             	sub    $0xc,%esp
	struct super_block * sb;
	/* struct m_inode * inode;*/
	int i;

	if (dev == ROOT_DEV) {
    cbd1:	8b 44 24 10          	mov    0x10(%esp),%eax
    cbd5:	3b 05 6c 0b 02 00    	cmp    0x20b6c,%eax
    cbdb:	75 15                	jne    cbf2 <put_super+0x24>
		printk("root diskette changed: prepare for armageddon\n\r");
    cbdd:	83 ec 0c             	sub    $0xc,%esp
    cbe0:	68 b8 8e 01 00       	push   $0x18eb8
    cbe5:	e8 69 b7 ff ff       	call   8353 <printk>
    cbea:	83 c4 10             	add    $0x10,%esp
		return;
    cbed:	e9 c2 00 00 00       	jmp    ccb4 <put_super+0xe6>
	}
	if (!(sb = get_super(dev)))
    cbf2:	83 ec 0c             	sub    $0xc,%esp
    cbf5:	ff 74 24 1c          	pushl  0x1c(%esp)
    cbf9:	e8 52 ff ff ff       	call   cb50 <get_super>
    cbfe:	83 c4 10             	add    $0x10,%esp
    cc01:	89 44 24 08          	mov    %eax,0x8(%esp)
    cc05:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cc0a:	75 05                	jne    cc11 <put_super+0x43>
		return;
    cc0c:	e9 a3 00 00 00       	jmp    ccb4 <put_super+0xe6>
	if (sb->s_imount) {
    cc11:	8b 44 24 08          	mov    0x8(%esp),%eax
    cc15:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
    cc19:	74 15                	je     cc30 <put_super+0x62>
		printk("Mounted disk changed - tssk, tssk\n\r");
    cc1b:	83 ec 0c             	sub    $0xc,%esp
    cc1e:	68 e8 8e 01 00       	push   $0x18ee8
    cc23:	e8 2b b7 ff ff       	call   8353 <printk>
    cc28:	83 c4 10             	add    $0x10,%esp
		return;
    cc2b:	e9 84 00 00 00       	jmp    ccb4 <put_super+0xe6>
	}
	lock_super(sb);
    cc30:	83 ec 0c             	sub    $0xc,%esp
    cc33:	ff 74 24 14          	pushl  0x14(%esp)
    cc37:	e8 98 fe ff ff       	call   cad4 <lock_super>
    cc3c:	83 c4 10             	add    $0x10,%esp
	sb->s_dev = 0;
    cc3f:	8b 44 24 08          	mov    0x8(%esp),%eax
    cc43:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
	for(i=0;i<I_MAP_SLOTS;i++)
    cc49:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    cc50:	00 
    cc51:	83 7c 24 04 07       	cmpl   $0x7,0x4(%esp)
    cc56:	7f 1f                	jg     cc77 <put_super+0xa9>
		brelse(sb->s_imap[i]);
    cc58:	83 ec 0c             	sub    $0xc,%esp
    cc5b:	8b 54 24 14          	mov    0x14(%esp),%edx
    cc5f:	8b 44 24 10          	mov    0x10(%esp),%eax
    cc63:	ff 74 82 14          	pushl  0x14(%edx,%eax,4)
    cc67:	e8 4b fa ff ff       	call   c6b7 <brelse>
    cc6c:	83 c4 10             	add    $0x10,%esp
	for(i=0;i<I_MAP_SLOTS;i++)
    cc6f:	8d 44 24 04          	lea    0x4(%esp),%eax
    cc73:	ff 00                	incl   (%eax)
    cc75:	eb da                	jmp    cc51 <put_super+0x83>
	for(i=0;i<Z_MAP_SLOTS;i++)
    cc77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    cc7e:	00 
    cc7f:	83 7c 24 04 07       	cmpl   $0x7,0x4(%esp)
    cc84:	7f 1f                	jg     cca5 <put_super+0xd7>
		brelse(sb->s_zmap[i]);
    cc86:	83 ec 0c             	sub    $0xc,%esp
    cc89:	8b 54 24 14          	mov    0x14(%esp),%edx
    cc8d:	8b 44 24 10          	mov    0x10(%esp),%eax
    cc91:	ff 74 82 34          	pushl  0x34(%edx,%eax,4)
    cc95:	e8 1d fa ff ff       	call   c6b7 <brelse>
    cc9a:	83 c4 10             	add    $0x10,%esp
	for(i=0;i<Z_MAP_SLOTS;i++)
    cc9d:	8d 44 24 04          	lea    0x4(%esp),%eax
    cca1:	ff 00                	incl   (%eax)
    cca3:	eb da                	jmp    cc7f <put_super+0xb1>
	free_super(sb);
    cca5:	83 ec 0c             	sub    $0xc,%esp
    cca8:	ff 74 24 14          	pushl  0x14(%esp)
    ccac:	e8 53 fe ff ff       	call   cb04 <free_super>
    ccb1:	83 c4 10             	add    $0x10,%esp
	return;
}
    ccb4:	83 c4 0c             	add    $0xc,%esp
    ccb7:	c3                   	ret    

0000ccb8 <read_super>:

static struct super_block * read_super(int dev)
{
    ccb8:	57                   	push   %edi
    ccb9:	56                   	push   %esi
    ccba:	53                   	push   %ebx
    ccbb:	83 ec 20             	sub    $0x20,%esp
	struct super_block * s;
	struct buffer_head * bh;
	int i,block;

	if (!dev)
    ccbe:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
    ccc3:	75 0d                	jne    ccd2 <read_super+0x1a>
		return NULL;
    ccc5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    cccc:	00 
    cccd:	e9 22 03 00 00       	jmp    cff4 <read_super+0x33c>
	check_disk_change(dev);
    ccd2:	83 ec 0c             	sub    $0xc,%esp
    ccd5:	ff 74 24 3c          	pushl  0x3c(%esp)
    ccd9:	e8 df f4 ff ff       	call   c1bd <check_disk_change>
    ccde:	83 c4 10             	add    $0x10,%esp
	if ((s = get_super(dev)))
    cce1:	83 ec 0c             	sub    $0xc,%esp
    cce4:	ff 74 24 3c          	pushl  0x3c(%esp)
    cce8:	e8 63 fe ff ff       	call   cb50 <get_super>
    cced:	83 c4 10             	add    $0x10,%esp
    ccf0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    ccf4:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    ccf9:	74 0d                	je     cd08 <read_super+0x50>
		return s;
    ccfb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ccff:	89 44 24 0c          	mov    %eax,0xc(%esp)
    cd03:	e9 ec 02 00 00       	jmp    cff4 <read_super+0x33c>
	for (s = 0+super_block ;; s++) {
    cd08:	c7 44 24 1c 80 22 02 	movl   $0x22280,0x1c(%esp)
    cd0f:	00 
		if (s >= NR_SUPER+super_block)
    cd10:	81 7c 24 1c e0 25 02 	cmpl   $0x225e0,0x1c(%esp)
    cd17:	00 
    cd18:	72 0d                	jb     cd27 <read_super+0x6f>
			return NULL;
    cd1a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    cd21:	00 
    cd22:	e9 cd 02 00 00       	jmp    cff4 <read_super+0x33c>
		if (!s->s_dev)
    cd27:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd2b:	66 83 78 54 00       	cmpw   $0x0,0x54(%eax)
    cd30:	75 02                	jne    cd34 <read_super+0x7c>
			break;
    cd32:	eb 09                	jmp    cd3d <read_super+0x85>
	for (s = 0+super_block ;; s++) {
    cd34:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    cd38:	83 00 6c             	addl   $0x6c,(%eax)
    cd3b:	eb d3                	jmp    cd10 <read_super+0x58>
	}
	s->s_dev = dev;
    cd3d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    cd41:	8b 44 24 30          	mov    0x30(%esp),%eax
    cd45:	66 89 42 54          	mov    %ax,0x54(%edx)
	s->s_isup = NULL;
    cd49:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd4d:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	s->s_imount = NULL;
    cd54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd58:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
	s->s_time = 0;
    cd5f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd63:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	s->s_rd_only = 0;
    cd6a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd6e:	c6 40 69 00          	movb   $0x0,0x69(%eax)
	s->s_dirt = 0;
    cd72:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cd76:	c6 40 6a 00          	movb   $0x0,0x6a(%eax)
	lock_super(s);
    cd7a:	83 ec 0c             	sub    $0xc,%esp
    cd7d:	ff 74 24 28          	pushl  0x28(%esp)
    cd81:	e8 4e fd ff ff       	call   cad4 <lock_super>
    cd86:	83 c4 10             	add    $0x10,%esp
	if (!(bh = bread(dev,1))) {
    cd89:	83 ec 08             	sub    $0x8,%esp
    cd8c:	6a 01                	push   $0x1
    cd8e:	ff 74 24 3c          	pushl  0x3c(%esp)
    cd92:	e8 6c f9 ff ff       	call   c703 <bread>
    cd97:	83 c4 10             	add    $0x10,%esp
    cd9a:	89 44 24 18          	mov    %eax,0x18(%esp)
    cd9e:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    cda3:	75 26                	jne    cdcb <read_super+0x113>
		s->s_dev=0;
    cda5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cda9:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
    cdaf:	83 ec 0c             	sub    $0xc,%esp
    cdb2:	ff 74 24 28          	pushl  0x28(%esp)
    cdb6:	e8 49 fd ff ff       	call   cb04 <free_super>
    cdbb:	83 c4 10             	add    $0x10,%esp
		return NULL;
    cdbe:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    cdc5:	00 
    cdc6:	e9 29 02 00 00       	jmp    cff4 <read_super+0x33c>
	}
	*((struct d_super_block *) s) =
    cdcb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    cdcf:	8b 44 24 18          	mov    0x18(%esp),%eax
    cdd3:	8b 00                	mov    (%eax),%eax
    cdd5:	89 d7                	mov    %edx,%edi
    cdd7:	89 c6                	mov    %eax,%esi
    cdd9:	fc                   	cld    
    cdda:	b8 05 00 00 00       	mov    $0x5,%eax
    cddf:	89 c1                	mov    %eax,%ecx
    cde1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		*((struct d_super_block *) bh->b_data);
	brelse(bh);
    cde3:	83 ec 0c             	sub    $0xc,%esp
    cde6:	ff 74 24 24          	pushl  0x24(%esp)
    cdea:	e8 c8 f8 ff ff       	call   c6b7 <brelse>
    cdef:	83 c4 10             	add    $0x10,%esp
	if (s->s_magic != SUPER_MAGIC) {
    cdf2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cdf6:	66 81 78 10 7f 13    	cmpw   $0x137f,0x10(%eax)
    cdfc:	74 26                	je     ce24 <read_super+0x16c>
		s->s_dev = 0;
    cdfe:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ce02:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
    ce08:	83 ec 0c             	sub    $0xc,%esp
    ce0b:	ff 74 24 28          	pushl  0x28(%esp)
    ce0f:	e8 f0 fc ff ff       	call   cb04 <free_super>
    ce14:	83 c4 10             	add    $0x10,%esp
		return NULL;
    ce17:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    ce1e:	00 
    ce1f:	e9 d0 01 00 00       	jmp    cff4 <read_super+0x33c>
	}
	for (i=0;i<I_MAP_SLOTS;i++)
    ce24:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    ce2b:	00 
    ce2c:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
    ce31:	7f 18                	jg     ce4b <read_super+0x193>
		s->s_imap[i] = NULL;
    ce33:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    ce37:	8b 44 24 14          	mov    0x14(%esp),%eax
    ce3b:	c7 44 82 14 00 00 00 	movl   $0x0,0x14(%edx,%eax,4)
    ce42:	00 
	for (i=0;i<I_MAP_SLOTS;i++)
    ce43:	8d 44 24 14          	lea    0x14(%esp),%eax
    ce47:	ff 00                	incl   (%eax)
    ce49:	eb e1                	jmp    ce2c <read_super+0x174>
	for (i=0;i<Z_MAP_SLOTS;i++)
    ce4b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    ce52:	00 
    ce53:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
    ce58:	7f 18                	jg     ce72 <read_super+0x1ba>
		s->s_zmap[i] = NULL;
    ce5a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    ce5e:	8b 44 24 14          	mov    0x14(%esp),%eax
    ce62:	c7 44 82 34 00 00 00 	movl   $0x0,0x34(%edx,%eax,4)
    ce69:	00 
	for (i=0;i<Z_MAP_SLOTS;i++)
    ce6a:	8d 44 24 14          	lea    0x14(%esp),%eax
    ce6e:	ff 00                	incl   (%eax)
    ce70:	eb e1                	jmp    ce53 <read_super+0x19b>
	block=2;
    ce72:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
    ce79:	00 
	for (i=0 ; i < s->s_imap_blocks ; i++)
    ce7a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    ce81:	00 
    ce82:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ce86:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    ce8a:	3b 44 24 14          	cmp    0x14(%esp),%eax
    ce8e:	7e 35                	jle    cec5 <read_super+0x20d>
		if ((s->s_imap[i]=bread(dev,block)))
    ce90:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    ce94:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    ce98:	83 ec 08             	sub    $0x8,%esp
    ce9b:	ff 74 24 18          	pushl  0x18(%esp)
    ce9f:	ff 74 24 3c          	pushl  0x3c(%esp)
    cea3:	e8 5b f8 ff ff       	call   c703 <bread>
    cea8:	83 c4 10             	add    $0x10,%esp
    ceab:	89 44 9e 14          	mov    %eax,0x14(%esi,%ebx,4)
    ceaf:	8b 44 9e 14          	mov    0x14(%esi,%ebx,4),%eax
    ceb3:	85 c0                	test   %eax,%eax
    ceb5:	74 0e                	je     cec5 <read_super+0x20d>
			block++;
    ceb7:	8d 44 24 10          	lea    0x10(%esp),%eax
    cebb:	ff 00                	incl   (%eax)
	for (i=0 ; i < s->s_imap_blocks ; i++)
    cebd:	8d 44 24 14          	lea    0x14(%esp),%eax
    cec1:	ff 00                	incl   (%eax)
    cec3:	eb bd                	jmp    ce82 <read_super+0x1ca>
		else
			break;
	for (i=0 ; i < s->s_zmap_blocks ; i++)
    cec5:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    cecc:	00 
    cecd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ced1:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    ced5:	3b 44 24 14          	cmp    0x14(%esp),%eax
    ced9:	7e 35                	jle    cf10 <read_super+0x258>
		if ((s->s_zmap[i]=bread(dev,block)))
    cedb:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    cedf:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    cee3:	83 ec 08             	sub    $0x8,%esp
    cee6:	ff 74 24 18          	pushl  0x18(%esp)
    ceea:	ff 74 24 3c          	pushl  0x3c(%esp)
    ceee:	e8 10 f8 ff ff       	call   c703 <bread>
    cef3:	83 c4 10             	add    $0x10,%esp
    cef6:	89 44 9e 34          	mov    %eax,0x34(%esi,%ebx,4)
    cefa:	8b 44 9e 34          	mov    0x34(%esi,%ebx,4),%eax
    cefe:	85 c0                	test   %eax,%eax
    cf00:	74 0e                	je     cf10 <read_super+0x258>
			block++;
    cf02:	8d 44 24 10          	lea    0x10(%esp),%eax
    cf06:	ff 00                	incl   (%eax)
	for (i=0 ; i < s->s_zmap_blocks ; i++)
    cf08:	8d 44 24 14          	lea    0x14(%esp),%eax
    cf0c:	ff 00                	incl   (%eax)
    cf0e:	eb bd                	jmp    cecd <read_super+0x215>
		else
			break;
	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
    cf10:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cf14:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    cf18:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cf1c:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    cf20:	8d 04 02             	lea    (%edx,%eax,1),%eax
    cf23:	83 c0 02             	add    $0x2,%eax
    cf26:	3b 44 24 10          	cmp    0x10(%esp),%eax
    cf2a:	74 7f                	je     cfab <read_super+0x2f3>
		for(i=0;i<I_MAP_SLOTS;i++)
    cf2c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    cf33:	00 
    cf34:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
    cf39:	7f 1f                	jg     cf5a <read_super+0x2a2>
			brelse(s->s_imap[i]);
    cf3b:	83 ec 0c             	sub    $0xc,%esp
    cf3e:	8b 54 24 28          	mov    0x28(%esp),%edx
    cf42:	8b 44 24 20          	mov    0x20(%esp),%eax
    cf46:	ff 74 82 14          	pushl  0x14(%edx,%eax,4)
    cf4a:	e8 68 f7 ff ff       	call   c6b7 <brelse>
    cf4f:	83 c4 10             	add    $0x10,%esp
		for(i=0;i<I_MAP_SLOTS;i++)
    cf52:	8d 44 24 14          	lea    0x14(%esp),%eax
    cf56:	ff 00                	incl   (%eax)
    cf58:	eb da                	jmp    cf34 <read_super+0x27c>
		for(i=0;i<Z_MAP_SLOTS;i++)
    cf5a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    cf61:	00 
    cf62:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
    cf67:	7f 1f                	jg     cf88 <read_super+0x2d0>
			brelse(s->s_zmap[i]);
    cf69:	83 ec 0c             	sub    $0xc,%esp
    cf6c:	8b 54 24 28          	mov    0x28(%esp),%edx
    cf70:	8b 44 24 20          	mov    0x20(%esp),%eax
    cf74:	ff 74 82 34          	pushl  0x34(%edx,%eax,4)
    cf78:	e8 3a f7 ff ff       	call   c6b7 <brelse>
    cf7d:	83 c4 10             	add    $0x10,%esp
		for(i=0;i<Z_MAP_SLOTS;i++)
    cf80:	8d 44 24 14          	lea    0x14(%esp),%eax
    cf84:	ff 00                	incl   (%eax)
    cf86:	eb da                	jmp    cf62 <read_super+0x2aa>
		s->s_dev=0;
    cf88:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cf8c:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		free_super(s);
    cf92:	83 ec 0c             	sub    $0xc,%esp
    cf95:	ff 74 24 28          	pushl  0x28(%esp)
    cf99:	e8 66 fb ff ff       	call   cb04 <free_super>
    cf9e:	83 c4 10             	add    $0x10,%esp
		return NULL;
    cfa1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    cfa8:	00 
    cfa9:	eb 49                	jmp    cff4 <read_super+0x33c>
	}
	s->s_imap[0]->b_data[0] |= 1;
    cfab:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cfaf:	8b 40 14             	mov    0x14(%eax),%eax
    cfb2:	8b 10                	mov    (%eax),%edx
    cfb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cfb8:	8b 40 14             	mov    0x14(%eax),%eax
    cfbb:	8b 00                	mov    (%eax),%eax
    cfbd:	8a 00                	mov    (%eax),%al
    cfbf:	83 c8 01             	or     $0x1,%eax
    cfc2:	88 02                	mov    %al,(%edx)
	s->s_zmap[0]->b_data[0] |= 1;
    cfc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cfc8:	8b 40 34             	mov    0x34(%eax),%eax
    cfcb:	8b 10                	mov    (%eax),%edx
    cfcd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cfd1:	8b 40 34             	mov    0x34(%eax),%eax
    cfd4:	8b 00                	mov    (%eax),%eax
    cfd6:	8a 00                	mov    (%eax),%al
    cfd8:	83 c8 01             	or     $0x1,%eax
    cfdb:	88 02                	mov    %al,(%edx)
	free_super(s);
    cfdd:	83 ec 0c             	sub    $0xc,%esp
    cfe0:	ff 74 24 28          	pushl  0x28(%esp)
    cfe4:	e8 1b fb ff ff       	call   cb04 <free_super>
    cfe9:	83 c4 10             	add    $0x10,%esp
	return s;
    cfec:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    cff0:	89 44 24 0c          	mov    %eax,0xc(%esp)
}
    cff4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cff8:	83 c4 20             	add    $0x20,%esp
    cffb:	5b                   	pop    %ebx
    cffc:	5e                   	pop    %esi
    cffd:	5f                   	pop    %edi
    cffe:	c3                   	ret    

0000cfff <sys_umount>:

int sys_umount(char * dev_name)
{
    cfff:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * inode;
	struct super_block * sb;
	int dev;

	if (!(inode=namei(dev_name)))
    d002:	83 ec 0c             	sub    $0xc,%esp
    d005:	ff 74 24 2c          	pushl  0x2c(%esp)
    d009:	e8 7a 2d 00 00       	call   fd88 <namei>
    d00e:	83 c4 10             	add    $0x10,%esp
    d011:	89 44 24 18          	mov    %eax,0x18(%esp)
    d015:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    d01a:	75 0d                	jne    d029 <sys_umount+0x2a>
		return -ENOENT;
    d01c:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
    d023:	ff 
    d024:	e9 5a 01 00 00       	jmp    d183 <sys_umount+0x184>
	dev = inode->i_zone[0];
    d029:	8b 44 24 18          	mov    0x18(%esp),%eax
    d02d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    d031:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!S_ISBLK(inode->i_mode)) {
    d035:	8b 44 24 18          	mov    0x18(%esp),%eax
    d039:	0f b7 00             	movzwl (%eax),%eax
    d03c:	25 00 f0 00 00       	and    $0xf000,%eax
    d041:	3d 00 60 00 00       	cmp    $0x6000,%eax
    d046:	74 1c                	je     d064 <sys_umount+0x65>
		iput(inode);
    d048:	83 ec 0c             	sub    $0xc,%esp
    d04b:	ff 74 24 24          	pushl  0x24(%esp)
    d04f:	e8 f9 e7 ff ff       	call   b84d <iput>
    d054:	83 c4 10             	add    $0x10,%esp
		return -ENOTBLK;
    d057:	c7 44 24 0c f1 ff ff 	movl   $0xfffffff1,0xc(%esp)
    d05e:	ff 
    d05f:	e9 1f 01 00 00       	jmp    d183 <sys_umount+0x184>
	}
	iput(inode);
    d064:	83 ec 0c             	sub    $0xc,%esp
    d067:	ff 74 24 24          	pushl  0x24(%esp)
    d06b:	e8 dd e7 ff ff       	call   b84d <iput>
    d070:	83 c4 10             	add    $0x10,%esp
	if (dev==ROOT_DEV)
    d073:	8b 44 24 10          	mov    0x10(%esp),%eax
    d077:	3b 05 6c 0b 02 00    	cmp    0x20b6c,%eax
    d07d:	75 0d                	jne    d08c <sys_umount+0x8d>
		return -EBUSY;
    d07f:	c7 44 24 0c f0 ff ff 	movl   $0xfffffff0,0xc(%esp)
    d086:	ff 
    d087:	e9 f7 00 00 00       	jmp    d183 <sys_umount+0x184>
	if (!(sb=get_super(dev)) || !(sb->s_imount))
    d08c:	83 ec 0c             	sub    $0xc,%esp
    d08f:	ff 74 24 1c          	pushl  0x1c(%esp)
    d093:	e8 b8 fa ff ff       	call   cb50 <get_super>
    d098:	83 c4 10             	add    $0x10,%esp
    d09b:	89 44 24 14          	mov    %eax,0x14(%esp)
    d09f:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    d0a4:	74 0a                	je     d0b0 <sys_umount+0xb1>
    d0a6:	8b 44 24 14          	mov    0x14(%esp),%eax
    d0aa:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
    d0ae:	75 0d                	jne    d0bd <sys_umount+0xbe>
		return -ENOENT;
    d0b0:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
    d0b7:	ff 
    d0b8:	e9 c6 00 00 00       	jmp    d183 <sys_umount+0x184>
	if (!sb->s_imount->i_mount)
    d0bd:	8b 44 24 14          	mov    0x14(%esp),%eax
    d0c1:	8b 40 5c             	mov    0x5c(%eax),%eax
    d0c4:	80 78 35 00          	cmpb   $0x0,0x35(%eax)
    d0c8:	75 10                	jne    d0da <sys_umount+0xdb>
		printk("Mounted inode has i_mount=0\n");
    d0ca:	83 ec 0c             	sub    $0xc,%esp
    d0cd:	68 0c 8f 01 00       	push   $0x18f0c
    d0d2:	e8 7c b2 ff ff       	call   8353 <printk>
    d0d7:	83 c4 10             	add    $0x10,%esp
	for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)
    d0da:	c7 44 24 18 60 04 02 	movl   $0x20460,0x18(%esp)
    d0e1:	00 
    d0e2:	81 7c 24 18 60 0b 02 	cmpl   $0x20b60,0x18(%esp)
    d0e9:	00 
    d0ea:	73 2c                	jae    d118 <sys_umount+0x119>
		if (inode->i_dev==dev && inode->i_count)
    d0ec:	8b 44 24 18          	mov    0x18(%esp),%eax
    d0f0:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    d0f4:	3b 44 24 10          	cmp    0x10(%esp),%eax
    d0f8:	75 15                	jne    d10f <sys_umount+0x110>
    d0fa:	8b 44 24 18          	mov    0x18(%esp),%eax
    d0fe:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    d103:	74 0a                	je     d10f <sys_umount+0x110>
				return -EBUSY;
    d105:	c7 44 24 0c f0 ff ff 	movl   $0xfffffff0,0xc(%esp)
    d10c:	ff 
    d10d:	eb 74                	jmp    d183 <sys_umount+0x184>
	for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)
    d10f:	8d 44 24 18          	lea    0x18(%esp),%eax
    d113:	83 00 38             	addl   $0x38,(%eax)
    d116:	eb ca                	jmp    d0e2 <sys_umount+0xe3>
	sb->s_imount->i_mount=0;
    d118:	8b 44 24 14          	mov    0x14(%esp),%eax
    d11c:	8b 40 5c             	mov    0x5c(%eax),%eax
    d11f:	c6 40 35 00          	movb   $0x0,0x35(%eax)
	iput(sb->s_imount);
    d123:	83 ec 0c             	sub    $0xc,%esp
    d126:	8b 44 24 20          	mov    0x20(%esp),%eax
    d12a:	ff 70 5c             	pushl  0x5c(%eax)
    d12d:	e8 1b e7 ff ff       	call   b84d <iput>
    d132:	83 c4 10             	add    $0x10,%esp
	sb->s_imount = NULL;
    d135:	8b 44 24 14          	mov    0x14(%esp),%eax
    d139:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
	iput(sb->s_isup);
    d140:	83 ec 0c             	sub    $0xc,%esp
    d143:	8b 44 24 20          	mov    0x20(%esp),%eax
    d147:	ff 70 58             	pushl  0x58(%eax)
    d14a:	e8 fe e6 ff ff       	call   b84d <iput>
    d14f:	83 c4 10             	add    $0x10,%esp
	sb->s_isup = NULL;
    d152:	8b 44 24 14          	mov    0x14(%esp),%eax
    d156:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
	put_super(dev);
    d15d:	83 ec 0c             	sub    $0xc,%esp
    d160:	ff 74 24 1c          	pushl  0x1c(%esp)
    d164:	e8 65 fa ff ff       	call   cbce <put_super>
    d169:	83 c4 10             	add    $0x10,%esp
	sync_dev(dev);
    d16c:	83 ec 0c             	sub    $0xc,%esp
    d16f:	ff 74 24 1c          	pushl  0x1c(%esp)
    d173:	e8 dc ee ff ff       	call   c054 <sync_dev>
    d178:	83 c4 10             	add    $0x10,%esp
	return 0;
    d17b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    d182:	00 
}
    d183:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d187:	83 c4 1c             	add    $0x1c,%esp
    d18a:	c3                   	ret    

0000d18b <sys_mount>:

int sys_mount(char * dev_name, char * dir_name, int rw_flag)
{
    d18b:	83 ec 1c             	sub    $0x1c,%esp
	struct m_inode * dev_i, * dir_i;
	struct super_block * sb;
	int dev;

	if (!(dev_i=namei(dev_name)))
    d18e:	83 ec 0c             	sub    $0xc,%esp
    d191:	ff 74 24 2c          	pushl  0x2c(%esp)
    d195:	e8 ee 2b 00 00       	call   fd88 <namei>
    d19a:	83 c4 10             	add    $0x10,%esp
    d19d:	89 44 24 18          	mov    %eax,0x18(%esp)
    d1a1:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    d1a6:	75 0d                	jne    d1b5 <sys_mount+0x2a>
		return -ENOENT;
    d1a8:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
    d1af:	ff 
    d1b0:	e9 70 01 00 00       	jmp    d325 <sys_mount+0x19a>
	dev = dev_i->i_zone[0];
    d1b5:	8b 44 24 18          	mov    0x18(%esp),%eax
    d1b9:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    d1bd:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!S_ISBLK(dev_i->i_mode)) {
    d1c1:	8b 44 24 18          	mov    0x18(%esp),%eax
    d1c5:	0f b7 00             	movzwl (%eax),%eax
    d1c8:	25 00 f0 00 00       	and    $0xf000,%eax
    d1cd:	3d 00 60 00 00       	cmp    $0x6000,%eax
    d1d2:	74 1c                	je     d1f0 <sys_mount+0x65>
		iput(dev_i);
    d1d4:	83 ec 0c             	sub    $0xc,%esp
    d1d7:	ff 74 24 24          	pushl  0x24(%esp)
    d1db:	e8 6d e6 ff ff       	call   b84d <iput>
    d1e0:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    d1e3:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
    d1ea:	ff 
    d1eb:	e9 35 01 00 00       	jmp    d325 <sys_mount+0x19a>
	}
	iput(dev_i);
    d1f0:	83 ec 0c             	sub    $0xc,%esp
    d1f3:	ff 74 24 24          	pushl  0x24(%esp)
    d1f7:	e8 51 e6 ff ff       	call   b84d <iput>
    d1fc:	83 c4 10             	add    $0x10,%esp
	if (!(dir_i=namei(dir_name)))
    d1ff:	83 ec 0c             	sub    $0xc,%esp
    d202:	ff 74 24 30          	pushl  0x30(%esp)
    d206:	e8 7d 2b 00 00       	call   fd88 <namei>
    d20b:	83 c4 10             	add    $0x10,%esp
    d20e:	89 44 24 14          	mov    %eax,0x14(%esp)
    d212:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    d217:	75 0d                	jne    d226 <sys_mount+0x9b>
		return -ENOENT;
    d219:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
    d220:	ff 
    d221:	e9 ff 00 00 00       	jmp    d325 <sys_mount+0x19a>
	if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {
    d226:	8b 44 24 14          	mov    0x14(%esp),%eax
    d22a:	66 83 78 30 01       	cmpw   $0x1,0x30(%eax)
    d22f:	75 0d                	jne    d23e <sys_mount+0xb3>
    d231:	8b 44 24 14          	mov    0x14(%esp),%eax
    d235:	66 83 78 2e 01       	cmpw   $0x1,0x2e(%eax)
    d23a:	74 02                	je     d23e <sys_mount+0xb3>
    d23c:	eb 1c                	jmp    d25a <sys_mount+0xcf>
		iput(dir_i);
    d23e:	83 ec 0c             	sub    $0xc,%esp
    d241:	ff 74 24 20          	pushl  0x20(%esp)
    d245:	e8 03 e6 ff ff       	call   b84d <iput>
    d24a:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    d24d:	c7 44 24 08 f0 ff ff 	movl   $0xfffffff0,0x8(%esp)
    d254:	ff 
    d255:	e9 cb 00 00 00       	jmp    d325 <sys_mount+0x19a>
	}
	if (!S_ISDIR(dir_i->i_mode)) {
    d25a:	8b 44 24 14          	mov    0x14(%esp),%eax
    d25e:	0f b7 00             	movzwl (%eax),%eax
    d261:	25 00 f0 00 00       	and    $0xf000,%eax
    d266:	3d 00 40 00 00       	cmp    $0x4000,%eax
    d26b:	74 1c                	je     d289 <sys_mount+0xfe>
		iput(dir_i);
    d26d:	83 ec 0c             	sub    $0xc,%esp
    d270:	ff 74 24 20          	pushl  0x20(%esp)
    d274:	e8 d4 e5 ff ff       	call   b84d <iput>
    d279:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    d27c:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
    d283:	ff 
    d284:	e9 9c 00 00 00       	jmp    d325 <sys_mount+0x19a>
	}
	if (!(sb=read_super(dev))) {
    d289:	83 ec 0c             	sub    $0xc,%esp
    d28c:	ff 74 24 18          	pushl  0x18(%esp)
    d290:	e8 23 fa ff ff       	call   ccb8 <read_super>
    d295:	83 c4 10             	add    $0x10,%esp
    d298:	89 44 24 10          	mov    %eax,0x10(%esp)
    d29c:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    d2a1:	75 19                	jne    d2bc <sys_mount+0x131>
		iput(dir_i);
    d2a3:	83 ec 0c             	sub    $0xc,%esp
    d2a6:	ff 74 24 20          	pushl  0x20(%esp)
    d2aa:	e8 9e e5 ff ff       	call   b84d <iput>
    d2af:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    d2b2:	c7 44 24 08 f0 ff ff 	movl   $0xfffffff0,0x8(%esp)
    d2b9:	ff 
    d2ba:	eb 69                	jmp    d325 <sys_mount+0x19a>
	}
	if (sb->s_imount) {
    d2bc:	8b 44 24 10          	mov    0x10(%esp),%eax
    d2c0:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
    d2c4:	74 19                	je     d2df <sys_mount+0x154>
		iput(dir_i);
    d2c6:	83 ec 0c             	sub    $0xc,%esp
    d2c9:	ff 74 24 20          	pushl  0x20(%esp)
    d2cd:	e8 7b e5 ff ff       	call   b84d <iput>
    d2d2:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    d2d5:	c7 44 24 08 f0 ff ff 	movl   $0xfffffff0,0x8(%esp)
    d2dc:	ff 
    d2dd:	eb 46                	jmp    d325 <sys_mount+0x19a>
	}
	if (dir_i->i_mount) {
    d2df:	8b 44 24 14          	mov    0x14(%esp),%eax
    d2e3:	80 78 35 00          	cmpb   $0x0,0x35(%eax)
    d2e7:	74 19                	je     d302 <sys_mount+0x177>
		iput(dir_i);
    d2e9:	83 ec 0c             	sub    $0xc,%esp
    d2ec:	ff 74 24 20          	pushl  0x20(%esp)
    d2f0:	e8 58 e5 ff ff       	call   b84d <iput>
    d2f5:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    d2f8:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
    d2ff:	ff 
    d300:	eb 23                	jmp    d325 <sys_mount+0x19a>
	}
	sb->s_imount=dir_i;
    d302:	8b 54 24 10          	mov    0x10(%esp),%edx
    d306:	8b 44 24 14          	mov    0x14(%esp),%eax
    d30a:	89 42 5c             	mov    %eax,0x5c(%edx)
	dir_i->i_mount=1;
    d30d:	8b 44 24 14          	mov    0x14(%esp),%eax
    d311:	c6 40 35 01          	movb   $0x1,0x35(%eax)
	dir_i->i_dirt=1;		/* NOTE! we don't iput(dir_i) */
    d315:	8b 44 24 14          	mov    0x14(%esp),%eax
    d319:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	return 0;			/* we do that in umount */
    d31d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    d324:	00 
}
    d325:	8b 44 24 08          	mov    0x8(%esp),%eax
    d329:	83 c4 1c             	add    $0x1c,%esp
    d32c:	c3                   	ret    

0000d32d <mount_root>:

void mount_root(void)
{
    d32d:	53                   	push   %ebx
    d32e:	83 ec 18             	sub    $0x18,%esp
	struct super_block * p;
	struct m_inode * mi;

	if (32 != sizeof (struct d_inode))
		panic("bad i-node size");
	for(i=0;i<NR_FILE;i++)
    d331:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    d338:	00 
    d339:	83 7c 24 14 3f       	cmpl   $0x3f,0x14(%esp)
    d33e:	7f 18                	jg     d358 <mount_root+0x2b>
		file_table[i].f_count=0;
    d340:	8b 44 24 14          	mov    0x14(%esp),%eax
    d344:	c1 e0 04             	shl    $0x4,%eax
    d347:	66 c7 80 e4 25 02 00 	movw   $0x0,0x225e4(%eax)
    d34e:	00 00 
	for(i=0;i<NR_FILE;i++)
    d350:	8d 44 24 14          	lea    0x14(%esp),%eax
    d354:	ff 00                	incl   (%eax)
    d356:	eb e1                	jmp    d339 <mount_root+0xc>
	if (MAJOR(ROOT_DEV) == 2) {
    d358:	a1 6c 0b 02 00       	mov    0x20b6c,%eax
    d35d:	c1 e8 08             	shr    $0x8,%eax
    d360:	83 f8 02             	cmp    $0x2,%eax
    d363:	75 15                	jne    d37a <mount_root+0x4d>
		printk("Insert root floppy and press ENTER");
    d365:	83 ec 0c             	sub    $0xc,%esp
    d368:	68 2c 8f 01 00       	push   $0x18f2c
    d36d:	e8 e1 af ff ff       	call   8353 <printk>
    d372:	83 c4 10             	add    $0x10,%esp
		wait_for_keypress();
    d375:	e8 2f 7f 00 00       	call   152a9 <wait_for_keypress>
	}
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    d37a:	c7 44 24 0c 80 22 02 	movl   $0x22280,0xc(%esp)
    d381:	00 
    d382:	81 7c 24 0c e0 25 02 	cmpl   $0x225e0,0xc(%esp)
    d389:	00 
    d38a:	73 26                	jae    d3b2 <mount_root+0x85>
		p->s_dev = 0;
    d38c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d390:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		p->s_lock = 0;
    d396:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d39a:	c6 40 68 00          	movb   $0x0,0x68(%eax)
		p->s_wait = NULL;
    d39e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d3a2:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    d3a9:	8d 44 24 0c          	lea    0xc(%esp),%eax
    d3ad:	83 00 6c             	addl   $0x6c,(%eax)
    d3b0:	eb d0                	jmp    d382 <mount_root+0x55>
	}
	if (!(p=read_super(ROOT_DEV)))
    d3b2:	83 ec 0c             	sub    $0xc,%esp
    d3b5:	ff 35 6c 0b 02 00    	pushl  0x20b6c
    d3bb:	e8 f8 f8 ff ff       	call   ccb8 <read_super>
    d3c0:	83 c4 10             	add    $0x10,%esp
    d3c3:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d3c7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    d3cc:	75 10                	jne    d3de <mount_root+0xb1>
		panic("Unable to mount root");
    d3ce:	83 ec 0c             	sub    $0xc,%esp
    d3d1:	68 4f 8f 01 00       	push   $0x18f4f
    d3d6:	e8 3e af ff ff       	call   8319 <panic>
    d3db:	83 c4 10             	add    $0x10,%esp
	if (!(mi=iget(ROOT_DEV,ROOT_INO)))
    d3de:	83 ec 08             	sub    $0x8,%esp
    d3e1:	6a 01                	push   $0x1
    d3e3:	ff 35 6c 0b 02 00    	pushl  0x20b6c
    d3e9:	e8 9b e7 ff ff       	call   bb89 <iget>
    d3ee:	83 c4 10             	add    $0x10,%esp
    d3f1:	89 44 24 08          	mov    %eax,0x8(%esp)
    d3f5:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    d3fa:	75 10                	jne    d40c <mount_root+0xdf>
		panic("Unable to read root i-node");
    d3fc:	83 ec 0c             	sub    $0xc,%esp
    d3ff:	68 64 8f 01 00       	push   $0x18f64
    d404:	e8 10 af ff ff       	call   8319 <panic>
    d409:	83 c4 10             	add    $0x10,%esp
	mi->i_count += 3 ;	/* NOTE! it is logically used 4 times, not 1 */
    d40c:	8b 54 24 08          	mov    0x8(%esp),%edx
    d410:	8b 44 24 08          	mov    0x8(%esp),%eax
    d414:	66 8b 40 30          	mov    0x30(%eax),%ax
    d418:	83 c0 03             	add    $0x3,%eax
    d41b:	66 89 42 30          	mov    %ax,0x30(%edx)
	p->s_isup = p->s_imount = mi;
    d41f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    d423:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d427:	8b 44 24 08          	mov    0x8(%esp),%eax
    d42b:	89 42 5c             	mov    %eax,0x5c(%edx)
    d42e:	89 41 58             	mov    %eax,0x58(%ecx)
	current->pwd = mi;
    d431:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    d437:	8b 44 24 08          	mov    0x8(%esp),%eax
    d43b:	89 82 70 02 00 00    	mov    %eax,0x270(%edx)
	current->root = mi;
    d441:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    d447:	8b 44 24 08          	mov    0x8(%esp),%eax
    d44b:	89 82 74 02 00 00    	mov    %eax,0x274(%edx)
	free=0;
    d451:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    d458:	00 
	i=p->s_nzones;
    d459:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d45d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    d461:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (-- i >= 0)
    d465:	8d 44 24 14          	lea    0x14(%esp),%eax
    d469:	ff 08                	decl   (%eax)
    d46b:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    d470:	78 43                	js     d4b5 <mount_root+0x188>
		if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))
    d472:	b9 00 00 00 00       	mov    $0x0,%ecx
    d477:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    d47b:	81 e3 ff 1f 00 00    	and    $0x1fff,%ebx
    d481:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d485:	8b 44 24 14          	mov    0x14(%esp),%eax
    d489:	c1 f8 0d             	sar    $0xd,%eax
    d48c:	8b 44 82 34          	mov    0x34(%edx,%eax,4),%eax
    d490:	8b 00                	mov    (%eax),%eax
    d492:	89 44 24 04          	mov    %eax,0x4(%esp)
    d496:	89 c8                	mov    %ecx,%eax
    d498:	8b 54 24 04          	mov    0x4(%esp),%edx
    d49c:	0f a3 1a             	bt     %ebx,(%edx)
    d49f:	0f 92 c0             	setb   %al
    d4a2:	89 44 24 04          	mov    %eax,0x4(%esp)
    d4a6:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    d4ab:	75 b8                	jne    d465 <mount_root+0x138>
			free++;
    d4ad:	8d 44 24 10          	lea    0x10(%esp),%eax
    d4b1:	ff 00                	incl   (%eax)
    d4b3:	eb b0                	jmp    d465 <mount_root+0x138>
	printk("%d/%d free blocks\n\r",free,p->s_nzones);
    d4b5:	83 ec 04             	sub    $0x4,%esp
    d4b8:	8b 44 24 10          	mov    0x10(%esp),%eax
    d4bc:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    d4c0:	50                   	push   %eax
    d4c1:	ff 74 24 18          	pushl  0x18(%esp)
    d4c5:	68 7f 8f 01 00       	push   $0x18f7f
    d4ca:	e8 84 ae ff ff       	call   8353 <printk>
    d4cf:	83 c4 10             	add    $0x10,%esp
	free=0;
    d4d2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    d4d9:	00 
	i=p->s_ninodes+1;
    d4da:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d4de:	0f b7 00             	movzwl (%eax),%eax
    d4e1:	40                   	inc    %eax
    d4e2:	89 44 24 14          	mov    %eax,0x14(%esp)
	while (-- i >= 0)
    d4e6:	8d 44 24 14          	lea    0x14(%esp),%eax
    d4ea:	ff 08                	decl   (%eax)
    d4ec:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    d4f1:	78 43                	js     d536 <mount_root+0x209>
		if (!set_bit(i&8191,p->s_imap[i>>13]->b_data))
    d4f3:	b9 00 00 00 00       	mov    $0x0,%ecx
    d4f8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    d4fc:	81 e3 ff 1f 00 00    	and    $0x1fff,%ebx
    d502:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d506:	8b 44 24 14          	mov    0x14(%esp),%eax
    d50a:	c1 f8 0d             	sar    $0xd,%eax
    d50d:	8b 44 82 14          	mov    0x14(%edx,%eax,4),%eax
    d511:	8b 00                	mov    (%eax),%eax
    d513:	89 44 24 04          	mov    %eax,0x4(%esp)
    d517:	89 c8                	mov    %ecx,%eax
    d519:	8b 54 24 04          	mov    0x4(%esp),%edx
    d51d:	0f a3 1a             	bt     %ebx,(%edx)
    d520:	0f 92 c0             	setb   %al
    d523:	89 44 24 04          	mov    %eax,0x4(%esp)
    d527:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    d52c:	75 b8                	jne    d4e6 <mount_root+0x1b9>
			free++;
    d52e:	8d 44 24 10          	lea    0x10(%esp),%eax
    d532:	ff 00                	incl   (%eax)
    d534:	eb b0                	jmp    d4e6 <mount_root+0x1b9>
	printk("%d/%d free inodes\n\r",free,p->s_ninodes);
    d536:	83 ec 04             	sub    $0x4,%esp
    d539:	8b 44 24 10          	mov    0x10(%esp),%eax
    d53d:	0f b7 00             	movzwl (%eax),%eax
    d540:	50                   	push   %eax
    d541:	ff 74 24 18          	pushl  0x18(%esp)
    d545:	68 93 8f 01 00       	push   $0x18f93
    d54a:	e8 04 ae ff ff       	call   8353 <printk>
    d54f:	83 c4 10             	add    $0x10,%esp
}
    d552:	83 c4 18             	add    $0x18,%esp
    d555:	5b                   	pop    %ebx
    d556:	c3                   	ret    

0000d557 <block_write>:
#include <linux/kernel.h>
#include <asm/segment.h>
#include <asm/system.h>

int block_write(int dev, long * pos, char * buf, int count)
{
    d557:	53                   	push   %ebx
    d558:	83 ec 28             	sub    $0x28,%esp
	int block = *pos >> BLOCK_SIZE_BITS;
    d55b:	8b 44 24 34          	mov    0x34(%esp),%eax
    d55f:	8b 00                	mov    (%eax),%eax
    d561:	c1 f8 0a             	sar    $0xa,%eax
    d564:	89 44 24 24          	mov    %eax,0x24(%esp)
	int offset = *pos & (BLOCK_SIZE-1);
    d568:	8b 44 24 34          	mov    0x34(%esp),%eax
    d56c:	8b 00                	mov    (%eax),%eax
    d56e:	25 ff 03 00 00       	and    $0x3ff,%eax
    d573:	89 44 24 20          	mov    %eax,0x20(%esp)
	int chars;
	int written = 0;
    d577:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    d57e:	00 
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
    d57f:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    d584:	0f 8e 22 01 00 00    	jle    d6ac <block_write+0x155>
		chars = BLOCK_SIZE - offset;
    d58a:	b8 00 04 00 00       	mov    $0x400,%eax
    d58f:	2b 44 24 20          	sub    0x20(%esp),%eax
    d593:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (chars > count)
    d597:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d59b:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    d59f:	7e 08                	jle    d5a9 <block_write+0x52>
			chars=count;
    d5a1:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    d5a5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (chars == BLOCK_SIZE)
    d5a9:	81 7c 24 1c 00 04 00 	cmpl   $0x400,0x1c(%esp)
    d5b0:	00 
    d5b1:	75 19                	jne    d5cc <block_write+0x75>
			bh = getblk(dev,block);
    d5b3:	83 ec 08             	sub    $0x8,%esp
    d5b6:	ff 74 24 2c          	pushl  0x2c(%esp)
    d5ba:	ff 74 24 3c          	pushl  0x3c(%esp)
    d5be:	e8 95 ed ff ff       	call   c358 <getblk>
    d5c3:	83 c4 10             	add    $0x10,%esp
    d5c6:	89 44 24 14          	mov    %eax,0x14(%esp)
    d5ca:	eb 27                	jmp    d5f3 <block_write+0x9c>
		else
			bh = breada(dev,block,block+1,block+2,-1);
    d5cc:	83 ec 0c             	sub    $0xc,%esp
    d5cf:	6a ff                	push   $0xffffffff
    d5d1:	8b 44 24 34          	mov    0x34(%esp),%eax
    d5d5:	83 c0 02             	add    $0x2,%eax
    d5d8:	50                   	push   %eax
    d5d9:	8b 44 24 38          	mov    0x38(%esp),%eax
    d5dd:	40                   	inc    %eax
    d5de:	50                   	push   %eax
    d5df:	ff 74 24 3c          	pushl  0x3c(%esp)
    d5e3:	ff 74 24 4c          	pushl  0x4c(%esp)
    d5e7:	e8 c5 f2 ff ff       	call   c8b1 <breada>
    d5ec:	83 c4 20             	add    $0x20,%esp
    d5ef:	89 44 24 14          	mov    %eax,0x14(%esp)
		block++;
    d5f3:	8d 44 24 24          	lea    0x24(%esp),%eax
    d5f7:	ff 00                	incl   (%eax)
		if (!bh)
    d5f9:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    d5fe:	75 24                	jne    d624 <block_write+0xcd>
			return written?written:-EIO;
    d600:	8b 44 24 18          	mov    0x18(%esp),%eax
    d604:	89 44 24 08          	mov    %eax,0x8(%esp)
    d608:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    d60d:	75 08                	jne    d617 <block_write+0xc0>
    d60f:	c7 44 24 08 fb ff ff 	movl   $0xfffffffb,0x8(%esp)
    d616:	ff 
    d617:	8b 44 24 08          	mov    0x8(%esp),%eax
    d61b:	89 44 24 10          	mov    %eax,0x10(%esp)
    d61f:	e9 90 00 00 00       	jmp    d6b4 <block_write+0x15d>
		p = offset + bh->b_data;
    d624:	8b 54 24 14          	mov    0x14(%esp),%edx
    d628:	8b 44 24 20          	mov    0x20(%esp),%eax
    d62c:	8b 12                	mov    (%edx),%edx
    d62e:	01 c2                	add    %eax,%edx
    d630:	89 54 24 0c          	mov    %edx,0xc(%esp)
		offset = 0;
    d634:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    d63b:	00 
		*pos += chars;
    d63c:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    d640:	8b 54 24 34          	mov    0x34(%esp),%edx
    d644:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d648:	03 02                	add    (%edx),%eax
    d64a:	89 01                	mov    %eax,(%ecx)
		written += chars;
    d64c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d650:	8d 44 24 18          	lea    0x18(%esp),%eax
    d654:	01 10                	add    %edx,(%eax)
		count -= chars;
    d656:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d65a:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    d65e:	29 10                	sub    %edx,(%eax)
		while (chars-->0)
    d660:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d664:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    d668:	ff 08                	decl   (%eax)
    d66a:	85 d2                	test   %edx,%edx
    d66c:	7e 22                	jle    d690 <block_write+0x139>
			*(p++) = get_fs_byte(buf++);
    d66e:	83 ec 0c             	sub    $0xc,%esp
    d671:	8b 44 24 44          	mov    0x44(%esp),%eax
    d675:	50                   	push   %eax
    d676:	8d 44 24 48          	lea    0x48(%esp),%eax
    d67a:	ff 00                	incl   (%eax)
    d67c:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    d680:	ff 44 24 1c          	incl   0x1c(%esp)
    d684:	e8 34 00 00 00       	call   d6bd <get_fs_byte>
    d689:	83 c4 10             	add    $0x10,%esp
    d68c:	88 03                	mov    %al,(%ebx)
    d68e:	eb d0                	jmp    d660 <block_write+0x109>
		bh->b_dirt = 1;
    d690:	8b 44 24 14          	mov    0x14(%esp),%eax
    d694:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
    d698:	83 ec 0c             	sub    $0xc,%esp
    d69b:	ff 74 24 20          	pushl  0x20(%esp)
    d69f:	e8 13 f0 ff ff       	call   c6b7 <brelse>
    d6a4:	83 c4 10             	add    $0x10,%esp
    d6a7:	e9 d3 fe ff ff       	jmp    d57f <block_write+0x28>
	}
	return written;
    d6ac:	8b 44 24 18          	mov    0x18(%esp),%eax
    d6b0:	89 44 24 10          	mov    %eax,0x10(%esp)
}
    d6b4:	8b 44 24 10          	mov    0x10(%esp),%eax
    d6b8:	83 c4 28             	add    $0x28,%esp
    d6bb:	5b                   	pop    %ebx
    d6bc:	c3                   	ret    

0000d6bd <get_fs_byte>:
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    d6bd:	8b 44 24 04          	mov    0x4(%esp),%eax
    d6c1:	64 8a 00             	mov    %fs:(%eax),%al
	return _v;
    d6c4:	0f b6 c0             	movzbl %al,%eax
}
    d6c7:	c3                   	ret    

0000d6c8 <block_read>:

int block_read(int dev, unsigned long * pos, char * buf, int count)
{
    d6c8:	83 ec 2c             	sub    $0x2c,%esp
	int block = *pos >> BLOCK_SIZE_BITS;
    d6cb:	8b 44 24 34          	mov    0x34(%esp),%eax
    d6cf:	8b 00                	mov    (%eax),%eax
    d6d1:	c1 e8 0a             	shr    $0xa,%eax
    d6d4:	89 44 24 28          	mov    %eax,0x28(%esp)
	int offset = *pos & (BLOCK_SIZE-1);
    d6d8:	8b 44 24 34          	mov    0x34(%esp),%eax
    d6dc:	8b 00                	mov    (%eax),%eax
    d6de:	25 ff 03 00 00       	and    $0x3ff,%eax
    d6e3:	89 44 24 24          	mov    %eax,0x24(%esp)
	int chars;
	int read = 0;
    d6e7:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    d6ee:	00 
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
    d6ef:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    d6f4:	0f 8e f9 00 00 00    	jle    d7f3 <block_read+0x12b>
		chars = BLOCK_SIZE-offset;
    d6fa:	b8 00 04 00 00       	mov    $0x400,%eax
    d6ff:	2b 44 24 24          	sub    0x24(%esp),%eax
    d703:	89 44 24 20          	mov    %eax,0x20(%esp)
		if (chars > count)
    d707:	8b 44 24 20          	mov    0x20(%esp),%eax
    d70b:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    d70f:	7e 08                	jle    d719 <block_read+0x51>
			chars = count;
    d711:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    d715:	89 44 24 20          	mov    %eax,0x20(%esp)
		if (!(bh = breada(dev,block,block+1,block+2,-1)))
    d719:	83 ec 0c             	sub    $0xc,%esp
    d71c:	6a ff                	push   $0xffffffff
    d71e:	8b 44 24 38          	mov    0x38(%esp),%eax
    d722:	83 c0 02             	add    $0x2,%eax
    d725:	50                   	push   %eax
    d726:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    d72a:	40                   	inc    %eax
    d72b:	50                   	push   %eax
    d72c:	ff 74 24 40          	pushl  0x40(%esp)
    d730:	ff 74 24 4c          	pushl  0x4c(%esp)
    d734:	e8 78 f1 ff ff       	call   c8b1 <breada>
    d739:	83 c4 20             	add    $0x20,%esp
    d73c:	89 44 24 18          	mov    %eax,0x18(%esp)
    d740:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    d745:	75 24                	jne    d76b <block_read+0xa3>
			return read?read:-EIO;
    d747:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d74b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d74f:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    d754:	75 08                	jne    d75e <block_read+0x96>
    d756:	c7 44 24 0c fb ff ff 	movl   $0xfffffffb,0xc(%esp)
    d75d:	ff 
    d75e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d762:	89 44 24 14          	mov    %eax,0x14(%esp)
    d766:	e9 90 00 00 00       	jmp    d7fb <block_read+0x133>
		block++;
    d76b:	8d 44 24 28          	lea    0x28(%esp),%eax
    d76f:	ff 00                	incl   (%eax)
		p = offset + bh->b_data;
    d771:	8b 54 24 18          	mov    0x18(%esp),%edx
    d775:	8b 44 24 24          	mov    0x24(%esp),%eax
    d779:	8b 12                	mov    (%edx),%edx
    d77b:	01 c2                	add    %eax,%edx
    d77d:	89 54 24 10          	mov    %edx,0x10(%esp)
		offset = 0;
    d781:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
    d788:	00 
		*pos += chars;
    d789:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    d78d:	8b 54 24 34          	mov    0x34(%esp),%edx
    d791:	8b 44 24 20          	mov    0x20(%esp),%eax
    d795:	03 02                	add    (%edx),%eax
    d797:	89 01                	mov    %eax,(%ecx)
		read += chars;
    d799:	8b 54 24 20          	mov    0x20(%esp),%edx
    d79d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    d7a1:	01 10                	add    %edx,(%eax)
		count -= chars;
    d7a3:	8b 54 24 20          	mov    0x20(%esp),%edx
    d7a7:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    d7ab:	29 10                	sub    %edx,(%eax)
		while (chars-->0)
    d7ad:	8b 54 24 20          	mov    0x20(%esp),%edx
    d7b1:	8d 44 24 20          	lea    0x20(%esp),%eax
    d7b5:	ff 08                	decl   (%eax)
    d7b7:	85 d2                	test   %edx,%edx
    d7b9:	7e 24                	jle    d7df <block_read+0x117>
			put_fs_byte(*(p++),buf++);
    d7bb:	83 ec 08             	sub    $0x8,%esp
    d7be:	8b 44 24 40          	mov    0x40(%esp),%eax
    d7c2:	50                   	push   %eax
    d7c3:	8d 44 24 44          	lea    0x44(%esp),%eax
    d7c7:	ff 00                	incl   (%eax)
    d7c9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d7cd:	0f be 00             	movsbl (%eax),%eax
    d7d0:	50                   	push   %eax
    d7d1:	ff 44 24 20          	incl   0x20(%esp)
    d7d5:	e8 29 00 00 00       	call   d803 <put_fs_byte>
    d7da:	83 c4 10             	add    $0x10,%esp
    d7dd:	eb ce                	jmp    d7ad <block_read+0xe5>
		brelse(bh);
    d7df:	83 ec 0c             	sub    $0xc,%esp
    d7e2:	ff 74 24 24          	pushl  0x24(%esp)
    d7e6:	e8 cc ee ff ff       	call   c6b7 <brelse>
    d7eb:	83 c4 10             	add    $0x10,%esp
    d7ee:	e9 fc fe ff ff       	jmp    d6ef <block_read+0x27>
	}
	return read;
    d7f3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d7f7:	89 44 24 14          	mov    %eax,0x14(%esp)
}
    d7fb:	8b 44 24 14          	mov    0x14(%esp),%eax
    d7ff:	83 c4 2c             	add    $0x2c,%esp
    d802:	c3                   	ret    

0000d803 <put_fs_byte>:

static inline void put_fs_byte(char val,char *addr)
{
    d803:	83 ec 04             	sub    $0x4,%esp
    d806:	8b 44 24 08          	mov    0x8(%esp),%eax
    d80a:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    d80e:	8a 54 24 03          	mov    0x3(%esp),%dl
    d812:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d816:	64 88 10             	mov    %dl,%fs:(%eax)
}
    d819:	83 c4 04             	add    $0x4,%esp
    d81c:	c3                   	ret    

0000d81d <rw_ttyx>:
extern int tty_write(unsigned minor,char * buf,int count);

typedef int (*crw_ptr)(int rw,unsigned minor,char * buf,int count,off_t * pos);

static int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)
{
    d81d:	83 ec 0c             	sub    $0xc,%esp
	return ((rw==READ)?tty_read(minor,buf,count):
    d820:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    d825:	75 1d                	jne    d844 <rw_ttyx+0x27>
    d827:	83 ec 04             	sub    $0x4,%esp
    d82a:	ff 74 24 20          	pushl  0x20(%esp)
    d82e:	ff 74 24 20          	pushl  0x20(%esp)
    d832:	ff 74 24 20          	pushl  0x20(%esp)
    d836:	e8 88 7e 00 00       	call   156c3 <tty_read>
    d83b:	83 c4 10             	add    $0x10,%esp
    d83e:	89 44 24 08          	mov    %eax,0x8(%esp)
    d842:	eb 1b                	jmp    d85f <rw_ttyx+0x42>
    d844:	83 ec 04             	sub    $0x4,%esp
    d847:	ff 74 24 20          	pushl  0x20(%esp)
    d84b:	ff 74 24 20          	pushl  0x20(%esp)
    d84f:	ff 74 24 20          	pushl  0x20(%esp)
    d853:	e8 04 81 00 00       	call   1595c <tty_write>
    d858:	83 c4 10             	add    $0x10,%esp
    d85b:	89 44 24 08          	mov    %eax,0x8(%esp)
    d85f:	8b 44 24 08          	mov    0x8(%esp),%eax
		tty_write(minor,buf,count));
}
    d863:	83 c4 0c             	add    $0xc,%esp
    d866:	c3                   	ret    

0000d867 <rw_tty>:

static int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)
{
    d867:	83 ec 0c             	sub    $0xc,%esp
	if (current->tty<0)
    d86a:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    d86f:	83 b8 68 02 00 00 00 	cmpl   $0x0,0x268(%eax)
    d876:	79 0a                	jns    d882 <rw_tty+0x1b>
		return -EPERM;
    d878:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
    d87f:	ff 
    d880:	eb 2a                	jmp    d8ac <rw_tty+0x45>
	return rw_ttyx(rw,current->tty,buf,count,pos);
    d882:	83 ec 0c             	sub    $0xc,%esp
    d885:	ff 74 24 2c          	pushl  0x2c(%esp)
    d889:	ff 74 24 2c          	pushl  0x2c(%esp)
    d88d:	ff 74 24 2c          	pushl  0x2c(%esp)
    d891:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    d896:	ff b0 68 02 00 00    	pushl  0x268(%eax)
    d89c:	ff 74 24 2c          	pushl  0x2c(%esp)
    d8a0:	e8 78 ff ff ff       	call   d81d <rw_ttyx>
    d8a5:	83 c4 20             	add    $0x20,%esp
    d8a8:	89 44 24 08          	mov    %eax,0x8(%esp)
}
    d8ac:	8b 44 24 08          	mov    0x8(%esp),%eax
    d8b0:	83 c4 0c             	add    $0xc,%esp
    d8b3:	c3                   	ret    

0000d8b4 <rw_ram>:

static int rw_ram(int rw,char * buf, int count, off_t *pos)
{
	return -EIO;
    d8b4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    d8b9:	c3                   	ret    

0000d8ba <rw_mem>:

static int rw_mem(int rw,char * buf, int count, off_t * pos)
{
	return -EIO;
    d8ba:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    d8bf:	c3                   	ret    

0000d8c0 <rw_kmem>:

static int rw_kmem(int rw,char * buf, int count, off_t * pos)
{
	return -EIO;
    d8c0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
    d8c5:	c3                   	ret    

0000d8c6 <rw_port>:

static int rw_port(int rw,char * buf, int count, off_t * pos)
{
    d8c6:	83 ec 0c             	sub    $0xc,%esp
	int i=*pos;
    d8c9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d8cd:	8b 00                	mov    (%eax),%eax
    d8cf:	89 44 24 08          	mov    %eax,0x8(%esp)

	while (count-->0 && i<65536) {
    d8d3:	8b 54 24 18          	mov    0x18(%esp),%edx
    d8d7:	8d 44 24 18          	lea    0x18(%esp),%eax
    d8db:	ff 08                	decl   (%eax)
    d8dd:	85 d2                	test   %edx,%edx
    d8df:	7e 5d                	jle    d93e <rw_port+0x78>
    d8e1:	81 7c 24 08 ff ff 00 	cmpl   $0xffff,0x8(%esp)
    d8e8:	00 
    d8e9:	7f 53                	jg     d93e <rw_port+0x78>
		if (rw==READ)
    d8eb:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    d8f0:	75 29                	jne    d91b <rw_port+0x55>
			put_fs_byte(inb(i),buf++);
    d8f2:	8b 54 24 08          	mov    0x8(%esp),%edx
    d8f6:	ec                   	in     (%dx),%al
    d8f7:	88 44 24 07          	mov    %al,0x7(%esp)
    d8fb:	8a 44 24 07          	mov    0x7(%esp),%al
    d8ff:	0f be d0             	movsbl %al,%edx
    d902:	83 ec 08             	sub    $0x8,%esp
    d905:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d909:	50                   	push   %eax
    d90a:	8d 44 24 20          	lea    0x20(%esp),%eax
    d90e:	ff 00                	incl   (%eax)
    d910:	52                   	push   %edx
    d911:	e8 57 00 00 00       	call   d96d <put_fs_byte>
    d916:	83 c4 10             	add    $0x10,%esp
    d919:	eb 1b                	jmp    d936 <rw_port+0x70>
		else
			outb(get_fs_byte(buf++),i);
    d91b:	83 ec 0c             	sub    $0xc,%esp
    d91e:	8b 44 24 20          	mov    0x20(%esp),%eax
    d922:	50                   	push   %eax
    d923:	8d 44 24 24          	lea    0x24(%esp),%eax
    d927:	ff 00                	incl   (%eax)
    d929:	e8 34 00 00 00       	call   d962 <get_fs_byte>
    d92e:	83 c4 10             	add    $0x10,%esp
    d931:	8b 54 24 08          	mov    0x8(%esp),%edx
    d935:	ee                   	out    %al,(%dx)
		i++;
    d936:	8d 44 24 08          	lea    0x8(%esp),%eax
    d93a:	ff 00                	incl   (%eax)
    d93c:	eb 95                	jmp    d8d3 <rw_port+0xd>
	}
	i -= *pos;
    d93e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d942:	8b 10                	mov    (%eax),%edx
    d944:	8d 44 24 08          	lea    0x8(%esp),%eax
    d948:	29 10                	sub    %edx,(%eax)
	*pos += i;
    d94a:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    d94e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    d952:	8b 44 24 08          	mov    0x8(%esp),%eax
    d956:	03 02                	add    (%edx),%eax
    d958:	89 01                	mov    %eax,(%ecx)
	return i;
    d95a:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    d95e:	83 c4 0c             	add    $0xc,%esp
    d961:	c3                   	ret    

0000d962 <get_fs_byte>:
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    d962:	8b 44 24 04          	mov    0x4(%esp),%eax
    d966:	64 8a 00             	mov    %fs:(%eax),%al
	return _v;
    d969:	0f b6 c0             	movzbl %al,%eax
}
    d96c:	c3                   	ret    

0000d96d <put_fs_byte>:
{
    d96d:	83 ec 04             	sub    $0x4,%esp
    d970:	8b 44 24 08          	mov    0x8(%esp),%eax
    d974:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    d978:	8a 54 24 03          	mov    0x3(%esp),%dl
    d97c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d980:	64 88 10             	mov    %dl,%fs:(%eax)
}
    d983:	83 c4 04             	add    $0x4,%esp
    d986:	c3                   	ret    

0000d987 <rw_memory>:

static int rw_memory(int rw, unsigned minor, char * buf, int count, off_t * pos)
{
    d987:	83 ec 0c             	sub    $0xc,%esp
	switch(minor) {
    d98a:	83 7c 24 14 04       	cmpl   $0x4,0x14(%esp)
    d98f:	0f 87 ad 00 00 00    	ja     da42 <rw_memory+0xbb>
    d995:	8b 44 24 14          	mov    0x14(%esp),%eax
    d999:	c1 e0 02             	shl    $0x2,%eax
    d99c:	8b 80 a8 8f 01 00    	mov    0x18fa8(%eax),%eax
    d9a2:	ff e0                	jmp    *%eax
		case 0:
			return rw_ram(rw,buf,count,pos);
    d9a4:	ff 74 24 20          	pushl  0x20(%esp)
    d9a8:	ff 74 24 20          	pushl  0x20(%esp)
    d9ac:	ff 74 24 20          	pushl  0x20(%esp)
    d9b0:	ff 74 24 1c          	pushl  0x1c(%esp)
    d9b4:	e8 fb fe ff ff       	call   d8b4 <rw_ram>
    d9b9:	83 c4 10             	add    $0x10,%esp
    d9bc:	89 44 24 08          	mov    %eax,0x8(%esp)
    d9c0:	e9 85 00 00 00       	jmp    da4a <rw_memory+0xc3>
		case 1:
			return rw_mem(rw,buf,count,pos);
    d9c5:	ff 74 24 20          	pushl  0x20(%esp)
    d9c9:	ff 74 24 20          	pushl  0x20(%esp)
    d9cd:	ff 74 24 20          	pushl  0x20(%esp)
    d9d1:	ff 74 24 1c          	pushl  0x1c(%esp)
    d9d5:	e8 e0 fe ff ff       	call   d8ba <rw_mem>
    d9da:	83 c4 10             	add    $0x10,%esp
    d9dd:	89 44 24 08          	mov    %eax,0x8(%esp)
    d9e1:	eb 67                	jmp    da4a <rw_memory+0xc3>
		case 2:
			return rw_kmem(rw,buf,count,pos);
    d9e3:	ff 74 24 20          	pushl  0x20(%esp)
    d9e7:	ff 74 24 20          	pushl  0x20(%esp)
    d9eb:	ff 74 24 20          	pushl  0x20(%esp)
    d9ef:	ff 74 24 1c          	pushl  0x1c(%esp)
    d9f3:	e8 c8 fe ff ff       	call   d8c0 <rw_kmem>
    d9f8:	83 c4 10             	add    $0x10,%esp
    d9fb:	89 44 24 08          	mov    %eax,0x8(%esp)
    d9ff:	eb 49                	jmp    da4a <rw_memory+0xc3>
		case 3:
			return (rw==READ)?0:count;	/* rw_null */
    da01:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    da06:	74 0a                	je     da12 <rw_memory+0x8b>
    da08:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    da0c:	89 44 24 04          	mov    %eax,0x4(%esp)
    da10:	eb 08                	jmp    da1a <rw_memory+0x93>
    da12:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    da19:	00 
    da1a:	8b 44 24 04          	mov    0x4(%esp),%eax
    da1e:	89 44 24 08          	mov    %eax,0x8(%esp)
    da22:	eb 26                	jmp    da4a <rw_memory+0xc3>
		case 4:
			return rw_port(rw,buf,count,pos);
    da24:	ff 74 24 20          	pushl  0x20(%esp)
    da28:	ff 74 24 20          	pushl  0x20(%esp)
    da2c:	ff 74 24 20          	pushl  0x20(%esp)
    da30:	ff 74 24 1c          	pushl  0x1c(%esp)
    da34:	e8 8d fe ff ff       	call   d8c6 <rw_port>
    da39:	83 c4 10             	add    $0x10,%esp
    da3c:	89 44 24 08          	mov    %eax,0x8(%esp)
    da40:	eb 08                	jmp    da4a <rw_memory+0xc3>
		default:
			return -EIO;
    da42:	c7 44 24 08 fb ff ff 	movl   $0xfffffffb,0x8(%esp)
    da49:	ff 
	}
}
    da4a:	8b 44 24 08          	mov    0x8(%esp),%eax
    da4e:	83 c4 0c             	add    $0xc,%esp
    da51:	c3                   	ret    

0000da52 <rw_char>:
	rw_tty,		/* /dev/tty */
	NULL,		/* /dev/lp */
	NULL};		/* unnamed pipes */

int rw_char(int rw,int dev, char * buf, int count, off_t * pos)
{
    da52:	83 ec 0c             	sub    $0xc,%esp
	crw_ptr call_addr;

	if (MAJOR(dev)>=NRDEVS)
    da55:	8b 44 24 14          	mov    0x14(%esp),%eax
    da59:	c1 e8 08             	shr    $0x8,%eax
    da5c:	83 f8 07             	cmp    $0x7,%eax
    da5f:	76 0a                	jbe    da6b <rw_char+0x19>
		return -ENODEV;
    da61:	c7 44 24 04 ed ff ff 	movl   $0xffffffed,0x4(%esp)
    da68:	ff 
    da69:	eb 46                	jmp    dab1 <rw_char+0x5f>
	if (!(call_addr=crw_table[MAJOR(dev)]))
    da6b:	8b 44 24 14          	mov    0x14(%esp),%eax
    da6f:	c1 e8 08             	shr    $0x8,%eax
    da72:	8b 04 85 00 be 01 00 	mov    0x1be00(,%eax,4),%eax
    da79:	89 44 24 08          	mov    %eax,0x8(%esp)
    da7d:	85 c0                	test   %eax,%eax
    da7f:	75 0a                	jne    da8b <rw_char+0x39>
		return -ENODEV;
    da81:	c7 44 24 04 ed ff ff 	movl   $0xffffffed,0x4(%esp)
    da88:	ff 
    da89:	eb 26                	jmp    dab1 <rw_char+0x5f>
	return call_addr(rw,MINOR(dev),buf,count,pos);
    da8b:	83 ec 0c             	sub    $0xc,%esp
    da8e:	ff 74 24 2c          	pushl  0x2c(%esp)
    da92:	ff 74 24 2c          	pushl  0x2c(%esp)
    da96:	ff 74 24 2c          	pushl  0x2c(%esp)
    da9a:	0f b6 44 24 2c       	movzbl 0x2c(%esp),%eax
    da9f:	50                   	push   %eax
    daa0:	ff 74 24 2c          	pushl  0x2c(%esp)
    daa4:	8b 44 24 28          	mov    0x28(%esp),%eax
    daa8:	ff d0                	call   *%eax
    daaa:	83 c4 20             	add    $0x20,%esp
    daad:	89 44 24 04          	mov    %eax,0x4(%esp)
}
    dab1:	8b 44 24 04          	mov    0x4(%esp),%eax
    dab5:	83 c4 0c             	add    $0xc,%esp
    dab8:	c3                   	ret    

0000dab9 <file_read>:

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))

int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    dab9:	53                   	push   %ebx
    daba:	83 ec 38             	sub    $0x38,%esp
	int left,chars,nr;
	struct buffer_head * bh;

	if ((left=count)<=0)
    dabd:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    dac1:	89 44 24 34          	mov    %eax,0x34(%esp)
    dac5:	85 c0                	test   %eax,%eax
    dac7:	7f 0d                	jg     dad6 <file_read+0x1d>
		return 0;
    dac9:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    dad0:	00 
    dad1:	e9 dd 01 00 00       	jmp    dcb3 <file_read+0x1fa>
	while (left) {
    dad6:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
    dadb:	0f 84 82 01 00 00    	je     dc63 <file_read+0x1aa>
		if ((nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE))) {
    dae1:	83 ec 08             	sub    $0x8,%esp
    dae4:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    dae8:	8b 40 0c             	mov    0xc(%eax),%eax
    daeb:	89 44 24 24          	mov    %eax,0x24(%esp)
    daef:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    daf4:	79 08                	jns    dafe <file_read+0x45>
    daf6:	81 44 24 24 ff 03 00 	addl   $0x3ff,0x24(%esp)
    dafd:	00 
    dafe:	8b 44 24 24          	mov    0x24(%esp),%eax
    db02:	c1 f8 0a             	sar    $0xa,%eax
    db05:	50                   	push   %eax
    db06:	ff 74 24 4c          	pushl  0x4c(%esp)
    db0a:	e8 06 dd ff ff       	call   b815 <bmap>
    db0f:	83 c4 10             	add    $0x10,%esp
    db12:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    db16:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
    db1b:	74 28                	je     db45 <file_read+0x8c>
			if (!(bh=bread(inode->i_dev,nr)))
    db1d:	83 ec 08             	sub    $0x8,%esp
    db20:	ff 74 24 34          	pushl  0x34(%esp)
    db24:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    db28:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    db2c:	50                   	push   %eax
    db2d:	e8 d1 eb ff ff       	call   c703 <bread>
    db32:	83 c4 10             	add    $0x10,%esp
    db35:	89 44 24 28          	mov    %eax,0x28(%esp)
    db39:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    db3e:	75 0d                	jne    db4d <file_read+0x94>
				break;
    db40:	e9 1e 01 00 00       	jmp    dc63 <file_read+0x1aa>
		} else
			bh = NULL;
    db45:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    db4c:	00 
		nr = filp->f_pos % BLOCK_SIZE;
    db4d:	8b 44 24 44          	mov    0x44(%esp),%eax
    db51:	8b 40 0c             	mov    0xc(%eax),%eax
    db54:	89 44 24 18          	mov    %eax,0x18(%esp)
    db58:	8b 44 24 18          	mov    0x18(%esp),%eax
    db5c:	89 44 24 14          	mov    %eax,0x14(%esp)
    db60:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    db65:	79 08                	jns    db6f <file_read+0xb6>
    db67:	81 44 24 14 ff 03 00 	addl   $0x3ff,0x14(%esp)
    db6e:	00 
    db6f:	8b 44 24 14          	mov    0x14(%esp),%eax
    db73:	c1 f8 0a             	sar    $0xa,%eax
    db76:	c1 e0 0a             	shl    $0xa,%eax
    db79:	8b 54 24 18          	mov    0x18(%esp),%edx
    db7d:	29 c2                	sub    %eax,%edx
    db7f:	89 d0                	mov    %edx,%eax
    db81:	89 44 24 2c          	mov    %eax,0x2c(%esp)
		chars = MIN( BLOCK_SIZE-nr , left );
    db85:	b8 00 04 00 00       	mov    $0x400,%eax
    db8a:	2b 44 24 2c          	sub    0x2c(%esp),%eax
    db8e:	89 44 24 30          	mov    %eax,0x30(%esp)
    db92:	8b 44 24 34          	mov    0x34(%esp),%eax
    db96:	89 44 24 0c          	mov    %eax,0xc(%esp)
    db9a:	8b 54 24 30          	mov    0x30(%esp),%edx
    db9e:	89 54 24 10          	mov    %edx,0x10(%esp)
    dba2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dba6:	39 44 24 10          	cmp    %eax,0x10(%esp)
    dbaa:	7e 08                	jle    dbb4 <file_read+0xfb>
    dbac:	8b 54 24 0c          	mov    0xc(%esp),%edx
    dbb0:	89 54 24 10          	mov    %edx,0x10(%esp)
    dbb4:	8b 44 24 10          	mov    0x10(%esp),%eax
    dbb8:	89 44 24 30          	mov    %eax,0x30(%esp)
		filp->f_pos += chars;
    dbbc:	8b 4c 24 44          	mov    0x44(%esp),%ecx
    dbc0:	8b 54 24 44          	mov    0x44(%esp),%edx
    dbc4:	8b 44 24 30          	mov    0x30(%esp),%eax
    dbc8:	03 42 0c             	add    0xc(%edx),%eax
    dbcb:	89 41 0c             	mov    %eax,0xc(%ecx)
		left -= chars;
    dbce:	8b 54 24 30          	mov    0x30(%esp),%edx
    dbd2:	8d 44 24 34          	lea    0x34(%esp),%eax
    dbd6:	29 10                	sub    %edx,(%eax)
		if (bh) {
    dbd8:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    dbdd:	74 58                	je     dc37 <file_read+0x17e>
			char * p = nr + bh->b_data;
    dbdf:	8b 44 24 28          	mov    0x28(%esp),%eax
    dbe3:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    dbe7:	8b 00                	mov    (%eax),%eax
    dbe9:	01 d0                	add    %edx,%eax
    dbeb:	89 44 24 24          	mov    %eax,0x24(%esp)
			while (chars-->0)
    dbef:	8b 54 24 30          	mov    0x30(%esp),%edx
    dbf3:	8d 44 24 30          	lea    0x30(%esp),%eax
    dbf7:	ff 08                	decl   (%eax)
    dbf9:	85 d2                	test   %edx,%edx
    dbfb:	7e 26                	jle    dc23 <file_read+0x16a>
				put_fs_byte(*(p++),buf++);
    dbfd:	83 ec 08             	sub    $0x8,%esp
    dc00:	8b 44 24 50          	mov    0x50(%esp),%eax
    dc04:	50                   	push   %eax
    dc05:	8d 44 24 54          	lea    0x54(%esp),%eax
    dc09:	ff 00                	incl   (%eax)
    dc0b:	8b 44 24 30          	mov    0x30(%esp),%eax
    dc0f:	0f be 00             	movsbl (%eax),%eax
    dc12:	50                   	push   %eax
    dc13:	8d 44 24 34          	lea    0x34(%esp),%eax
    dc17:	ff 00                	incl   (%eax)
    dc19:	e8 9e 00 00 00       	call   dcbc <put_fs_byte>
    dc1e:	83 c4 10             	add    $0x10,%esp
    dc21:	eb cc                	jmp    dbef <file_read+0x136>
			brelse(bh);
    dc23:	83 ec 0c             	sub    $0xc,%esp
    dc26:	ff 74 24 34          	pushl  0x34(%esp)
    dc2a:	e8 88 ea ff ff       	call   c6b7 <brelse>
    dc2f:	83 c4 10             	add    $0x10,%esp
    dc32:	e9 9f fe ff ff       	jmp    dad6 <file_read+0x1d>
		} else {
			while (chars-->0)
    dc37:	8b 54 24 30          	mov    0x30(%esp),%edx
    dc3b:	8d 44 24 30          	lea    0x30(%esp),%eax
    dc3f:	ff 08                	decl   (%eax)
    dc41:	85 d2                	test   %edx,%edx
    dc43:	0f 8e 8d fe ff ff    	jle    dad6 <file_read+0x1d>
				put_fs_byte(0,buf++);
    dc49:	83 ec 08             	sub    $0x8,%esp
    dc4c:	8b 44 24 50          	mov    0x50(%esp),%eax
    dc50:	50                   	push   %eax
    dc51:	8d 44 24 54          	lea    0x54(%esp),%eax
    dc55:	ff 00                	incl   (%eax)
    dc57:	6a 00                	push   $0x0
    dc59:	e8 5e 00 00 00       	call   dcbc <put_fs_byte>
    dc5e:	83 c4 10             	add    $0x10,%esp
    dc61:	eb d4                	jmp    dc37 <file_read+0x17e>
		}
	}
	inode->i_atime = CURRENT_TIME;
    dc63:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    dc67:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    dc6d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    dc72:	f7 e9                	imul   %ecx
    dc74:	c1 fa 05             	sar    $0x5,%edx
    dc77:	89 c8                	mov    %ecx,%eax
    dc79:	c1 f8 1f             	sar    $0x1f,%eax
    dc7c:	29 c2                	sub    %eax,%edx
    dc7e:	89 d0                	mov    %edx,%eax
    dc80:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    dc86:	89 43 24             	mov    %eax,0x24(%ebx)
	return (count-left)?(count-left):-ERROR;
    dc89:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    dc8d:	3b 44 24 34          	cmp    0x34(%esp),%eax
    dc91:	74 10                	je     dca3 <file_read+0x1ea>
    dc93:	8b 54 24 34          	mov    0x34(%esp),%edx
    dc97:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    dc9b:	29 d0                	sub    %edx,%eax
    dc9d:	89 44 24 08          	mov    %eax,0x8(%esp)
    dca1:	eb 08                	jmp    dcab <file_read+0x1f2>
    dca3:	c7 44 24 08 9d ff ff 	movl   $0xffffff9d,0x8(%esp)
    dcaa:	ff 
    dcab:	8b 54 24 08          	mov    0x8(%esp),%edx
    dcaf:	89 54 24 20          	mov    %edx,0x20(%esp)
}
    dcb3:	8b 44 24 20          	mov    0x20(%esp),%eax
    dcb7:	83 c4 38             	add    $0x38,%esp
    dcba:	5b                   	pop    %ebx
    dcbb:	c3                   	ret    

0000dcbc <put_fs_byte>:
{
    dcbc:	83 ec 04             	sub    $0x4,%esp
    dcbf:	8b 44 24 08          	mov    0x8(%esp),%eax
    dcc3:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    dcc7:	8a 54 24 03          	mov    0x3(%esp),%dl
    dccb:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dccf:	64 88 10             	mov    %dl,%fs:(%eax)
}
    dcd2:	83 c4 04             	add    $0x4,%esp
    dcd5:	c3                   	ret    

0000dcd6 <file_write>:

int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    dcd6:	53                   	push   %ebx
    dcd7:	83 ec 28             	sub    $0x28,%esp
	off_t pos;
	int block,c;
	struct buffer_head * bh;
	char * p;
	int i=0;
    dcda:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    dce1:	00 

/*
 * ok, append may not work when many processes are writing at the same time
 * but so what. That way leads to madness anyway.
 */
	if (filp->f_flags & O_APPEND)
    dce2:	8b 44 24 34          	mov    0x34(%esp),%eax
    dce6:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    dcea:	25 00 04 00 00       	and    $0x400,%eax
    dcef:	85 c0                	test   %eax,%eax
    dcf1:	74 0d                	je     dd00 <file_write+0x2a>
		pos = inode->i_size;
    dcf3:	8b 44 24 30          	mov    0x30(%esp),%eax
    dcf7:	8b 40 04             	mov    0x4(%eax),%eax
    dcfa:	89 44 24 24          	mov    %eax,0x24(%esp)
    dcfe:	eb 0b                	jmp    dd0b <file_write+0x35>
	else
		pos = filp->f_pos;
    dd00:	8b 44 24 34          	mov    0x34(%esp),%eax
    dd04:	8b 40 0c             	mov    0xc(%eax),%eax
    dd07:	89 44 24 24          	mov    %eax,0x24(%esp)
	while (i<count) {
    dd0b:	8b 44 24 10          	mov    0x10(%esp),%eax
    dd0f:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    dd13:	0f 8d 5a 01 00 00    	jge    de73 <file_write+0x19d>
		if (!(block = create_block(inode,pos/BLOCK_SIZE)))
    dd19:	83 ec 08             	sub    $0x8,%esp
    dd1c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    dd20:	89 44 24 14          	mov    %eax,0x14(%esp)
    dd24:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    dd29:	79 08                	jns    dd33 <file_write+0x5d>
    dd2b:	81 44 24 14 ff 03 00 	addl   $0x3ff,0x14(%esp)
    dd32:	00 
    dd33:	8b 44 24 14          	mov    0x14(%esp),%eax
    dd37:	c1 f8 0a             	sar    $0xa,%eax
    dd3a:	50                   	push   %eax
    dd3b:	ff 74 24 3c          	pushl  0x3c(%esp)
    dd3f:	e8 ed da ff ff       	call   b831 <create_block>
    dd44:	83 c4 10             	add    $0x10,%esp
    dd47:	89 44 24 20          	mov    %eax,0x20(%esp)
    dd4b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    dd50:	75 05                	jne    dd57 <file_write+0x81>
			break;
    dd52:	e9 1c 01 00 00       	jmp    de73 <file_write+0x19d>
		if (!(bh=bread(inode->i_dev,block)))
    dd57:	83 ec 08             	sub    $0x8,%esp
    dd5a:	ff 74 24 28          	pushl  0x28(%esp)
    dd5e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    dd62:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    dd66:	50                   	push   %eax
    dd67:	e8 97 e9 ff ff       	call   c703 <bread>
    dd6c:	83 c4 10             	add    $0x10,%esp
    dd6f:	89 44 24 18          	mov    %eax,0x18(%esp)
    dd73:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    dd78:	75 05                	jne    dd7f <file_write+0xa9>
			break;
    dd7a:	e9 f4 00 00 00       	jmp    de73 <file_write+0x19d>
		c = pos % BLOCK_SIZE;
    dd7f:	8b 44 24 24          	mov    0x24(%esp),%eax
    dd83:	89 44 24 08          	mov    %eax,0x8(%esp)
    dd87:	8b 54 24 08          	mov    0x8(%esp),%edx
    dd8b:	89 54 24 04          	mov    %edx,0x4(%esp)
    dd8f:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    dd94:	79 08                	jns    dd9e <file_write+0xc8>
    dd96:	81 44 24 04 ff 03 00 	addl   $0x3ff,0x4(%esp)
    dd9d:	00 
    dd9e:	8b 44 24 04          	mov    0x4(%esp),%eax
    dda2:	c1 f8 0a             	sar    $0xa,%eax
    dda5:	c1 e0 0a             	shl    $0xa,%eax
    dda8:	8b 54 24 08          	mov    0x8(%esp),%edx
    ddac:	29 c2                	sub    %eax,%edx
    ddae:	89 d0                	mov    %edx,%eax
    ddb0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		p = c + bh->b_data;
    ddb4:	8b 54 24 18          	mov    0x18(%esp),%edx
    ddb8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ddbc:	03 02                	add    (%edx),%eax
    ddbe:	89 44 24 14          	mov    %eax,0x14(%esp)
		bh->b_dirt = 1;
    ddc2:	8b 44 24 18          	mov    0x18(%esp),%eax
    ddc6:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		c = BLOCK_SIZE-c;
    ddca:	b8 00 04 00 00       	mov    $0x400,%eax
    ddcf:	2b 44 24 1c          	sub    0x1c(%esp),%eax
    ddd3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (c > count-i) c = count-i;
    ddd7:	8b 54 24 10          	mov    0x10(%esp),%edx
    dddb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    dddf:	29 d0                	sub    %edx,%eax
    dde1:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
    dde5:	7d 10                	jge    ddf7 <file_write+0x121>
    dde7:	8b 44 24 10          	mov    0x10(%esp),%eax
    ddeb:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    ddef:	29 c2                	sub    %eax,%edx
    ddf1:	89 d0                	mov    %edx,%eax
    ddf3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		pos += c;
    ddf7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    ddfb:	8d 44 24 24          	lea    0x24(%esp),%eax
    ddff:	01 10                	add    %edx,(%eax)
		if (pos > inode->i_size) {
    de01:	8b 54 24 30          	mov    0x30(%esp),%edx
    de05:	8b 44 24 24          	mov    0x24(%esp),%eax
    de09:	3b 42 04             	cmp    0x4(%edx),%eax
    de0c:	76 13                	jbe    de21 <file_write+0x14b>
			inode->i_size = pos;
    de0e:	8b 44 24 30          	mov    0x30(%esp),%eax
    de12:	8b 54 24 24          	mov    0x24(%esp),%edx
    de16:	89 50 04             	mov    %edx,0x4(%eax)
			inode->i_dirt = 1;
    de19:	8b 44 24 30          	mov    0x30(%esp),%eax
    de1d:	c6 40 33 01          	movb   $0x1,0x33(%eax)
		}
		i += c;
    de21:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    de25:	8d 44 24 10          	lea    0x10(%esp),%eax
    de29:	01 10                	add    %edx,(%eax)
		while (c-->0)
    de2b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    de2f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    de33:	ff 08                	decl   (%eax)
    de35:	85 d2                	test   %edx,%edx
    de37:	7e 26                	jle    de5f <file_write+0x189>
			*(p++) = get_fs_byte(buf++);
    de39:	8b 44 24 14          	mov    0x14(%esp),%eax
    de3d:	89 c3                	mov    %eax,%ebx
    de3f:	83 ec 0c             	sub    $0xc,%esp
    de42:	8b 44 24 44          	mov    0x44(%esp),%eax
    de46:	50                   	push   %eax
    de47:	8d 44 24 48          	lea    0x48(%esp),%eax
    de4b:	ff 00                	incl   (%eax)
    de4d:	8d 44 24 24          	lea    0x24(%esp),%eax
    de51:	ff 00                	incl   (%eax)
    de53:	e8 a0 00 00 00       	call   def8 <get_fs_byte>
    de58:	83 c4 10             	add    $0x10,%esp
    de5b:	88 03                	mov    %al,(%ebx)
    de5d:	eb cc                	jmp    de2b <file_write+0x155>
		brelse(bh);
    de5f:	83 ec 0c             	sub    $0xc,%esp
    de62:	ff 74 24 24          	pushl  0x24(%esp)
    de66:	e8 4c e8 ff ff       	call   c6b7 <brelse>
    de6b:	83 c4 10             	add    $0x10,%esp
    de6e:	e9 98 fe ff ff       	jmp    dd0b <file_write+0x35>
	}
	inode->i_mtime = CURRENT_TIME;
    de73:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    de77:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    de7d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    de82:	f7 e9                	imul   %ecx
    de84:	c1 fa 05             	sar    $0x5,%edx
    de87:	89 c8                	mov    %ecx,%eax
    de89:	c1 f8 1f             	sar    $0x1f,%eax
    de8c:	29 c2                	sub    %eax,%edx
    de8e:	89 d0                	mov    %edx,%eax
    de90:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    de96:	89 43 08             	mov    %eax,0x8(%ebx)
	if (!(filp->f_flags & O_APPEND)) {
    de99:	8b 44 24 34          	mov    0x34(%esp),%eax
    de9d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    dea1:	25 00 04 00 00       	and    $0x400,%eax
    dea6:	85 c0                	test   %eax,%eax
    dea8:	75 31                	jne    dedb <file_write+0x205>
		filp->f_pos = pos;
    deaa:	8b 54 24 34          	mov    0x34(%esp),%edx
    deae:	8b 44 24 24          	mov    0x24(%esp),%eax
    deb2:	89 42 0c             	mov    %eax,0xc(%edx)
		inode->i_ctime = CURRENT_TIME;
    deb5:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    deb9:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    debf:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    dec4:	f7 e9                	imul   %ecx
    dec6:	c1 fa 05             	sar    $0x5,%edx
    dec9:	89 c8                	mov    %ecx,%eax
    decb:	c1 f8 1f             	sar    $0x1f,%eax
    dece:	29 c2                	sub    %eax,%edx
    ded0:	89 d0                	mov    %edx,%eax
    ded2:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    ded8:	89 43 28             	mov    %eax,0x28(%ebx)
	}
	return (i?i:-1);
    dedb:	8b 44 24 10          	mov    0x10(%esp),%eax
    dedf:	89 04 24             	mov    %eax,(%esp)
    dee2:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    dee7:	75 07                	jne    def0 <file_write+0x21a>
    dee9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
    def0:	8b 04 24             	mov    (%esp),%eax
}
    def3:	83 c4 28             	add    $0x28,%esp
    def6:	5b                   	pop    %ebx
    def7:	c3                   	ret    

0000def8 <get_fs_byte>:
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    def8:	8b 44 24 04          	mov    0x4(%esp),%eax
    defc:	64 8a 00             	mov    %fs:(%eax),%al
	return _v;
    deff:	0f b6 c0             	movzbl %al,%eax
}
    df02:	c3                   	ret    

0000df03 <cp_stat>:
#include <linux/sched.h>
#include <linux/kernel.h>
#include <asm/segment.h>

static void cp_stat(struct m_inode * inode, struct stat * statbuf)
{
    df03:	83 ec 3c             	sub    $0x3c,%esp
	struct stat tmp;
	int i;

	verify_area(statbuf,sizeof (* statbuf));
    df06:	83 ec 08             	sub    $0x8,%esp
    df09:	6a 20                	push   $0x20
    df0b:	ff 74 24 50          	pushl  0x50(%esp)
    df0f:	e8 58 9f ff ff       	call   7e6c <verify_area>
    df14:	83 c4 10             	add    $0x10,%esp
	tmp.st_dev = inode->i_dev;
    df17:	8b 44 24 40          	mov    0x40(%esp),%eax
    df1b:	66 8b 40 2c          	mov    0x2c(%eax),%ax
    df1f:	66 89 44 24 10       	mov    %ax,0x10(%esp)
	tmp.st_ino = inode->i_num;
    df24:	8b 44 24 40          	mov    0x40(%esp),%eax
    df28:	66 8b 40 2e          	mov    0x2e(%eax),%ax
    df2c:	66 89 44 24 12       	mov    %ax,0x12(%esp)
	tmp.st_mode = inode->i_mode;
    df31:	8b 44 24 40          	mov    0x40(%esp),%eax
    df35:	66 8b 00             	mov    (%eax),%ax
    df38:	66 89 44 24 14       	mov    %ax,0x14(%esp)
	tmp.st_nlink = inode->i_nlinks;
    df3d:	8b 44 24 40          	mov    0x40(%esp),%eax
    df41:	8a 40 0d             	mov    0xd(%eax),%al
    df44:	88 44 24 16          	mov    %al,0x16(%esp)
	tmp.st_uid = inode->i_uid;
    df48:	8b 44 24 40          	mov    0x40(%esp),%eax
    df4c:	66 8b 40 02          	mov    0x2(%eax),%ax
    df50:	66 89 44 24 18       	mov    %ax,0x18(%esp)
	tmp.st_gid = inode->i_gid;
    df55:	8b 44 24 40          	mov    0x40(%esp),%eax
    df59:	8a 40 0c             	mov    0xc(%eax),%al
    df5c:	88 44 24 1a          	mov    %al,0x1a(%esp)
	tmp.st_rdev = inode->i_zone[0];
    df60:	8b 44 24 40          	mov    0x40(%esp),%eax
    df64:	66 8b 40 0e          	mov    0xe(%eax),%ax
    df68:	66 89 44 24 1c       	mov    %ax,0x1c(%esp)
	tmp.st_size = inode->i_size;
    df6d:	8b 44 24 40          	mov    0x40(%esp),%eax
    df71:	8b 40 04             	mov    0x4(%eax),%eax
    df74:	89 44 24 20          	mov    %eax,0x20(%esp)
	tmp.st_atime = inode->i_atime;
    df78:	8b 44 24 40          	mov    0x40(%esp),%eax
    df7c:	8b 40 24             	mov    0x24(%eax),%eax
    df7f:	89 44 24 24          	mov    %eax,0x24(%esp)
	tmp.st_mtime = inode->i_mtime;
    df83:	8b 44 24 40          	mov    0x40(%esp),%eax
    df87:	8b 40 08             	mov    0x8(%eax),%eax
    df8a:	89 44 24 28          	mov    %eax,0x28(%esp)
	tmp.st_ctime = inode->i_ctime;
    df8e:	8b 44 24 40          	mov    0x40(%esp),%eax
    df92:	8b 40 28             	mov    0x28(%eax),%eax
    df95:	89 44 24 2c          	mov    %eax,0x2c(%esp)
	for (i=0 ; i<sizeof (tmp) ; i++)
    df99:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    dfa0:	00 
    dfa1:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
    dfa6:	77 28                	ja     dfd0 <cp_stat+0xcd>
		put_fs_byte(((char *) &tmp)[i],&((char *) statbuf)[i]);
    dfa8:	83 ec 08             	sub    $0x8,%esp
    dfab:	8b 44 24 14          	mov    0x14(%esp),%eax
    dfaf:	03 44 24 4c          	add    0x4c(%esp),%eax
    dfb3:	50                   	push   %eax
    dfb4:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    dfb8:	03 44 24 18          	add    0x18(%esp),%eax
    dfbc:	0f be 00             	movsbl (%eax),%eax
    dfbf:	50                   	push   %eax
    dfc0:	e8 0f 00 00 00       	call   dfd4 <put_fs_byte>
    dfc5:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<sizeof (tmp) ; i++)
    dfc8:	8d 44 24 0c          	lea    0xc(%esp),%eax
    dfcc:	ff 00                	incl   (%eax)
    dfce:	eb d1                	jmp    dfa1 <cp_stat+0x9e>
}
    dfd0:	83 c4 3c             	add    $0x3c,%esp
    dfd3:	c3                   	ret    

0000dfd4 <put_fs_byte>:
{
    dfd4:	83 ec 04             	sub    $0x4,%esp
    dfd7:	8b 44 24 08          	mov    0x8(%esp),%eax
    dfdb:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    dfdf:	8a 54 24 03          	mov    0x3(%esp),%dl
    dfe3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    dfe7:	64 88 10             	mov    %dl,%fs:(%eax)
}
    dfea:	83 c4 04             	add    $0x4,%esp
    dfed:	c3                   	ret    

0000dfee <sys_stat>:

int sys_stat(char * filename, struct stat * statbuf)
{
    dfee:	83 ec 0c             	sub    $0xc,%esp
	struct m_inode * inode;

	if (!(inode=namei(filename)))
    dff1:	83 ec 0c             	sub    $0xc,%esp
    dff4:	ff 74 24 1c          	pushl  0x1c(%esp)
    dff8:	e8 8b 1d 00 00       	call   fd88 <namei>
    dffd:	83 c4 10             	add    $0x10,%esp
    e000:	89 44 24 08          	mov    %eax,0x8(%esp)
    e004:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    e009:	75 0a                	jne    e015 <sys_stat+0x27>
		return -ENOENT;
    e00b:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    e012:	ff 
    e013:	eb 2a                	jmp    e03f <sys_stat+0x51>
	cp_stat(inode,statbuf);
    e015:	83 ec 08             	sub    $0x8,%esp
    e018:	ff 74 24 1c          	pushl  0x1c(%esp)
    e01c:	ff 74 24 14          	pushl  0x14(%esp)
    e020:	e8 de fe ff ff       	call   df03 <cp_stat>
    e025:	83 c4 10             	add    $0x10,%esp
	iput(inode);
    e028:	83 ec 0c             	sub    $0xc,%esp
    e02b:	ff 74 24 14          	pushl  0x14(%esp)
    e02f:	e8 19 d8 ff ff       	call   b84d <iput>
    e034:	83 c4 10             	add    $0x10,%esp
	return 0;
    e037:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    e03e:	00 
}
    e03f:	8b 44 24 04          	mov    0x4(%esp),%eax
    e043:	83 c4 0c             	add    $0xc,%esp
    e046:	c3                   	ret    

0000e047 <sys_fstat>:

int sys_fstat(unsigned int fd, struct stat * statbuf)
{
    e047:	83 ec 0c             	sub    $0xc,%esp
	struct file * f;
	struct m_inode * inode;

	if (fd >= NR_OPEN || !(f=current->filp[fd]) || !(inode=f->f_inode))
    e04a:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
    e04f:	77 27                	ja     e078 <sys_fstat+0x31>
    e051:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e056:	8b 54 24 10          	mov    0x10(%esp),%edx
    e05a:	8b 84 90 80 02 00 00 	mov    0x280(%eax,%edx,4),%eax
    e061:	89 44 24 08          	mov    %eax,0x8(%esp)
    e065:	85 c0                	test   %eax,%eax
    e067:	74 0f                	je     e078 <sys_fstat+0x31>
    e069:	8b 44 24 08          	mov    0x8(%esp),%eax
    e06d:	8b 40 08             	mov    0x8(%eax),%eax
    e070:	89 44 24 04          	mov    %eax,0x4(%esp)
    e074:	85 c0                	test   %eax,%eax
    e076:	75 09                	jne    e081 <sys_fstat+0x3a>
		return -EBADF;
    e078:	c7 04 24 f7 ff ff ff 	movl   $0xfffffff7,(%esp)
    e07f:	eb 1a                	jmp    e09b <sys_fstat+0x54>
	cp_stat(inode,statbuf);
    e081:	83 ec 08             	sub    $0x8,%esp
    e084:	ff 74 24 1c          	pushl  0x1c(%esp)
    e088:	ff 74 24 10          	pushl  0x10(%esp)
    e08c:	e8 72 fe ff ff       	call   df03 <cp_stat>
    e091:	83 c4 10             	add    $0x10,%esp
	return 0;
    e094:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
}
    e09b:	8b 04 24             	mov    (%esp),%eax
    e09e:	83 c4 0c             	add    $0xc,%esp
    e0a1:	c3                   	ret    

0000e0a2 <create_tables>:
 * create_tables() parses the env- and arg-strings in new user
 * memory and creates the pointer tables from them, and puts their
 * addresses on the "stack", returning the new stack pointer value.
 */
static unsigned long * create_tables(char * p,int argc,int envc)
{
    e0a2:	83 ec 0c             	sub    $0xc,%esp
	unsigned long *argv,*envp;
	unsigned long * sp;

	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
    e0a5:	8b 44 24 10          	mov    0x10(%esp),%eax
    e0a9:	83 e0 fc             	and    $0xfffffffc,%eax
    e0ac:	89 04 24             	mov    %eax,(%esp)
	sp -= envc+1;
    e0af:	8b 44 24 18          	mov    0x18(%esp),%eax
    e0b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e0ba:	8b 04 24             	mov    (%esp),%eax
    e0bd:	29 d0                	sub    %edx,%eax
    e0bf:	83 e8 04             	sub    $0x4,%eax
    e0c2:	89 04 24             	mov    %eax,(%esp)
	envp = sp;
    e0c5:	8b 04 24             	mov    (%esp),%eax
    e0c8:	89 44 24 04          	mov    %eax,0x4(%esp)
	sp -= argc+1;
    e0cc:	8b 44 24 14          	mov    0x14(%esp),%eax
    e0d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e0d7:	8b 04 24             	mov    (%esp),%eax
    e0da:	29 d0                	sub    %edx,%eax
    e0dc:	83 e8 04             	sub    $0x4,%eax
    e0df:	89 04 24             	mov    %eax,(%esp)
	argv = sp;
    e0e2:	8b 04 24             	mov    (%esp),%eax
    e0e5:	89 44 24 08          	mov    %eax,0x8(%esp)
	put_fs_long((unsigned long)envp,--sp);
    e0e9:	83 ec 08             	sub    $0x8,%esp
    e0ec:	8d 44 24 08          	lea    0x8(%esp),%eax
    e0f0:	83 28 04             	subl   $0x4,(%eax)
    e0f3:	ff 74 24 08          	pushl  0x8(%esp)
    e0f7:	ff 74 24 10          	pushl  0x10(%esp)
    e0fb:	e8 f1 00 00 00       	call   e1f1 <put_fs_long>
    e100:	83 c4 10             	add    $0x10,%esp
	put_fs_long((unsigned long)argv,--sp);
    e103:	83 ec 08             	sub    $0x8,%esp
    e106:	8d 44 24 08          	lea    0x8(%esp),%eax
    e10a:	83 28 04             	subl   $0x4,(%eax)
    e10d:	ff 74 24 08          	pushl  0x8(%esp)
    e111:	ff 74 24 14          	pushl  0x14(%esp)
    e115:	e8 d7 00 00 00       	call   e1f1 <put_fs_long>
    e11a:	83 c4 10             	add    $0x10,%esp
	put_fs_long((unsigned long)argc,--sp);
    e11d:	83 ec 08             	sub    $0x8,%esp
    e120:	8d 44 24 08          	lea    0x8(%esp),%eax
    e124:	83 28 04             	subl   $0x4,(%eax)
    e127:	ff 74 24 08          	pushl  0x8(%esp)
    e12b:	ff 74 24 20          	pushl  0x20(%esp)
    e12f:	e8 bd 00 00 00       	call   e1f1 <put_fs_long>
    e134:	83 c4 10             	add    $0x10,%esp
	while (argc-->0) {
    e137:	8b 54 24 14          	mov    0x14(%esp),%edx
    e13b:	8d 44 24 14          	lea    0x14(%esp),%eax
    e13f:	ff 08                	decl   (%eax)
    e141:	85 d2                	test   %edx,%edx
    e143:	7e 35                	jle    e17a <create_tables+0xd8>
		put_fs_long((unsigned long) p,argv++);
    e145:	83 ec 08             	sub    $0x8,%esp
    e148:	8b 44 24 10          	mov    0x10(%esp),%eax
    e14c:	50                   	push   %eax
    e14d:	8d 44 24 14          	lea    0x14(%esp),%eax
    e151:	83 00 04             	addl   $0x4,(%eax)
    e154:	ff 74 24 1c          	pushl  0x1c(%esp)
    e158:	e8 94 00 00 00       	call   e1f1 <put_fs_long>
    e15d:	83 c4 10             	add    $0x10,%esp
		while (get_fs_byte(p++)) /* nothing */ ;
    e160:	83 ec 0c             	sub    $0xc,%esp
    e163:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e167:	50                   	push   %eax
    e168:	ff 44 24 20          	incl   0x20(%esp)
    e16c:	e8 75 00 00 00       	call   e1e6 <get_fs_byte>
    e171:	83 c4 10             	add    $0x10,%esp
    e174:	84 c0                	test   %al,%al
    e176:	74 bf                	je     e137 <create_tables+0x95>
    e178:	eb e6                	jmp    e160 <create_tables+0xbe>
	}
	put_fs_long(0,argv);
    e17a:	83 ec 08             	sub    $0x8,%esp
    e17d:	ff 74 24 10          	pushl  0x10(%esp)
    e181:	6a 00                	push   $0x0
    e183:	e8 69 00 00 00       	call   e1f1 <put_fs_long>
    e188:	83 c4 10             	add    $0x10,%esp
	while (envc-->0) {
    e18b:	8b 54 24 18          	mov    0x18(%esp),%edx
    e18f:	8d 44 24 18          	lea    0x18(%esp),%eax
    e193:	ff 08                	decl   (%eax)
    e195:	85 d2                	test   %edx,%edx
    e197:	7e 35                	jle    e1ce <create_tables+0x12c>
		put_fs_long((unsigned long) p,envp++);
    e199:	83 ec 08             	sub    $0x8,%esp
    e19c:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e1a0:	50                   	push   %eax
    e1a1:	8d 44 24 10          	lea    0x10(%esp),%eax
    e1a5:	83 00 04             	addl   $0x4,(%eax)
    e1a8:	ff 74 24 1c          	pushl  0x1c(%esp)
    e1ac:	e8 40 00 00 00       	call   e1f1 <put_fs_long>
    e1b1:	83 c4 10             	add    $0x10,%esp
		while (get_fs_byte(p++)) /* nothing */ ;
    e1b4:	83 ec 0c             	sub    $0xc,%esp
    e1b7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    e1bb:	50                   	push   %eax
    e1bc:	ff 44 24 20          	incl   0x20(%esp)
    e1c0:	e8 21 00 00 00       	call   e1e6 <get_fs_byte>
    e1c5:	83 c4 10             	add    $0x10,%esp
    e1c8:	84 c0                	test   %al,%al
    e1ca:	74 bf                	je     e18b <create_tables+0xe9>
    e1cc:	eb e6                	jmp    e1b4 <create_tables+0x112>
	}
	put_fs_long(0,envp);
    e1ce:	83 ec 08             	sub    $0x8,%esp
    e1d1:	ff 74 24 0c          	pushl  0xc(%esp)
    e1d5:	6a 00                	push   $0x0
    e1d7:	e8 15 00 00 00       	call   e1f1 <put_fs_long>
    e1dc:	83 c4 10             	add    $0x10,%esp
	return sp;
    e1df:	8b 04 24             	mov    (%esp),%eax
}
    e1e2:	83 c4 0c             	add    $0xc,%esp
    e1e5:	c3                   	ret    

0000e1e6 <get_fs_byte>:
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    e1e6:	8b 44 24 04          	mov    0x4(%esp),%eax
    e1ea:	64 8a 00             	mov    %fs:(%eax),%al
	return _v;
    e1ed:	0f b6 c0             	movzbl %al,%eax
}
    e1f0:	c3                   	ret    

0000e1f1 <put_fs_long>:
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    e1f1:	8b 54 24 04          	mov    0x4(%esp),%edx
    e1f5:	8b 44 24 08          	mov    0x8(%esp),%eax
    e1f9:	64 89 10             	mov    %edx,%fs:(%eax)
}
    e1fc:	c3                   	ret    

0000e1fd <count>:

/*
 * count() counts the number of arguments/envelopes
 */
static int count(char ** argv)
{
    e1fd:	83 ec 0c             	sub    $0xc,%esp
	int i=0;
    e200:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    e207:	00 
	char ** tmp;

	if ((tmp = argv))
    e208:	8b 44 24 10          	mov    0x10(%esp),%eax
    e20c:	89 44 24 04          	mov    %eax,0x4(%esp)
    e210:	85 c0                	test   %eax,%eax
    e212:	74 23                	je     e237 <count+0x3a>
		while (get_fs_long((unsigned long *) (tmp++)))
    e214:	83 ec 0c             	sub    $0xc,%esp
    e217:	8b 44 24 10          	mov    0x10(%esp),%eax
    e21b:	50                   	push   %eax
    e21c:	8d 44 24 14          	lea    0x14(%esp),%eax
    e220:	83 00 04             	addl   $0x4,(%eax)
    e223:	e8 17 00 00 00       	call   e23f <get_fs_long>
    e228:	83 c4 10             	add    $0x10,%esp
    e22b:	85 c0                	test   %eax,%eax
    e22d:	74 08                	je     e237 <count+0x3a>
			i++;
    e22f:	8d 44 24 08          	lea    0x8(%esp),%eax
    e233:	ff 00                	incl   (%eax)
    e235:	eb dd                	jmp    e214 <count+0x17>

	return i;
    e237:	8b 44 24 08          	mov    0x8(%esp),%eax
}
    e23b:	83 c4 0c             	add    $0xc,%esp
    e23e:	c3                   	ret    

0000e23f <get_fs_long>:
{
    e23f:	83 ec 04             	sub    $0x4,%esp
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
    e242:	8b 44 24 08          	mov    0x8(%esp),%eax
    e246:	64 8b 00             	mov    %fs:(%eax),%eax
    e249:	89 04 24             	mov    %eax,(%esp)
    e24c:	8b 04 24             	mov    (%esp),%eax
}
    e24f:	83 c4 04             	add    $0x4,%esp
    e252:	c3                   	ret    

0000e253 <copy_strings>:
 * it is expensive to load a segment register, we try to avoid calling
 * set_fs() unless we absolutely have to.
 */
static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,
		unsigned long p, int from_kmem)
{
    e253:	53                   	push   %ebx
    e254:	83 ec 28             	sub    $0x28,%esp
	char *tmp, *pag=NULL;
    e257:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    e25e:	00 
	int len, offset = 0;
    e25f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    e266:	00 
	unsigned long old_fs, new_fs;

	if (!p)
    e267:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    e26c:	75 0d                	jne    e27b <copy_strings+0x28>
		return 0;	/* bullet-proofing */
    e26e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    e275:	00 
    e276:	e9 ab 01 00 00       	jmp    e426 <copy_strings+0x1d3>
	new_fs = get_ds();
    e27b:	e8 ca 01 00 00       	call   e44a <get_ds>
    e280:	89 44 24 10          	mov    %eax,0x10(%esp)
	old_fs = get_fs();
    e284:	e8 ad 01 00 00       	call   e436 <get_fs>
    e289:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (from_kmem==2)
    e28d:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    e292:	75 0f                	jne    e2a3 <copy_strings+0x50>
		set_fs(new_fs);
    e294:	83 ec 0c             	sub    $0xc,%esp
    e297:	ff 74 24 1c          	pushl  0x1c(%esp)
    e29b:	e8 8f 01 00 00       	call   e42f <set_fs>
    e2a0:	83 c4 10             	add    $0x10,%esp
	while (argc-- > 0) {
    e2a3:	8b 44 24 30          	mov    0x30(%esp),%eax
    e2a7:	ff 4c 24 30          	decl   0x30(%esp)
    e2ab:	85 c0                	test   %eax,%eax
    e2ad:	0f 8e 55 01 00 00    	jle    e408 <copy_strings+0x1b5>
		if (from_kmem == 1)
    e2b3:	83 7c 24 40 01       	cmpl   $0x1,0x40(%esp)
    e2b8:	75 0f                	jne    e2c9 <copy_strings+0x76>
			set_fs(new_fs);
    e2ba:	83 ec 0c             	sub    $0xc,%esp
    e2bd:	ff 74 24 1c          	pushl  0x1c(%esp)
    e2c1:	e8 69 01 00 00       	call   e42f <set_fs>
    e2c6:	83 c4 10             	add    $0x10,%esp
		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))
    e2c9:	8b 44 24 30          	mov    0x30(%esp),%eax
    e2cd:	c1 e0 02             	shl    $0x2,%eax
    e2d0:	03 44 24 34          	add    0x34(%esp),%eax
    e2d4:	50                   	push   %eax
    e2d5:	e8 65 ff ff ff       	call   e23f <get_fs_long>
    e2da:	83 c4 04             	add    $0x4,%esp
    e2dd:	89 44 24 24          	mov    %eax,0x24(%esp)
    e2e1:	8b 44 24 24          	mov    0x24(%esp),%eax
    e2e5:	85 c0                	test   %eax,%eax
    e2e7:	75 10                	jne    e2f9 <copy_strings+0xa6>
			panic("argc is wrong");
    e2e9:	83 ec 0c             	sub    $0xc,%esp
    e2ec:	68 bc 8f 01 00       	push   $0x18fbc
    e2f1:	e8 23 a0 ff ff       	call   8319 <panic>
    e2f6:	83 c4 10             	add    $0x10,%esp
		if (from_kmem == 1)
    e2f9:	83 7c 24 40 01       	cmpl   $0x1,0x40(%esp)
    e2fe:	75 0f                	jne    e30f <copy_strings+0xbc>
			set_fs(old_fs);
    e300:	83 ec 0c             	sub    $0xc,%esp
    e303:	ff 74 24 20          	pushl  0x20(%esp)
    e307:	e8 23 01 00 00       	call   e42f <set_fs>
    e30c:	83 c4 10             	add    $0x10,%esp
		len=0;		/* remember zero-padding */
    e30f:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    e316:	00 
		do {
			len++;
    e317:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    e31b:	ff 00                	incl   (%eax)
		} while (get_fs_byte(tmp++));
    e31d:	8b 44 24 24          	mov    0x24(%esp),%eax
    e321:	50                   	push   %eax
    e322:	8d 44 24 28          	lea    0x28(%esp),%eax
    e326:	ff 00                	incl   (%eax)
    e328:	e8 b9 fe ff ff       	call   e1e6 <get_fs_byte>
    e32d:	83 c4 04             	add    $0x4,%esp
    e330:	84 c0                	test   %al,%al
    e332:	74 02                	je     e336 <copy_strings+0xe3>
    e334:	eb e1                	jmp    e317 <copy_strings+0xc4>
		if (p-len < 0) {	/* this shouldn't happen - 128kB */
			set_fs(old_fs);
			return 0;
		}
		while (len) {
    e336:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    e33b:	0f 84 62 ff ff ff    	je     e2a3 <copy_strings+0x50>
			--p; --tmp; --len;
    e341:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    e345:	ff 08                	decl   (%eax)
    e347:	8d 44 24 24          	lea    0x24(%esp),%eax
    e34b:	ff 08                	decl   (%eax)
    e34d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    e351:	ff 08                	decl   (%eax)
			if (--offset < 0) {
    e353:	8d 44 24 18          	lea    0x18(%esp),%eax
    e357:	ff 08                	decl   (%eax)
    e359:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    e35e:	0f 89 87 00 00 00    	jns    e3eb <copy_strings+0x198>
				offset = p % PAGE_SIZE;
    e364:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e368:	25 ff 0f 00 00       	and    $0xfff,%eax
    e36d:	89 44 24 18          	mov    %eax,0x18(%esp)
				if (from_kmem==2)
    e371:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    e376:	75 0f                	jne    e387 <copy_strings+0x134>
					set_fs(old_fs);
    e378:	83 ec 0c             	sub    $0xc,%esp
    e37b:	ff 74 24 20          	pushl  0x20(%esp)
    e37f:	e8 ab 00 00 00       	call   e42f <set_fs>
    e384:	83 c4 10             	add    $0x10,%esp
				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
    e387:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e38b:	c1 e8 0c             	shr    $0xc,%eax
    e38e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e395:	8b 44 24 38          	mov    0x38(%esp),%eax
    e399:	8b 04 02             	mov    (%edx,%eax,1),%eax
    e39c:	89 44 24 20          	mov    %eax,0x20(%esp)
    e3a0:	85 c0                	test   %eax,%eax
    e3a2:	75 31                	jne    e3d5 <copy_strings+0x182>
    e3a4:	e8 c7 b5 ff ff       	call   9970 <get_free_page>
    e3a9:	89 c1                	mov    %eax,%ecx
    e3ab:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e3af:	c1 e8 0c             	shr    $0xc,%eax
    e3b2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e3b9:	8b 44 24 38          	mov    0x38(%esp),%eax
    e3bd:	89 0c 02             	mov    %ecx,(%edx,%eax,1)
    e3c0:	8b 04 02             	mov    (%edx,%eax,1),%eax
    e3c3:	89 44 24 20          	mov    %eax,0x20(%esp)
    e3c7:	85 c0                	test   %eax,%eax
    e3c9:	75 0a                	jne    e3d5 <copy_strings+0x182>
				    !(pag = (char *) page[p/PAGE_SIZE] =
				      (unsigned long *) get_free_page())) 
					return 0;
    e3cb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    e3d2:	00 
    e3d3:	eb 51                	jmp    e426 <copy_strings+0x1d3>
				if (from_kmem==2)
    e3d5:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    e3da:	75 0f                	jne    e3eb <copy_strings+0x198>
					set_fs(new_fs);
    e3dc:	83 ec 0c             	sub    $0xc,%esp
    e3df:	ff 74 24 1c          	pushl  0x1c(%esp)
    e3e3:	e8 47 00 00 00       	call   e42f <set_fs>
    e3e8:	83 c4 10             	add    $0x10,%esp

			}
			*(pag + offset) = get_fs_byte(tmp);
    e3eb:	8b 44 24 18          	mov    0x18(%esp),%eax
    e3ef:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    e3f3:	01 c3                	add    %eax,%ebx
    e3f5:	ff 74 24 24          	pushl  0x24(%esp)
    e3f9:	e8 e8 fd ff ff       	call   e1e6 <get_fs_byte>
    e3fe:	83 c4 04             	add    $0x4,%esp
    e401:	88 03                	mov    %al,(%ebx)
    e403:	e9 2e ff ff ff       	jmp    e336 <copy_strings+0xe3>
		}
	}
	if (from_kmem==2)
    e408:	83 7c 24 40 02       	cmpl   $0x2,0x40(%esp)
    e40d:	75 0f                	jne    e41e <copy_strings+0x1cb>
		set_fs(old_fs);
    e40f:	83 ec 0c             	sub    $0xc,%esp
    e412:	ff 74 24 20          	pushl  0x20(%esp)
    e416:	e8 14 00 00 00       	call   e42f <set_fs>
    e41b:	83 c4 10             	add    $0x10,%esp
	return p;
    e41e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    e422:	89 44 24 0c          	mov    %eax,0xc(%esp)
}
    e426:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e42a:	83 c4 28             	add    $0x28,%esp
    e42d:	5b                   	pop    %ebx
    e42e:	c3                   	ret    

0000e42f <set_fs>:
	return _v;
}

static inline void set_fs(unsigned long val)
{
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    e42f:	8b 44 24 04          	mov    0x4(%esp),%eax
    e433:	8e e0                	mov    %eax,%fs
}
    e435:	c3                   	ret    

0000e436 <get_fs>:
{
    e436:	83 ec 04             	sub    $0x4,%esp
	__asm__("mov %%fs,%%ax":"=a" (_v):);
    e439:	66 8c e0             	mov    %fs,%ax
    e43c:	66 89 44 24 02       	mov    %ax,0x2(%esp)
	return _v;
    e441:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
}
    e446:	83 c4 04             	add    $0x4,%esp
    e449:	c3                   	ret    

0000e44a <get_ds>:
{
    e44a:	83 ec 04             	sub    $0x4,%esp
	__asm__("mov %%ds,%%ax":"=a" (_v):);
    e44d:	66 8c d8             	mov    %ds,%ax
    e450:	66 89 44 24 02       	mov    %ax,0x2(%esp)
	return _v;
    e455:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
}
    e45a:	83 c4 04             	add    $0x4,%esp
    e45d:	c3                   	ret    

0000e45e <change_ldt>:

static unsigned long change_ldt(unsigned long text_size,unsigned long * page)
{
    e45e:	53                   	push   %ebx
    e45f:	83 ec 18             	sub    $0x18,%esp
	unsigned long code_limit,data_limit,code_base,data_base;
	int i;

	code_limit = text_size+PAGE_SIZE -1;
    e462:	8b 44 24 20          	mov    0x20(%esp),%eax
    e466:	05 ff 0f 00 00       	add    $0xfff,%eax
    e46b:	89 44 24 14          	mov    %eax,0x14(%esp)
	code_limit &= 0xFFFFF000;
    e46f:	8d 44 24 14          	lea    0x14(%esp),%eax
    e473:	81 20 00 f0 ff ff    	andl   $0xfffff000,(%eax)
	data_limit = 0x4000000;
    e479:	c7 44 24 10 00 00 00 	movl   $0x4000000,0x10(%esp)
    e480:	04 
	code_base = get_base(current->ldt[1]);
    e481:	83 ec 0c             	sub    $0xc,%esp
    e484:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e489:	05 d8 02 00 00       	add    $0x2d8,%eax
    e48e:	50                   	push   %eax
    e48f:	e8 47 01 00 00       	call   e5db <_get_base>
    e494:	83 c4 10             	add    $0x10,%esp
    e497:	89 44 24 0c          	mov    %eax,0xc(%esp)
	data_base = code_base;
    e49b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e49f:	89 44 24 08          	mov    %eax,0x8(%esp)
	set_base(current->ldt[1],code_base);
    e4a3:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    e4a9:	81 c3 da 02 00 00    	add    $0x2da,%ebx
    e4af:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    e4b5:	81 c1 dc 02 00 00    	add    $0x2dc,%ecx
    e4bb:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e4c0:	05 df 02 00 00       	add    $0x2df,%eax
    e4c5:	8b 54 24 0c          	mov    0xc(%esp),%edx
    e4c9:	52                   	push   %edx
    e4ca:	66 89 13             	mov    %dx,(%ebx)
    e4cd:	c1 ca 10             	ror    $0x10,%edx
    e4d0:	88 11                	mov    %dl,(%ecx)
    e4d2:	88 30                	mov    %dh,(%eax)
    e4d4:	5a                   	pop    %edx
	set_limit(current->ldt[1],code_limit);
    e4d5:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    e4db:	81 c3 d8 02 00 00    	add    $0x2d8,%ebx
    e4e1:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    e4e7:	81 c1 de 02 00 00    	add    $0x2de,%ecx
    e4ed:	8b 44 24 14          	mov    0x14(%esp),%eax
    e4f1:	48                   	dec    %eax
    e4f2:	89 c2                	mov    %eax,%edx
    e4f4:	c1 ea 0c             	shr    $0xc,%edx
    e4f7:	52                   	push   %edx
    e4f8:	66 89 13             	mov    %dx,(%ebx)
    e4fb:	c1 ca 10             	ror    $0x10,%edx
    e4fe:	8a 31                	mov    (%ecx),%dh
    e500:	80 e6 f0             	and    $0xf0,%dh
    e503:	08 f2                	or     %dh,%dl
    e505:	88 11                	mov    %dl,(%ecx)
    e507:	5a                   	pop    %edx
	set_base(current->ldt[2],data_base);
    e508:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    e50e:	81 c3 e2 02 00 00    	add    $0x2e2,%ebx
    e514:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    e51a:	81 c1 e4 02 00 00    	add    $0x2e4,%ecx
    e520:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e525:	05 e7 02 00 00       	add    $0x2e7,%eax
    e52a:	8b 54 24 08          	mov    0x8(%esp),%edx
    e52e:	52                   	push   %edx
    e52f:	66 89 13             	mov    %dx,(%ebx)
    e532:	c1 ca 10             	ror    $0x10,%edx
    e535:	88 11                	mov    %dl,(%ecx)
    e537:	88 30                	mov    %dh,(%eax)
    e539:	5a                   	pop    %edx
	set_limit(current->ldt[2],data_limit);
    e53a:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    e540:	81 c3 e0 02 00 00    	add    $0x2e0,%ebx
    e546:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    e54c:	81 c1 e6 02 00 00    	add    $0x2e6,%ecx
    e552:	8b 44 24 10          	mov    0x10(%esp),%eax
    e556:	48                   	dec    %eax
    e557:	89 c2                	mov    %eax,%edx
    e559:	c1 ea 0c             	shr    $0xc,%edx
    e55c:	52                   	push   %edx
    e55d:	66 89 13             	mov    %dx,(%ebx)
    e560:	c1 ca 10             	ror    $0x10,%edx
    e563:	8a 31                	mov    (%ecx),%dh
    e565:	80 e6 f0             	and    $0xf0,%dh
    e568:	08 f2                	or     %dh,%dl
    e56a:	88 11                	mov    %dl,(%ecx)
    e56c:	5a                   	pop    %edx
/* make sure fs points to the NEW data segment */
	__asm__("pushl $0x17\n\tpop %%fs"::);
    e56d:	6a 17                	push   $0x17
    e56f:	0f a1                	pop    %fs
	data_base += data_limit;
    e571:	8b 54 24 10          	mov    0x10(%esp),%edx
    e575:	8d 44 24 08          	lea    0x8(%esp),%eax
    e579:	01 10                	add    %edx,(%eax)
	for (i=MAX_ARG_PAGES-1 ; i>=0 ; i--) {
    e57b:	c7 44 24 04 1f 00 00 	movl   $0x1f,0x4(%esp)
    e582:	00 
    e583:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    e588:	78 48                	js     e5d2 <change_ldt+0x174>
		data_base -= PAGE_SIZE;
    e58a:	8d 44 24 08          	lea    0x8(%esp),%eax
    e58e:	81 28 00 10 00 00    	subl   $0x1000,(%eax)
		if (page[i])
    e594:	8b 44 24 04          	mov    0x4(%esp),%eax
    e598:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e59f:	8b 44 24 24          	mov    0x24(%esp),%eax
    e5a3:	83 3c 02 00          	cmpl   $0x0,(%edx,%eax,1)
    e5a7:	74 21                	je     e5ca <change_ldt+0x16c>
			put_page(page[i],data_base);
    e5a9:	83 ec 08             	sub    $0x8,%esp
    e5ac:	ff 74 24 10          	pushl  0x10(%esp)
    e5b0:	8b 44 24 10          	mov    0x10(%esp),%eax
    e5b4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e5bb:	8b 44 24 30          	mov    0x30(%esp),%eax
    e5bf:	ff 34 02             	pushl  (%edx,%eax,1)
    e5c2:	e8 d9 b6 ff ff       	call   9ca0 <put_page>
    e5c7:	83 c4 10             	add    $0x10,%esp
	for (i=MAX_ARG_PAGES-1 ; i>=0 ; i--) {
    e5ca:	8d 44 24 04          	lea    0x4(%esp),%eax
    e5ce:	ff 08                	decl   (%eax)
    e5d0:	eb b1                	jmp    e583 <change_ldt+0x125>
	}
	return data_limit;
    e5d2:	8b 44 24 10          	mov    0x10(%esp),%eax
}
    e5d6:	83 c4 18             	add    $0x18,%esp
    e5d9:	5b                   	pop    %ebx
    e5da:	c3                   	ret    

0000e5db <_get_base>:
        :"memory"); \
__base;})
**/

static inline unsigned long _get_base(char * addr)
{
    e5db:	53                   	push   %ebx
    e5dc:	83 ec 08             	sub    $0x8,%esp
         unsigned long __base;
         __asm__("movb %3,%%dh\n\t"
    e5df:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    e5e3:	83 c1 02             	add    $0x2,%ecx
    e5e6:	8b 44 24 10          	mov    0x10(%esp),%eax
    e5ea:	83 c0 04             	add    $0x4,%eax
    e5ed:	89 04 24             	mov    %eax,(%esp)
    e5f0:	8b 44 24 10          	mov    0x10(%esp),%eax
    e5f4:	83 c0 07             	add    $0x7,%eax
    e5f7:	8b 1c 24             	mov    (%esp),%ebx
    e5fa:	8a 30                	mov    (%eax),%dh
    e5fc:	8a 13                	mov    (%ebx),%dl
    e5fe:	c1 e2 10             	shl    $0x10,%edx
    e601:	66 8b 11             	mov    (%ecx),%dx
    e604:	89 14 24             	mov    %edx,(%esp)
    e607:	8b 04 24             	mov    (%esp),%eax
    e60a:	89 44 24 04          	mov    %eax,0x4(%esp)
                 "movw %1,%%dx"
                 :"=&d" (__base)
                 :"m" (*((addr)+2)),
                  "m" (*((addr)+4)),
                  "m" (*((addr)+7)));
         return __base;
    e60e:	8b 44 24 04          	mov    0x4(%esp),%eax
}
    e612:	83 c4 08             	add    $0x8,%esp
    e615:	5b                   	pop    %ebx
    e616:	c3                   	ret    

0000e617 <do_execve>:
/*
 * 'do_execve()' executes a new program.
 */
int do_execve(unsigned long * eip,long tmp,char * filename,
	char ** argv, char ** envp)
{
    e617:	57                   	push   %edi
    e618:	56                   	push   %esi
    e619:	53                   	push   %ebx
    e61a:	81 ec 00 05 00 00    	sub    $0x500,%esp
	struct exec ex;
	unsigned long page[MAX_ARG_PAGES];
	int i,argc,envc;
	int e_uid, e_gid;
	int retval;
	int sh_bang = 0;
    e620:	c7 84 24 34 04 00 00 	movl   $0x0,0x434(%esp)
    e627:	00 00 00 00 
	unsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;
    e62b:	c7 84 24 30 04 00 00 	movl   $0x1fffc,0x430(%esp)
    e632:	fc ff 01 00 

	if ((0xffff & eip[1]) != 0x000f)
    e636:	8b 84 24 10 05 00 00 	mov    0x510(%esp),%eax
    e63d:	83 c0 04             	add    $0x4,%eax
    e640:	0f b7 00             	movzwl (%eax),%eax
    e643:	83 f8 0f             	cmp    $0xf,%eax
    e646:	74 10                	je     e658 <do_execve+0x41>
		panic("execve called from supervisor mode");
    e648:	83 ec 0c             	sub    $0xc,%esp
    e64b:	68 cc 8f 01 00       	push   $0x18fcc
    e650:	e8 c4 9c ff ff       	call   8319 <panic>
    e655:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<MAX_ARG_PAGES ; i++)	/* clear page-table */
    e658:	c7 84 24 4c 04 00 00 	movl   $0x0,0x44c(%esp)
    e65f:	00 00 00 00 
    e663:	83 bc 24 4c 04 00 00 	cmpl   $0x1f,0x44c(%esp)
    e66a:	1f 
    e66b:	7f 1d                	jg     e68a <do_execve+0x73>
		page[i]=0;
    e66d:	8b 84 24 4c 04 00 00 	mov    0x44c(%esp),%eax
    e674:	c7 84 84 50 04 00 00 	movl   $0x0,0x450(%esp,%eax,4)
    e67b:	00 00 00 00 
	for (i=0 ; i<MAX_ARG_PAGES ; i++)	/* clear page-table */
    e67f:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    e686:	ff 00                	incl   (%eax)
    e688:	eb d9                	jmp    e663 <do_execve+0x4c>
	if (!(inode=namei(filename)))		/* get executables inode */
    e68a:	83 ec 0c             	sub    $0xc,%esp
    e68d:	ff b4 24 24 05 00 00 	pushl  0x524(%esp)
    e694:	e8 ef 16 00 00       	call   fd88 <namei>
    e699:	83 c4 10             	add    $0x10,%esp
    e69c:	89 84 24 fc 04 00 00 	mov    %eax,0x4fc(%esp)
    e6a3:	83 bc 24 fc 04 00 00 	cmpl   $0x0,0x4fc(%esp)
    e6aa:	00 
    e6ab:	75 0d                	jne    e6ba <do_execve+0xa3>
		return -ENOENT;
    e6ad:	c7 44 24 18 fe ff ff 	movl   $0xfffffffe,0x18(%esp)
    e6b4:	ff 
    e6b5:	e9 28 09 00 00       	jmp    efe2 <do_execve+0x9cb>
	argc = count(argv);
    e6ba:	83 ec 0c             	sub    $0xc,%esp
    e6bd:	ff b4 24 28 05 00 00 	pushl  0x528(%esp)
    e6c4:	e8 34 fb ff ff       	call   e1fd <count>
    e6c9:	83 c4 10             	add    $0x10,%esp
    e6cc:	89 84 24 48 04 00 00 	mov    %eax,0x448(%esp)
	envc = count(envp);
    e6d3:	83 ec 0c             	sub    $0xc,%esp
    e6d6:	ff b4 24 2c 05 00 00 	pushl  0x52c(%esp)
    e6dd:	e8 1b fb ff ff       	call   e1fd <count>
    e6e2:	83 c4 10             	add    $0x10,%esp
    e6e5:	89 84 24 44 04 00 00 	mov    %eax,0x444(%esp)
	
restart_interp:
	if (!S_ISREG(inode->i_mode)) {	/* must be regular file */
    e6ec:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    e6f3:	0f b7 00             	movzwl (%eax),%eax
    e6f6:	25 00 f0 00 00       	and    $0xf000,%eax
    e6fb:	3d 00 80 00 00       	cmp    $0x8000,%eax
    e700:	74 10                	je     e712 <do_execve+0xfb>
		retval = -EACCES;
    e702:	c7 84 24 38 04 00 00 	movl   $0xfffffff3,0x438(%esp)
    e709:	f3 ff ff ff 
		goto exec_error2;
    e70d:	e9 7a 08 00 00       	jmp    ef8c <do_execve+0x975>
	}
	i = inode->i_mode;
    e712:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    e719:	0f b7 00             	movzwl (%eax),%eax
    e71c:	89 84 24 4c 04 00 00 	mov    %eax,0x44c(%esp)
	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
    e723:	8b 84 24 4c 04 00 00 	mov    0x44c(%esp),%eax
    e72a:	25 00 08 00 00       	and    $0x800,%eax
    e72f:	85 c0                	test   %eax,%eax
    e731:	74 11                	je     e744 <do_execve+0x12d>
    e733:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    e73a:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    e73e:	89 44 24 14          	mov    %eax,0x14(%esp)
    e742:	eb 10                	jmp    e754 <do_execve+0x13d>
    e744:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e749:	0f b7 80 42 02 00 00 	movzwl 0x242(%eax),%eax
    e750:	89 44 24 14          	mov    %eax,0x14(%esp)
    e754:	8b 44 24 14          	mov    0x14(%esp),%eax
    e758:	89 84 24 40 04 00 00 	mov    %eax,0x440(%esp)
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
    e75f:	8b 84 24 4c 04 00 00 	mov    0x44c(%esp),%eax
    e766:	25 00 04 00 00       	and    $0x400,%eax
    e76b:	85 c0                	test   %eax,%eax
    e76d:	74 11                	je     e780 <do_execve+0x169>
    e76f:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    e776:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
    e77a:	89 44 24 10          	mov    %eax,0x10(%esp)
    e77e:	eb 10                	jmp    e790 <do_execve+0x179>
    e780:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e785:	0f b7 80 48 02 00 00 	movzwl 0x248(%eax),%eax
    e78c:	89 44 24 10          	mov    %eax,0x10(%esp)
    e790:	8b 54 24 10          	mov    0x10(%esp),%edx
    e794:	89 94 24 3c 04 00 00 	mov    %edx,0x43c(%esp)
	if (current->euid == inode->i_uid)
    e79b:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e7a0:	8b 94 24 fc 04 00 00 	mov    0x4fc(%esp),%edx
    e7a7:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
    e7ae:	66 3b 42 02          	cmp    0x2(%edx),%ax
    e7b2:	75 0c                	jne    e7c0 <do_execve+0x1a9>
		i >>= 6;
    e7b4:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    e7bb:	c1 38 06             	sarl   $0x6,(%eax)
    e7be:	eb 24                	jmp    e7e4 <do_execve+0x1cd>
	else if (current->egid == inode->i_gid)
    e7c0:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e7c5:	8b 94 24 fc 04 00 00 	mov    0x4fc(%esp),%edx
    e7cc:	66 0f b6 52 0c       	movzbw 0xc(%edx),%dx
    e7d1:	66 39 90 48 02 00 00 	cmp    %dx,0x248(%eax)
    e7d8:	75 0a                	jne    e7e4 <do_execve+0x1cd>
		i >>= 3;
    e7da:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    e7e1:	c1 38 03             	sarl   $0x3,(%eax)
	if (!(i & 1) &&
    e7e4:	8b 84 24 4c 04 00 00 	mov    0x44c(%esp),%eax
    e7eb:	83 e0 01             	and    $0x1,%eax
    e7ee:	85 c0                	test   %eax,%eax
    e7f0:	75 32                	jne    e824 <do_execve+0x20d>
    e7f2:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    e7f9:	0f b7 00             	movzwl (%eax),%eax
    e7fc:	83 e0 49             	and    $0x49,%eax
    e7ff:	85 c0                	test   %eax,%eax
    e801:	74 11                	je     e814 <do_execve+0x1fd>
    e803:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    e808:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
    e80f:	00 
    e810:	75 02                	jne    e814 <do_execve+0x1fd>
    e812:	eb 10                	jmp    e824 <do_execve+0x20d>
	    !((inode->i_mode & 0111) && suser())) {
		retval = -ENOEXEC;
    e814:	c7 84 24 38 04 00 00 	movl   $0xfffffff8,0x438(%esp)
    e81b:	f8 ff ff ff 
		goto exec_error2;
    e81f:	e9 68 07 00 00       	jmp    ef8c <do_execve+0x975>
	}
	if (!(bh = bread(inode->i_dev,inode->i_zone[0]))) {
    e824:	83 ec 08             	sub    $0x8,%esp
    e827:	8b 84 24 04 05 00 00 	mov    0x504(%esp),%eax
    e82e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    e832:	50                   	push   %eax
    e833:	8b 84 24 08 05 00 00 	mov    0x508(%esp),%eax
    e83a:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    e83e:	50                   	push   %eax
    e83f:	e8 bf de ff ff       	call   c703 <bread>
    e844:	83 c4 10             	add    $0x10,%esp
    e847:	89 84 24 f8 04 00 00 	mov    %eax,0x4f8(%esp)
    e84e:	83 bc 24 f8 04 00 00 	cmpl   $0x0,0x4f8(%esp)
    e855:	00 
    e856:	75 10                	jne    e868 <do_execve+0x251>
		retval = -EACCES;
    e858:	c7 84 24 38 04 00 00 	movl   $0xfffffff3,0x438(%esp)
    e85f:	f3 ff ff ff 
		goto exec_error2;
    e863:	e9 24 07 00 00       	jmp    ef8c <do_execve+0x975>
	}
	ex = *((struct exec *) bh->b_data);	/* read exec-header */
    e868:	8b 84 24 f8 04 00 00 	mov    0x4f8(%esp),%eax
    e86f:	8b 00                	mov    (%eax),%eax
    e871:	8d bc 24 d0 04 00 00 	lea    0x4d0(%esp),%edi
    e878:	89 c6                	mov    %eax,%esi
    e87a:	fc                   	cld    
    e87b:	b8 08 00 00 00       	mov    $0x8,%eax
    e880:	89 c1                	mov    %eax,%ecx
    e882:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {
    e884:	8b 84 24 f8 04 00 00 	mov    0x4f8(%esp),%eax
    e88b:	8b 00                	mov    (%eax),%eax
    e88d:	80 38 23             	cmpb   $0x23,(%eax)
    e890:	0f 85 e1 02 00 00    	jne    eb77 <do_execve+0x560>
    e896:	8b 84 24 f8 04 00 00 	mov    0x4f8(%esp),%eax
    e89d:	8b 00                	mov    (%eax),%eax
    e89f:	40                   	inc    %eax
    e8a0:	80 38 21             	cmpb   $0x21,(%eax)
    e8a3:	0f 85 ce 02 00 00    	jne    eb77 <do_execve+0x560>
    e8a9:	83 bc 24 34 04 00 00 	cmpl   $0x0,0x434(%esp)
    e8b0:	00 
    e8b1:	0f 85 c0 02 00 00    	jne    eb77 <do_execve+0x560>
		 */

		char buf[1023], *cp, *interp, *i_name, *i_arg;
		unsigned long old_fs;

		strncpy(buf, bh->b_data+2, 1022);
    e8b7:	83 ec 04             	sub    $0x4,%esp
    e8ba:	68 fe 03 00 00       	push   $0x3fe
    e8bf:	8b 84 24 00 05 00 00 	mov    0x500(%esp),%eax
    e8c6:	8b 00                	mov    (%eax),%eax
    e8c8:	83 c0 02             	add    $0x2,%eax
    e8cb:	50                   	push   %eax
    e8cc:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    e8d0:	50                   	push   %eax
    e8d1:	e8 61 07 00 00       	call   f037 <strncpy>
    e8d6:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
    e8d9:	83 ec 0c             	sub    $0xc,%esp
    e8dc:	ff b4 24 04 05 00 00 	pushl  0x504(%esp)
    e8e3:	e8 cf dd ff ff       	call   c6b7 <brelse>
    e8e8:	83 c4 10             	add    $0x10,%esp
		iput(inode);
    e8eb:	83 ec 0c             	sub    $0xc,%esp
    e8ee:	ff b4 24 08 05 00 00 	pushl  0x508(%esp)
    e8f5:	e8 53 cf ff ff       	call   b84d <iput>
    e8fa:	83 c4 10             	add    $0x10,%esp
		buf[1022] = '\0';
    e8fd:	c6 84 24 2e 04 00 00 	movb   $0x0,0x42e(%esp)
    e904:	00 
		if ((cp = strchr(buf, '\n'))) {
    e905:	83 ec 08             	sub    $0x8,%esp
    e908:	6a 0a                	push   $0xa
    e90a:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    e90e:	50                   	push   %eax
    e90f:	e8 f6 06 00 00       	call   f00a <strchr>
    e914:	83 c4 10             	add    $0x10,%esp
    e917:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    e91b:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
    e920:	74 2b                	je     e94d <do_execve+0x336>
			*cp = '\0';
    e922:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e926:	c6 00 00             	movb   $0x0,(%eax)
			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
    e929:	8d 44 24 30          	lea    0x30(%esp),%eax
    e92d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    e931:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e935:	80 38 20             	cmpb   $0x20,(%eax)
    e938:	74 0b                	je     e945 <do_execve+0x32e>
    e93a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e93e:	80 38 09             	cmpb   $0x9,(%eax)
    e941:	74 02                	je     e945 <do_execve+0x32e>
    e943:	eb 08                	jmp    e94d <do_execve+0x336>
    e945:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    e949:	ff 00                	incl   (%eax)
    e94b:	eb e4                	jmp    e931 <do_execve+0x31a>
		}
		if (!cp || *cp == '\0') {
    e94d:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
    e952:	74 09                	je     e95d <do_execve+0x346>
    e954:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e958:	80 38 00             	cmpb   $0x0,(%eax)
    e95b:	75 10                	jne    e96d <do_execve+0x356>
			retval = -ENOEXEC; /* No interpreter name found */
    e95d:	c7 84 24 38 04 00 00 	movl   $0xfffffff8,0x438(%esp)
    e964:	f8 ff ff ff 
			goto exec_error1;
    e968:	e9 31 06 00 00       	jmp    ef9e <do_execve+0x987>
		}
		interp = i_name = cp;
    e96d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e971:	89 44 24 24          	mov    %eax,0x24(%esp)
    e975:	89 44 24 28          	mov    %eax,0x28(%esp)
		i_arg = 0;
    e979:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    e980:	00 
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
    e981:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e985:	80 38 00             	cmpb   $0x0,(%eax)
    e988:	74 2c                	je     e9b6 <do_execve+0x39f>
    e98a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e98e:	80 38 20             	cmpb   $0x20,(%eax)
    e991:	74 23                	je     e9b6 <do_execve+0x39f>
    e993:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e997:	80 38 09             	cmpb   $0x9,(%eax)
    e99a:	74 1a                	je     e9b6 <do_execve+0x39f>
 			if (*cp == '/')
    e99c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e9a0:	80 38 2f             	cmpb   $0x2f,(%eax)
    e9a3:	75 09                	jne    e9ae <do_execve+0x397>
				i_name = cp+1;
    e9a5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e9a9:	40                   	inc    %eax
    e9aa:	89 44 24 24          	mov    %eax,0x24(%esp)
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
    e9ae:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    e9b2:	ff 00                	incl   (%eax)
    e9b4:	eb cb                	jmp    e981 <do_execve+0x36a>
		}
		if (*cp) {
    e9b6:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e9ba:	80 38 00             	cmpb   $0x0,(%eax)
    e9bd:	74 15                	je     e9d4 <do_execve+0x3bd>
			*cp++ = '\0';
    e9bf:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e9c3:	c6 00 00             	movb   $0x0,(%eax)
    e9c6:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    e9ca:	ff 00                	incl   (%eax)
			i_arg = cp;
    e9cc:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    e9d0:	89 44 24 20          	mov    %eax,0x20(%esp)
		}
		/*
		 * OK, we've parsed out the interpreter name and
		 * (optional) argument.
		 */
		if (sh_bang++ == 0) {
    e9d4:	8d 84 24 34 04 00 00 	lea    0x434(%esp),%eax
    e9db:	ff 00                	incl   (%eax)
    e9dd:	83 bc 24 34 04 00 00 	cmpl   $0x1,0x434(%esp)
    e9e4:	01 
    e9e5:	75 6f                	jne    ea56 <do_execve+0x43f>
			p = copy_strings(envc, envp, page, p, 0);
    e9e7:	83 ec 0c             	sub    $0xc,%esp
    e9ea:	6a 00                	push   $0x0
    e9ec:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    e9f3:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    e9fa:	50                   	push   %eax
    e9fb:	ff b4 24 38 05 00 00 	pushl  0x538(%esp)
    ea02:	ff b4 24 60 04 00 00 	pushl  0x460(%esp)
    ea09:	e8 45 f8 ff ff       	call   e253 <copy_strings>
    ea0e:	83 c4 20             	add    $0x20,%esp
    ea11:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
			p = copy_strings(--argc, argv+1, page, p, 0);
    ea18:	83 ec 0c             	sub    $0xc,%esp
    ea1b:	6a 00                	push   $0x0
    ea1d:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    ea24:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    ea2b:	50                   	push   %eax
    ea2c:	8b 84 24 34 05 00 00 	mov    0x534(%esp),%eax
    ea33:	83 c0 04             	add    $0x4,%eax
    ea36:	50                   	push   %eax
    ea37:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    ea3e:	ff 08                	decl   (%eax)
    ea40:	ff b4 24 64 04 00 00 	pushl  0x464(%esp)
    ea47:	e8 07 f8 ff ff       	call   e253 <copy_strings>
    ea4c:	83 c4 20             	add    $0x20,%esp
    ea4f:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
		 *           (3) filename of shell script
		 *
		 * This is done in reverse order, because of how the
		 * user environment and arguments are stored.
		 */
		p = copy_strings(1, &filename, page, p, 1);
    ea56:	83 ec 0c             	sub    $0xc,%esp
    ea59:	6a 01                	push   $0x1
    ea5b:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    ea62:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    ea69:	50                   	push   %eax
    ea6a:	8d 84 24 30 05 00 00 	lea    0x530(%esp),%eax
    ea71:	50                   	push   %eax
    ea72:	6a 01                	push   $0x1
    ea74:	e8 da f7 ff ff       	call   e253 <copy_strings>
    ea79:	83 c4 20             	add    $0x20,%esp
    ea7c:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
		argc++;
    ea83:	8d 84 24 48 04 00 00 	lea    0x448(%esp),%eax
    ea8a:	ff 00                	incl   (%eax)
		if (i_arg) {
    ea8c:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    ea91:	74 33                	je     eac6 <do_execve+0x4af>
			p = copy_strings(1, &i_arg, page, p, 2);
    ea93:	83 ec 0c             	sub    $0xc,%esp
    ea96:	6a 02                	push   $0x2
    ea98:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    ea9f:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    eaa6:	50                   	push   %eax
    eaa7:	8d 44 24 38          	lea    0x38(%esp),%eax
    eaab:	50                   	push   %eax
    eaac:	6a 01                	push   $0x1
    eaae:	e8 a0 f7 ff ff       	call   e253 <copy_strings>
    eab3:	83 c4 20             	add    $0x20,%esp
    eab6:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
			argc++;
    eabd:	8d 84 24 48 04 00 00 	lea    0x448(%esp),%eax
    eac4:	ff 00                	incl   (%eax)
		}
		p = copy_strings(1, &i_name, page, p, 2);
    eac6:	83 ec 0c             	sub    $0xc,%esp
    eac9:	6a 02                	push   $0x2
    eacb:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    ead2:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    ead9:	50                   	push   %eax
    eada:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    eade:	50                   	push   %eax
    eadf:	6a 01                	push   $0x1
    eae1:	e8 6d f7 ff ff       	call   e253 <copy_strings>
    eae6:	83 c4 20             	add    $0x20,%esp
    eae9:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
		argc++;
    eaf0:	8d 84 24 48 04 00 00 	lea    0x448(%esp),%eax
    eaf7:	ff 00                	incl   (%eax)
		if (!p) {
    eaf9:	83 bc 24 30 04 00 00 	cmpl   $0x0,0x430(%esp)
    eb00:	00 
    eb01:	75 10                	jne    eb13 <do_execve+0x4fc>
			retval = -ENOMEM;
    eb03:	c7 84 24 38 04 00 00 	movl   $0xfffffff4,0x438(%esp)
    eb0a:	f4 ff ff ff 
			goto exec_error1;
    eb0e:	e9 8b 04 00 00       	jmp    ef9e <do_execve+0x987>
		}
		/*
		 * OK, now restart the process with the interpreter's inode.
		 */
		old_fs = get_fs();
    eb13:	e8 1e f9 ff ff       	call   e436 <get_fs>
    eb18:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		set_fs(get_ds());
    eb1c:	e8 29 f9 ff ff       	call   e44a <get_ds>
    eb21:	50                   	push   %eax
    eb22:	e8 08 f9 ff ff       	call   e42f <set_fs>
    eb27:	83 c4 04             	add    $0x4,%esp
		if (!(inode=namei(interp))) { /* get executables inode */
    eb2a:	83 ec 0c             	sub    $0xc,%esp
    eb2d:	ff 74 24 34          	pushl  0x34(%esp)
    eb31:	e8 52 12 00 00       	call   fd88 <namei>
    eb36:	83 c4 10             	add    $0x10,%esp
    eb39:	89 84 24 fc 04 00 00 	mov    %eax,0x4fc(%esp)
    eb40:	83 bc 24 fc 04 00 00 	cmpl   $0x0,0x4fc(%esp)
    eb47:	00 
    eb48:	75 1c                	jne    eb66 <do_execve+0x54f>
			set_fs(old_fs);
    eb4a:	ff 74 24 1c          	pushl  0x1c(%esp)
    eb4e:	e8 dc f8 ff ff       	call   e42f <set_fs>
    eb53:	83 c4 04             	add    $0x4,%esp
			retval = -ENOENT;
    eb56:	c7 84 24 38 04 00 00 	movl   $0xfffffffe,0x438(%esp)
    eb5d:	fe ff ff ff 
			goto exec_error1;
    eb61:	e9 38 04 00 00       	jmp    ef9e <do_execve+0x987>
		}
		set_fs(old_fs);
    eb66:	ff 74 24 1c          	pushl  0x1c(%esp)
    eb6a:	e8 c0 f8 ff ff       	call   e42f <set_fs>
    eb6f:	83 c4 04             	add    $0x4,%esp
		goto restart_interp;
    eb72:	e9 75 fb ff ff       	jmp    e6ec <do_execve+0xd5>
	}
	brelse(bh);
    eb77:	83 ec 0c             	sub    $0xc,%esp
    eb7a:	ff b4 24 04 05 00 00 	pushl  0x504(%esp)
    eb81:	e8 31 db ff ff       	call   c6b7 <brelse>
    eb86:	83 c4 10             	add    $0x10,%esp
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
    eb89:	81 bc 24 d0 04 00 00 	cmpl   $0x10b,0x4d0(%esp)
    eb90:	0b 01 00 00 
    eb94:	0f 85 8e 00 00 00    	jne    ec28 <do_execve+0x611>
    eb9a:	83 bc 24 e8 04 00 00 	cmpl   $0x0,0x4e8(%esp)
    eba1:	00 
    eba2:	0f 85 80 00 00 00    	jne    ec28 <do_execve+0x611>
    eba8:	83 bc 24 ec 04 00 00 	cmpl   $0x0,0x4ec(%esp)
    ebaf:	00 
    ebb0:	75 76                	jne    ec28 <do_execve+0x611>
    ebb2:	8b 84 24 d8 04 00 00 	mov    0x4d8(%esp),%eax
    ebb9:	03 84 24 d4 04 00 00 	add    0x4d4(%esp),%eax
    ebc0:	03 84 24 dc 04 00 00 	add    0x4dc(%esp),%eax
    ebc7:	3d 00 00 00 03       	cmp    $0x3000000,%eax
    ebcc:	77 5a                	ja     ec28 <do_execve+0x611>
    ebce:	8b 84 24 d8 04 00 00 	mov    0x4d8(%esp),%eax
    ebd5:	8b 94 24 d4 04 00 00 	mov    0x4d4(%esp),%edx
    ebdc:	01 c2                	add    %eax,%edx
    ebde:	89 54 24 0c          	mov    %edx,0xc(%esp)
    ebe2:	8b 84 24 e0 04 00 00 	mov    0x4e0(%esp),%eax
    ebe9:	01 44 24 0c          	add    %eax,0xc(%esp)
    ebed:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    ebf4:	8b 40 04             	mov    0x4(%eax),%eax
    ebf7:	89 44 24 08          	mov    %eax,0x8(%esp)
    ebfb:	81 bc 24 d0 04 00 00 	cmpl   $0x10b,0x4d0(%esp)
    ec02:	0b 01 00 00 
    ec06:	75 11                	jne    ec19 <do_execve+0x602>
    ec08:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec0c:	05 00 04 00 00       	add    $0x400,%eax
    ec11:	39 44 24 08          	cmp    %eax,0x8(%esp)
    ec15:	72 11                	jb     ec28 <do_execve+0x611>
    ec17:	eb 1f                	jmp    ec38 <do_execve+0x621>
    ec19:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ec1d:	83 c0 20             	add    $0x20,%eax
    ec20:	39 44 24 08          	cmp    %eax,0x8(%esp)
    ec24:	72 02                	jb     ec28 <do_execve+0x611>
    ec26:	eb 10                	jmp    ec38 <do_execve+0x621>
		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
		inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
		retval = -ENOEXEC;
    ec28:	c7 84 24 38 04 00 00 	movl   $0xfffffff8,0x438(%esp)
    ec2f:	f8 ff ff ff 
		goto exec_error2;
    ec33:	e9 54 03 00 00       	jmp    ef8c <do_execve+0x975>
	}
	if (N_TXTOFF(ex) != BLOCK_SIZE) {
    ec38:	81 bc 24 d0 04 00 00 	cmpl   $0x10b,0x4d0(%esp)
    ec3f:	0b 01 00 00 
    ec43:	74 27                	je     ec6c <do_execve+0x655>
		printk("%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.", filename);
    ec45:	83 ec 08             	sub    $0x8,%esp
    ec48:	ff b4 24 20 05 00 00 	pushl  0x520(%esp)
    ec4f:	68 f0 8f 01 00       	push   $0x18ff0
    ec54:	e8 fa 96 ff ff       	call   8353 <printk>
    ec59:	83 c4 10             	add    $0x10,%esp
		retval = -ENOEXEC;
    ec5c:	c7 84 24 38 04 00 00 	movl   $0xfffffff8,0x438(%esp)
    ec63:	f8 ff ff ff 
		goto exec_error2;
    ec67:	e9 20 03 00 00       	jmp    ef8c <do_execve+0x975>
	}
	if (!sh_bang) {
    ec6c:	83 bc 24 34 04 00 00 	cmpl   $0x0,0x434(%esp)
    ec73:	00 
    ec74:	75 7c                	jne    ecf2 <do_execve+0x6db>
		p = copy_strings(envc,envp,page,p,0);
    ec76:	83 ec 0c             	sub    $0xc,%esp
    ec79:	6a 00                	push   $0x0
    ec7b:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    ec82:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    ec89:	50                   	push   %eax
    ec8a:	ff b4 24 38 05 00 00 	pushl  0x538(%esp)
    ec91:	ff b4 24 60 04 00 00 	pushl  0x460(%esp)
    ec98:	e8 b6 f5 ff ff       	call   e253 <copy_strings>
    ec9d:	83 c4 20             	add    $0x20,%esp
    eca0:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
		p = copy_strings(argc,argv,page,p,0);
    eca7:	83 ec 0c             	sub    $0xc,%esp
    ecaa:	6a 00                	push   $0x0
    ecac:	ff b4 24 40 04 00 00 	pushl  0x440(%esp)
    ecb3:	8d 84 24 64 04 00 00 	lea    0x464(%esp),%eax
    ecba:	50                   	push   %eax
    ecbb:	ff b4 24 34 05 00 00 	pushl  0x534(%esp)
    ecc2:	ff b4 24 64 04 00 00 	pushl  0x464(%esp)
    ecc9:	e8 85 f5 ff ff       	call   e253 <copy_strings>
    ecce:	83 c4 20             	add    $0x20,%esp
    ecd1:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
		if (!p) {
    ecd8:	83 bc 24 30 04 00 00 	cmpl   $0x0,0x430(%esp)
    ecdf:	00 
    ece0:	75 10                	jne    ecf2 <do_execve+0x6db>
			retval = -ENOMEM;
    ece2:	c7 84 24 38 04 00 00 	movl   $0xfffffff4,0x438(%esp)
    ece9:	f4 ff ff ff 
			goto exec_error2;
    eced:	e9 9a 02 00 00       	jmp    ef8c <do_execve+0x975>
		}
	}
/* OK, This is the point of no return */
	if (current->executable)
    ecf2:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ecf7:	83 b8 78 02 00 00 00 	cmpl   $0x0,0x278(%eax)
    ecfe:	74 16                	je     ed16 <do_execve+0x6ff>
		iput(current->executable);
    ed00:	83 ec 0c             	sub    $0xc,%esp
    ed03:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ed08:	ff b0 78 02 00 00    	pushl  0x278(%eax)
    ed0e:	e8 3a cb ff ff       	call   b84d <iput>
    ed13:	83 c4 10             	add    $0x10,%esp
	current->executable = inode;
    ed16:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ed1c:	8b 84 24 fc 04 00 00 	mov    0x4fc(%esp),%eax
    ed23:	89 82 78 02 00 00    	mov    %eax,0x278(%edx)
	for (i=0 ; i<32 ; i++)
    ed29:	c7 84 24 4c 04 00 00 	movl   $0x0,0x44c(%esp)
    ed30:	00 00 00 00 
    ed34:	83 bc 24 4c 04 00 00 	cmpl   $0x1f,0x44c(%esp)
    ed3b:	1f 
    ed3c:	7f 26                	jg     ed64 <do_execve+0x74d>
		current->sigaction[i].sa_handler = NULL;
    ed3e:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ed44:	8b 84 24 4c 04 00 00 	mov    0x44c(%esp),%eax
    ed4b:	c1 e0 04             	shl    $0x4,%eax
    ed4e:	01 d0                	add    %edx,%eax
    ed50:	83 c0 10             	add    $0x10,%eax
    ed53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for (i=0 ; i<32 ; i++)
    ed59:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    ed60:	ff 00                	incl   (%eax)
    ed62:	eb d0                	jmp    ed34 <do_execve+0x71d>
	for (i=0 ; i<NR_OPEN ; i++)
    ed64:	c7 84 24 4c 04 00 00 	movl   $0x0,0x44c(%esp)
    ed6b:	00 00 00 00 
    ed6f:	83 bc 24 4c 04 00 00 	cmpl   $0x13,0x44c(%esp)
    ed76:	13 
    ed77:	7f 38                	jg     edb1 <do_execve+0x79a>
		if ((current->close_on_exec>>i)&1)
    ed79:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ed7e:	8b 8c 24 4c 04 00 00 	mov    0x44c(%esp),%ecx
    ed85:	8b 80 7c 02 00 00    	mov    0x27c(%eax),%eax
    ed8b:	d3 e8                	shr    %cl,%eax
    ed8d:	83 e0 01             	and    $0x1,%eax
    ed90:	85 c0                	test   %eax,%eax
    ed92:	74 12                	je     eda6 <do_execve+0x78f>
			sys_close(i);
    ed94:	83 ec 0c             	sub    $0xc,%esp
    ed97:	ff b4 24 58 04 00 00 	pushl  0x458(%esp)
    ed9e:	e8 14 c0 ff ff       	call   adb7 <sys_close>
    eda3:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<NR_OPEN ; i++)
    eda6:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    edad:	ff 00                	incl   (%eax)
    edaf:	eb be                	jmp    ed6f <do_execve+0x758>
	current->close_on_exec = 0;
    edb1:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    edb6:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%eax)
    edbd:	00 00 00 
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
    edc0:	b8 0f 00 00 00       	mov    $0xf,%eax
    edc5:	0f 03 c0             	lsl    %ax,%eax
    edc8:	40                   	inc    %eax
    edc9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    edcd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    edd1:	83 ec 08             	sub    $0x8,%esp
    edd4:	50                   	push   %eax
    edd5:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    edda:	05 d8 02 00 00       	add    $0x2d8,%eax
    eddf:	50                   	push   %eax
    ede0:	e8 f6 f7 ff ff       	call   e5db <_get_base>
    ede5:	83 c4 04             	add    $0x4,%esp
    ede8:	50                   	push   %eax
    ede9:	e8 13 ac ff ff       	call   9a01 <free_page_tables>
    edee:	83 c4 10             	add    $0x10,%esp
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
    edf1:	b8 17 00 00 00       	mov    $0x17,%eax
    edf6:	0f 03 c0             	lsl    %ax,%eax
    edf9:	40                   	inc    %eax
    edfa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    edfe:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    ee02:	83 ec 08             	sub    $0x8,%esp
    ee05:	50                   	push   %eax
    ee06:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ee0b:	05 e0 02 00 00       	add    $0x2e0,%eax
    ee10:	50                   	push   %eax
    ee11:	e8 c5 f7 ff ff       	call   e5db <_get_base>
    ee16:	83 c4 04             	add    $0x4,%esp
    ee19:	50                   	push   %eax
    ee1a:	e8 e2 ab ff ff       	call   9a01 <free_page_tables>
    ee1f:	83 c4 10             	add    $0x10,%esp
	if (last_task_used_math == current)
    ee22:	a1 c8 e9 01 00       	mov    0x1e9c8,%eax
    ee27:	3b 05 20 bc 01 00    	cmp    0x1bc20,%eax
    ee2d:	75 0a                	jne    ee39 <do_execve+0x822>
		last_task_used_math = NULL;
    ee2f:	c7 05 c8 e9 01 00 00 	movl   $0x0,0x1e9c8
    ee36:	00 00 00 
	current->used_math = 0;
    ee39:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    ee3e:	66 c7 80 64 02 00 00 	movw   $0x0,0x264(%eax)
    ee45:	00 00 
	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
    ee47:	83 ec 08             	sub    $0x8,%esp
    ee4a:	8d 84 24 58 04 00 00 	lea    0x458(%esp),%eax
    ee51:	50                   	push   %eax
    ee52:	ff b4 24 e0 04 00 00 	pushl  0x4e0(%esp)
    ee59:	e8 00 f6 ff ff       	call   e45e <change_ldt>
    ee5e:	83 c4 10             	add    $0x10,%esp
    ee61:	03 84 24 30 04 00 00 	add    0x430(%esp),%eax
    ee68:	2d 00 00 02 00       	sub    $0x20000,%eax
    ee6d:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
	p = (unsigned long) create_tables((char *)p,argc,envc);
    ee74:	83 ec 04             	sub    $0x4,%esp
    ee77:	ff b4 24 48 04 00 00 	pushl  0x448(%esp)
    ee7e:	ff b4 24 50 04 00 00 	pushl  0x450(%esp)
    ee85:	ff b4 24 3c 04 00 00 	pushl  0x43c(%esp)
    ee8c:	e8 11 f2 ff ff       	call   e0a2 <create_tables>
    ee91:	83 c4 10             	add    $0x10,%esp
    ee94:	89 84 24 30 04 00 00 	mov    %eax,0x430(%esp)
	current->brk = ex.a_bss +
    ee9b:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
    eea1:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    eea7:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    eead:	8b 84 24 d4 04 00 00 	mov    0x4d4(%esp),%eax
    eeb4:	89 82 1c 02 00 00    	mov    %eax,0x21c(%edx)
    eeba:	03 84 24 d8 04 00 00 	add    0x4d8(%esp),%eax
    eec1:	89 81 20 02 00 00    	mov    %eax,0x220(%ecx)
    eec7:	8b 81 20 02 00 00    	mov    0x220(%ecx),%eax
    eecd:	03 84 24 dc 04 00 00 	add    0x4dc(%esp),%eax
    eed4:	89 83 24 02 00 00    	mov    %eax,0x224(%ebx)
		(current->end_data = ex.a_data +
		(current->end_code = ex.a_text));
	current->start_stack = p & 0xfffff000;
    eeda:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    eee0:	8b 84 24 30 04 00 00 	mov    0x430(%esp),%eax
    eee7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    eeec:	89 82 28 02 00 00    	mov    %eax,0x228(%edx)
	current->euid = e_uid;
    eef2:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    eef8:	8b 84 24 40 04 00 00 	mov    0x440(%esp),%eax
    eeff:	66 89 82 42 02 00 00 	mov    %ax,0x242(%edx)
	current->egid = e_gid;
    ef06:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    ef0c:	8b 84 24 3c 04 00 00 	mov    0x43c(%esp),%eax
    ef13:	66 89 82 48 02 00 00 	mov    %ax,0x248(%edx)
	i = ex.a_text+ex.a_data;
    ef1a:	8b 84 24 d8 04 00 00 	mov    0x4d8(%esp),%eax
    ef21:	03 84 24 d4 04 00 00 	add    0x4d4(%esp),%eax
    ef28:	89 84 24 4c 04 00 00 	mov    %eax,0x44c(%esp)
	while (i&0xfff)
    ef2f:	8b 84 24 4c 04 00 00 	mov    0x44c(%esp),%eax
    ef36:	25 ff 0f 00 00       	and    $0xfff,%eax
    ef3b:	85 c0                	test   %eax,%eax
    ef3d:	74 20                	je     ef5f <do_execve+0x948>
		put_fs_byte(0,(char *) (i++));
    ef3f:	83 ec 08             	sub    $0x8,%esp
    ef42:	8b 84 24 54 04 00 00 	mov    0x454(%esp),%eax
    ef49:	50                   	push   %eax
    ef4a:	8d 84 24 58 04 00 00 	lea    0x458(%esp),%eax
    ef51:	ff 00                	incl   (%eax)
    ef53:	6a 00                	push   $0x0
    ef55:	e8 96 00 00 00       	call   eff0 <put_fs_byte>
    ef5a:	83 c4 10             	add    $0x10,%esp
    ef5d:	eb d0                	jmp    ef2f <do_execve+0x918>
	eip[0] = ex.a_entry;		/* eip, magic happens :-) */
    ef5f:	8b 94 24 10 05 00 00 	mov    0x510(%esp),%edx
    ef66:	8b 84 24 e4 04 00 00 	mov    0x4e4(%esp),%eax
    ef6d:	89 02                	mov    %eax,(%edx)
	eip[3] = p;			/* stack pointer */
    ef6f:	8b 94 24 10 05 00 00 	mov    0x510(%esp),%edx
    ef76:	83 c2 0c             	add    $0xc,%edx
    ef79:	8b 84 24 30 04 00 00 	mov    0x430(%esp),%eax
    ef80:	89 02                	mov    %eax,(%edx)
	return 0;
    ef82:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    ef89:	00 
    ef8a:	eb 56                	jmp    efe2 <do_execve+0x9cb>
exec_error2:
	iput(inode);
    ef8c:	83 ec 0c             	sub    $0xc,%esp
    ef8f:	ff b4 24 08 05 00 00 	pushl  0x508(%esp)
    ef96:	e8 b2 c8 ff ff       	call   b84d <iput>
    ef9b:	83 c4 10             	add    $0x10,%esp
exec_error1:
	for (i=0 ; i<MAX_ARG_PAGES ; i++)
    ef9e:	c7 84 24 4c 04 00 00 	movl   $0x0,0x44c(%esp)
    efa5:	00 00 00 00 
    efa9:	83 bc 24 4c 04 00 00 	cmpl   $0x1f,0x44c(%esp)
    efb0:	1f 
    efb1:	7f 24                	jg     efd7 <do_execve+0x9c0>
		free_page(page[i]);
    efb3:	83 ec 0c             	sub    $0xc,%esp
    efb6:	8b 84 24 58 04 00 00 	mov    0x458(%esp),%eax
    efbd:	ff b4 84 5c 04 00 00 	pushl  0x45c(%esp,%eax,4)
    efc4:	e8 dc a9 ff ff       	call   99a5 <free_page>
    efc9:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i<MAX_ARG_PAGES ; i++)
    efcc:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    efd3:	ff 00                	incl   (%eax)
    efd5:	eb d2                	jmp    efa9 <do_execve+0x992>
	return(retval);
    efd7:	8b 84 24 38 04 00 00 	mov    0x438(%esp),%eax
    efde:	89 44 24 18          	mov    %eax,0x18(%esp)
}
    efe2:	8b 44 24 18          	mov    0x18(%esp),%eax
    efe6:	81 c4 00 05 00 00    	add    $0x500,%esp
    efec:	5b                   	pop    %ebx
    efed:	5e                   	pop    %esi
    efee:	5f                   	pop    %edi
    efef:	c3                   	ret    

0000eff0 <put_fs_byte>:
{
    eff0:	83 ec 04             	sub    $0x4,%esp
    eff3:	8b 44 24 08          	mov    0x8(%esp),%eax
    eff7:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    effb:	8a 54 24 03          	mov    0x3(%esp),%dl
    efff:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f003:	64 88 10             	mov    %dl,%fs:(%eax)
}
    f006:	83 c4 04             	add    $0x4,%esp
    f009:	c3                   	ret    

0000f00a <strchr>:
{
    f00a:	56                   	push   %esi
    f00b:	83 ec 04             	sub    $0x4,%esp
    f00e:	8b 44 24 10          	mov    0x10(%esp),%eax
    f012:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__("cld\n\t"
    f016:	8b 74 24 0c          	mov    0xc(%esp),%esi
    f01a:	8a 44 24 03          	mov    0x3(%esp),%al
    f01e:	fc                   	cld    
    f01f:	88 c4                	mov    %al,%ah
    f021:	ac                   	lods   %ds:(%esi),%al
    f022:	38 e0                	cmp    %ah,%al
    f024:	74 09                	je     f02f <strchr+0x25>
    f026:	84 c0                	test   %al,%al
    f028:	75 f7                	jne    f021 <strchr+0x17>
    f02a:	be 01 00 00 00       	mov    $0x1,%esi
    f02f:	89 f0                	mov    %esi,%eax
    f031:	48                   	dec    %eax
}
    f032:	83 c4 04             	add    $0x4,%esp
    f035:	5e                   	pop    %esi
    f036:	c3                   	ret    

0000f037 <strncpy>:
{
    f037:	57                   	push   %edi
    f038:	56                   	push   %esi
__asm__("cld\n"
    f039:	8b 74 24 10          	mov    0x10(%esp),%esi
    f03d:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    f041:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    f045:	fc                   	cld    
    f046:	49                   	dec    %ecx
    f047:	78 08                	js     f051 <strncpy+0x1a>
    f049:	ac                   	lods   %ds:(%esi),%al
    f04a:	aa                   	stos   %al,%es:(%edi)
    f04b:	84 c0                	test   %al,%al
    f04d:	75 f7                	jne    f046 <strncpy+0xf>
    f04f:	f3 aa                	rep stos %al,%es:(%edi)
return dest;
    f051:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
    f055:	5e                   	pop    %esi
    f056:	5f                   	pop    %edi
    f057:	c3                   	ret    

0000f058 <read_pipe>:
#include <linux/sched.h>
#include <linux/mm.h>	/* for get_free_page */
#include <asm/segment.h>

int read_pipe(struct m_inode * inode, char * buf, int count)
{
    f058:	83 ec 1c             	sub    $0x1c,%esp
	int chars, size, read = 0;
    f05b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    f062:	00 

	while (count>0) {
    f063:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f068:	0f 8e 24 01 00 00    	jle    f192 <read_pipe+0x13a>
		while (!(size=PIPE_SIZE(*inode))) {
    f06e:	8b 44 24 20          	mov    0x20(%esp),%eax
    f072:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
    f076:	8b 44 24 20          	mov    0x20(%esp),%eax
    f07a:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    f07e:	29 c2                	sub    %eax,%edx
    f080:	89 d0                	mov    %edx,%eax
    f082:	25 ff 0f 00 00       	and    $0xfff,%eax
    f087:	89 44 24 14          	mov    %eax,0x14(%esp)
    f08b:	8b 44 24 14          	mov    0x14(%esp),%eax
    f08f:	85 c0                	test   %eax,%eax
    f091:	75 40                	jne    f0d3 <read_pipe+0x7b>
			wake_up(&inode->i_wait);
    f093:	83 ec 0c             	sub    $0xc,%esp
    f096:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f09a:	83 c0 20             	add    $0x20,%eax
    f09d:	50                   	push   %eax
    f09e:	e8 00 7f ff ff       	call   6fa3 <wake_up>
    f0a3:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) /* are there any writers? */
    f0a6:	8b 44 24 20          	mov    0x20(%esp),%eax
    f0aa:	66 83 78 30 02       	cmpw   $0x2,0x30(%eax)
    f0af:	74 0d                	je     f0be <read_pipe+0x66>
				return read;
    f0b1:	8b 44 24 10          	mov    0x10(%esp),%eax
    f0b5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f0b9:	e9 ef 00 00 00       	jmp    f1ad <read_pipe+0x155>
			sleep_on(&inode->i_wait);
    f0be:	83 ec 0c             	sub    $0xc,%esp
    f0c1:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f0c5:	83 c0 20             	add    $0x20,%eax
    f0c8:	50                   	push   %eax
    f0c9:	e8 b7 7b ff ff       	call   6c85 <sleep_on>
    f0ce:	83 c4 10             	add    $0x10,%esp
    f0d1:	eb 9b                	jmp    f06e <read_pipe+0x16>
		}
		chars = PAGE_SIZE-PIPE_TAIL(*inode);
    f0d3:	8b 44 24 20          	mov    0x20(%esp),%eax
    f0d7:	0f b7 50 10          	movzwl 0x10(%eax),%edx
    f0db:	b8 00 10 00 00       	mov    $0x1000,%eax
    f0e0:	29 d0                	sub    %edx,%eax
    f0e2:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (chars > count)
    f0e6:	8b 44 24 18          	mov    0x18(%esp),%eax
    f0ea:	3b 44 24 28          	cmp    0x28(%esp),%eax
    f0ee:	7e 08                	jle    f0f8 <read_pipe+0xa0>
			chars = count;
    f0f0:	8b 44 24 28          	mov    0x28(%esp),%eax
    f0f4:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (chars > size)
    f0f8:	8b 44 24 18          	mov    0x18(%esp),%eax
    f0fc:	3b 44 24 14          	cmp    0x14(%esp),%eax
    f100:	7e 08                	jle    f10a <read_pipe+0xb2>
			chars = size;
    f102:	8b 44 24 14          	mov    0x14(%esp),%eax
    f106:	89 44 24 18          	mov    %eax,0x18(%esp)
		count -= chars;
    f10a:	8b 54 24 18          	mov    0x18(%esp),%edx
    f10e:	8d 44 24 28          	lea    0x28(%esp),%eax
    f112:	29 10                	sub    %edx,(%eax)
		read += chars;
    f114:	8b 54 24 18          	mov    0x18(%esp),%edx
    f118:	8d 44 24 10          	lea    0x10(%esp),%eax
    f11c:	01 10                	add    %edx,(%eax)
		size = PIPE_TAIL(*inode);
    f11e:	8b 44 24 20          	mov    0x20(%esp),%eax
    f122:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    f126:	89 44 24 14          	mov    %eax,0x14(%esp)
		PIPE_TAIL(*inode) += chars;
    f12a:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    f12e:	8b 54 24 20          	mov    0x20(%esp),%edx
    f132:	8b 44 24 18          	mov    0x18(%esp),%eax
    f136:	66 03 42 10          	add    0x10(%edx),%ax
    f13a:	66 89 41 10          	mov    %ax,0x10(%ecx)
		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);
    f13e:	8b 54 24 20          	mov    0x20(%esp),%edx
    f142:	8b 44 24 20          	mov    0x20(%esp),%eax
    f146:	66 8b 40 10          	mov    0x10(%eax),%ax
    f14a:	25 ff 0f 00 00       	and    $0xfff,%eax
    f14f:	66 89 42 10          	mov    %ax,0x10(%edx)
		while (chars-->0)
    f153:	8b 54 24 18          	mov    0x18(%esp),%edx
    f157:	8d 44 24 18          	lea    0x18(%esp),%eax
    f15b:	ff 08                	decl   (%eax)
    f15d:	85 d2                	test   %edx,%edx
    f15f:	0f 8e fe fe ff ff    	jle    f063 <read_pipe+0xb>
			put_fs_byte(((char *)inode->i_size)[size++],buf++);
    f165:	83 ec 08             	sub    $0x8,%esp
    f168:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f16c:	50                   	push   %eax
    f16d:	8d 44 24 30          	lea    0x30(%esp),%eax
    f171:	ff 00                	incl   (%eax)
    f173:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    f177:	8b 44 24 20          	mov    0x20(%esp),%eax
    f17b:	03 42 04             	add    0x4(%edx),%eax
    f17e:	0f be 00             	movsbl (%eax),%eax
    f181:	50                   	push   %eax
    f182:	8d 44 24 24          	lea    0x24(%esp),%eax
    f186:	ff 00                	incl   (%eax)
    f188:	e8 28 00 00 00       	call   f1b5 <put_fs_byte>
    f18d:	83 c4 10             	add    $0x10,%esp
    f190:	eb c1                	jmp    f153 <read_pipe+0xfb>
	}
	wake_up(&inode->i_wait);
    f192:	83 ec 0c             	sub    $0xc,%esp
    f195:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f199:	83 c0 20             	add    $0x20,%eax
    f19c:	50                   	push   %eax
    f19d:	e8 01 7e ff ff       	call   6fa3 <wake_up>
    f1a2:	83 c4 10             	add    $0x10,%esp
	return read;
    f1a5:	8b 44 24 10          	mov    0x10(%esp),%eax
    f1a9:	89 44 24 0c          	mov    %eax,0xc(%esp)
}
    f1ad:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f1b1:	83 c4 1c             	add    $0x1c,%esp
    f1b4:	c3                   	ret    

0000f1b5 <put_fs_byte>:
{
    f1b5:	83 ec 04             	sub    $0x4,%esp
    f1b8:	8b 44 24 08          	mov    0x8(%esp),%eax
    f1bc:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
    f1c0:	8a 54 24 03          	mov    0x3(%esp),%dl
    f1c4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f1c8:	64 88 10             	mov    %dl,%fs:(%eax)
}
    f1cb:	83 c4 04             	add    $0x4,%esp
    f1ce:	c3                   	ret    

0000f1cf <write_pipe>:
	
int write_pipe(struct m_inode * inode, char * buf, int count)
{
    f1cf:	53                   	push   %ebx
    f1d0:	83 ec 18             	sub    $0x18,%esp
	int chars, size, written = 0;
    f1d3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    f1da:	00 

	while (count>0) {
    f1db:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f1e0:	0f 8e 54 01 00 00    	jle    f33a <write_pipe+0x16b>
		while (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {
    f1e6:	8b 44 24 20          	mov    0x20(%esp),%eax
    f1ea:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
    f1ee:	8b 44 24 20          	mov    0x20(%esp),%eax
    f1f2:	0f b7 40 10          	movzwl 0x10(%eax),%eax
    f1f6:	29 c2                	sub    %eax,%edx
    f1f8:	89 d0                	mov    %edx,%eax
    f1fa:	f7 d0                	not    %eax
    f1fc:	25 ff 0f 00 00       	and    $0xfff,%eax
    f201:	89 44 24 10          	mov    %eax,0x10(%esp)
    f205:	8b 44 24 10          	mov    0x10(%esp),%eax
    f209:	85 c0                	test   %eax,%eax
    f20b:	75 6e                	jne    f27b <write_pipe+0xac>
			wake_up(&inode->i_wait);
    f20d:	83 ec 0c             	sub    $0xc,%esp
    f210:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f214:	83 c0 20             	add    $0x20,%eax
    f217:	50                   	push   %eax
    f218:	e8 86 7d ff ff       	call   6fa3 <wake_up>
    f21d:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) { /* no readers */
    f220:	8b 44 24 20          	mov    0x20(%esp),%eax
    f224:	66 83 78 30 02       	cmpw   $0x2,0x30(%eax)
    f229:	74 38                	je     f263 <write_pipe+0x94>
				current->signal |= (1<<(SIGPIPE-1));
    f22b:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    f230:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    f236:	8b 52 0c             	mov    0xc(%edx),%edx
    f239:	80 ce 10             	or     $0x10,%dh
    f23c:	89 50 0c             	mov    %edx,0xc(%eax)
				return written?written:-1;
    f23f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f243:	89 44 24 04          	mov    %eax,0x4(%esp)
    f247:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f24c:	75 08                	jne    f256 <write_pipe+0x87>
    f24e:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
    f255:	ff 
    f256:	8b 44 24 04          	mov    0x4(%esp),%eax
    f25a:	89 44 24 08          	mov    %eax,0x8(%esp)
    f25e:	e9 f2 00 00 00       	jmp    f355 <write_pipe+0x186>
			}
			sleep_on(&inode->i_wait);
    f263:	83 ec 0c             	sub    $0xc,%esp
    f266:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f26a:	83 c0 20             	add    $0x20,%eax
    f26d:	50                   	push   %eax
    f26e:	e8 12 7a ff ff       	call   6c85 <sleep_on>
    f273:	83 c4 10             	add    $0x10,%esp
    f276:	e9 6b ff ff ff       	jmp    f1e6 <write_pipe+0x17>
		}
		chars = PAGE_SIZE-PIPE_HEAD(*inode);
    f27b:	8b 44 24 20          	mov    0x20(%esp),%eax
    f27f:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
    f283:	b8 00 10 00 00       	mov    $0x1000,%eax
    f288:	29 d0                	sub    %edx,%eax
    f28a:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars > count)
    f28e:	8b 44 24 14          	mov    0x14(%esp),%eax
    f292:	3b 44 24 28          	cmp    0x28(%esp),%eax
    f296:	7e 08                	jle    f2a0 <write_pipe+0xd1>
			chars = count;
    f298:	8b 44 24 28          	mov    0x28(%esp),%eax
    f29c:	89 44 24 14          	mov    %eax,0x14(%esp)
		if (chars > size)
    f2a0:	8b 44 24 14          	mov    0x14(%esp),%eax
    f2a4:	3b 44 24 10          	cmp    0x10(%esp),%eax
    f2a8:	7e 08                	jle    f2b2 <write_pipe+0xe3>
			chars = size;
    f2aa:	8b 44 24 10          	mov    0x10(%esp),%eax
    f2ae:	89 44 24 14          	mov    %eax,0x14(%esp)
		count -= chars;
    f2b2:	8b 54 24 14          	mov    0x14(%esp),%edx
    f2b6:	8d 44 24 28          	lea    0x28(%esp),%eax
    f2ba:	29 10                	sub    %edx,(%eax)
		written += chars;
    f2bc:	8b 54 24 14          	mov    0x14(%esp),%edx
    f2c0:	8d 44 24 0c          	lea    0xc(%esp),%eax
    f2c4:	01 10                	add    %edx,(%eax)
		size = PIPE_HEAD(*inode);
    f2c6:	8b 44 24 20          	mov    0x20(%esp),%eax
    f2ca:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    f2ce:	89 44 24 10          	mov    %eax,0x10(%esp)
		PIPE_HEAD(*inode) += chars;
    f2d2:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    f2d6:	8b 54 24 20          	mov    0x20(%esp),%edx
    f2da:	8b 44 24 14          	mov    0x14(%esp),%eax
    f2de:	66 03 42 0e          	add    0xe(%edx),%ax
    f2e2:	66 89 41 0e          	mov    %ax,0xe(%ecx)
		PIPE_HEAD(*inode) &= (PAGE_SIZE-1);
    f2e6:	8b 54 24 20          	mov    0x20(%esp),%edx
    f2ea:	8b 44 24 20          	mov    0x20(%esp),%eax
    f2ee:	66 8b 40 0e          	mov    0xe(%eax),%ax
    f2f2:	25 ff 0f 00 00       	and    $0xfff,%eax
    f2f7:	66 89 42 0e          	mov    %ax,0xe(%edx)
		while (chars-->0)
    f2fb:	8b 54 24 14          	mov    0x14(%esp),%edx
    f2ff:	8d 44 24 14          	lea    0x14(%esp),%eax
    f303:	ff 08                	decl   (%eax)
    f305:	85 d2                	test   %edx,%edx
    f307:	0f 8e ce fe ff ff    	jle    f1db <write_pipe+0xc>
			((char *)inode->i_size)[size++]=get_fs_byte(buf++);
    f30d:	8b 54 24 20          	mov    0x20(%esp),%edx
    f311:	8b 44 24 10          	mov    0x10(%esp),%eax
    f315:	89 c3                	mov    %eax,%ebx
    f317:	03 5a 04             	add    0x4(%edx),%ebx
    f31a:	83 ec 0c             	sub    $0xc,%esp
    f31d:	8b 44 24 30          	mov    0x30(%esp),%eax
    f321:	50                   	push   %eax
    f322:	8d 44 24 34          	lea    0x34(%esp),%eax
    f326:	ff 00                	incl   (%eax)
    f328:	8d 44 24 20          	lea    0x20(%esp),%eax
    f32c:	ff 00                	incl   (%eax)
    f32e:	e8 2b 00 00 00       	call   f35e <get_fs_byte>
    f333:	83 c4 10             	add    $0x10,%esp
    f336:	88 03                	mov    %al,(%ebx)
    f338:	eb c1                	jmp    f2fb <write_pipe+0x12c>
	}
	wake_up(&inode->i_wait);
    f33a:	83 ec 0c             	sub    $0xc,%esp
    f33d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f341:	83 c0 20             	add    $0x20,%eax
    f344:	50                   	push   %eax
    f345:	e8 59 7c ff ff       	call   6fa3 <wake_up>
    f34a:	83 c4 10             	add    $0x10,%esp
	return written;
    f34d:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f351:	89 44 24 08          	mov    %eax,0x8(%esp)
}
    f355:	8b 44 24 08          	mov    0x8(%esp),%eax
    f359:	83 c4 18             	add    $0x18,%esp
    f35c:	5b                   	pop    %ebx
    f35d:	c3                   	ret    

0000f35e <get_fs_byte>:
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    f35e:	8b 44 24 04          	mov    0x4(%esp),%eax
    f362:	64 8a 00             	mov    %fs:(%eax),%al
	return _v;
    f365:	0f b6 c0             	movzbl %al,%eax
}
    f368:	c3                   	ret    

0000f369 <sys_pipe>:

int sys_pipe(unsigned long * fildes)
{
    f369:	53                   	push   %ebx
    f36a:	83 ec 28             	sub    $0x28,%esp
	struct m_inode * inode;
	struct file * f[2];
	int fd[2];
	int i,j;

	j=0;
    f36d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    f374:	00 
	for(i=0;j<2 && i<NR_FILE;i++)
    f375:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    f37c:	00 
    f37d:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    f382:	7f 46                	jg     f3ca <sys_pipe+0x61>
    f384:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
    f389:	7f 3f                	jg     f3ca <sys_pipe+0x61>
		if (!file_table[i].f_count)
    f38b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f38f:	c1 e0 04             	shl    $0x4,%eax
    f392:	66 83 b8 e4 25 02 00 	cmpw   $0x0,0x225e4(%eax)
    f399:	00 
    f39a:	75 26                	jne    f3c2 <sys_pipe+0x59>
			(f[j++]=i+file_table)->f_count++;
    f39c:	8b 44 24 08          	mov    0x8(%esp),%eax
    f3a0:	89 c2                	mov    %eax,%edx
    f3a2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f3a6:	c1 e0 04             	shl    $0x4,%eax
    f3a9:	05 e0 25 02 00       	add    $0x225e0,%eax
    f3ae:	89 44 94 18          	mov    %eax,0x18(%esp,%edx,4)
    f3b2:	8b 54 94 18          	mov    0x18(%esp,%edx,4),%edx
    f3b6:	8d 44 24 08          	lea    0x8(%esp),%eax
    f3ba:	ff 00                	incl   (%eax)
    f3bc:	89 d0                	mov    %edx,%eax
    f3be:	66 ff 40 04          	incw   0x4(%eax)
	for(i=0;j<2 && i<NR_FILE;i++)
    f3c2:	8d 44 24 0c          	lea    0xc(%esp),%eax
    f3c6:	ff 00                	incl   (%eax)
    f3c8:	eb b3                	jmp    f37d <sys_pipe+0x14>
	if (j==1)
    f3ca:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    f3cf:	75 0a                	jne    f3db <sys_pipe+0x72>
		f[0]->f_count=0;
    f3d1:	8b 44 24 18          	mov    0x18(%esp),%eax
    f3d5:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
	if (j<2)
    f3db:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    f3e0:	7f 0d                	jg     f3ef <sys_pipe+0x86>
		return -1;
    f3e2:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
    f3e9:	ff 
    f3ea:	e9 69 01 00 00       	jmp    f558 <sys_pipe+0x1ef>
	j=0;
    f3ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    f3f6:	00 
	for(i=0;j<2 && i<NR_OPEN;i++)
    f3f7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    f3fe:	00 
    f3ff:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    f404:	7f 4a                	jg     f450 <sys_pipe+0xe7>
    f406:	83 7c 24 0c 13       	cmpl   $0x13,0xc(%esp)
    f40b:	7f 43                	jg     f450 <sys_pipe+0xe7>
		if (!current->filp[i]) {
    f40d:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    f413:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f417:	83 bc 82 80 02 00 00 	cmpl   $0x0,0x280(%edx,%eax,4)
    f41e:	00 
    f41f:	75 27                	jne    f448 <sys_pipe+0xdf>
			current->filp[ fd[j]=i ] = f[j];
    f421:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    f427:	8b 44 24 08          	mov    0x8(%esp),%eax
    f42b:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f42f:	89 54 84 10          	mov    %edx,0x10(%esp,%eax,4)
    f433:	8b 44 24 08          	mov    0x8(%esp),%eax
    f437:	8b 44 84 18          	mov    0x18(%esp,%eax,4),%eax
    f43b:	89 84 91 80 02 00 00 	mov    %eax,0x280(%ecx,%edx,4)
			j++;
    f442:	8d 44 24 08          	lea    0x8(%esp),%eax
    f446:	ff 00                	incl   (%eax)
	for(i=0;j<2 && i<NR_OPEN;i++)
    f448:	8d 44 24 0c          	lea    0xc(%esp),%eax
    f44c:	ff 00                	incl   (%eax)
    f44e:	eb af                	jmp    f3ff <sys_pipe+0x96>
		}
	if (j==1)
    f450:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    f455:	75 15                	jne    f46c <sys_pipe+0x103>
		current->filp[fd[0]]=NULL;
    f457:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    f45d:	8b 44 24 10          	mov    0x10(%esp),%eax
    f461:	c7 84 82 80 02 00 00 	movl   $0x0,0x280(%edx,%eax,4)
    f468:	00 00 00 00 
	if (j<2) {
    f46c:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
    f471:	7f 21                	jg     f494 <sys_pipe+0x12b>
		f[0]->f_count=f[1]->f_count=0;
    f473:	8b 54 24 18          	mov    0x18(%esp),%edx
    f477:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f47b:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
    f481:	66 c7 42 04 00 00    	movw   $0x0,0x4(%edx)
		return -1;
    f487:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
    f48e:	ff 
    f48f:	e9 c4 00 00 00       	jmp    f558 <sys_pipe+0x1ef>
	}
	if (!(inode=get_pipe_inode())) {
    f494:	e8 78 c6 ff ff       	call   bb11 <get_pipe_inode>
    f499:	89 44 24 24          	mov    %eax,0x24(%esp)
    f49d:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    f4a2:	75 48                	jne    f4ec <sys_pipe+0x183>
		current->filp[fd[0]] =
    f4a4:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
    f4aa:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    f4ae:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    f4b4:	8b 44 24 14          	mov    0x14(%esp),%eax
    f4b8:	c7 84 82 80 02 00 00 	movl   $0x0,0x280(%edx,%eax,4)
    f4bf:	00 00 00 00 
    f4c3:	c7 84 99 80 02 00 00 	movl   $0x0,0x280(%ecx,%ebx,4)
    f4ca:	00 00 00 00 
			current->filp[fd[1]] = NULL;
		f[0]->f_count = f[1]->f_count = 0;
    f4ce:	8b 54 24 18          	mov    0x18(%esp),%edx
    f4d2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f4d6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
    f4dc:	66 c7 42 04 00 00    	movw   $0x0,0x4(%edx)
		return -1;
    f4e2:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
    f4e9:	ff 
    f4ea:	eb 6c                	jmp    f558 <sys_pipe+0x1ef>
	}
	f[0]->f_inode = f[1]->f_inode = inode;
    f4ec:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    f4f0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    f4f4:	8b 44 24 24          	mov    0x24(%esp),%eax
    f4f8:	89 42 08             	mov    %eax,0x8(%edx)
    f4fb:	89 41 08             	mov    %eax,0x8(%ecx)
	f[0]->f_pos = f[1]->f_pos = 0;
    f4fe:	8b 54 24 18          	mov    0x18(%esp),%edx
    f502:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f506:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    f50d:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	f[0]->f_mode = 1;		/* read */
    f514:	8b 44 24 18          	mov    0x18(%esp),%eax
    f518:	66 c7 00 01 00       	movw   $0x1,(%eax)
	f[1]->f_mode = 2;		/* write */
    f51d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f521:	66 c7 00 02 00       	movw   $0x2,(%eax)
	put_fs_long(fd[0],0+fildes);
    f526:	83 ec 08             	sub    $0x8,%esp
    f529:	ff 74 24 38          	pushl  0x38(%esp)
    f52d:	ff 74 24 1c          	pushl  0x1c(%esp)
    f531:	e8 2b 00 00 00       	call   f561 <put_fs_long>
    f536:	83 c4 10             	add    $0x10,%esp
	put_fs_long(fd[1],1+fildes);
    f539:	83 ec 08             	sub    $0x8,%esp
    f53c:	8b 44 24 38          	mov    0x38(%esp),%eax
    f540:	83 c0 04             	add    $0x4,%eax
    f543:	50                   	push   %eax
    f544:	ff 74 24 20          	pushl  0x20(%esp)
    f548:	e8 14 00 00 00       	call   f561 <put_fs_long>
    f54d:	83 c4 10             	add    $0x10,%esp
	return 0;
    f550:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    f557:	00 
}
    f558:	8b 44 24 04          	mov    0x4(%esp),%eax
    f55c:	83 c4 28             	add    $0x28,%esp
    f55f:	5b                   	pop    %ebx
    f560:	c3                   	ret    

0000f561 <put_fs_long>:
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
    f561:	8b 54 24 04          	mov    0x4(%esp),%edx
    f565:	8b 44 24 08          	mov    0x8(%esp),%eax
    f569:	64 89 10             	mov    %edx,%fs:(%eax)
}
    f56c:	c3                   	ret    

0000f56d <permission>:
 * is used to check for read/write/execute permissions on a file.
 * I don't know if we should look at just the euid or both euid and
 * uid, but that should be easily changed.
 */
static int permission(struct m_inode * inode,int mask)
{
    f56d:	83 ec 08             	sub    $0x8,%esp
	int mode = inode->i_mode;
    f570:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f574:	0f b7 00             	movzwl (%eax),%eax
    f577:	89 44 24 04          	mov    %eax,0x4(%esp)

/* special case: not even root can read/write a deleted file */
	if (inode->i_dev && !inode->i_nlinks)
    f57b:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f57f:	66 83 78 2c 00       	cmpw   $0x0,0x2c(%eax)
    f584:	74 13                	je     f599 <permission+0x2c>
    f586:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f58a:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
    f58e:	75 09                	jne    f599 <permission+0x2c>
		return 0;
    f590:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f597:	eb 6d                	jmp    f606 <permission+0x99>
	else if (current->euid==inode->i_uid)
    f599:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    f59e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f5a2:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
    f5a9:	66 3b 42 02          	cmp    0x2(%edx),%ax
    f5ad:	75 09                	jne    f5b8 <permission+0x4b>
		mode >>= 6;
    f5af:	8d 44 24 04          	lea    0x4(%esp),%eax
    f5b3:	c1 38 06             	sarl   $0x6,(%eax)
    f5b6:	eb 1e                	jmp    f5d6 <permission+0x69>
	else if (current->egid==inode->i_gid)
    f5b8:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    f5bd:	8b 54 24 0c          	mov    0xc(%esp),%edx
    f5c1:	66 0f b6 52 0c       	movzbw 0xc(%edx),%dx
    f5c6:	66 39 90 48 02 00 00 	cmp    %dx,0x248(%eax)
    f5cd:	75 07                	jne    f5d6 <permission+0x69>
		mode >>= 3;
    f5cf:	8d 44 24 04          	lea    0x4(%esp),%eax
    f5d3:	c1 38 03             	sarl   $0x3,(%eax)
	if (((mode & mask & 0007) == mask) || suser())
    f5d6:	8b 44 24 10          	mov    0x10(%esp),%eax
    f5da:	23 44 24 04          	and    0x4(%esp),%eax
    f5de:	83 e0 07             	and    $0x7,%eax
    f5e1:	3b 44 24 10          	cmp    0x10(%esp),%eax
    f5e5:	74 0f                	je     f5f6 <permission+0x89>
    f5e7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    f5ec:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
    f5f3:	00 
    f5f4:	75 09                	jne    f5ff <permission+0x92>
		return 1;
    f5f6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    f5fd:	eb 07                	jmp    f606 <permission+0x99>
	return 0;
    f5ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
}
    f606:	8b 04 24             	mov    (%esp),%eax
    f609:	83 c4 08             	add    $0x8,%esp
    f60c:	c3                   	ret    

0000f60d <match>:
 * some sanity tests.
 *
 * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.
 */
static int match(int len,const char * name,struct dir_entry * de)
{
    f60d:	57                   	push   %edi
    f60e:	56                   	push   %esi
    f60f:	83 ec 04             	sub    $0x4,%esp
	register int same ;

	if (!de || !de->inode || len > NAME_LEN)
    f612:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    f617:	74 13                	je     f62c <match+0x1f>
    f619:	8b 44 24 18          	mov    0x18(%esp),%eax
    f61d:	66 83 38 00          	cmpw   $0x0,(%eax)
    f621:	74 09                	je     f62c <match+0x1f>
    f623:	83 7c 24 10 0e       	cmpl   $0xe,0x10(%esp)
    f628:	7f 02                	jg     f62c <match+0x1f>
    f62a:	eb 09                	jmp    f635 <match+0x28>
		return 0;
    f62c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f633:	eb 3d                	jmp    f672 <match+0x65>
	if (len < NAME_LEN && de->name[len])
    f635:	83 7c 24 10 0d       	cmpl   $0xd,0x10(%esp)
    f63a:	7f 18                	jg     f654 <match+0x47>
    f63c:	8b 54 24 18          	mov    0x18(%esp),%edx
    f640:	8b 44 24 10          	mov    0x10(%esp),%eax
    f644:	80 7c 02 02 00       	cmpb   $0x0,0x2(%edx,%eax,1)
    f649:	74 09                	je     f654 <match+0x47>
		return 0;
    f64b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f652:	eb 1e                	jmp    f672 <match+0x65>
	__asm__("cld\n\t"
    f654:	b8 00 00 00 00       	mov    $0x0,%eax
    f659:	8b 74 24 14          	mov    0x14(%esp),%esi
    f65d:	8b 7c 24 18          	mov    0x18(%esp),%edi
    f661:	83 c7 02             	add    $0x2,%edi
    f664:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    f668:	fc                   	cld    
    f669:	64 f3 a6             	repz cmpsb %es:(%edi),%fs:(%esi)
    f66c:	0f 94 c0             	sete   %al
		"fs ; repe ; cmpsb\n\t"
		"setz %%al"
		:"=a" (same)
		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
		);
	return same;
    f66f:	89 04 24             	mov    %eax,(%esp)
}
    f672:	8b 04 24             	mov    (%esp),%eax
    f675:	83 c4 04             	add    $0x4,%esp
    f678:	5e                   	pop    %esi
    f679:	5f                   	pop    %edi
    f67a:	c3                   	ret    

0000f67b <find_entry>:
 * This also takes care of the few special cases due to '..'-traversal
 * over a pseudo-root and a mount point.
 */
static struct buffer_head * find_entry(struct m_inode ** dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
    f67b:	83 ec 1c             	sub    $0x1c,%esp

#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
    f67e:	83 7c 24 28 0e       	cmpl   $0xe,0x28(%esp)
    f683:	7e 08                	jle    f68d <find_entry+0x12>
		namelen = NAME_LEN;
    f685:	c7 44 24 28 0e 00 00 	movl   $0xe,0x28(%esp)
    f68c:	00 
#endif
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
    f68d:	8b 44 24 20          	mov    0x20(%esp),%eax
    f691:	8b 00                	mov    (%eax),%eax
    f693:	8b 40 04             	mov    0x4(%eax),%eax
    f696:	c1 e8 04             	shr    $0x4,%eax
    f699:	89 44 24 18          	mov    %eax,0x18(%esp)
	*res_dir = NULL;
    f69d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f6a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (!namelen)
    f6a7:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
    f6ac:	75 0c                	jne    f6ba <find_entry+0x3f>
		return NULL;
    f6ae:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f6b5:	e9 fb 01 00 00       	jmp    f8b5 <find_entry+0x23a>
/* check for '..', as we might have to do some "magic" for it */
	if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
    f6ba:	83 7c 24 28 02       	cmpl   $0x2,0x28(%esp)
    f6bf:	0f 85 a3 00 00 00    	jne    f768 <find_entry+0xed>
    f6c5:	83 ec 0c             	sub    $0xc,%esp
    f6c8:	ff 74 24 30          	pushl  0x30(%esp)
    f6cc:	e8 eb 01 00 00       	call   f8bc <get_fs_byte>
    f6d1:	83 c4 10             	add    $0x10,%esp
    f6d4:	3c 2e                	cmp    $0x2e,%al
    f6d6:	0f 85 8c 00 00 00    	jne    f768 <find_entry+0xed>
    f6dc:	83 ec 0c             	sub    $0xc,%esp
    f6df:	8b 44 24 30          	mov    0x30(%esp),%eax
    f6e3:	40                   	inc    %eax
    f6e4:	50                   	push   %eax
    f6e5:	e8 d2 01 00 00       	call   f8bc <get_fs_byte>
    f6ea:	83 c4 10             	add    $0x10,%esp
    f6ed:	3c 2e                	cmp    $0x2e,%al
    f6ef:	75 77                	jne    f768 <find_entry+0xed>
/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
		if ((*dir) == current->root)
    f6f1:	8b 44 24 20          	mov    0x20(%esp),%eax
    f6f5:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
    f6fb:	8b 00                	mov    (%eax),%eax
    f6fd:	3b 82 74 02 00 00    	cmp    0x274(%edx),%eax
    f703:	75 0a                	jne    f70f <find_entry+0x94>
			namelen=1;
    f705:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
    f70c:	00 
    f70d:	eb 59                	jmp    f768 <find_entry+0xed>
		else if ((*dir)->i_num == ROOT_INO) {
    f70f:	8b 44 24 20          	mov    0x20(%esp),%eax
    f713:	8b 00                	mov    (%eax),%eax
    f715:	66 83 78 2e 01       	cmpw   $0x1,0x2e(%eax)
    f71a:	75 4c                	jne    f768 <find_entry+0xed>
/* '..' over a mount-point results in 'dir' being exchanged for the mounted
   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
			sb=get_super((*dir)->i_dev);
    f71c:	83 ec 0c             	sub    $0xc,%esp
    f71f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f723:	8b 00                	mov    (%eax),%eax
    f725:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    f729:	50                   	push   %eax
    f72a:	e8 21 d4 ff ff       	call   cb50 <get_super>
    f72f:	83 c4 10             	add    $0x10,%esp
    f732:	89 44 24 04          	mov    %eax,0x4(%esp)
			if (sb->s_imount) {
    f736:	8b 44 24 04          	mov    0x4(%esp),%eax
    f73a:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
    f73e:	74 28                	je     f768 <find_entry+0xed>
				iput(*dir);
    f740:	83 ec 0c             	sub    $0xc,%esp
    f743:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f747:	ff 30                	pushl  (%eax)
    f749:	e8 ff c0 ff ff       	call   b84d <iput>
    f74e:	83 c4 10             	add    $0x10,%esp
				(*dir)=sb->s_imount;
    f751:	8b 54 24 20          	mov    0x20(%esp),%edx
    f755:	8b 44 24 04          	mov    0x4(%esp),%eax
    f759:	8b 40 5c             	mov    0x5c(%eax),%eax
    f75c:	89 02                	mov    %eax,(%edx)
				(*dir)->i_count++;
    f75e:	8b 44 24 20          	mov    0x20(%esp),%eax
    f762:	8b 00                	mov    (%eax),%eax
    f764:	66 ff 40 30          	incw   0x30(%eax)
			}
		}
	}
	if (!(block = (*dir)->i_zone[0]))
    f768:	8b 44 24 20          	mov    0x20(%esp),%eax
    f76c:	8b 00                	mov    (%eax),%eax
    f76e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    f772:	89 44 24 14          	mov    %eax,0x14(%esp)
    f776:	8b 44 24 14          	mov    0x14(%esp),%eax
    f77a:	85 c0                	test   %eax,%eax
    f77c:	75 0c                	jne    f78a <find_entry+0x10f>
		return NULL;
    f77e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f785:	e9 2b 01 00 00       	jmp    f8b5 <find_entry+0x23a>
	if (!(bh = bread((*dir)->i_dev,block)))
    f78a:	83 ec 08             	sub    $0x8,%esp
    f78d:	ff 74 24 1c          	pushl  0x1c(%esp)
    f791:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f795:	8b 00                	mov    (%eax),%eax
    f797:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    f79b:	50                   	push   %eax
    f79c:	e8 62 cf ff ff       	call   c703 <bread>
    f7a1:	83 c4 10             	add    $0x10,%esp
    f7a4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f7a8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f7ad:	75 0c                	jne    f7bb <find_entry+0x140>
		return NULL;
    f7af:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    f7b6:	e9 fa 00 00 00       	jmp    f8b5 <find_entry+0x23a>
	i = 0;
    f7bb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    f7c2:	00 
	de = (struct dir_entry *) bh->b_data;
    f7c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f7c7:	8b 00                	mov    (%eax),%eax
    f7c9:	89 44 24 08          	mov    %eax,0x8(%esp)
	while (i < entries) {
    f7cd:	8b 44 24 10          	mov    0x10(%esp),%eax
    f7d1:	3b 44 24 18          	cmp    0x18(%esp),%eax
    f7d5:	0f 8d c4 00 00 00    	jge    f89f <find_entry+0x224>
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
    f7db:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f7df:	8b 00                	mov    (%eax),%eax
    f7e1:	05 00 04 00 00       	add    $0x400,%eax
    f7e6:	3b 44 24 08          	cmp    0x8(%esp),%eax
    f7ea:	77 76                	ja     f862 <find_entry+0x1e7>
			brelse(bh);
    f7ec:	83 ec 0c             	sub    $0xc,%esp
    f7ef:	ff 74 24 18          	pushl  0x18(%esp)
    f7f3:	e8 bf ce ff ff       	call   c6b7 <brelse>
    f7f8:	83 c4 10             	add    $0x10,%esp
			bh = NULL;
    f7fb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    f802:	00 
			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||
    f803:	83 ec 08             	sub    $0x8,%esp
    f806:	8b 44 24 18          	mov    0x18(%esp),%eax
    f80a:	c1 e8 06             	shr    $0x6,%eax
    f80d:	50                   	push   %eax
    f80e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f812:	ff 30                	pushl  (%eax)
    f814:	e8 fc bf ff ff       	call   b815 <bmap>
    f819:	83 c4 10             	add    $0x10,%esp
    f81c:	89 44 24 14          	mov    %eax,0x14(%esp)
    f820:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    f825:	74 25                	je     f84c <find_entry+0x1d1>
    f827:	83 ec 08             	sub    $0x8,%esp
    f82a:	ff 74 24 1c          	pushl  0x1c(%esp)
    f82e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f832:	8b 00                	mov    (%eax),%eax
    f834:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    f838:	50                   	push   %eax
    f839:	e8 c5 ce ff ff       	call   c703 <bread>
    f83e:	83 c4 10             	add    $0x10,%esp
    f841:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f845:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f84a:	75 0c                	jne    f858 <find_entry+0x1dd>
			    !(bh = bread((*dir)->i_dev,block))) {
				i += DIR_ENTRIES_PER_BLOCK;
    f84c:	8d 44 24 10          	lea    0x10(%esp),%eax
    f850:	83 00 40             	addl   $0x40,(%eax)
				continue;
    f853:	e9 75 ff ff ff       	jmp    f7cd <find_entry+0x152>
			}
			de = (struct dir_entry *) bh->b_data;
    f858:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f85c:	8b 00                	mov    (%eax),%eax
    f85e:	89 44 24 08          	mov    %eax,0x8(%esp)
		}
		if (match(namelen,name,de)) {
    f862:	ff 74 24 08          	pushl  0x8(%esp)
    f866:	ff 74 24 28          	pushl  0x28(%esp)
    f86a:	ff 74 24 30          	pushl  0x30(%esp)
    f86e:	e8 9a fd ff ff       	call   f60d <match>
    f873:	83 c4 0c             	add    $0xc,%esp
    f876:	85 c0                	test   %eax,%eax
    f878:	74 13                	je     f88d <find_entry+0x212>
			*res_dir = de;
    f87a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    f87e:	8b 54 24 08          	mov    0x8(%esp),%edx
    f882:	89 10                	mov    %edx,(%eax)
			return bh;
    f884:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f888:	89 04 24             	mov    %eax,(%esp)
    f88b:	eb 28                	jmp    f8b5 <find_entry+0x23a>
		}
		de++;
    f88d:	8d 44 24 08          	lea    0x8(%esp),%eax
    f891:	83 00 10             	addl   $0x10,(%eax)
		i++;
    f894:	8d 44 24 10          	lea    0x10(%esp),%eax
    f898:	ff 00                	incl   (%eax)
    f89a:	e9 2e ff ff ff       	jmp    f7cd <find_entry+0x152>
	}
	brelse(bh);
    f89f:	83 ec 0c             	sub    $0xc,%esp
    f8a2:	ff 74 24 18          	pushl  0x18(%esp)
    f8a6:	e8 0c ce ff ff       	call   c6b7 <brelse>
    f8ab:	83 c4 10             	add    $0x10,%esp
	return NULL;
    f8ae:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
}
    f8b5:	8b 04 24             	mov    (%esp),%eax
    f8b8:	83 c4 1c             	add    $0x1c,%esp
    f8bb:	c3                   	ret    

0000f8bc <get_fs_byte>:
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
    f8bc:	8b 44 24 04          	mov    0x4(%esp),%eax
    f8c0:	64 8a 00             	mov    %fs:(%eax),%al
	return _v;
    f8c3:	0f b6 c0             	movzbl %al,%eax
}
    f8c6:	c3                   	ret    

0000f8c7 <add_entry>:
 * may not sleep between calling this and putting something into
 * the entry, as someone else might have used it while you slept.
 */
static struct buffer_head * add_entry(struct m_inode * dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
    f8c7:	53                   	push   %ebx
    f8c8:	83 ec 28             	sub    $0x28,%esp
	int block,i;
	struct buffer_head * bh;
	struct dir_entry * de;

	*res_dir = NULL;
    f8cb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    f8cf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
    f8d5:	83 7c 24 38 0e       	cmpl   $0xe,0x38(%esp)
    f8da:	7e 08                	jle    f8e4 <add_entry+0x1d>
		namelen = NAME_LEN;
    f8dc:	c7 44 24 38 0e 00 00 	movl   $0xe,0x38(%esp)
    f8e3:	00 
#endif
	if (!namelen)
    f8e4:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
    f8e9:	75 0d                	jne    f8f8 <add_entry+0x31>
		return NULL;
    f8eb:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    f8f2:	00 
    f8f3:	e9 0c 02 00 00       	jmp    fb04 <add_entry+0x23d>
	if (!(block = dir->i_zone[0]))
    f8f8:	8b 44 24 30          	mov    0x30(%esp),%eax
    f8fc:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    f900:	89 44 24 24          	mov    %eax,0x24(%esp)
    f904:	8b 44 24 24          	mov    0x24(%esp),%eax
    f908:	85 c0                	test   %eax,%eax
    f90a:	75 0d                	jne    f919 <add_entry+0x52>
		return NULL;
    f90c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    f913:	00 
    f914:	e9 eb 01 00 00       	jmp    fb04 <add_entry+0x23d>
	if (!(bh = bread(dir->i_dev,block)))
    f919:	83 ec 08             	sub    $0x8,%esp
    f91c:	ff 74 24 2c          	pushl  0x2c(%esp)
    f920:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    f924:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    f928:	50                   	push   %eax
    f929:	e8 d5 cd ff ff       	call   c703 <bread>
    f92e:	83 c4 10             	add    $0x10,%esp
    f931:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    f935:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    f93a:	75 0d                	jne    f949 <add_entry+0x82>
		return NULL;
    f93c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    f943:	00 
    f944:	e9 bb 01 00 00       	jmp    fb04 <add_entry+0x23d>
	i = 0;
    f949:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    f950:	00 
	de = (struct dir_entry *) bh->b_data;
    f951:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f955:	8b 00                	mov    (%eax),%eax
    f957:	89 44 24 18          	mov    %eax,0x18(%esp)
	while (1) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
    f95b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f95f:	8b 00                	mov    (%eax),%eax
    f961:	05 00 04 00 00       	add    $0x400,%eax
    f966:	3b 44 24 18          	cmp    0x18(%esp),%eax
    f96a:	77 7f                	ja     f9eb <add_entry+0x124>
			brelse(bh);
    f96c:	83 ec 0c             	sub    $0xc,%esp
    f96f:	ff 74 24 28          	pushl  0x28(%esp)
    f973:	e8 3f cd ff ff       	call   c6b7 <brelse>
    f978:	83 c4 10             	add    $0x10,%esp
			bh = NULL;
    f97b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    f982:	00 
			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);
    f983:	83 ec 08             	sub    $0x8,%esp
    f986:	8b 44 24 28          	mov    0x28(%esp),%eax
    f98a:	c1 e8 06             	shr    $0x6,%eax
    f98d:	50                   	push   %eax
    f98e:	ff 74 24 3c          	pushl  0x3c(%esp)
    f992:	e8 9a be ff ff       	call   b831 <create_block>
    f997:	83 c4 10             	add    $0x10,%esp
    f99a:	89 44 24 24          	mov    %eax,0x24(%esp)
			if (!block)
    f99e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
    f9a3:	75 0d                	jne    f9b2 <add_entry+0xeb>
				return NULL;
    f9a5:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    f9ac:	00 
    f9ad:	e9 52 01 00 00       	jmp    fb04 <add_entry+0x23d>
			if (!(bh = bread(dir->i_dev,block))) {
    f9b2:	83 ec 08             	sub    $0x8,%esp
    f9b5:	ff 74 24 2c          	pushl  0x2c(%esp)
    f9b9:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    f9bd:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    f9c1:	50                   	push   %eax
    f9c2:	e8 3c cd ff ff       	call   c703 <bread>
    f9c7:	83 c4 10             	add    $0x10,%esp
    f9ca:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    f9ce:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    f9d3:	75 0c                	jne    f9e1 <add_entry+0x11a>
				i += DIR_ENTRIES_PER_BLOCK;
    f9d5:	8d 44 24 20          	lea    0x20(%esp),%eax
    f9d9:	83 00 40             	addl   $0x40,(%eax)
				continue;
    f9dc:	e9 7a ff ff ff       	jmp    f95b <add_entry+0x94>
			}
			de = (struct dir_entry *) bh->b_data;
    f9e1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    f9e5:	8b 00                	mov    (%eax),%eax
    f9e7:	89 44 24 18          	mov    %eax,0x18(%esp)
		}
		if (i*sizeof(struct dir_entry) >= dir->i_size) {
    f9eb:	8b 44 24 20          	mov    0x20(%esp),%eax
    f9ef:	89 c2                	mov    %eax,%edx
    f9f1:	c1 e2 04             	shl    $0x4,%edx
    f9f4:	8b 44 24 30          	mov    0x30(%esp),%eax
    f9f8:	3b 50 04             	cmp    0x4(%eax),%edx
    f9fb:	72 48                	jb     fa45 <add_entry+0x17e>
			de->inode=0;
    f9fd:	8b 44 24 18          	mov    0x18(%esp),%eax
    fa01:	66 c7 00 00 00       	movw   $0x0,(%eax)
			dir->i_size = (i+1)*sizeof(struct dir_entry);
    fa06:	8b 54 24 30          	mov    0x30(%esp),%edx
    fa0a:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa0e:	c1 e0 04             	shl    $0x4,%eax
    fa11:	83 c0 10             	add    $0x10,%eax
    fa14:	89 42 04             	mov    %eax,0x4(%edx)
			dir->i_dirt = 1;
    fa17:	8b 44 24 30          	mov    0x30(%esp),%eax
    fa1b:	c6 40 33 01          	movb   $0x1,0x33(%eax)
			dir->i_ctime = CURRENT_TIME;
    fa1f:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    fa23:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    fa29:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    fa2e:	f7 e9                	imul   %ecx
    fa30:	c1 fa 05             	sar    $0x5,%edx
    fa33:	89 c8                	mov    %ecx,%eax
    fa35:	c1 f8 1f             	sar    $0x1f,%eax
    fa38:	29 c2                	sub    %eax,%edx
    fa3a:	89 d0                	mov    %edx,%eax
    fa3c:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    fa42:	89 43 28             	mov    %eax,0x28(%ebx)
		}
		if (!de->inode) {
    fa45:	8b 44 24 18          	mov    0x18(%esp),%eax
    fa49:	66 83 38 00          	cmpw   $0x0,(%eax)
    fa4d:	0f 85 9f 00 00 00    	jne    faf2 <add_entry+0x22b>
			dir->i_mtime = CURRENT_TIME;
    fa53:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    fa57:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    fa5d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    fa62:	f7 e9                	imul   %ecx
    fa64:	c1 fa 05             	sar    $0x5,%edx
    fa67:	89 c8                	mov    %ecx,%eax
    fa69:	c1 f8 1f             	sar    $0x1f,%eax
    fa6c:	29 c2                	sub    %eax,%edx
    fa6e:	89 d0                	mov    %edx,%eax
    fa70:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    fa76:	89 43 08             	mov    %eax,0x8(%ebx)
			for (i=0; i < NAME_LEN ; i++)
    fa79:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    fa80:	00 
    fa81:	83 7c 24 20 0d       	cmpl   $0xd,0x20(%esp)
    fa86:	7f 4e                	jg     fad6 <add_entry+0x20f>
				de->name[i]=(i<namelen)?get_fs_byte(name+i):0;
    fa88:	8b 44 24 18          	mov    0x18(%esp),%eax
    fa8c:	89 44 24 10          	mov    %eax,0x10(%esp)
    fa90:	8b 54 24 20          	mov    0x20(%esp),%edx
    fa94:	89 54 24 0c          	mov    %edx,0xc(%esp)
    fa98:	8b 44 24 20          	mov    0x20(%esp),%eax
    fa9c:	3b 44 24 38          	cmp    0x38(%esp),%eax
    faa0:	7d 17                	jge    fab9 <add_entry+0x1f2>
    faa2:	8b 44 24 20          	mov    0x20(%esp),%eax
    faa6:	03 44 24 34          	add    0x34(%esp),%eax
    faaa:	50                   	push   %eax
    faab:	e8 0c fe ff ff       	call   f8bc <get_fs_byte>
    fab0:	83 c4 04             	add    $0x4,%esp
    fab3:	88 44 24 0b          	mov    %al,0xb(%esp)
    fab7:	eb 05                	jmp    fabe <add_entry+0x1f7>
    fab9:	c6 44 24 0b 00       	movb   $0x0,0xb(%esp)
    fabe:	8a 4c 24 0b          	mov    0xb(%esp),%cl
    fac2:	8b 44 24 10          	mov    0x10(%esp),%eax
    fac6:	8b 54 24 0c          	mov    0xc(%esp),%edx
    faca:	88 4c 10 02          	mov    %cl,0x2(%eax,%edx,1)
			for (i=0; i < NAME_LEN ; i++)
    face:	8d 44 24 20          	lea    0x20(%esp),%eax
    fad2:	ff 00                	incl   (%eax)
    fad4:	eb ab                	jmp    fa81 <add_entry+0x1ba>
			bh->b_dirt = 1;
    fad6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    fada:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
			*res_dir = de;
    fade:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    fae2:	8b 44 24 18          	mov    0x18(%esp),%eax
    fae6:	89 02                	mov    %eax,(%edx)
			return bh;
    fae8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    faec:	89 44 24 14          	mov    %eax,0x14(%esp)
    faf0:	eb 12                	jmp    fb04 <add_entry+0x23d>
		}
		de++;
    faf2:	8d 44 24 18          	lea    0x18(%esp),%eax
    faf6:	83 00 10             	addl   $0x10,(%eax)
		i++;
    faf9:	8d 44 24 20          	lea    0x20(%esp),%eax
    fafd:	ff 00                	incl   (%eax)
    faff:	e9 57 fe ff ff       	jmp    f95b <add_entry+0x94>
	}
	brelse(bh);
	return NULL;
}
    fb04:	8b 44 24 14          	mov    0x14(%esp),%eax
    fb08:	83 c4 28             	add    $0x28,%esp
    fb0b:	5b                   	pop    %ebx
    fb0c:	c3                   	ret    

0000fb0d <get_dir>:
 *
 * Getdir traverses the pathname until it hits the topmost directory.
 * It returns NULL on failure.
 */
static struct m_inode * get_dir(const char * pathname)
{
    fb0d:	83 ec 2c             	sub    $0x2c,%esp
	struct m_inode * inode;
	struct buffer_head * bh;
	int namelen,inr,idev;
	struct dir_entry * de;

	if (!current->root || !current->root->i_count)
    fb10:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fb15:	83 b8 74 02 00 00 00 	cmpl   $0x0,0x274(%eax)
    fb1c:	74 12                	je     fb30 <get_dir+0x23>
    fb1e:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fb23:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    fb29:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    fb2e:	75 10                	jne    fb40 <get_dir+0x33>
		panic("No root inode");
    fb30:	83 ec 0c             	sub    $0xc,%esp
    fb33:	68 1c 90 01 00       	push   $0x1901c
    fb38:	e8 dc 87 ff ff       	call   8319 <panic>
    fb3d:	83 c4 10             	add    $0x10,%esp
	if (!current->pwd || !current->pwd->i_count)
    fb40:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fb45:	83 b8 70 02 00 00 00 	cmpl   $0x0,0x270(%eax)
    fb4c:	74 12                	je     fb60 <get_dir+0x53>
    fb4e:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fb53:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    fb59:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
    fb5e:	75 10                	jne    fb70 <get_dir+0x63>
		panic("No cwd inode");
    fb60:	83 ec 0c             	sub    $0xc,%esp
    fb63:	68 2a 90 01 00       	push   $0x1902a
    fb68:	e8 ac 87 ff ff       	call   8319 <panic>
    fb6d:	83 c4 10             	add    $0x10,%esp
	if ((c=get_fs_byte(pathname))=='/') {
    fb70:	ff 74 24 30          	pushl  0x30(%esp)
    fb74:	e8 43 fd ff ff       	call   f8bc <get_fs_byte>
    fb79:	83 c4 04             	add    $0x4,%esp
    fb7c:	88 44 24 2b          	mov    %al,0x2b(%esp)
    fb80:	8a 44 24 2b          	mov    0x2b(%esp),%al
    fb84:	3c 2f                	cmp    $0x2f,%al
    fb86:	75 15                	jne    fb9d <get_dir+0x90>
		inode = current->root;
    fb88:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fb8d:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
    fb93:	89 44 24 20          	mov    %eax,0x20(%esp)
		pathname++;
    fb97:	ff 44 24 30          	incl   0x30(%esp)
    fb9b:	eb 25                	jmp    fbc2 <get_dir+0xb5>
	} else if (c)
    fb9d:	80 7c 24 2b 00       	cmpb   $0x0,0x2b(%esp)
    fba2:	74 11                	je     fbb5 <get_dir+0xa8>
		inode = current->pwd;
    fba4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fba9:	8b 80 70 02 00 00    	mov    0x270(%eax),%eax
    fbaf:	89 44 24 20          	mov    %eax,0x20(%esp)
    fbb3:	eb 0d                	jmp    fbc2 <get_dir+0xb5>
	else
		return NULL;	/* empty name is bad */
    fbb5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fbbc:	00 
    fbbd:	e9 36 01 00 00       	jmp    fcf8 <get_dir+0x1eb>
	inode->i_count++;
    fbc2:	8b 44 24 20          	mov    0x20(%esp),%eax
    fbc6:	66 ff 40 30          	incw   0x30(%eax)
	while (1) {
		thisname = pathname;
    fbca:	8b 44 24 30          	mov    0x30(%esp),%eax
    fbce:	89 44 24 24          	mov    %eax,0x24(%esp)
		if (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {
    fbd2:	8b 44 24 20          	mov    0x20(%esp),%eax
    fbd6:	0f b7 00             	movzwl (%eax),%eax
    fbd9:	25 00 f0 00 00       	and    $0xf000,%eax
    fbde:	3d 00 40 00 00       	cmp    $0x4000,%eax
    fbe3:	75 12                	jne    fbf7 <get_dir+0xea>
    fbe5:	6a 01                	push   $0x1
    fbe7:	ff 74 24 24          	pushl  0x24(%esp)
    fbeb:	e8 7d f9 ff ff       	call   f56d <permission>
    fbf0:	83 c4 08             	add    $0x8,%esp
    fbf3:	85 c0                	test   %eax,%eax
    fbf5:	75 1c                	jne    fc13 <get_dir+0x106>
			iput(inode);
    fbf7:	83 ec 0c             	sub    $0xc,%esp
    fbfa:	ff 74 24 2c          	pushl  0x2c(%esp)
    fbfe:	e8 4a bc ff ff       	call   b84d <iput>
    fc03:	83 c4 10             	add    $0x10,%esp
			return NULL;
    fc06:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fc0d:	00 
    fc0e:	e9 e5 00 00 00       	jmp    fcf8 <get_dir+0x1eb>
		}
		for(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)
    fc13:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    fc1a:	00 
    fc1b:	8b 44 24 30          	mov    0x30(%esp),%eax
    fc1f:	50                   	push   %eax
    fc20:	ff 44 24 34          	incl   0x34(%esp)
    fc24:	e8 93 fc ff ff       	call   f8bc <get_fs_byte>
    fc29:	83 c4 04             	add    $0x4,%esp
    fc2c:	88 44 24 2b          	mov    %al,0x2b(%esp)
    fc30:	8a 44 24 2b          	mov    0x2b(%esp),%al
    fc34:	84 c0                	test   %al,%al
    fc36:	74 0f                	je     fc47 <get_dir+0x13a>
    fc38:	80 7c 24 2b 2f       	cmpb   $0x2f,0x2b(%esp)
    fc3d:	74 08                	je     fc47 <get_dir+0x13a>
    fc3f:	8d 44 24 18          	lea    0x18(%esp),%eax
    fc43:	ff 00                	incl   (%eax)
    fc45:	eb d4                	jmp    fc1b <get_dir+0x10e>
			/* nothing */ ;
		if (!c)
    fc47:	80 7c 24 2b 00       	cmpb   $0x0,0x2b(%esp)
    fc4c:	75 0d                	jne    fc5b <get_dir+0x14e>
			return inode;
    fc4e:	8b 44 24 20          	mov    0x20(%esp),%eax
    fc52:	89 44 24 08          	mov    %eax,0x8(%esp)
    fc56:	e9 9d 00 00 00       	jmp    fcf8 <get_dir+0x1eb>
		if (!(bh = find_entry(&inode,thisname,namelen,&de))) {
    fc5b:	8d 44 24 0c          	lea    0xc(%esp),%eax
    fc5f:	50                   	push   %eax
    fc60:	ff 74 24 1c          	pushl  0x1c(%esp)
    fc64:	ff 74 24 2c          	pushl  0x2c(%esp)
    fc68:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    fc6c:	50                   	push   %eax
    fc6d:	e8 09 fa ff ff       	call   f67b <find_entry>
    fc72:	83 c4 10             	add    $0x10,%esp
    fc75:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    fc79:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
    fc7e:	75 19                	jne    fc99 <get_dir+0x18c>
			iput(inode);
    fc80:	83 ec 0c             	sub    $0xc,%esp
    fc83:	ff 74 24 2c          	pushl  0x2c(%esp)
    fc87:	e8 c1 bb ff ff       	call   b84d <iput>
    fc8c:	83 c4 10             	add    $0x10,%esp
			return NULL;
    fc8f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fc96:	00 
    fc97:	eb 5f                	jmp    fcf8 <get_dir+0x1eb>
		}
		inr = de->inode;
    fc99:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fc9d:	0f b7 00             	movzwl (%eax),%eax
    fca0:	89 44 24 14          	mov    %eax,0x14(%esp)
		idev = inode->i_dev;
    fca4:	8b 44 24 20          	mov    0x20(%esp),%eax
    fca8:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    fcac:	89 44 24 10          	mov    %eax,0x10(%esp)
		brelse(bh);
    fcb0:	83 ec 0c             	sub    $0xc,%esp
    fcb3:	ff 74 24 28          	pushl  0x28(%esp)
    fcb7:	e8 fb c9 ff ff       	call   c6b7 <brelse>
    fcbc:	83 c4 10             	add    $0x10,%esp
		iput(inode);
    fcbf:	83 ec 0c             	sub    $0xc,%esp
    fcc2:	ff 74 24 2c          	pushl  0x2c(%esp)
    fcc6:	e8 82 bb ff ff       	call   b84d <iput>
    fccb:	83 c4 10             	add    $0x10,%esp
		if (!(inode = iget(idev,inr)))
    fcce:	83 ec 08             	sub    $0x8,%esp
    fcd1:	ff 74 24 1c          	pushl  0x1c(%esp)
    fcd5:	ff 74 24 1c          	pushl  0x1c(%esp)
    fcd9:	e8 ab be ff ff       	call   bb89 <iget>
    fcde:	83 c4 10             	add    $0x10,%esp
    fce1:	89 44 24 20          	mov    %eax,0x20(%esp)
    fce5:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
    fcea:	0f 85 da fe ff ff    	jne    fbca <get_dir+0xbd>
			return NULL;
    fcf0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fcf7:	00 
	}
}
    fcf8:	8b 44 24 08          	mov    0x8(%esp),%eax
    fcfc:	83 c4 2c             	add    $0x2c,%esp
    fcff:	c3                   	ret    

0000fd00 <dir_namei>:
 * dir_namei() returns the inode of the directory of the
 * specified name, and the name within that directory.
 */
static struct m_inode * dir_namei(const char * pathname,
	int * namelen, const char ** name)
{
    fd00:	83 ec 1c             	sub    $0x1c,%esp
	char c;
	const char * basename;
	struct m_inode * dir;

	if (!(dir = get_dir(pathname)))
    fd03:	83 ec 0c             	sub    $0xc,%esp
    fd06:	ff 74 24 2c          	pushl  0x2c(%esp)
    fd0a:	e8 fe fd ff ff       	call   fb0d <get_dir>
    fd0f:	83 c4 10             	add    $0x10,%esp
    fd12:	89 44 24 10          	mov    %eax,0x10(%esp)
    fd16:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    fd1b:	75 0a                	jne    fd27 <dir_namei+0x27>
		return NULL;
    fd1d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    fd24:	00 
    fd25:	eb 59                	jmp    fd80 <dir_namei+0x80>
	basename = pathname;
    fd27:	8b 44 24 20          	mov    0x20(%esp),%eax
    fd2b:	89 44 24 14          	mov    %eax,0x14(%esp)
	while ((c=get_fs_byte(pathname++)))
    fd2f:	8b 44 24 20          	mov    0x20(%esp),%eax
    fd33:	50                   	push   %eax
    fd34:	ff 44 24 24          	incl   0x24(%esp)
    fd38:	e8 7f fb ff ff       	call   f8bc <get_fs_byte>
    fd3d:	83 c4 04             	add    $0x4,%esp
    fd40:	88 44 24 1b          	mov    %al,0x1b(%esp)
    fd44:	8a 44 24 1b          	mov    0x1b(%esp),%al
    fd48:	84 c0                	test   %al,%al
    fd4a:	74 11                	je     fd5d <dir_namei+0x5d>
		if (c=='/')
    fd4c:	80 7c 24 1b 2f       	cmpb   $0x2f,0x1b(%esp)
    fd51:	75 dc                	jne    fd2f <dir_namei+0x2f>
			basename=pathname;
    fd53:	8b 44 24 20          	mov    0x20(%esp),%eax
    fd57:	89 44 24 14          	mov    %eax,0x14(%esp)
    fd5b:	eb d2                	jmp    fd2f <dir_namei+0x2f>
	*namelen = pathname-basename-1;
    fd5d:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    fd61:	8b 54 24 14          	mov    0x14(%esp),%edx
    fd65:	8b 44 24 20          	mov    0x20(%esp),%eax
    fd69:	29 d0                	sub    %edx,%eax
    fd6b:	48                   	dec    %eax
    fd6c:	89 01                	mov    %eax,(%ecx)
	*name = basename;
    fd6e:	8b 54 24 28          	mov    0x28(%esp),%edx
    fd72:	8b 44 24 14          	mov    0x14(%esp),%eax
    fd76:	89 02                	mov    %eax,(%edx)
	return dir;
    fd78:	8b 44 24 10          	mov    0x10(%esp),%eax
    fd7c:	89 44 24 0c          	mov    %eax,0xc(%esp)
}
    fd80:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fd84:	83 c4 1c             	add    $0x1c,%esp
    fd87:	c3                   	ret    

0000fd88 <namei>:
 * is used by most simple commands to get the inode of a specified name.
 * Open, link etc use their own routines, but this is enough for things
 * like 'chmod' etc.
 */
struct m_inode * namei(const char * pathname)
{
    fd88:	53                   	push   %ebx
    fd89:	83 ec 28             	sub    $0x28,%esp
	int inr,dev,namelen;
	struct m_inode * dir;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!(dir = dir_namei(pathname,&namelen,&basename)))
    fd8c:	83 ec 04             	sub    $0x4,%esp
    fd8f:	8d 44 24 28          	lea    0x28(%esp),%eax
    fd93:	50                   	push   %eax
    fd94:	8d 44 24 20          	lea    0x20(%esp),%eax
    fd98:	50                   	push   %eax
    fd99:	ff 74 24 3c          	pushl  0x3c(%esp)
    fd9d:	e8 5e ff ff ff       	call   fd00 <dir_namei>
    fda2:	83 c4 10             	add    $0x10,%esp
    fda5:	89 44 24 14          	mov    %eax,0x14(%esp)
    fda9:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    fdae:	75 0d                	jne    fdbd <namei+0x35>
		return NULL;
    fdb0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fdb7:	00 
    fdb8:	e9 de 00 00 00       	jmp    fe9b <namei+0x113>
	if (!namelen)			/* special case: '/usr/' etc */
    fdbd:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    fdc2:	75 0d                	jne    fdd1 <namei+0x49>
		return dir;
    fdc4:	8b 44 24 14          	mov    0x14(%esp),%eax
    fdc8:	89 44 24 08          	mov    %eax,0x8(%esp)
    fdcc:	e9 ca 00 00 00       	jmp    fe9b <namei+0x113>
	bh = find_entry(&dir,basename,namelen,&de);
    fdd1:	8d 44 24 0c          	lea    0xc(%esp),%eax
    fdd5:	50                   	push   %eax
    fdd6:	ff 74 24 1c          	pushl  0x1c(%esp)
    fdda:	ff 74 24 2c          	pushl  0x2c(%esp)
    fdde:	8d 44 24 20          	lea    0x20(%esp),%eax
    fde2:	50                   	push   %eax
    fde3:	e8 93 f8 ff ff       	call   f67b <find_entry>
    fde8:	83 c4 10             	add    $0x10,%esp
    fdeb:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!bh) {
    fdef:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    fdf4:	75 1c                	jne    fe12 <namei+0x8a>
		iput(dir);
    fdf6:	83 ec 0c             	sub    $0xc,%esp
    fdf9:	ff 74 24 20          	pushl  0x20(%esp)
    fdfd:	e8 4b ba ff ff       	call   b84d <iput>
    fe02:	83 c4 10             	add    $0x10,%esp
		return NULL;
    fe05:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fe0c:	00 
    fe0d:	e9 89 00 00 00       	jmp    fe9b <namei+0x113>
	}
	inr = de->inode;
    fe12:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fe16:	0f b7 00             	movzwl (%eax),%eax
    fe19:	89 44 24 20          	mov    %eax,0x20(%esp)
	dev = dir->i_dev;
    fe1d:	8b 44 24 14          	mov    0x14(%esp),%eax
    fe21:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    fe25:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	brelse(bh);
    fe29:	83 ec 0c             	sub    $0xc,%esp
    fe2c:	ff 74 24 1c          	pushl  0x1c(%esp)
    fe30:	e8 82 c8 ff ff       	call   c6b7 <brelse>
    fe35:	83 c4 10             	add    $0x10,%esp
	iput(dir);
    fe38:	83 ec 0c             	sub    $0xc,%esp
    fe3b:	ff 74 24 20          	pushl  0x20(%esp)
    fe3f:	e8 09 ba ff ff       	call   b84d <iput>
    fe44:	83 c4 10             	add    $0x10,%esp
	dir=iget(dev,inr);
    fe47:	83 ec 08             	sub    $0x8,%esp
    fe4a:	ff 74 24 28          	pushl  0x28(%esp)
    fe4e:	ff 74 24 28          	pushl  0x28(%esp)
    fe52:	e8 32 bd ff ff       	call   bb89 <iget>
    fe57:	83 c4 10             	add    $0x10,%esp
    fe5a:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (dir) {
    fe5e:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    fe63:	74 2e                	je     fe93 <namei+0x10b>
		dir->i_atime=CURRENT_TIME;
    fe65:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    fe69:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
    fe6f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
    fe74:	f7 e9                	imul   %ecx
    fe76:	c1 fa 05             	sar    $0x5,%edx
    fe79:	89 c8                	mov    %ecx,%eax
    fe7b:	c1 f8 1f             	sar    $0x1f,%eax
    fe7e:	29 c2                	sub    %eax,%edx
    fe80:	89 d0                	mov    %edx,%eax
    fe82:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
    fe88:	89 43 24             	mov    %eax,0x24(%ebx)
		dir->i_dirt=1;
    fe8b:	8b 44 24 14          	mov    0x14(%esp),%eax
    fe8f:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	}
	return dir;
    fe93:	8b 44 24 14          	mov    0x14(%esp),%eax
    fe97:	89 44 24 08          	mov    %eax,0x8(%esp)
}
    fe9b:	8b 44 24 08          	mov    0x8(%esp),%eax
    fe9f:	83 c4 28             	add    $0x28,%esp
    fea2:	5b                   	pop    %ebx
    fea3:	c3                   	ret    

0000fea4 <open_namei>:
 *
 * namei for open - this is in fact almost the whole open-routine.
 */
int open_namei(const char * pathname, int flag, int mode,
	struct m_inode ** res_inode)
{
    fea4:	53                   	push   %ebx
    fea5:	83 ec 28             	sub    $0x28,%esp
	int inr,dev,namelen;
	struct m_inode * dir, *inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))
    fea8:	8b 44 24 34          	mov    0x34(%esp),%eax
    feac:	25 00 02 00 00       	and    $0x200,%eax
    feb1:	85 c0                	test   %eax,%eax
    feb3:	74 12                	je     fec7 <open_namei+0x23>
    feb5:	8b 44 24 34          	mov    0x34(%esp),%eax
    feb9:	83 e0 03             	and    $0x3,%eax
    febc:	85 c0                	test   %eax,%eax
    febe:	75 07                	jne    fec7 <open_namei+0x23>
		flag |= O_WRONLY;
    fec0:	8d 44 24 34          	lea    0x34(%esp),%eax
    fec4:	83 08 01             	orl    $0x1,(%eax)
	mode &= 0777 & ~current->umask;
    fec7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
    fecc:	0f b7 80 6c 02 00 00 	movzwl 0x26c(%eax),%eax
    fed3:	f7 d0                	not    %eax
    fed5:	23 44 24 38          	and    0x38(%esp),%eax
    fed9:	25 ff 01 00 00       	and    $0x1ff,%eax
    fede:	89 44 24 38          	mov    %eax,0x38(%esp)
	mode |= I_REGULAR;
    fee2:	8d 44 24 38          	lea    0x38(%esp),%eax
    fee6:	81 08 00 80 00 00    	orl    $0x8000,(%eax)
	if (!(dir = dir_namei(pathname,&namelen,&basename)))
    feec:	83 ec 04             	sub    $0x4,%esp
    feef:	8d 44 24 28          	lea    0x28(%esp),%eax
    fef3:	50                   	push   %eax
    fef4:	8d 44 24 20          	lea    0x20(%esp),%eax
    fef8:	50                   	push   %eax
    fef9:	ff 74 24 3c          	pushl  0x3c(%esp)
    fefd:	e8 fe fd ff ff       	call   fd00 <dir_namei>
    ff02:	83 c4 10             	add    $0x10,%esp
    ff05:	89 44 24 14          	mov    %eax,0x14(%esp)
    ff09:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    ff0e:	75 0d                	jne    ff1d <open_namei+0x79>
		return -ENOENT;
    ff10:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    ff17:	ff 
    ff18:	e9 eb 02 00 00       	jmp    10208 <open_namei+0x364>
	if (!namelen) {			/* special case: '/usr/' etc */
    ff1d:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
    ff22:	75 40                	jne    ff64 <open_namei+0xc0>
		if (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {
    ff24:	8b 44 24 34          	mov    0x34(%esp),%eax
    ff28:	25 43 02 00 00       	and    $0x243,%eax
    ff2d:	85 c0                	test   %eax,%eax
    ff2f:	75 17                	jne    ff48 <open_namei+0xa4>
			*res_inode=dir;
    ff31:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    ff35:	8b 44 24 14          	mov    0x14(%esp),%eax
    ff39:	89 02                	mov    %eax,(%edx)
			return 0;
    ff3b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    ff42:	00 
    ff43:	e9 c0 02 00 00       	jmp    10208 <open_namei+0x364>
		}
		iput(dir);
    ff48:	83 ec 0c             	sub    $0xc,%esp
    ff4b:	ff 74 24 20          	pushl  0x20(%esp)
    ff4f:	e8 f9 b8 ff ff       	call   b84d <iput>
    ff54:	83 c4 10             	add    $0x10,%esp
		return -EISDIR;
    ff57:	c7 44 24 04 eb ff ff 	movl   $0xffffffeb,0x4(%esp)
    ff5e:	ff 
    ff5f:	e9 a4 02 00 00       	jmp    10208 <open_namei+0x364>
	}
	bh = find_entry(&dir,basename,namelen,&de);
    ff64:	8d 44 24 08          	lea    0x8(%esp),%eax
    ff68:	50                   	push   %eax
    ff69:	ff 74 24 1c          	pushl  0x1c(%esp)
    ff6d:	ff 74 24 2c          	pushl  0x2c(%esp)
    ff71:	8d 44 24 20          	lea    0x20(%esp),%eax
    ff75:	50                   	push   %eax
    ff76:	e8 00 f7 ff ff       	call   f67b <find_entry>
    ff7b:	83 c4 10             	add    $0x10,%esp
    ff7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!bh) {
    ff82:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    ff87:	0f 85 59 01 00 00    	jne    100e6 <open_namei+0x242>
		if (!(flag & O_CREAT)) {
    ff8d:	8b 44 24 34          	mov    0x34(%esp),%eax
    ff91:	83 e0 40             	and    $0x40,%eax
    ff94:	85 c0                	test   %eax,%eax
    ff96:	75 1c                	jne    ffb4 <open_namei+0x110>
			iput(dir);
    ff98:	83 ec 0c             	sub    $0xc,%esp
    ff9b:	ff 74 24 20          	pushl  0x20(%esp)
    ff9f:	e8 a9 b8 ff ff       	call   b84d <iput>
    ffa4:	83 c4 10             	add    $0x10,%esp
			return -ENOENT;
    ffa7:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
    ffae:	ff 
    ffaf:	e9 54 02 00 00       	jmp    10208 <open_namei+0x364>
		}
		if (!permission(dir,MAY_WRITE)) {
    ffb4:	6a 02                	push   $0x2
    ffb6:	ff 74 24 18          	pushl  0x18(%esp)
    ffba:	e8 ae f5 ff ff       	call   f56d <permission>
    ffbf:	83 c4 08             	add    $0x8,%esp
    ffc2:	85 c0                	test   %eax,%eax
    ffc4:	75 1c                	jne    ffe2 <open_namei+0x13e>
			iput(dir);
    ffc6:	83 ec 0c             	sub    $0xc,%esp
    ffc9:	ff 74 24 20          	pushl  0x20(%esp)
    ffcd:	e8 7b b8 ff ff       	call   b84d <iput>
    ffd2:	83 c4 10             	add    $0x10,%esp
			return -EACCES;
    ffd5:	c7 44 24 04 f3 ff ff 	movl   $0xfffffff3,0x4(%esp)
    ffdc:	ff 
    ffdd:	e9 26 02 00 00       	jmp    10208 <open_namei+0x364>
		}
		inode = new_inode(dir->i_dev);
    ffe2:	83 ec 0c             	sub    $0xc,%esp
    ffe5:	8b 44 24 20          	mov    0x20(%esp),%eax
    ffe9:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
    ffed:	50                   	push   %eax
    ffee:	e8 eb 17 00 00       	call   117de <new_inode>
    fff3:	83 c4 10             	add    $0x10,%esp
    fff6:	89 44 24 10          	mov    %eax,0x10(%esp)
		if (!inode) {
    fffa:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    ffff:	75 1c                	jne    1001d <open_namei+0x179>
			iput(dir);
   10001:	83 ec 0c             	sub    $0xc,%esp
   10004:	ff 74 24 20          	pushl  0x20(%esp)
   10008:	e8 40 b8 ff ff       	call   b84d <iput>
   1000d:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
   10010:	c7 44 24 04 e4 ff ff 	movl   $0xffffffe4,0x4(%esp)
   10017:	ff 
   10018:	e9 eb 01 00 00       	jmp    10208 <open_namei+0x364>
		}
		inode->i_uid = current->euid;
   1001d:	8b 54 24 10          	mov    0x10(%esp),%edx
   10021:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10026:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
   1002d:	66 89 42 02          	mov    %ax,0x2(%edx)
		inode->i_mode = mode;
   10031:	8b 54 24 10          	mov    0x10(%esp),%edx
   10035:	8b 44 24 38          	mov    0x38(%esp),%eax
   10039:	66 89 02             	mov    %ax,(%edx)
		inode->i_dirt = 1;
   1003c:	8b 44 24 10          	mov    0x10(%esp),%eax
   10040:	c6 40 33 01          	movb   $0x1,0x33(%eax)
		bh = add_entry(dir,basename,namelen,&de);
   10044:	8d 44 24 08          	lea    0x8(%esp),%eax
   10048:	50                   	push   %eax
   10049:	ff 74 24 1c          	pushl  0x1c(%esp)
   1004d:	ff 74 24 2c          	pushl  0x2c(%esp)
   10051:	ff 74 24 20          	pushl  0x20(%esp)
   10055:	e8 6d f8 ff ff       	call   f8c7 <add_entry>
   1005a:	83 c4 10             	add    $0x10,%esp
   1005d:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (!bh) {
   10061:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   10066:	75 32                	jne    1009a <open_namei+0x1f6>
			inode->i_nlinks--;
   10068:	8b 44 24 10          	mov    0x10(%esp),%eax
   1006c:	fe 48 0d             	decb   0xd(%eax)
			iput(inode);
   1006f:	83 ec 0c             	sub    $0xc,%esp
   10072:	ff 74 24 1c          	pushl  0x1c(%esp)
   10076:	e8 d2 b7 ff ff       	call   b84d <iput>
   1007b:	83 c4 10             	add    $0x10,%esp
			iput(dir);
   1007e:	83 ec 0c             	sub    $0xc,%esp
   10081:	ff 74 24 20          	pushl  0x20(%esp)
   10085:	e8 c3 b7 ff ff       	call   b84d <iput>
   1008a:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
   1008d:	c7 44 24 04 e4 ff ff 	movl   $0xffffffe4,0x4(%esp)
   10094:	ff 
   10095:	e9 6e 01 00 00       	jmp    10208 <open_namei+0x364>
		}
		de->inode = inode->i_num;
   1009a:	8b 54 24 08          	mov    0x8(%esp),%edx
   1009e:	8b 44 24 10          	mov    0x10(%esp),%eax
   100a2:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   100a6:	66 89 02             	mov    %ax,(%edx)
		bh->b_dirt = 1;
   100a9:	8b 44 24 0c          	mov    0xc(%esp),%eax
   100ad:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
   100b1:	83 ec 0c             	sub    $0xc,%esp
   100b4:	ff 74 24 18          	pushl  0x18(%esp)
   100b8:	e8 fa c5 ff ff       	call   c6b7 <brelse>
   100bd:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   100c0:	83 ec 0c             	sub    $0xc,%esp
   100c3:	ff 74 24 20          	pushl  0x20(%esp)
   100c7:	e8 81 b7 ff ff       	call   b84d <iput>
   100cc:	83 c4 10             	add    $0x10,%esp
		*res_inode = inode;
   100cf:	8b 54 24 3c          	mov    0x3c(%esp),%edx
   100d3:	8b 44 24 10          	mov    0x10(%esp),%eax
   100d7:	89 02                	mov    %eax,(%edx)
		return 0;
   100d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   100e0:	00 
   100e1:	e9 22 01 00 00       	jmp    10208 <open_namei+0x364>
	}
	inr = de->inode;
   100e6:	8b 44 24 08          	mov    0x8(%esp),%eax
   100ea:	0f b7 00             	movzwl (%eax),%eax
   100ed:	89 44 24 20          	mov    %eax,0x20(%esp)
	dev = dir->i_dev;
   100f1:	8b 44 24 14          	mov    0x14(%esp),%eax
   100f5:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   100f9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	brelse(bh);
   100fd:	83 ec 0c             	sub    $0xc,%esp
   10100:	ff 74 24 18          	pushl  0x18(%esp)
   10104:	e8 ae c5 ff ff       	call   c6b7 <brelse>
   10109:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   1010c:	83 ec 0c             	sub    $0xc,%esp
   1010f:	ff 74 24 20          	pushl  0x20(%esp)
   10113:	e8 35 b7 ff ff       	call   b84d <iput>
   10118:	83 c4 10             	add    $0x10,%esp
	if (flag & O_EXCL)
   1011b:	8b 44 24 34          	mov    0x34(%esp),%eax
   1011f:	83 e0 80             	and    $0xffffff80,%eax
   10122:	84 c0                	test   %al,%al
   10124:	74 0d                	je     10133 <open_namei+0x28f>
		return -EEXIST;
   10126:	c7 44 24 04 ef ff ff 	movl   $0xffffffef,0x4(%esp)
   1012d:	ff 
   1012e:	e9 d5 00 00 00       	jmp    10208 <open_namei+0x364>
	if (!(inode=iget(dev,inr)))
   10133:	83 ec 08             	sub    $0x8,%esp
   10136:	ff 74 24 28          	pushl  0x28(%esp)
   1013a:	ff 74 24 28          	pushl  0x28(%esp)
   1013e:	e8 46 ba ff ff       	call   bb89 <iget>
   10143:	83 c4 10             	add    $0x10,%esp
   10146:	89 44 24 10          	mov    %eax,0x10(%esp)
   1014a:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1014f:	75 0d                	jne    1015e <open_namei+0x2ba>
		return -EACCES;
   10151:	c7 44 24 04 f3 ff ff 	movl   $0xfffffff3,0x4(%esp)
   10158:	ff 
   10159:	e9 aa 00 00 00       	jmp    10208 <open_namei+0x364>
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
   1015e:	8b 44 24 10          	mov    0x10(%esp),%eax
   10162:	0f b7 00             	movzwl (%eax),%eax
   10165:	25 00 f0 00 00       	and    $0xf000,%eax
   1016a:	3d 00 40 00 00       	cmp    $0x4000,%eax
   1016f:	75 0b                	jne    1017c <open_namei+0x2d8>
   10171:	8b 44 24 34          	mov    0x34(%esp),%eax
   10175:	83 e0 03             	and    $0x3,%eax
   10178:	85 c0                	test   %eax,%eax
   1017a:	75 1f                	jne    1019b <open_namei+0x2f7>
   1017c:	8b 44 24 34          	mov    0x34(%esp),%eax
   10180:	83 e0 03             	and    $0x3,%eax
   10183:	0f be 80 37 90 01 00 	movsbl 0x19037(%eax),%eax
   1018a:	50                   	push   %eax
   1018b:	ff 74 24 14          	pushl  0x14(%esp)
   1018f:	e8 d9 f3 ff ff       	call   f56d <permission>
   10194:	83 c4 08             	add    $0x8,%esp
   10197:	85 c0                	test   %eax,%eax
   10199:	75 19                	jne    101b4 <open_namei+0x310>
	    !permission(inode,ACC_MODE(flag))) {
		iput(inode);
   1019b:	83 ec 0c             	sub    $0xc,%esp
   1019e:	ff 74 24 1c          	pushl  0x1c(%esp)
   101a2:	e8 a6 b6 ff ff       	call   b84d <iput>
   101a7:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   101aa:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
   101b1:	ff 
   101b2:	eb 54                	jmp    10208 <open_namei+0x364>
	}
	inode->i_atime = CURRENT_TIME;
   101b4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   101b8:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   101be:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   101c3:	f7 e9                	imul   %ecx
   101c5:	c1 fa 05             	sar    $0x5,%edx
   101c8:	89 c8                	mov    %ecx,%eax
   101ca:	c1 f8 1f             	sar    $0x1f,%eax
   101cd:	29 c2                	sub    %eax,%edx
   101cf:	89 d0                	mov    %edx,%eax
   101d1:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   101d7:	89 43 24             	mov    %eax,0x24(%ebx)
	if (flag & O_TRUNC)
   101da:	8b 44 24 34          	mov    0x34(%esp),%eax
   101de:	25 00 02 00 00       	and    $0x200,%eax
   101e3:	85 c0                	test   %eax,%eax
   101e5:	74 0f                	je     101f6 <open_namei+0x352>
		truncate(inode);
   101e7:	83 ec 0c             	sub    $0xc,%esp
   101ea:	ff 74 24 1c          	pushl  0x1c(%esp)
   101ee:	e8 19 1c 00 00       	call   11e0c <truncate>
   101f3:	83 c4 10             	add    $0x10,%esp
	*res_inode = inode;
   101f6:	8b 54 24 3c          	mov    0x3c(%esp),%edx
   101fa:	8b 44 24 10          	mov    0x10(%esp),%eax
   101fe:	89 02                	mov    %eax,(%edx)
	return 0;
   10200:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   10207:	00 
}
   10208:	8b 44 24 04          	mov    0x4(%esp),%eax
   1020c:	83 c4 28             	add    $0x28,%esp
   1020f:	5b                   	pop    %ebx
   10210:	c3                   	ret    

00010211 <sys_mknod>:

int sys_mknod(const char * filename, int mode, int dev)
{
   10211:	56                   	push   %esi
   10212:	53                   	push   %ebx
   10213:	83 ec 24             	sub    $0x24,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh;
	struct dir_entry * de;
	
	if (!suser())
   10216:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   1021b:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
   10222:	00 
   10223:	74 0d                	je     10232 <sys_mknod+0x21>
		return -EPERM;
   10225:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   1022c:	ff 
   1022d:	e9 1e 02 00 00       	jmp    10450 <sys_mknod+0x23f>
	if (!(dir = dir_namei(filename,&namelen,&basename)))
   10232:	83 ec 04             	sub    $0x4,%esp
   10235:	8d 44 24 24          	lea    0x24(%esp),%eax
   10239:	50                   	push   %eax
   1023a:	8d 44 24 24          	lea    0x24(%esp),%eax
   1023e:	50                   	push   %eax
   1023f:	ff 74 24 3c          	pushl  0x3c(%esp)
   10243:	e8 b8 fa ff ff       	call   fd00 <dir_namei>
   10248:	83 c4 10             	add    $0x10,%esp
   1024b:	89 44 24 18          	mov    %eax,0x18(%esp)
   1024f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10254:	75 0d                	jne    10263 <sys_mknod+0x52>
		return -ENOENT;
   10256:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
   1025d:	ff 
   1025e:	e9 ed 01 00 00       	jmp    10450 <sys_mknod+0x23f>
	if (!namelen) {
   10263:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10268:	75 1c                	jne    10286 <sys_mknod+0x75>
		iput(dir);
   1026a:	83 ec 0c             	sub    $0xc,%esp
   1026d:	ff 74 24 24          	pushl  0x24(%esp)
   10271:	e8 d7 b5 ff ff       	call   b84d <iput>
   10276:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10279:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
   10280:	ff 
   10281:	e9 ca 01 00 00       	jmp    10450 <sys_mknod+0x23f>
	}
	if (!permission(dir,MAY_WRITE)) {
   10286:	6a 02                	push   $0x2
   10288:	ff 74 24 1c          	pushl  0x1c(%esp)
   1028c:	e8 dc f2 ff ff       	call   f56d <permission>
   10291:	83 c4 08             	add    $0x8,%esp
   10294:	85 c0                	test   %eax,%eax
   10296:	75 1c                	jne    102b4 <sys_mknod+0xa3>
		iput(dir);
   10298:	83 ec 0c             	sub    $0xc,%esp
   1029b:	ff 74 24 24          	pushl  0x24(%esp)
   1029f:	e8 a9 b5 ff ff       	call   b84d <iput>
   102a4:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   102a7:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   102ae:	ff 
   102af:	e9 9c 01 00 00       	jmp    10450 <sys_mknod+0x23f>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   102b4:	8d 44 24 0c          	lea    0xc(%esp),%eax
   102b8:	50                   	push   %eax
   102b9:	ff 74 24 20          	pushl  0x20(%esp)
   102bd:	ff 74 24 28          	pushl  0x28(%esp)
   102c1:	8d 44 24 24          	lea    0x24(%esp),%eax
   102c5:	50                   	push   %eax
   102c6:	e8 b0 f3 ff ff       	call   f67b <find_entry>
   102cb:	83 c4 10             	add    $0x10,%esp
   102ce:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (bh) {
   102d2:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   102d7:	74 2b                	je     10304 <sys_mknod+0xf3>
		brelse(bh);
   102d9:	83 ec 0c             	sub    $0xc,%esp
   102dc:	ff 74 24 1c          	pushl  0x1c(%esp)
   102e0:	e8 d2 c3 ff ff       	call   c6b7 <brelse>
   102e5:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   102e8:	83 ec 0c             	sub    $0xc,%esp
   102eb:	ff 74 24 24          	pushl  0x24(%esp)
   102ef:	e8 59 b5 ff ff       	call   b84d <iput>
   102f4:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   102f7:	c7 44 24 08 ef ff ff 	movl   $0xffffffef,0x8(%esp)
   102fe:	ff 
   102ff:	e9 4c 01 00 00       	jmp    10450 <sys_mknod+0x23f>
	}
	inode = new_inode(dir->i_dev);
   10304:	83 ec 0c             	sub    $0xc,%esp
   10307:	8b 44 24 24          	mov    0x24(%esp),%eax
   1030b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1030f:	50                   	push   %eax
   10310:	e8 c9 14 00 00       	call   117de <new_inode>
   10315:	83 c4 10             	add    $0x10,%esp
   10318:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (!inode) {
   1031c:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   10321:	75 1c                	jne    1033f <sys_mknod+0x12e>
		iput(dir);
   10323:	83 ec 0c             	sub    $0xc,%esp
   10326:	ff 74 24 24          	pushl  0x24(%esp)
   1032a:	e8 1e b5 ff ff       	call   b84d <iput>
   1032f:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   10332:	c7 44 24 08 e4 ff ff 	movl   $0xffffffe4,0x8(%esp)
   10339:	ff 
   1033a:	e9 11 01 00 00       	jmp    10450 <sys_mknod+0x23f>
	}
	inode->i_mode = mode;
   1033f:	8b 44 24 14          	mov    0x14(%esp),%eax
   10343:	8b 54 24 34          	mov    0x34(%esp),%edx
   10347:	66 89 10             	mov    %dx,(%eax)
	if (S_ISBLK(mode) || S_ISCHR(mode))
   1034a:	8b 44 24 34          	mov    0x34(%esp),%eax
   1034e:	25 00 f0 00 00       	and    $0xf000,%eax
   10353:	3d 00 60 00 00       	cmp    $0x6000,%eax
   10358:	74 12                	je     1036c <sys_mknod+0x15b>
   1035a:	8b 44 24 34          	mov    0x34(%esp),%eax
   1035e:	25 00 f0 00 00       	and    $0xf000,%eax
   10363:	3d 00 20 00 00       	cmp    $0x2000,%eax
   10368:	74 02                	je     1036c <sys_mknod+0x15b>
   1036a:	eb 0c                	jmp    10378 <sys_mknod+0x167>
		inode->i_zone[0] = dev;
   1036c:	8b 54 24 14          	mov    0x14(%esp),%edx
   10370:	8b 44 24 38          	mov    0x38(%esp),%eax
   10374:	66 89 42 0e          	mov    %ax,0xe(%edx)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
   10378:	8b 74 24 14          	mov    0x14(%esp),%esi
   1037c:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   10380:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   10386:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   1038b:	f7 e9                	imul   %ecx
   1038d:	c1 fa 05             	sar    $0x5,%edx
   10390:	89 c8                	mov    %ecx,%eax
   10392:	c1 f8 1f             	sar    $0x1f,%eax
   10395:	29 c2                	sub    %eax,%edx
   10397:	89 d0                	mov    %edx,%eax
   10399:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   1039f:	89 43 24             	mov    %eax,0x24(%ebx)
   103a2:	8b 43 24             	mov    0x24(%ebx),%eax
   103a5:	89 46 08             	mov    %eax,0x8(%esi)
	inode->i_dirt = 1;
   103a8:	8b 44 24 14          	mov    0x14(%esp),%eax
   103ac:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	bh = add_entry(dir,basename,namelen,&de);
   103b0:	8d 44 24 0c          	lea    0xc(%esp),%eax
   103b4:	50                   	push   %eax
   103b5:	ff 74 24 20          	pushl  0x20(%esp)
   103b9:	ff 74 24 28          	pushl  0x28(%esp)
   103bd:	ff 74 24 24          	pushl  0x24(%esp)
   103c1:	e8 01 f5 ff ff       	call   f8c7 <add_entry>
   103c6:	83 c4 10             	add    $0x10,%esp
   103c9:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!bh) {
   103cd:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   103d2:	75 30                	jne    10404 <sys_mknod+0x1f3>
		iput(dir);
   103d4:	83 ec 0c             	sub    $0xc,%esp
   103d7:	ff 74 24 24          	pushl  0x24(%esp)
   103db:	e8 6d b4 ff ff       	call   b84d <iput>
   103e0:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks=0;
   103e3:	8b 44 24 14          	mov    0x14(%esp),%eax
   103e7:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		iput(inode);
   103eb:	83 ec 0c             	sub    $0xc,%esp
   103ee:	ff 74 24 20          	pushl  0x20(%esp)
   103f2:	e8 56 b4 ff ff       	call   b84d <iput>
   103f7:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   103fa:	c7 44 24 08 e4 ff ff 	movl   $0xffffffe4,0x8(%esp)
   10401:	ff 
   10402:	eb 4c                	jmp    10450 <sys_mknod+0x23f>
	}
	de->inode = inode->i_num;
   10404:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10408:	8b 44 24 14          	mov    0x14(%esp),%eax
   1040c:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   10410:	66 89 02             	mov    %ax,(%edx)
	bh->b_dirt = 1;
   10413:	8b 44 24 10          	mov    0x10(%esp),%eax
   10417:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	iput(dir);
   1041b:	83 ec 0c             	sub    $0xc,%esp
   1041e:	ff 74 24 24          	pushl  0x24(%esp)
   10422:	e8 26 b4 ff ff       	call   b84d <iput>
   10427:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   1042a:	83 ec 0c             	sub    $0xc,%esp
   1042d:	ff 74 24 20          	pushl  0x20(%esp)
   10431:	e8 17 b4 ff ff       	call   b84d <iput>
   10436:	83 c4 10             	add    $0x10,%esp
	brelse(bh);
   10439:	83 ec 0c             	sub    $0xc,%esp
   1043c:	ff 74 24 1c          	pushl  0x1c(%esp)
   10440:	e8 72 c2 ff ff       	call   c6b7 <brelse>
   10445:	83 c4 10             	add    $0x10,%esp
	return 0;
   10448:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   1044f:	00 
}
   10450:	8b 44 24 08          	mov    0x8(%esp),%eax
   10454:	83 c4 24             	add    $0x24,%esp
   10457:	5b                   	pop    %ebx
   10458:	5e                   	pop    %esi
   10459:	c3                   	ret    

0001045a <sys_mkdir>:

int sys_mkdir(const char * pathname, int mode)
{
   1045a:	56                   	push   %esi
   1045b:	53                   	push   %ebx
   1045c:	83 ec 24             	sub    $0x24,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh, *dir_block;
	struct dir_entry * de;

	if (!suser())
   1045f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10464:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
   1046b:	00 
   1046c:	74 0d                	je     1047b <sys_mkdir+0x21>
		return -EPERM;
   1046e:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
   10475:	ff 
   10476:	e9 9d 03 00 00       	jmp    10818 <sys_mkdir+0x3be>
	if (!(dir = dir_namei(pathname,&namelen,&basename)))
   1047b:	83 ec 04             	sub    $0x4,%esp
   1047e:	8d 44 24 24          	lea    0x24(%esp),%eax
   10482:	50                   	push   %eax
   10483:	8d 44 24 24          	lea    0x24(%esp),%eax
   10487:	50                   	push   %eax
   10488:	ff 74 24 3c          	pushl  0x3c(%esp)
   1048c:	e8 6f f8 ff ff       	call   fd00 <dir_namei>
   10491:	83 c4 10             	add    $0x10,%esp
   10494:	89 44 24 18          	mov    %eax,0x18(%esp)
   10498:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1049d:	75 0d                	jne    104ac <sys_mkdir+0x52>
		return -ENOENT;
   1049f:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
   104a6:	ff 
   104a7:	e9 6c 03 00 00       	jmp    10818 <sys_mkdir+0x3be>
	if (!namelen) {
   104ac:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   104b1:	75 1c                	jne    104cf <sys_mkdir+0x75>
		iput(dir);
   104b3:	83 ec 0c             	sub    $0xc,%esp
   104b6:	ff 74 24 24          	pushl  0x24(%esp)
   104ba:	e8 8e b3 ff ff       	call   b84d <iput>
   104bf:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   104c2:	c7 44 24 04 fe ff ff 	movl   $0xfffffffe,0x4(%esp)
   104c9:	ff 
   104ca:	e9 49 03 00 00       	jmp    10818 <sys_mkdir+0x3be>
	}
	if (!permission(dir,MAY_WRITE)) {
   104cf:	6a 02                	push   $0x2
   104d1:	ff 74 24 1c          	pushl  0x1c(%esp)
   104d5:	e8 93 f0 ff ff       	call   f56d <permission>
   104da:	83 c4 08             	add    $0x8,%esp
   104dd:	85 c0                	test   %eax,%eax
   104df:	75 1c                	jne    104fd <sys_mkdir+0xa3>
		iput(dir);
   104e1:	83 ec 0c             	sub    $0xc,%esp
   104e4:	ff 74 24 24          	pushl  0x24(%esp)
   104e8:	e8 60 b3 ff ff       	call   b84d <iput>
   104ed:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   104f0:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
   104f7:	ff 
   104f8:	e9 1b 03 00 00       	jmp    10818 <sys_mkdir+0x3be>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   104fd:	8d 44 24 08          	lea    0x8(%esp),%eax
   10501:	50                   	push   %eax
   10502:	ff 74 24 20          	pushl  0x20(%esp)
   10506:	ff 74 24 28          	pushl  0x28(%esp)
   1050a:	8d 44 24 24          	lea    0x24(%esp),%eax
   1050e:	50                   	push   %eax
   1050f:	e8 67 f1 ff ff       	call   f67b <find_entry>
   10514:	83 c4 10             	add    $0x10,%esp
   10517:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (bh) {
   1051b:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   10520:	74 2b                	je     1054d <sys_mkdir+0xf3>
		brelse(bh);
   10522:	83 ec 0c             	sub    $0xc,%esp
   10525:	ff 74 24 1c          	pushl  0x1c(%esp)
   10529:	e8 89 c1 ff ff       	call   c6b7 <brelse>
   1052e:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10531:	83 ec 0c             	sub    $0xc,%esp
   10534:	ff 74 24 24          	pushl  0x24(%esp)
   10538:	e8 10 b3 ff ff       	call   b84d <iput>
   1053d:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   10540:	c7 44 24 04 ef ff ff 	movl   $0xffffffef,0x4(%esp)
   10547:	ff 
   10548:	e9 cb 02 00 00       	jmp    10818 <sys_mkdir+0x3be>
	}
	inode = new_inode(dir->i_dev);
   1054d:	83 ec 0c             	sub    $0xc,%esp
   10550:	8b 44 24 24          	mov    0x24(%esp),%eax
   10554:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10558:	50                   	push   %eax
   10559:	e8 80 12 00 00       	call   117de <new_inode>
   1055e:	83 c4 10             	add    $0x10,%esp
   10561:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (!inode) {
   10565:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1056a:	75 1c                	jne    10588 <sys_mkdir+0x12e>
		iput(dir);
   1056c:	83 ec 0c             	sub    $0xc,%esp
   1056f:	ff 74 24 24          	pushl  0x24(%esp)
   10573:	e8 d5 b2 ff ff       	call   b84d <iput>
   10578:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   1057b:	c7 44 24 04 e4 ff ff 	movl   $0xffffffe4,0x4(%esp)
   10582:	ff 
   10583:	e9 90 02 00 00       	jmp    10818 <sys_mkdir+0x3be>
	}
	inode->i_size = 32;
   10588:	8b 44 24 14          	mov    0x14(%esp),%eax
   1058c:	c7 40 04 20 00 00 00 	movl   $0x20,0x4(%eax)
	inode->i_dirt = 1;
   10593:	8b 44 24 14          	mov    0x14(%esp),%eax
   10597:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
   1059b:	8b 74 24 14          	mov    0x14(%esp),%esi
   1059f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   105a3:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   105a9:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   105ae:	f7 e9                	imul   %ecx
   105b0:	c1 fa 05             	sar    $0x5,%edx
   105b3:	89 c8                	mov    %ecx,%eax
   105b5:	c1 f8 1f             	sar    $0x1f,%eax
   105b8:	29 c2                	sub    %eax,%edx
   105ba:	89 d0                	mov    %edx,%eax
   105bc:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   105c2:	89 43 24             	mov    %eax,0x24(%ebx)
   105c5:	8b 43 24             	mov    0x24(%ebx),%eax
   105c8:	89 46 08             	mov    %eax,0x8(%esi)
	if (!(inode->i_zone[0]=new_block(inode->i_dev))) {
   105cb:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   105cf:	83 ec 0c             	sub    $0xc,%esp
   105d2:	8b 44 24 20          	mov    0x20(%esp),%eax
   105d6:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   105da:	50                   	push   %eax
   105db:	e8 9a 0e 00 00       	call   1147a <new_block>
   105e0:	83 c4 10             	add    $0x10,%esp
   105e3:	66 89 43 0e          	mov    %ax,0xe(%ebx)
   105e7:	66 8b 43 0e          	mov    0xe(%ebx),%ax
   105eb:	66 85 c0             	test   %ax,%ax
   105ee:	75 32                	jne    10622 <sys_mkdir+0x1c8>
		iput(dir);
   105f0:	83 ec 0c             	sub    $0xc,%esp
   105f3:	ff 74 24 24          	pushl  0x24(%esp)
   105f7:	e8 51 b2 ff ff       	call   b84d <iput>
   105fc:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   105ff:	8b 44 24 14          	mov    0x14(%esp),%eax
   10603:	fe 48 0d             	decb   0xd(%eax)
		iput(inode);
   10606:	83 ec 0c             	sub    $0xc,%esp
   10609:	ff 74 24 20          	pushl  0x20(%esp)
   1060d:	e8 3b b2 ff ff       	call   b84d <iput>
   10612:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   10615:	c7 44 24 04 e4 ff ff 	movl   $0xffffffe4,0x4(%esp)
   1061c:	ff 
   1061d:	e9 f6 01 00 00       	jmp    10818 <sys_mkdir+0x3be>
	}
	inode->i_dirt = 1;
   10622:	8b 44 24 14          	mov    0x14(%esp),%eax
   10626:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	if (!(dir_block=bread(inode->i_dev,inode->i_zone[0]))) {
   1062a:	83 ec 08             	sub    $0x8,%esp
   1062d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10631:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   10635:	50                   	push   %eax
   10636:	8b 44 24 20          	mov    0x20(%esp),%eax
   1063a:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1063e:	50                   	push   %eax
   1063f:	e8 bf c0 ff ff       	call   c703 <bread>
   10644:	83 c4 10             	add    $0x10,%esp
   10647:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1064b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   10650:	75 4f                	jne    106a1 <sys_mkdir+0x247>
		iput(dir);
   10652:	83 ec 0c             	sub    $0xc,%esp
   10655:	ff 74 24 24          	pushl  0x24(%esp)
   10659:	e8 ef b1 ff ff       	call   b84d <iput>
   1065e:	83 c4 10             	add    $0x10,%esp
		free_block(inode->i_dev,inode->i_zone[0]);
   10661:	83 ec 08             	sub    $0x8,%esp
   10664:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10668:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1066c:	50                   	push   %eax
   1066d:	8b 44 24 20          	mov    0x20(%esp),%eax
   10671:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10675:	50                   	push   %eax
   10676:	e8 59 0c 00 00       	call   112d4 <free_block>
   1067b:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks--;
   1067e:	8b 44 24 14          	mov    0x14(%esp),%eax
   10682:	fe 48 0d             	decb   0xd(%eax)
		iput(inode);
   10685:	83 ec 0c             	sub    $0xc,%esp
   10688:	ff 74 24 20          	pushl  0x20(%esp)
   1068c:	e8 bc b1 ff ff       	call   b84d <iput>
   10691:	83 c4 10             	add    $0x10,%esp
		return -ERROR;
   10694:	c7 44 24 04 9d ff ff 	movl   $0xffffff9d,0x4(%esp)
   1069b:	ff 
   1069c:	e9 77 01 00 00       	jmp    10818 <sys_mkdir+0x3be>
	}
	de = (struct dir_entry *) dir_block->b_data;
   106a1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   106a5:	8b 00                	mov    (%eax),%eax
   106a7:	89 44 24 08          	mov    %eax,0x8(%esp)
	de->inode=inode->i_num;
   106ab:	8b 54 24 08          	mov    0x8(%esp),%edx
   106af:	8b 44 24 14          	mov    0x14(%esp),%eax
   106b3:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   106b7:	66 89 02             	mov    %ax,(%edx)
	strcpy(de->name,".");
   106ba:	83 ec 08             	sub    $0x8,%esp
   106bd:	68 3c 90 01 00       	push   $0x1903c
   106c2:	8b 44 24 14          	mov    0x14(%esp),%eax
   106c6:	83 c0 02             	add    $0x2,%eax
   106c9:	50                   	push   %eax
   106ca:	e8 41 7d 00 00       	call   18410 <strcpy>
   106cf:	83 c4 10             	add    $0x10,%esp
	de++;
   106d2:	8d 44 24 08          	lea    0x8(%esp),%eax
   106d6:	83 00 10             	addl   $0x10,(%eax)
	de->inode = dir->i_num;
   106d9:	8b 54 24 08          	mov    0x8(%esp),%edx
   106dd:	8b 44 24 18          	mov    0x18(%esp),%eax
   106e1:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   106e5:	66 89 02             	mov    %ax,(%edx)
	strcpy(de->name,"..");
   106e8:	83 ec 08             	sub    $0x8,%esp
   106eb:	68 3e 90 01 00       	push   $0x1903e
   106f0:	8b 44 24 14          	mov    0x14(%esp),%eax
   106f4:	83 c0 02             	add    $0x2,%eax
   106f7:	50                   	push   %eax
   106f8:	e8 13 7d 00 00       	call   18410 <strcpy>
   106fd:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks = 2;
   10700:	8b 44 24 14          	mov    0x14(%esp),%eax
   10704:	c6 40 0d 02          	movb   $0x2,0xd(%eax)
	dir_block->b_dirt = 1;
   10708:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1070c:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(dir_block);
   10710:	83 ec 0c             	sub    $0xc,%esp
   10713:	ff 74 24 18          	pushl  0x18(%esp)
   10717:	e8 9b bf ff ff       	call   c6b7 <brelse>
   1071c:	83 c4 10             	add    $0x10,%esp
	inode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);
   1071f:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   10723:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10728:	66 8b 80 6c 02 00 00 	mov    0x26c(%eax),%ax
   1072f:	89 c2                	mov    %eax,%edx
   10731:	f7 d2                	not    %edx
   10733:	8b 44 24 34          	mov    0x34(%esp),%eax
   10737:	21 d0                	and    %edx,%eax
   10739:	25 ff 01 00 00       	and    $0x1ff,%eax
   1073e:	80 cc 40             	or     $0x40,%ah
   10741:	66 89 01             	mov    %ax,(%ecx)
	inode->i_dirt = 1;
   10744:	8b 44 24 14          	mov    0x14(%esp),%eax
   10748:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	bh = add_entry(dir,basename,namelen,&de);
   1074c:	8d 44 24 08          	lea    0x8(%esp),%eax
   10750:	50                   	push   %eax
   10751:	ff 74 24 20          	pushl  0x20(%esp)
   10755:	ff 74 24 28          	pushl  0x28(%esp)
   10759:	ff 74 24 24          	pushl  0x24(%esp)
   1075d:	e8 65 f1 ff ff       	call   f8c7 <add_entry>
   10762:	83 c4 10             	add    $0x10,%esp
   10765:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!bh) {
   10769:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1076e:	75 4d                	jne    107bd <sys_mkdir+0x363>
		iput(dir);
   10770:	83 ec 0c             	sub    $0xc,%esp
   10773:	ff 74 24 24          	pushl  0x24(%esp)
   10777:	e8 d1 b0 ff ff       	call   b84d <iput>
   1077c:	83 c4 10             	add    $0x10,%esp
		free_block(inode->i_dev,inode->i_zone[0]);
   1077f:	83 ec 08             	sub    $0x8,%esp
   10782:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10786:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1078a:	50                   	push   %eax
   1078b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1078f:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10793:	50                   	push   %eax
   10794:	e8 3b 0b 00 00       	call   112d4 <free_block>
   10799:	83 c4 10             	add    $0x10,%esp
		inode->i_nlinks=0;
   1079c:	8b 44 24 14          	mov    0x14(%esp),%eax
   107a0:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
		iput(inode);
   107a4:	83 ec 0c             	sub    $0xc,%esp
   107a7:	ff 74 24 20          	pushl  0x20(%esp)
   107ab:	e8 9d b0 ff ff       	call   b84d <iput>
   107b0:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   107b3:	c7 44 24 04 e4 ff ff 	movl   $0xffffffe4,0x4(%esp)
   107ba:	ff 
   107bb:	eb 5b                	jmp    10818 <sys_mkdir+0x3be>
	}
	de->inode = inode->i_num;
   107bd:	8b 54 24 08          	mov    0x8(%esp),%edx
   107c1:	8b 44 24 14          	mov    0x14(%esp),%eax
   107c5:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   107c9:	66 89 02             	mov    %ax,(%edx)
	bh->b_dirt = 1;
   107cc:	8b 44 24 10          	mov    0x10(%esp),%eax
   107d0:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	dir->i_nlinks++;
   107d4:	8b 44 24 18          	mov    0x18(%esp),%eax
   107d8:	fe 40 0d             	incb   0xd(%eax)
	dir->i_dirt = 1;
   107db:	8b 44 24 18          	mov    0x18(%esp),%eax
   107df:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(dir);
   107e3:	83 ec 0c             	sub    $0xc,%esp
   107e6:	ff 74 24 24          	pushl  0x24(%esp)
   107ea:	e8 5e b0 ff ff       	call   b84d <iput>
   107ef:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   107f2:	83 ec 0c             	sub    $0xc,%esp
   107f5:	ff 74 24 20          	pushl  0x20(%esp)
   107f9:	e8 4f b0 ff ff       	call   b84d <iput>
   107fe:	83 c4 10             	add    $0x10,%esp
	brelse(bh);
   10801:	83 ec 0c             	sub    $0xc,%esp
   10804:	ff 74 24 1c          	pushl  0x1c(%esp)
   10808:	e8 aa be ff ff       	call   c6b7 <brelse>
   1080d:	83 c4 10             	add    $0x10,%esp
	return 0;
   10810:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   10817:	00 
}
   10818:	8b 44 24 04          	mov    0x4(%esp),%eax
   1081c:	83 c4 24             	add    $0x24,%esp
   1081f:	5b                   	pop    %ebx
   10820:	5e                   	pop    %esi
   10821:	c3                   	ret    

00010822 <empty_dir>:

/*
 * routine to check that the specified directory is empty (for rmdir)
 */
static int empty_dir(struct m_inode * inode)
{
   10822:	83 ec 1c             	sub    $0x1c,%esp
	int nr,block;
	int len;
	struct buffer_head * bh;
	struct dir_entry * de;

	len = inode->i_size / sizeof (struct dir_entry);
   10825:	8b 44 24 20          	mov    0x20(%esp),%eax
   10829:	8b 40 04             	mov    0x4(%eax),%eax
   1082c:	c1 e8 04             	shr    $0x4,%eax
   1082f:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (len<2 || !inode->i_zone[0] ||
   10833:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
   10838:	7e 33                	jle    1086d <empty_dir+0x4b>
   1083a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1083e:	66 83 78 0e 00       	cmpw   $0x0,0xe(%eax)
   10843:	74 28                	je     1086d <empty_dir+0x4b>
   10845:	83 ec 08             	sub    $0x8,%esp
   10848:	8b 44 24 28          	mov    0x28(%esp),%eax
   1084c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   10850:	50                   	push   %eax
   10851:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   10855:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10859:	50                   	push   %eax
   1085a:	e8 a4 be ff ff       	call   c703 <bread>
   1085f:	83 c4 10             	add    $0x10,%esp
   10862:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10866:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1086b:	75 26                	jne    10893 <empty_dir+0x71>
	    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {
	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
   1086d:	83 ec 08             	sub    $0x8,%esp
   10870:	8b 44 24 28          	mov    0x28(%esp),%eax
   10874:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10878:	50                   	push   %eax
   10879:	68 44 90 01 00       	push   $0x19044
   1087e:	e8 d0 7a ff ff       	call   8353 <printk>
   10883:	83 c4 10             	add    $0x10,%esp
		return 0;
   10886:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   1088d:	00 
   1088e:	e9 73 01 00 00       	jmp    10a06 <empty_dir+0x1e4>
	}
	de = (struct dir_entry *) bh->b_data;
   10893:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10897:	8b 00                	mov    (%eax),%eax
   10899:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (de[0].inode != inode->i_num || !de[1].inode || 
   1089d:	8b 44 24 08          	mov    0x8(%esp),%eax
   108a1:	8b 54 24 20          	mov    0x20(%esp),%edx
   108a5:	66 8b 00             	mov    (%eax),%ax
   108a8:	66 3b 42 2e          	cmp    0x2e(%edx),%ax
   108ac:	75 47                	jne    108f5 <empty_dir+0xd3>
   108ae:	8b 44 24 08          	mov    0x8(%esp),%eax
   108b2:	83 c0 10             	add    $0x10,%eax
   108b5:	66 83 38 00          	cmpw   $0x0,(%eax)
   108b9:	74 3a                	je     108f5 <empty_dir+0xd3>
   108bb:	8b 44 24 08          	mov    0x8(%esp),%eax
   108bf:	83 c0 02             	add    $0x2,%eax
   108c2:	83 ec 08             	sub    $0x8,%esp
   108c5:	50                   	push   %eax
   108c6:	68 3c 90 01 00       	push   $0x1903c
   108cb:	e8 79 7b 00 00       	call   18449 <strcmp>
   108d0:	83 c4 10             	add    $0x10,%esp
   108d3:	85 c0                	test   %eax,%eax
   108d5:	75 1e                	jne    108f5 <empty_dir+0xd3>
   108d7:	8b 44 24 08          	mov    0x8(%esp),%eax
   108db:	83 c0 12             	add    $0x12,%eax
   108de:	83 ec 08             	sub    $0x8,%esp
   108e1:	50                   	push   %eax
   108e2:	68 3e 90 01 00       	push   $0x1903e
   108e7:	e8 5d 7b 00 00       	call   18449 <strcmp>
   108ec:	83 c4 10             	add    $0x10,%esp
   108ef:	85 c0                	test   %eax,%eax
   108f1:	75 02                	jne    108f5 <empty_dir+0xd3>
   108f3:	eb 26                	jmp    1091b <empty_dir+0xf9>
	    strcmp(".",de[0].name) || strcmp("..",de[1].name)) {
	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
   108f5:	83 ec 08             	sub    $0x8,%esp
   108f8:	8b 44 24 28          	mov    0x28(%esp),%eax
   108fc:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10900:	50                   	push   %eax
   10901:	68 44 90 01 00       	push   $0x19044
   10906:	e8 48 7a ff ff       	call   8353 <printk>
   1090b:	83 c4 10             	add    $0x10,%esp
		return 0;
   1090e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   10915:	00 
   10916:	e9 eb 00 00 00       	jmp    10a06 <empty_dir+0x1e4>
	}
	nr = 2;
   1091b:	c7 44 24 18 02 00 00 	movl   $0x2,0x18(%esp)
   10922:	00 
	de += 2;
   10923:	8d 44 24 08          	lea    0x8(%esp),%eax
   10927:	83 00 20             	addl   $0x20,(%eax)
	while (nr<len) {
   1092a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1092e:	3b 44 24 10          	cmp    0x10(%esp),%eax
   10932:	0f 8d b7 00 00 00    	jge    109ef <empty_dir+0x1cd>
		if ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {
   10938:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1093c:	8b 00                	mov    (%eax),%eax
   1093e:	05 00 04 00 00       	add    $0x400,%eax
   10943:	3b 44 24 08          	cmp    0x8(%esp),%eax
   10947:	77 71                	ja     109ba <empty_dir+0x198>
			brelse(bh);
   10949:	83 ec 0c             	sub    $0xc,%esp
   1094c:	ff 74 24 18          	pushl  0x18(%esp)
   10950:	e8 62 bd ff ff       	call   c6b7 <brelse>
   10955:	83 c4 10             	add    $0x10,%esp
			block=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);
   10958:	83 ec 08             	sub    $0x8,%esp
   1095b:	8b 44 24 20          	mov    0x20(%esp),%eax
   1095f:	c1 e8 06             	shr    $0x6,%eax
   10962:	50                   	push   %eax
   10963:	ff 74 24 2c          	pushl  0x2c(%esp)
   10967:	e8 a9 ae ff ff       	call   b815 <bmap>
   1096c:	83 c4 10             	add    $0x10,%esp
   1096f:	89 44 24 14          	mov    %eax,0x14(%esp)
			if (!block) {
   10973:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   10978:	75 09                	jne    10983 <empty_dir+0x161>
				nr += DIR_ENTRIES_PER_BLOCK;
   1097a:	8d 44 24 18          	lea    0x18(%esp),%eax
   1097e:	83 00 40             	addl   $0x40,(%eax)
				continue;
   10981:	eb a7                	jmp    1092a <empty_dir+0x108>
			}
			if (!(bh=bread(inode->i_dev,block)))
   10983:	83 ec 08             	sub    $0x8,%esp
   10986:	ff 74 24 1c          	pushl  0x1c(%esp)
   1098a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1098e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10992:	50                   	push   %eax
   10993:	e8 6b bd ff ff       	call   c703 <bread>
   10998:	83 c4 10             	add    $0x10,%esp
   1099b:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1099f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   109a4:	75 0a                	jne    109b0 <empty_dir+0x18e>
				return 0;
   109a6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   109ad:	00 
   109ae:	eb 56                	jmp    10a06 <empty_dir+0x1e4>
			de = (struct dir_entry *) bh->b_data;
   109b0:	8b 44 24 0c          	mov    0xc(%esp),%eax
   109b4:	8b 00                	mov    (%eax),%eax
   109b6:	89 44 24 08          	mov    %eax,0x8(%esp)
		}
		if (de->inode) {
   109ba:	8b 44 24 08          	mov    0x8(%esp),%eax
   109be:	66 83 38 00          	cmpw   $0x0,(%eax)
   109c2:	74 19                	je     109dd <empty_dir+0x1bb>
			brelse(bh);
   109c4:	83 ec 0c             	sub    $0xc,%esp
   109c7:	ff 74 24 18          	pushl  0x18(%esp)
   109cb:	e8 e7 bc ff ff       	call   c6b7 <brelse>
   109d0:	83 c4 10             	add    $0x10,%esp
			return 0;
   109d3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   109da:	00 
   109db:	eb 29                	jmp    10a06 <empty_dir+0x1e4>
		}
		de++;
   109dd:	8d 44 24 08          	lea    0x8(%esp),%eax
   109e1:	83 00 10             	addl   $0x10,(%eax)
		nr++;
   109e4:	8d 44 24 18          	lea    0x18(%esp),%eax
   109e8:	ff 00                	incl   (%eax)
   109ea:	e9 3b ff ff ff       	jmp    1092a <empty_dir+0x108>
	}
	brelse(bh);
   109ef:	83 ec 0c             	sub    $0xc,%esp
   109f2:	ff 74 24 18          	pushl  0x18(%esp)
   109f6:	e8 bc bc ff ff       	call   c6b7 <brelse>
   109fb:	83 c4 10             	add    $0x10,%esp
	return 1;
   109fe:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   10a05:	00 
}
   10a06:	8b 44 24 04          	mov    0x4(%esp),%eax
   10a0a:	83 c4 1c             	add    $0x1c,%esp
   10a0d:	c3                   	ret    

00010a0e <sys_rmdir>:

int sys_rmdir(const char * name)
{
   10a0e:	56                   	push   %esi
   10a0f:	53                   	push   %ebx
   10a10:	83 ec 24             	sub    $0x24,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!suser())
   10a13:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10a18:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
   10a1f:	00 
   10a20:	74 0d                	je     10a2f <sys_rmdir+0x21>
		return -EPERM;
   10a22:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   10a29:	ff 
   10a2a:	e9 74 03 00 00       	jmp    10da3 <sys_rmdir+0x395>
	if (!(dir = dir_namei(name,&namelen,&basename)))
   10a2f:	83 ec 04             	sub    $0x4,%esp
   10a32:	8d 44 24 24          	lea    0x24(%esp),%eax
   10a36:	50                   	push   %eax
   10a37:	8d 44 24 24          	lea    0x24(%esp),%eax
   10a3b:	50                   	push   %eax
   10a3c:	ff 74 24 3c          	pushl  0x3c(%esp)
   10a40:	e8 bb f2 ff ff       	call   fd00 <dir_namei>
   10a45:	83 c4 10             	add    $0x10,%esp
   10a48:	89 44 24 18          	mov    %eax,0x18(%esp)
   10a4c:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10a51:	75 0d                	jne    10a60 <sys_rmdir+0x52>
		return -ENOENT;
   10a53:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
   10a5a:	ff 
   10a5b:	e9 43 03 00 00       	jmp    10da3 <sys_rmdir+0x395>
	if (!namelen) {
   10a60:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10a65:	75 1c                	jne    10a83 <sys_rmdir+0x75>
		iput(dir);
   10a67:	83 ec 0c             	sub    $0xc,%esp
   10a6a:	ff 74 24 24          	pushl  0x24(%esp)
   10a6e:	e8 da ad ff ff       	call   b84d <iput>
   10a73:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10a76:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
   10a7d:	ff 
   10a7e:	e9 20 03 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (!permission(dir,MAY_WRITE)) {
   10a83:	6a 02                	push   $0x2
   10a85:	ff 74 24 1c          	pushl  0x1c(%esp)
   10a89:	e8 df ea ff ff       	call   f56d <permission>
   10a8e:	83 c4 08             	add    $0x8,%esp
   10a91:	85 c0                	test   %eax,%eax
   10a93:	75 1c                	jne    10ab1 <sys_rmdir+0xa3>
		iput(dir);
   10a95:	83 ec 0c             	sub    $0xc,%esp
   10a98:	ff 74 24 24          	pushl  0x24(%esp)
   10a9c:	e8 ac ad ff ff       	call   b84d <iput>
   10aa1:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10aa4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   10aab:	ff 
   10aac:	e9 f2 02 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   10ab1:	8d 44 24 0c          	lea    0xc(%esp),%eax
   10ab5:	50                   	push   %eax
   10ab6:	ff 74 24 20          	pushl  0x20(%esp)
   10aba:	ff 74 24 28          	pushl  0x28(%esp)
   10abe:	8d 44 24 24          	lea    0x24(%esp),%eax
   10ac2:	50                   	push   %eax
   10ac3:	e8 b3 eb ff ff       	call   f67b <find_entry>
   10ac8:	83 c4 10             	add    $0x10,%esp
   10acb:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!bh) {
   10acf:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   10ad4:	75 1c                	jne    10af2 <sys_rmdir+0xe4>
		iput(dir);
   10ad6:	83 ec 0c             	sub    $0xc,%esp
   10ad9:	ff 74 24 24          	pushl  0x24(%esp)
   10add:	e8 6b ad ff ff       	call   b84d <iput>
   10ae2:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10ae5:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
   10aec:	ff 
   10aed:	e9 b1 02 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
   10af2:	83 ec 08             	sub    $0x8,%esp
   10af5:	8b 44 24 14          	mov    0x14(%esp),%eax
   10af9:	0f b7 00             	movzwl (%eax),%eax
   10afc:	50                   	push   %eax
   10afd:	8b 44 24 24          	mov    0x24(%esp),%eax
   10b01:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10b05:	50                   	push   %eax
   10b06:	e8 7e b0 ff ff       	call   bb89 <iget>
   10b0b:	83 c4 10             	add    $0x10,%esp
   10b0e:	89 44 24 14          	mov    %eax,0x14(%esp)
   10b12:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   10b17:	75 2b                	jne    10b44 <sys_rmdir+0x136>
		iput(dir);
   10b19:	83 ec 0c             	sub    $0xc,%esp
   10b1c:	ff 74 24 24          	pushl  0x24(%esp)
   10b20:	e8 28 ad ff ff       	call   b84d <iput>
   10b25:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10b28:	83 ec 0c             	sub    $0xc,%esp
   10b2b:	ff 74 24 1c          	pushl  0x1c(%esp)
   10b2f:	e8 83 bb ff ff       	call   c6b7 <brelse>
   10b34:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10b37:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   10b3e:	ff 
   10b3f:	e9 5f 02 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if ((dir->i_mode & S_ISVTX) && current->euid &&
   10b44:	8b 44 24 18          	mov    0x18(%esp),%eax
   10b48:	0f b7 00             	movzwl (%eax),%eax
   10b4b:	25 00 02 00 00       	and    $0x200,%eax
   10b50:	85 c0                	test   %eax,%eax
   10b52:	74 60                	je     10bb4 <sys_rmdir+0x1a6>
   10b54:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10b59:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
   10b60:	00 
   10b61:	74 51                	je     10bb4 <sys_rmdir+0x1a6>
   10b63:	8b 44 24 14          	mov    0x14(%esp),%eax
   10b67:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   10b6d:	66 8b 40 02          	mov    0x2(%eax),%ax
   10b71:	66 3b 82 42 02 00 00 	cmp    0x242(%edx),%ax
   10b78:	74 3a                	je     10bb4 <sys_rmdir+0x1a6>
	    inode->i_uid != current->euid) {
		iput(dir);
   10b7a:	83 ec 0c             	sub    $0xc,%esp
   10b7d:	ff 74 24 24          	pushl  0x24(%esp)
   10b81:	e8 c7 ac ff ff       	call   b84d <iput>
   10b86:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   10b89:	83 ec 0c             	sub    $0xc,%esp
   10b8c:	ff 74 24 20          	pushl  0x20(%esp)
   10b90:	e8 b8 ac ff ff       	call   b84d <iput>
   10b95:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10b98:	83 ec 0c             	sub    $0xc,%esp
   10b9b:	ff 74 24 1c          	pushl  0x1c(%esp)
   10b9f:	e8 13 bb ff ff       	call   c6b7 <brelse>
   10ba4:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10ba7:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   10bae:	ff 
   10baf:	e9 ef 01 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (inode->i_dev != dir->i_dev || inode->i_count>1) {
   10bb4:	8b 44 24 14          	mov    0x14(%esp),%eax
   10bb8:	8b 54 24 18          	mov    0x18(%esp),%edx
   10bbc:	66 8b 40 2c          	mov    0x2c(%eax),%ax
   10bc0:	66 3b 42 2c          	cmp    0x2c(%edx),%ax
   10bc4:	75 0d                	jne    10bd3 <sys_rmdir+0x1c5>
   10bc6:	8b 44 24 14          	mov    0x14(%esp),%eax
   10bca:	66 83 78 30 01       	cmpw   $0x1,0x30(%eax)
   10bcf:	77 02                	ja     10bd3 <sys_rmdir+0x1c5>
   10bd1:	eb 3a                	jmp    10c0d <sys_rmdir+0x1ff>
		iput(dir);
   10bd3:	83 ec 0c             	sub    $0xc,%esp
   10bd6:	ff 74 24 24          	pushl  0x24(%esp)
   10bda:	e8 6e ac ff ff       	call   b84d <iput>
   10bdf:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   10be2:	83 ec 0c             	sub    $0xc,%esp
   10be5:	ff 74 24 20          	pushl  0x20(%esp)
   10be9:	e8 5f ac ff ff       	call   b84d <iput>
   10bee:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10bf1:	83 ec 0c             	sub    $0xc,%esp
   10bf4:	ff 74 24 1c          	pushl  0x1c(%esp)
   10bf8:	e8 ba ba ff ff       	call   c6b7 <brelse>
   10bfd:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10c00:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   10c07:	ff 
   10c08:	e9 96 01 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (inode == dir) {	/* we may not delete ".", but "../dir" is ok */
   10c0d:	8b 44 24 14          	mov    0x14(%esp),%eax
   10c11:	3b 44 24 18          	cmp    0x18(%esp),%eax
   10c15:	75 3a                	jne    10c51 <sys_rmdir+0x243>
		iput(inode);
   10c17:	83 ec 0c             	sub    $0xc,%esp
   10c1a:	ff 74 24 20          	pushl  0x20(%esp)
   10c1e:	e8 2a ac ff ff       	call   b84d <iput>
   10c23:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10c26:	83 ec 0c             	sub    $0xc,%esp
   10c29:	ff 74 24 24          	pushl  0x24(%esp)
   10c2d:	e8 1b ac ff ff       	call   b84d <iput>
   10c32:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10c35:	83 ec 0c             	sub    $0xc,%esp
   10c38:	ff 74 24 1c          	pushl  0x1c(%esp)
   10c3c:	e8 76 ba ff ff       	call   c6b7 <brelse>
   10c41:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10c44:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   10c4b:	ff 
   10c4c:	e9 52 01 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (!S_ISDIR(inode->i_mode)) {
   10c51:	8b 44 24 14          	mov    0x14(%esp),%eax
   10c55:	0f b7 00             	movzwl (%eax),%eax
   10c58:	25 00 f0 00 00       	and    $0xf000,%eax
   10c5d:	3d 00 40 00 00       	cmp    $0x4000,%eax
   10c62:	74 3a                	je     10c9e <sys_rmdir+0x290>
		iput(inode);
   10c64:	83 ec 0c             	sub    $0xc,%esp
   10c67:	ff 74 24 20          	pushl  0x20(%esp)
   10c6b:	e8 dd ab ff ff       	call   b84d <iput>
   10c70:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10c73:	83 ec 0c             	sub    $0xc,%esp
   10c76:	ff 74 24 24          	pushl  0x24(%esp)
   10c7a:	e8 ce ab ff ff       	call   b84d <iput>
   10c7f:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10c82:	83 ec 0c             	sub    $0xc,%esp
   10c85:	ff 74 24 1c          	pushl  0x1c(%esp)
   10c89:	e8 29 ba ff ff       	call   c6b7 <brelse>
   10c8e:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
   10c91:	c7 44 24 08 ec ff ff 	movl   $0xffffffec,0x8(%esp)
   10c98:	ff 
   10c99:	e9 05 01 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (!empty_dir(inode)) {
   10c9e:	83 ec 0c             	sub    $0xc,%esp
   10ca1:	ff 74 24 20          	pushl  0x20(%esp)
   10ca5:	e8 78 fb ff ff       	call   10822 <empty_dir>
   10caa:	83 c4 10             	add    $0x10,%esp
   10cad:	85 c0                	test   %eax,%eax
   10caf:	75 3a                	jne    10ceb <sys_rmdir+0x2dd>
		iput(inode);
   10cb1:	83 ec 0c             	sub    $0xc,%esp
   10cb4:	ff 74 24 20          	pushl  0x20(%esp)
   10cb8:	e8 90 ab ff ff       	call   b84d <iput>
   10cbd:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10cc0:	83 ec 0c             	sub    $0xc,%esp
   10cc3:	ff 74 24 24          	pushl  0x24(%esp)
   10cc7:	e8 81 ab ff ff       	call   b84d <iput>
   10ccc:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10ccf:	83 ec 0c             	sub    $0xc,%esp
   10cd2:	ff 74 24 1c          	pushl  0x1c(%esp)
   10cd6:	e8 dc b9 ff ff       	call   c6b7 <brelse>
   10cdb:	83 c4 10             	add    $0x10,%esp
		return -ENOTEMPTY;
   10cde:	c7 44 24 08 d9 ff ff 	movl   $0xffffffd9,0x8(%esp)
   10ce5:	ff 
   10ce6:	e9 b8 00 00 00       	jmp    10da3 <sys_rmdir+0x395>
	}
	if (inode->i_nlinks != 2)
   10ceb:	8b 44 24 14          	mov    0x14(%esp),%eax
   10cef:	80 78 0d 02          	cmpb   $0x2,0xd(%eax)
   10cf3:	74 19                	je     10d0e <sys_rmdir+0x300>
		printk("empty directory has nlink!=2 (%d)",inode->i_nlinks);
   10cf5:	83 ec 08             	sub    $0x8,%esp
   10cf8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10cfc:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   10d00:	50                   	push   %eax
   10d01:	68 6c 90 01 00       	push   $0x1906c
   10d06:	e8 48 76 ff ff       	call   8353 <printk>
   10d0b:	83 c4 10             	add    $0x10,%esp
	de->inode = 0;
   10d0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   10d12:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
   10d17:	8b 44 24 10          	mov    0x10(%esp),%eax
   10d1b:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   10d1f:	83 ec 0c             	sub    $0xc,%esp
   10d22:	ff 74 24 1c          	pushl  0x1c(%esp)
   10d26:	e8 8c b9 ff ff       	call   c6b7 <brelse>
   10d2b:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks=0;
   10d2e:	8b 44 24 14          	mov    0x14(%esp),%eax
   10d32:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	inode->i_dirt=1;
   10d36:	8b 44 24 14          	mov    0x14(%esp),%eax
   10d3a:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	dir->i_nlinks--;
   10d3e:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d42:	fe 48 0d             	decb   0xd(%eax)
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
   10d45:	8b 74 24 18          	mov    0x18(%esp),%esi
   10d49:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   10d4d:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   10d53:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   10d58:	f7 e9                	imul   %ecx
   10d5a:	c1 fa 05             	sar    $0x5,%edx
   10d5d:	89 c8                	mov    %ecx,%eax
   10d5f:	c1 f8 1f             	sar    $0x1f,%eax
   10d62:	29 c2                	sub    %eax,%edx
   10d64:	89 d0                	mov    %edx,%eax
   10d66:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   10d6c:	89 43 08             	mov    %eax,0x8(%ebx)
   10d6f:	8b 43 08             	mov    0x8(%ebx),%eax
   10d72:	89 46 28             	mov    %eax,0x28(%esi)
	dir->i_dirt=1;
   10d75:	8b 44 24 18          	mov    0x18(%esp),%eax
   10d79:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(dir);
   10d7d:	83 ec 0c             	sub    $0xc,%esp
   10d80:	ff 74 24 24          	pushl  0x24(%esp)
   10d84:	e8 c4 aa ff ff       	call   b84d <iput>
   10d89:	83 c4 10             	add    $0x10,%esp
	iput(inode);
   10d8c:	83 ec 0c             	sub    $0xc,%esp
   10d8f:	ff 74 24 20          	pushl  0x20(%esp)
   10d93:	e8 b5 aa ff ff       	call   b84d <iput>
   10d98:	83 c4 10             	add    $0x10,%esp
	return 0;
   10d9b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   10da2:	00 
}
   10da3:	8b 44 24 08          	mov    0x8(%esp),%eax
   10da7:	83 c4 24             	add    $0x24,%esp
   10daa:	5b                   	pop    %ebx
   10dab:	5e                   	pop    %esi
   10dac:	c3                   	ret    

00010dad <sys_unlink>:

int sys_unlink(const char * name)
{
   10dad:	53                   	push   %ebx
   10dae:	83 ec 28             	sub    $0x28,%esp
	int namelen;
	struct m_inode * dir, * inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!(dir = dir_namei(name,&namelen,&basename)))
   10db1:	83 ec 04             	sub    $0x4,%esp
   10db4:	8d 44 24 28          	lea    0x28(%esp),%eax
   10db8:	50                   	push   %eax
   10db9:	8d 44 24 28          	lea    0x28(%esp),%eax
   10dbd:	50                   	push   %eax
   10dbe:	ff 74 24 3c          	pushl  0x3c(%esp)
   10dc2:	e8 39 ef ff ff       	call   fd00 <dir_namei>
   10dc7:	83 c4 10             	add    $0x10,%esp
   10dca:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   10dce:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   10dd3:	75 0d                	jne    10de2 <sys_unlink+0x35>
		return -ENOENT;
   10dd5:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
   10ddc:	ff 
   10ddd:	e9 6b 02 00 00       	jmp    1104d <sys_unlink+0x2a0>
	if (!namelen) {
   10de2:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   10de7:	75 1c                	jne    10e05 <sys_unlink+0x58>
		iput(dir);
   10de9:	83 ec 0c             	sub    $0xc,%esp
   10dec:	ff 74 24 28          	pushl  0x28(%esp)
   10df0:	e8 58 aa ff ff       	call   b84d <iput>
   10df5:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10df8:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
   10dff:	ff 
   10e00:	e9 48 02 00 00       	jmp    1104d <sys_unlink+0x2a0>
	}
	if (!permission(dir,MAY_WRITE)) {
   10e05:	6a 02                	push   $0x2
   10e07:	ff 74 24 20          	pushl  0x20(%esp)
   10e0b:	e8 5d e7 ff ff       	call   f56d <permission>
   10e10:	83 c4 08             	add    $0x8,%esp
   10e13:	85 c0                	test   %eax,%eax
   10e15:	75 1c                	jne    10e33 <sys_unlink+0x86>
		iput(dir);
   10e17:	83 ec 0c             	sub    $0xc,%esp
   10e1a:	ff 74 24 28          	pushl  0x28(%esp)
   10e1e:	e8 2a aa ff ff       	call   b84d <iput>
   10e23:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10e26:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
   10e2d:	ff 
   10e2e:	e9 1a 02 00 00       	jmp    1104d <sys_unlink+0x2a0>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   10e33:	8d 44 24 10          	lea    0x10(%esp),%eax
   10e37:	50                   	push   %eax
   10e38:	ff 74 24 24          	pushl  0x24(%esp)
   10e3c:	ff 74 24 2c          	pushl  0x2c(%esp)
   10e40:	8d 44 24 28          	lea    0x28(%esp),%eax
   10e44:	50                   	push   %eax
   10e45:	e8 31 e8 ff ff       	call   f67b <find_entry>
   10e4a:	83 c4 10             	add    $0x10,%esp
   10e4d:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (!bh) {
   10e51:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   10e56:	75 1c                	jne    10e74 <sys_unlink+0xc7>
		iput(dir);
   10e58:	83 ec 0c             	sub    $0xc,%esp
   10e5b:	ff 74 24 28          	pushl  0x28(%esp)
   10e5f:	e8 e9 a9 ff ff       	call   b84d <iput>
   10e64:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10e67:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
   10e6e:	ff 
   10e6f:	e9 d9 01 00 00       	jmp    1104d <sys_unlink+0x2a0>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
   10e74:	83 ec 08             	sub    $0x8,%esp
   10e77:	8b 44 24 18          	mov    0x18(%esp),%eax
   10e7b:	0f b7 00             	movzwl (%eax),%eax
   10e7e:	50                   	push   %eax
   10e7f:	8b 44 24 28          	mov    0x28(%esp),%eax
   10e83:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10e87:	50                   	push   %eax
   10e88:	e8 fc ac ff ff       	call   bb89 <iget>
   10e8d:	83 c4 10             	add    $0x10,%esp
   10e90:	89 44 24 18          	mov    %eax,0x18(%esp)
   10e94:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   10e99:	75 2b                	jne    10ec6 <sys_unlink+0x119>
		iput(dir);
   10e9b:	83 ec 0c             	sub    $0xc,%esp
   10e9e:	ff 74 24 28          	pushl  0x28(%esp)
   10ea2:	e8 a6 a9 ff ff       	call   b84d <iput>
   10ea7:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10eaa:	83 ec 0c             	sub    $0xc,%esp
   10ead:	ff 74 24 20          	pushl  0x20(%esp)
   10eb1:	e8 01 b8 ff ff       	call   c6b7 <brelse>
   10eb6:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   10eb9:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
   10ec0:	ff 
   10ec1:	e9 87 01 00 00       	jmp    1104d <sys_unlink+0x2a0>
	}
	if ((dir->i_mode & S_ISVTX) && !suser() &&
   10ec6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10eca:	0f b7 00             	movzwl (%eax),%eax
   10ecd:	25 00 02 00 00       	and    $0x200,%eax
   10ed2:	85 c0                	test   %eax,%eax
   10ed4:	74 75                	je     10f4b <sys_unlink+0x19e>
   10ed6:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10edb:	66 83 b8 42 02 00 00 	cmpw   $0x0,0x242(%eax)
   10ee2:	00 
   10ee3:	74 66                	je     10f4b <sys_unlink+0x19e>
   10ee5:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10eea:	8b 54 24 18          	mov    0x18(%esp),%edx
   10eee:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
   10ef5:	66 3b 42 02          	cmp    0x2(%edx),%ax
   10ef9:	74 50                	je     10f4b <sys_unlink+0x19e>
   10efb:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   10f00:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   10f04:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
   10f0b:	66 3b 42 02          	cmp    0x2(%edx),%ax
   10f0f:	74 3a                	je     10f4b <sys_unlink+0x19e>
	    current->euid != inode->i_uid &&
	    current->euid != dir->i_uid) {
		iput(dir);
   10f11:	83 ec 0c             	sub    $0xc,%esp
   10f14:	ff 74 24 28          	pushl  0x28(%esp)
   10f18:	e8 30 a9 ff ff       	call   b84d <iput>
   10f1d:	83 c4 10             	add    $0x10,%esp
		iput(inode);
   10f20:	83 ec 0c             	sub    $0xc,%esp
   10f23:	ff 74 24 24          	pushl  0x24(%esp)
   10f27:	e8 21 a9 ff ff       	call   b84d <iput>
   10f2c:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10f2f:	83 ec 0c             	sub    $0xc,%esp
   10f32:	ff 74 24 20          	pushl  0x20(%esp)
   10f36:	e8 7c b7 ff ff       	call   c6b7 <brelse>
   10f3b:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10f3e:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
   10f45:	ff 
   10f46:	e9 02 01 00 00       	jmp    1104d <sys_unlink+0x2a0>
	}
	if (S_ISDIR(inode->i_mode)) {
   10f4b:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f4f:	0f b7 00             	movzwl (%eax),%eax
   10f52:	25 00 f0 00 00       	and    $0xf000,%eax
   10f57:	3d 00 40 00 00       	cmp    $0x4000,%eax
   10f5c:	75 3a                	jne    10f98 <sys_unlink+0x1eb>
		iput(inode);
   10f5e:	83 ec 0c             	sub    $0xc,%esp
   10f61:	ff 74 24 24          	pushl  0x24(%esp)
   10f65:	e8 e3 a8 ff ff       	call   b84d <iput>
   10f6a:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   10f6d:	83 ec 0c             	sub    $0xc,%esp
   10f70:	ff 74 24 28          	pushl  0x28(%esp)
   10f74:	e8 d4 a8 ff ff       	call   b84d <iput>
   10f79:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
   10f7c:	83 ec 0c             	sub    $0xc,%esp
   10f7f:	ff 74 24 20          	pushl  0x20(%esp)
   10f83:	e8 2f b7 ff ff       	call   c6b7 <brelse>
   10f88:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   10f8b:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
   10f92:	ff 
   10f93:	e9 b5 00 00 00       	jmp    1104d <sys_unlink+0x2a0>
	}
	if (!inode->i_nlinks) {
   10f98:	8b 44 24 18          	mov    0x18(%esp),%eax
   10f9c:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   10fa0:	75 30                	jne    10fd2 <sys_unlink+0x225>
		printk("Deleting nonexistent file (%04x:%d), %d\n",
   10fa2:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fa6:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   10faa:	50                   	push   %eax
   10fab:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10faf:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   10fb3:	50                   	push   %eax
   10fb4:	8b 44 24 20          	mov    0x20(%esp),%eax
   10fb8:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   10fbc:	50                   	push   %eax
   10fbd:	68 90 90 01 00       	push   $0x19090
   10fc2:	e8 8c 73 ff ff       	call   8353 <printk>
   10fc7:	83 c4 10             	add    $0x10,%esp
			inode->i_dev,inode->i_num,inode->i_nlinks);
		inode->i_nlinks=1;
   10fca:	8b 44 24 18          	mov    0x18(%esp),%eax
   10fce:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	}
	de->inode = 0;
   10fd2:	8b 44 24 10          	mov    0x10(%esp),%eax
   10fd6:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
   10fdb:	8b 44 24 14          	mov    0x14(%esp),%eax
   10fdf:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   10fe3:	83 ec 0c             	sub    $0xc,%esp
   10fe6:	ff 74 24 20          	pushl  0x20(%esp)
   10fea:	e8 c8 b6 ff ff       	call   c6b7 <brelse>
   10fef:	83 c4 10             	add    $0x10,%esp
	inode->i_nlinks--;
   10ff2:	8b 44 24 18          	mov    0x18(%esp),%eax
   10ff6:	fe 48 0d             	decb   0xd(%eax)
	inode->i_dirt = 1;
   10ff9:	8b 44 24 18          	mov    0x18(%esp),%eax
   10ffd:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_ctime = CURRENT_TIME;
   11001:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   11005:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   1100b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   11010:	f7 e9                	imul   %ecx
   11012:	c1 fa 05             	sar    $0x5,%edx
   11015:	89 c8                	mov    %ecx,%eax
   11017:	c1 f8 1f             	sar    $0x1f,%eax
   1101a:	29 c2                	sub    %eax,%edx
   1101c:	89 d0                	mov    %edx,%eax
   1101e:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   11024:	89 43 28             	mov    %eax,0x28(%ebx)
	iput(inode);
   11027:	83 ec 0c             	sub    $0xc,%esp
   1102a:	ff 74 24 24          	pushl  0x24(%esp)
   1102e:	e8 1a a8 ff ff       	call   b84d <iput>
   11033:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   11036:	83 ec 0c             	sub    $0xc,%esp
   11039:	ff 74 24 28          	pushl  0x28(%esp)
   1103d:	e8 0b a8 ff ff       	call   b84d <iput>
   11042:	83 c4 10             	add    $0x10,%esp
	return 0;
   11045:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1104c:	00 
}
   1104d:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11051:	83 c4 28             	add    $0x28,%esp
   11054:	5b                   	pop    %ebx
   11055:	c3                   	ret    

00011056 <sys_link>:

int sys_link(const char * oldname, const char * newname)
{
   11056:	53                   	push   %ebx
   11057:	83 ec 28             	sub    $0x28,%esp
	struct m_inode * oldinode, * dir;
	struct buffer_head * bh;
	const char * basename;
	int namelen;

	oldinode=namei(oldname);
   1105a:	83 ec 0c             	sub    $0xc,%esp
   1105d:	ff 74 24 3c          	pushl  0x3c(%esp)
   11061:	e8 22 ed ff ff       	call   fd88 <namei>
   11066:	83 c4 10             	add    $0x10,%esp
   11069:	89 44 24 20          	mov    %eax,0x20(%esp)
	if (!oldinode)
   1106d:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   11072:	75 0d                	jne    11081 <sys_link+0x2b>
		return -ENOENT;
   11074:	c7 44 24 0c fe ff ff 	movl   $0xfffffffe,0xc(%esp)
   1107b:	ff 
   1107c:	e9 4a 02 00 00       	jmp    112cb <sys_link+0x275>
	if (S_ISDIR(oldinode->i_mode)) {
   11081:	8b 44 24 20          	mov    0x20(%esp),%eax
   11085:	0f b7 00             	movzwl (%eax),%eax
   11088:	25 00 f0 00 00       	and    $0xf000,%eax
   1108d:	3d 00 40 00 00       	cmp    $0x4000,%eax
   11092:	75 1c                	jne    110b0 <sys_link+0x5a>
		iput(oldinode);
   11094:	83 ec 0c             	sub    $0xc,%esp
   11097:	ff 74 24 2c          	pushl  0x2c(%esp)
   1109b:	e8 ad a7 ff ff       	call   b84d <iput>
   110a0:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   110a3:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
   110aa:	ff 
   110ab:	e9 1b 02 00 00       	jmp    112cb <sys_link+0x275>
	}
	dir = dir_namei(newname,&namelen,&basename);
   110b0:	83 ec 04             	sub    $0x4,%esp
   110b3:	8d 44 24 18          	lea    0x18(%esp),%eax
   110b7:	50                   	push   %eax
   110b8:	8d 44 24 18          	lea    0x18(%esp),%eax
   110bc:	50                   	push   %eax
   110bd:	ff 74 24 40          	pushl  0x40(%esp)
   110c1:	e8 3a ec ff ff       	call   fd00 <dir_namei>
   110c6:	83 c4 10             	add    $0x10,%esp
   110c9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (!dir) {
   110cd:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   110d2:	75 1c                	jne    110f0 <sys_link+0x9a>
		iput(oldinode);
   110d4:	83 ec 0c             	sub    $0xc,%esp
   110d7:	ff 74 24 2c          	pushl  0x2c(%esp)
   110db:	e8 6d a7 ff ff       	call   b84d <iput>
   110e0:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   110e3:	c7 44 24 0c f3 ff ff 	movl   $0xfffffff3,0xc(%esp)
   110ea:	ff 
   110eb:	e9 db 01 00 00       	jmp    112cb <sys_link+0x275>
	}
	if (!namelen) {
   110f0:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   110f5:	75 2b                	jne    11122 <sys_link+0xcc>
		iput(oldinode);
   110f7:	83 ec 0c             	sub    $0xc,%esp
   110fa:	ff 74 24 2c          	pushl  0x2c(%esp)
   110fe:	e8 4a a7 ff ff       	call   b84d <iput>
   11103:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   11106:	83 ec 0c             	sub    $0xc,%esp
   11109:	ff 74 24 28          	pushl  0x28(%esp)
   1110d:	e8 3b a7 ff ff       	call   b84d <iput>
   11112:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
   11115:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
   1111c:	ff 
   1111d:	e9 a9 01 00 00       	jmp    112cb <sys_link+0x275>
	}
	if (dir->i_dev != oldinode->i_dev) {
   11122:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11126:	8b 54 24 20          	mov    0x20(%esp),%edx
   1112a:	66 8b 40 2c          	mov    0x2c(%eax),%ax
   1112e:	66 3b 42 2c          	cmp    0x2c(%edx),%ax
   11132:	74 2b                	je     1115f <sys_link+0x109>
		iput(dir);
   11134:	83 ec 0c             	sub    $0xc,%esp
   11137:	ff 74 24 28          	pushl  0x28(%esp)
   1113b:	e8 0d a7 ff ff       	call   b84d <iput>
   11140:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   11143:	83 ec 0c             	sub    $0xc,%esp
   11146:	ff 74 24 2c          	pushl  0x2c(%esp)
   1114a:	e8 fe a6 ff ff       	call   b84d <iput>
   1114f:	83 c4 10             	add    $0x10,%esp
		return -EXDEV;
   11152:	c7 44 24 0c ee ff ff 	movl   $0xffffffee,0xc(%esp)
   11159:	ff 
   1115a:	e9 6c 01 00 00       	jmp    112cb <sys_link+0x275>
	}
	if (!permission(dir,MAY_WRITE)) {
   1115f:	6a 02                	push   $0x2
   11161:	ff 74 24 20          	pushl  0x20(%esp)
   11165:	e8 03 e4 ff ff       	call   f56d <permission>
   1116a:	83 c4 08             	add    $0x8,%esp
   1116d:	85 c0                	test   %eax,%eax
   1116f:	75 2b                	jne    1119c <sys_link+0x146>
		iput(dir);
   11171:	83 ec 0c             	sub    $0xc,%esp
   11174:	ff 74 24 28          	pushl  0x28(%esp)
   11178:	e8 d0 a6 ff ff       	call   b84d <iput>
   1117d:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   11180:	83 ec 0c             	sub    $0xc,%esp
   11183:	ff 74 24 2c          	pushl  0x2c(%esp)
   11187:	e8 c1 a6 ff ff       	call   b84d <iput>
   1118c:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
   1118f:	c7 44 24 0c f3 ff ff 	movl   $0xfffffff3,0xc(%esp)
   11196:	ff 
   11197:	e9 2f 01 00 00       	jmp    112cb <sys_link+0x275>
	}
	bh = find_entry(&dir,basename,namelen,&de);
   1119c:	8d 44 24 24          	lea    0x24(%esp),%eax
   111a0:	50                   	push   %eax
   111a1:	ff 74 24 14          	pushl  0x14(%esp)
   111a5:	ff 74 24 1c          	pushl  0x1c(%esp)
   111a9:	8d 44 24 28          	lea    0x28(%esp),%eax
   111ad:	50                   	push   %eax
   111ae:	e8 c8 e4 ff ff       	call   f67b <find_entry>
   111b3:	83 c4 10             	add    $0x10,%esp
   111b6:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (bh) {
   111ba:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   111bf:	74 3a                	je     111fb <sys_link+0x1a5>
		brelse(bh);
   111c1:	83 ec 0c             	sub    $0xc,%esp
   111c4:	ff 74 24 24          	pushl  0x24(%esp)
   111c8:	e8 ea b4 ff ff       	call   c6b7 <brelse>
   111cd:	83 c4 10             	add    $0x10,%esp
		iput(dir);
   111d0:	83 ec 0c             	sub    $0xc,%esp
   111d3:	ff 74 24 28          	pushl  0x28(%esp)
   111d7:	e8 71 a6 ff ff       	call   b84d <iput>
   111dc:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   111df:	83 ec 0c             	sub    $0xc,%esp
   111e2:	ff 74 24 2c          	pushl  0x2c(%esp)
   111e6:	e8 62 a6 ff ff       	call   b84d <iput>
   111eb:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
   111ee:	c7 44 24 0c ef ff ff 	movl   $0xffffffef,0xc(%esp)
   111f5:	ff 
   111f6:	e9 d0 00 00 00       	jmp    112cb <sys_link+0x275>
	}
	bh = add_entry(dir,basename,namelen,&de);
   111fb:	8d 44 24 24          	lea    0x24(%esp),%eax
   111ff:	50                   	push   %eax
   11200:	ff 74 24 14          	pushl  0x14(%esp)
   11204:	ff 74 24 1c          	pushl  0x1c(%esp)
   11208:	ff 74 24 28          	pushl  0x28(%esp)
   1120c:	e8 b6 e6 ff ff       	call   f8c7 <add_entry>
   11211:	83 c4 10             	add    $0x10,%esp
   11214:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!bh) {
   11218:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   1121d:	75 2b                	jne    1124a <sys_link+0x1f4>
		iput(dir);
   1121f:	83 ec 0c             	sub    $0xc,%esp
   11222:	ff 74 24 28          	pushl  0x28(%esp)
   11226:	e8 22 a6 ff ff       	call   b84d <iput>
   1122b:	83 c4 10             	add    $0x10,%esp
		iput(oldinode);
   1122e:	83 ec 0c             	sub    $0xc,%esp
   11231:	ff 74 24 2c          	pushl  0x2c(%esp)
   11235:	e8 13 a6 ff ff       	call   b84d <iput>
   1123a:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
   1123d:	c7 44 24 0c e4 ff ff 	movl   $0xffffffe4,0xc(%esp)
   11244:	ff 
   11245:	e9 81 00 00 00       	jmp    112cb <sys_link+0x275>
	}
	de->inode = oldinode->i_num;
   1124a:	8b 54 24 24          	mov    0x24(%esp),%edx
   1124e:	8b 44 24 20          	mov    0x20(%esp),%eax
   11252:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   11256:	66 89 02             	mov    %ax,(%edx)
	bh->b_dirt = 1;
   11259:	8b 44 24 18          	mov    0x18(%esp),%eax
   1125d:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   11261:	83 ec 0c             	sub    $0xc,%esp
   11264:	ff 74 24 24          	pushl  0x24(%esp)
   11268:	e8 4a b4 ff ff       	call   c6b7 <brelse>
   1126d:	83 c4 10             	add    $0x10,%esp
	iput(dir);
   11270:	83 ec 0c             	sub    $0xc,%esp
   11273:	ff 74 24 28          	pushl  0x28(%esp)
   11277:	e8 d1 a5 ff ff       	call   b84d <iput>
   1127c:	83 c4 10             	add    $0x10,%esp
	oldinode->i_nlinks++;
   1127f:	8b 44 24 20          	mov    0x20(%esp),%eax
   11283:	fe 40 0d             	incb   0xd(%eax)
	oldinode->i_ctime = CURRENT_TIME;
   11286:	8b 5c 24 20          	mov    0x20(%esp),%ebx
   1128a:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   11290:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   11295:	f7 e9                	imul   %ecx
   11297:	c1 fa 05             	sar    $0x5,%edx
   1129a:	89 c8                	mov    %ecx,%eax
   1129c:	c1 f8 1f             	sar    $0x1f,%eax
   1129f:	29 c2                	sub    %eax,%edx
   112a1:	89 d0                	mov    %edx,%eax
   112a3:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   112a9:	89 43 28             	mov    %eax,0x28(%ebx)
	oldinode->i_dirt = 1;
   112ac:	8b 44 24 20          	mov    0x20(%esp),%eax
   112b0:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	iput(oldinode);
   112b4:	83 ec 0c             	sub    $0xc,%esp
   112b7:	ff 74 24 2c          	pushl  0x2c(%esp)
   112bb:	e8 8d a5 ff ff       	call   b84d <iput>
   112c0:	83 c4 10             	add    $0x10,%esp
	return 0;
   112c3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   112ca:	00 
}
   112cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
   112cf:	83 c4 28             	add    $0x28,%esp
   112d2:	5b                   	pop    %ebx
   112d3:	c3                   	ret    

000112d4 <free_block>:
	"3:" \
	:"=c" (__res):"c" (0),"S" (addr)); \
__res;})

void free_block(int dev, int block)
{
   112d4:	83 ec 2c             	sub    $0x2c,%esp
	struct super_block * sb;
	struct buffer_head * bh;

	if (!(sb = get_super(dev)))
   112d7:	83 ec 0c             	sub    $0xc,%esp
   112da:	ff 74 24 3c          	pushl  0x3c(%esp)
   112de:	e8 6d b8 ff ff       	call   cb50 <get_super>
   112e3:	83 c4 10             	add    $0x10,%esp
   112e6:	89 44 24 28          	mov    %eax,0x28(%esp)
   112ea:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   112ef:	75 10                	jne    11301 <free_block+0x2d>
		panic("trying to free block on nonexistent device");
   112f1:	83 ec 0c             	sub    $0xc,%esp
   112f4:	68 bc 90 01 00       	push   $0x190bc
   112f9:	e8 1b 70 ff ff       	call   8319 <panic>
   112fe:	83 c4 10             	add    $0x10,%esp
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
   11301:	8b 44 24 28          	mov    0x28(%esp),%eax
   11305:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   11309:	3b 44 24 34          	cmp    0x34(%esp),%eax
   1130d:	7f 10                	jg     1131f <free_block+0x4b>
   1130f:	8b 44 24 28          	mov    0x28(%esp),%eax
   11313:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11317:	3b 44 24 34          	cmp    0x34(%esp),%eax
   1131b:	7e 02                	jle    1131f <free_block+0x4b>
   1131d:	eb 10                	jmp    1132f <free_block+0x5b>
		panic("trying to free block not in datazone");
   1131f:	83 ec 0c             	sub    $0xc,%esp
   11322:	68 e8 90 01 00       	push   $0x190e8
   11327:	e8 ed 6f ff ff       	call   8319 <panic>
   1132c:	83 c4 10             	add    $0x10,%esp
	bh = get_hash_table(dev,block);
   1132f:	83 ec 08             	sub    $0x8,%esp
   11332:	ff 74 24 3c          	pushl  0x3c(%esp)
   11336:	ff 74 24 3c          	pushl  0x3c(%esp)
   1133a:	e8 a5 af ff ff       	call   c2e4 <get_hash_table>
   1133f:	83 c4 10             	add    $0x10,%esp
   11342:	89 44 24 24          	mov    %eax,0x24(%esp)
	if (bh) {
   11346:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   1134b:	74 4c                	je     11399 <free_block+0xc5>
		if (bh->b_count != 1) {
   1134d:	8b 44 24 24          	mov    0x24(%esp),%eax
   11351:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
   11355:	74 23                	je     1137a <free_block+0xa6>
			printk("trying to free block (%04x:%d), count=%d\n",
   11357:	8b 44 24 24          	mov    0x24(%esp),%eax
   1135b:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
   1135f:	50                   	push   %eax
   11360:	ff 74 24 38          	pushl  0x38(%esp)
   11364:	ff 74 24 38          	pushl  0x38(%esp)
   11368:	68 10 91 01 00       	push   $0x19110
   1136d:	e8 e1 6f ff ff       	call   8353 <printk>
   11372:	83 c4 10             	add    $0x10,%esp
				dev,block,bh->b_count);
			return;
   11375:	e9 fc 00 00 00       	jmp    11476 <free_block+0x1a2>
		}
		bh->b_dirt=0;
   1137a:	8b 44 24 24          	mov    0x24(%esp),%eax
   1137e:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
		bh->b_uptodate=0;
   11382:	8b 44 24 24          	mov    0x24(%esp),%eax
   11386:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
		brelse(bh);
   1138a:	83 ec 0c             	sub    $0xc,%esp
   1138d:	ff 74 24 30          	pushl  0x30(%esp)
   11391:	e8 21 b3 ff ff       	call   c6b7 <brelse>
   11396:	83 c4 10             	add    $0x10,%esp
	}
	block -= sb->s_firstdatazone - 1 ;
   11399:	8b 44 24 28          	mov    0x28(%esp),%eax
   1139d:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   113a1:	8b 44 24 34          	mov    0x34(%esp),%eax
   113a5:	29 d0                	sub    %edx,%eax
   113a7:	40                   	inc    %eax
   113a8:	89 44 24 34          	mov    %eax,0x34(%esp)
	if (clear_bit(block&8191,sb->s_zmap[block/8192]->b_data)) {
   113ac:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
   113b3:	00 
   113b4:	8b 44 24 34          	mov    0x34(%esp),%eax
   113b8:	25 ff 1f 00 00       	and    $0x1fff,%eax
   113bd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   113c1:	8b 54 24 28          	mov    0x28(%esp),%edx
   113c5:	89 54 24 18          	mov    %edx,0x18(%esp)
   113c9:	8b 44 24 34          	mov    0x34(%esp),%eax
   113cd:	89 44 24 14          	mov    %eax,0x14(%esp)
   113d1:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   113d6:	79 08                	jns    113e0 <free_block+0x10c>
   113d8:	81 44 24 14 ff 1f 00 	addl   $0x1fff,0x14(%esp)
   113df:	00 
   113e0:	8b 44 24 14          	mov    0x14(%esp),%eax
   113e4:	c1 f8 0d             	sar    $0xd,%eax
   113e7:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   113eb:	8b 44 81 34          	mov    0x34(%ecx,%eax,4),%eax
   113ef:	8b 00                	mov    (%eax),%eax
   113f1:	89 44 24 08          	mov    %eax,0x8(%esp)
   113f5:	8b 44 24 20          	mov    0x20(%esp),%eax
   113f9:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   113fd:	8b 54 24 08          	mov    0x8(%esp),%edx
   11401:	0f b3 0a             	btr    %ecx,(%edx)
   11404:	0f 93 c0             	setae  %al
   11407:	89 44 24 08          	mov    %eax,0x8(%esp)
   1140b:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   11410:	74 32                	je     11444 <free_block+0x170>
		printk("block (%04x:%d) ",dev,block+sb->s_firstdatazone-1);
   11412:	83 ec 04             	sub    $0x4,%esp
   11415:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   11419:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   1141d:	03 44 24 38          	add    0x38(%esp),%eax
   11421:	48                   	dec    %eax
   11422:	50                   	push   %eax
   11423:	ff 74 24 38          	pushl  0x38(%esp)
   11427:	68 3a 91 01 00       	push   $0x1913a
   1142c:	e8 22 6f ff ff       	call   8353 <printk>
   11431:	83 c4 10             	add    $0x10,%esp
		panic("free_block: bit already cleared");
   11434:	83 ec 0c             	sub    $0xc,%esp
   11437:	68 4c 91 01 00       	push   $0x1914c
   1143c:	e8 d8 6e ff ff       	call   8319 <panic>
   11441:	83 c4 10             	add    $0x10,%esp
	}
	sb->s_zmap[block/8192]->b_dirt = 1;
   11444:	8b 44 24 28          	mov    0x28(%esp),%eax
   11448:	89 44 24 10          	mov    %eax,0x10(%esp)
   1144c:	8b 44 24 34          	mov    0x34(%esp),%eax
   11450:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11454:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11459:	79 08                	jns    11463 <free_block+0x18f>
   1145b:	81 44 24 0c ff 1f 00 	addl   $0x1fff,0xc(%esp)
   11462:	00 
   11463:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11467:	c1 f8 0d             	sar    $0xd,%eax
   1146a:	8b 54 24 10          	mov    0x10(%esp),%edx
   1146e:	8b 44 82 34          	mov    0x34(%edx,%eax,4),%eax
   11472:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
}
   11476:	83 c4 2c             	add    $0x2c,%esp
   11479:	c3                   	ret    

0001147a <new_block>:

int new_block(int dev)
{
   1147a:	57                   	push   %edi
   1147b:	56                   	push   %esi
   1147c:	53                   	push   %ebx
   1147d:	83 ec 20             	sub    $0x20,%esp
	struct buffer_head * bh;
	struct super_block * sb;
	int i,j;

	if (!(sb = get_super(dev)))
   11480:	83 ec 0c             	sub    $0xc,%esp
   11483:	ff 74 24 3c          	pushl  0x3c(%esp)
   11487:	e8 c4 b6 ff ff       	call   cb50 <get_super>
   1148c:	83 c4 10             	add    $0x10,%esp
   1148f:	89 44 24 18          	mov    %eax,0x18(%esp)
   11493:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   11498:	75 10                	jne    114aa <new_block+0x30>
		panic("trying to get new block from nonexistant device");
   1149a:	83 ec 0c             	sub    $0xc,%esp
   1149d:	68 6c 91 01 00       	push   $0x1916c
   114a2:	e8 72 6e ff ff       	call   8319 <panic>
   114a7:	83 c4 10             	add    $0x10,%esp
	j = 8192;
   114aa:	c7 44 24 10 00 20 00 	movl   $0x2000,0x10(%esp)
   114b1:	00 
	for (i=0 ; i<8 ; i++)
   114b2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   114b9:	00 
   114ba:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
   114bf:	7f 56                	jg     11517 <new_block+0x9d>
		if ((bh=sb->s_zmap[i]))
   114c1:	8b 44 24 18          	mov    0x18(%esp),%eax
   114c5:	8b 54 24 14          	mov    0x14(%esp),%edx
   114c9:	8b 44 90 34          	mov    0x34(%eax,%edx,4),%eax
   114cd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   114d1:	85 c0                	test   %eax,%eax
   114d3:	74 3a                	je     1150f <new_block+0x95>
			if ((j=find_first_zero(bh->b_data))<8192)
   114d5:	b9 00 00 00 00       	mov    $0x0,%ecx
   114da:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   114de:	8b 30                	mov    (%eax),%esi
   114e0:	fc                   	cld    
   114e1:	ad                   	lods   %ds:(%esi),%eax
   114e2:	f7 d0                	not    %eax
   114e4:	0f bc d0             	bsf    %eax,%edx
   114e7:	74 04                	je     114ed <new_block+0x73>
   114e9:	01 d1                	add    %edx,%ecx
   114eb:	eb 0b                	jmp    114f8 <new_block+0x7e>
   114ed:	83 c1 20             	add    $0x20,%ecx
   114f0:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
   114f6:	7c e9                	jl     114e1 <new_block+0x67>
   114f8:	89 c8                	mov    %ecx,%eax
   114fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
   114fe:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11502:	89 44 24 10          	mov    %eax,0x10(%esp)
   11506:	3d ff 1f 00 00       	cmp    $0x1fff,%eax
   1150b:	7f 02                	jg     1150f <new_block+0x95>
				break;
   1150d:	eb 08                	jmp    11517 <new_block+0x9d>
	for (i=0 ; i<8 ; i++)
   1150f:	8d 44 24 14          	lea    0x14(%esp),%eax
   11513:	ff 00                	incl   (%eax)
   11515:	eb a3                	jmp    114ba <new_block+0x40>
	if (i>=8 || !bh || j>=8192)
   11517:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
   1151c:	7f 13                	jg     11531 <new_block+0xb7>
   1151e:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   11523:	74 0c                	je     11531 <new_block+0xb7>
   11525:	81 7c 24 10 ff 1f 00 	cmpl   $0x1fff,0x10(%esp)
   1152c:	00 
   1152d:	7f 02                	jg     11531 <new_block+0xb7>
   1152f:	eb 0d                	jmp    1153e <new_block+0xc4>
		return 0;
   11531:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   11538:	00 
   11539:	e9 fe 00 00 00       	jmp    1163c <new_block+0x1c2>
	if (set_bit(j,bh->b_data))
   1153e:	b9 00 00 00 00       	mov    $0x0,%ecx
   11543:	8b 54 24 10          	mov    0x10(%esp),%edx
   11547:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1154b:	8b 00                	mov    (%eax),%eax
   1154d:	89 44 24 04          	mov    %eax,0x4(%esp)
   11551:	89 c8                	mov    %ecx,%eax
   11553:	8b 5c 24 04          	mov    0x4(%esp),%ebx
   11557:	0f ab 13             	bts    %edx,(%ebx)
   1155a:	0f 92 c0             	setb   %al
   1155d:	89 44 24 04          	mov    %eax,0x4(%esp)
   11561:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   11566:	74 10                	je     11578 <new_block+0xfe>
		panic("new_block: bit already set");
   11568:	83 ec 0c             	sub    $0xc,%esp
   1156b:	68 9c 91 01 00       	push   $0x1919c
   11570:	e8 a4 6d ff ff       	call   8319 <panic>
   11575:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   11578:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1157c:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	j += i*8192 + sb->s_firstdatazone-1;
   11580:	8b 44 24 14          	mov    0x14(%esp),%eax
   11584:	89 c2                	mov    %eax,%edx
   11586:	c1 e2 0d             	shl    $0xd,%edx
   11589:	8b 44 24 18          	mov    0x18(%esp),%eax
   1158d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   11591:	8d 04 02             	lea    (%edx,%eax,1),%eax
   11594:	03 44 24 10          	add    0x10(%esp),%eax
   11598:	48                   	dec    %eax
   11599:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (j >= sb->s_nzones)
   1159d:	8b 44 24 18          	mov    0x18(%esp),%eax
   115a1:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   115a5:	3b 44 24 10          	cmp    0x10(%esp),%eax
   115a9:	7f 0d                	jg     115b8 <new_block+0x13e>
		return 0;
   115ab:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   115b2:	00 
   115b3:	e9 84 00 00 00       	jmp    1163c <new_block+0x1c2>
	if (!(bh=getblk(dev,j)))
   115b8:	83 ec 08             	sub    $0x8,%esp
   115bb:	ff 74 24 18          	pushl  0x18(%esp)
   115bf:	ff 74 24 3c          	pushl  0x3c(%esp)
   115c3:	e8 90 ad ff ff       	call   c358 <getblk>
   115c8:	83 c4 10             	add    $0x10,%esp
   115cb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   115cf:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   115d4:	75 10                	jne    115e6 <new_block+0x16c>
		panic("new_block: cannot get block");
   115d6:	83 ec 0c             	sub    $0xc,%esp
   115d9:	68 b7 91 01 00       	push   $0x191b7
   115de:	e8 36 6d ff ff       	call   8319 <panic>
   115e3:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count != 1)
   115e6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   115ea:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
   115ee:	74 10                	je     11600 <new_block+0x186>
		panic("new block: count is != 1");
   115f0:	83 ec 0c             	sub    $0xc,%esp
   115f3:	68 d3 91 01 00       	push   $0x191d3
   115f8:	e8 1c 6d ff ff       	call   8319 <panic>
   115fd:	83 c4 10             	add    $0x10,%esp
	clear_block(bh->b_data);
   11600:	ba 00 00 00 00       	mov    $0x0,%edx
   11605:	b9 00 01 00 00       	mov    $0x100,%ecx
   1160a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1160e:	8b 38                	mov    (%eax),%edi
   11610:	89 d0                	mov    %edx,%eax
   11612:	fc                   	cld    
   11613:	f3 ab                	rep stos %eax,%es:(%edi)
	bh->b_uptodate = 1;
   11615:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11619:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
	bh->b_dirt = 1;
   1161d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11621:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
   11625:	83 ec 0c             	sub    $0xc,%esp
   11628:	ff 74 24 28          	pushl  0x28(%esp)
   1162c:	e8 86 b0 ff ff       	call   c6b7 <brelse>
   11631:	83 c4 10             	add    $0x10,%esp
	return j;
   11634:	8b 44 24 10          	mov    0x10(%esp),%eax
   11638:	89 44 24 08          	mov    %eax,0x8(%esp)
}
   1163c:	8b 44 24 08          	mov    0x8(%esp),%eax
   11640:	83 c4 20             	add    $0x20,%esp
   11643:	5b                   	pop    %ebx
   11644:	5e                   	pop    %esi
   11645:	5f                   	pop    %edi
   11646:	c3                   	ret    

00011647 <free_inode>:

void free_inode(struct m_inode * inode)
{
   11647:	53                   	push   %ebx
   11648:	83 ec 18             	sub    $0x18,%esp
	struct super_block * sb;
	struct buffer_head * bh;

	if (!inode)
   1164b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   11650:	75 05                	jne    11657 <free_inode+0x10>
		return;
   11652:	e9 5e 01 00 00       	jmp    117b5 <free_inode+0x16e>
	if (!inode->i_dev) {
   11657:	8b 44 24 20          	mov    0x20(%esp),%eax
   1165b:	66 83 78 2c 00       	cmpw   $0x0,0x2c(%eax)
   11660:	75 18                	jne    1167a <free_inode+0x33>
		memset(inode,0,sizeof(*inode));
   11662:	83 ec 04             	sub    $0x4,%esp
   11665:	6a 38                	push   $0x38
   11667:	6a 00                	push   $0x0
   11669:	ff 74 24 2c          	pushl  0x2c(%esp)
   1166d:	e8 48 01 00 00       	call   117ba <memset>
   11672:	83 c4 10             	add    $0x10,%esp
		return;
   11675:	e9 3b 01 00 00       	jmp    117b5 <free_inode+0x16e>
	}
	if (inode->i_count>1) {
   1167a:	8b 44 24 20          	mov    0x20(%esp),%eax
   1167e:	66 83 78 30 01       	cmpw   $0x1,0x30(%eax)
   11683:	76 29                	jbe    116ae <free_inode+0x67>
		printk("trying to free inode with count=%d\n",inode->i_count);
   11685:	83 ec 08             	sub    $0x8,%esp
   11688:	8b 44 24 28          	mov    0x28(%esp),%eax
   1168c:	0f b7 40 30          	movzwl 0x30(%eax),%eax
   11690:	50                   	push   %eax
   11691:	68 ec 91 01 00       	push   $0x191ec
   11696:	e8 b8 6c ff ff       	call   8353 <printk>
   1169b:	83 c4 10             	add    $0x10,%esp
		panic("free_inode");
   1169e:	83 ec 0c             	sub    $0xc,%esp
   116a1:	68 10 92 01 00       	push   $0x19210
   116a6:	e8 6e 6c ff ff       	call   8319 <panic>
   116ab:	83 c4 10             	add    $0x10,%esp
	}
	if (inode->i_nlinks)
   116ae:	8b 44 24 20          	mov    0x20(%esp),%eax
   116b2:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   116b6:	74 10                	je     116c8 <free_inode+0x81>
		panic("trying to free inode with links");
   116b8:	83 ec 0c             	sub    $0xc,%esp
   116bb:	68 1c 92 01 00       	push   $0x1921c
   116c0:	e8 54 6c ff ff       	call   8319 <panic>
   116c5:	83 c4 10             	add    $0x10,%esp
	if (!(sb = get_super(inode->i_dev)))
   116c8:	83 ec 0c             	sub    $0xc,%esp
   116cb:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   116cf:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   116d3:	50                   	push   %eax
   116d4:	e8 77 b4 ff ff       	call   cb50 <get_super>
   116d9:	83 c4 10             	add    $0x10,%esp
   116dc:	89 44 24 14          	mov    %eax,0x14(%esp)
   116e0:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   116e5:	75 10                	jne    116f7 <free_inode+0xb0>
		panic("trying to free inode on nonexistent device");
   116e7:	83 ec 0c             	sub    $0xc,%esp
   116ea:	68 3c 92 01 00       	push   $0x1923c
   116ef:	e8 25 6c ff ff       	call   8319 <panic>
   116f4:	83 c4 10             	add    $0x10,%esp
	if (inode->i_num < 1 || inode->i_num > sb->s_ninodes)
   116f7:	8b 44 24 20          	mov    0x20(%esp),%eax
   116fb:	66 83 78 2e 00       	cmpw   $0x0,0x2e(%eax)
   11700:	74 13                	je     11715 <free_inode+0xce>
   11702:	8b 44 24 20          	mov    0x20(%esp),%eax
   11706:	8b 54 24 14          	mov    0x14(%esp),%edx
   1170a:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   1170e:	66 3b 02             	cmp    (%edx),%ax
   11711:	77 02                	ja     11715 <free_inode+0xce>
   11713:	eb 10                	jmp    11725 <free_inode+0xde>
		panic("trying to free inode 0 or nonexistant inode");
   11715:	83 ec 0c             	sub    $0xc,%esp
   11718:	68 68 92 01 00       	push   $0x19268
   1171d:	e8 f7 6b ff ff       	call   8319 <panic>
   11722:	83 c4 10             	add    $0x10,%esp
	if (!(bh=sb->s_imap[inode->i_num>>13]))
   11725:	8b 54 24 14          	mov    0x14(%esp),%edx
   11729:	8b 44 24 20          	mov    0x20(%esp),%eax
   1172d:	66 8b 40 2e          	mov    0x2e(%eax),%ax
   11731:	66 c1 e8 0d          	shr    $0xd,%ax
   11735:	0f b7 c0             	movzwl %ax,%eax
   11738:	8b 44 82 14          	mov    0x14(%edx,%eax,4),%eax
   1173c:	89 44 24 10          	mov    %eax,0x10(%esp)
   11740:	85 c0                	test   %eax,%eax
   11742:	75 10                	jne    11754 <free_inode+0x10d>
		panic("nonexistent imap in superblock");
   11744:	83 ec 0c             	sub    $0xc,%esp
   11747:	68 94 92 01 00       	push   $0x19294
   1174c:	e8 c8 6b ff ff       	call   8319 <panic>
   11751:	83 c4 10             	add    $0x10,%esp
	if (clear_bit(inode->i_num&8191,bh->b_data))
   11754:	b9 00 00 00 00       	mov    $0x0,%ecx
   11759:	8b 44 24 20          	mov    0x20(%esp),%eax
   1175d:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
   11761:	89 c2                	mov    %eax,%edx
   11763:	81 e2 ff 1f 00 00    	and    $0x1fff,%edx
   11769:	8b 44 24 10          	mov    0x10(%esp),%eax
   1176d:	8b 00                	mov    (%eax),%eax
   1176f:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11773:	89 c8                	mov    %ecx,%eax
   11775:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   11779:	0f b3 13             	btr    %edx,(%ebx)
   1177c:	0f 93 c0             	setae  %al
   1177f:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11783:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   11788:	74 10                	je     1179a <free_inode+0x153>
		printk("free_inode: bit already cleared.\n\r");
   1178a:	83 ec 0c             	sub    $0xc,%esp
   1178d:	68 b4 92 01 00       	push   $0x192b4
   11792:	e8 bc 6b ff ff       	call   8353 <printk>
   11797:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   1179a:	8b 44 24 10          	mov    0x10(%esp),%eax
   1179e:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	memset(inode,0,sizeof(*inode));
   117a2:	83 ec 04             	sub    $0x4,%esp
   117a5:	6a 38                	push   $0x38
   117a7:	6a 00                	push   $0x0
   117a9:	ff 74 24 2c          	pushl  0x2c(%esp)
   117ad:	e8 08 00 00 00       	call   117ba <memset>
   117b2:	83 c4 10             	add    $0x10,%esp
}
   117b5:	83 c4 18             	add    $0x18,%esp
   117b8:	5b                   	pop    %ebx
   117b9:	c3                   	ret    

000117ba <memset>:
{
   117ba:	57                   	push   %edi
   117bb:	83 ec 04             	sub    $0x4,%esp
   117be:	8b 44 24 10          	mov    0x10(%esp),%eax
   117c2:	88 44 24 03          	mov    %al,0x3(%esp)
__asm__("cld\n\t"
   117c6:	8a 44 24 03          	mov    0x3(%esp),%al
   117ca:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   117ce:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   117d2:	fc                   	cld    
   117d3:	f3 aa                	rep stos %al,%es:(%edi)
return s;
   117d5:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   117d9:	83 c4 04             	add    $0x4,%esp
   117dc:	5f                   	pop    %edi
   117dd:	c3                   	ret    

000117de <new_inode>:

struct m_inode * new_inode(int dev)
{
   117de:	57                   	push   %edi
   117df:	56                   	push   %esi
   117e0:	53                   	push   %ebx
   117e1:	83 ec 20             	sub    $0x20,%esp
	struct m_inode * inode;
	struct super_block * sb;
	struct buffer_head * bh;
	int i,j;

	if (!(inode=get_empty_inode()))
   117e4:	e8 c2 a1 ff ff       	call   b9ab <get_empty_inode>
   117e9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   117ed:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   117f2:	75 0d                	jne    11801 <new_inode+0x23>
		return NULL;
   117f4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   117fb:	00 
   117fc:	e9 c0 01 00 00       	jmp    119c1 <new_inode+0x1e3>
	if (!(sb = get_super(dev)))
   11801:	83 ec 0c             	sub    $0xc,%esp
   11804:	ff 74 24 3c          	pushl  0x3c(%esp)
   11808:	e8 43 b3 ff ff       	call   cb50 <get_super>
   1180d:	83 c4 10             	add    $0x10,%esp
   11810:	89 44 24 18          	mov    %eax,0x18(%esp)
   11814:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   11819:	75 10                	jne    1182b <new_inode+0x4d>
		panic("new_inode with unknown device");
   1181b:	83 ec 0c             	sub    $0xc,%esp
   1181e:	68 d7 92 01 00       	push   $0x192d7
   11823:	e8 f1 6a ff ff       	call   8319 <panic>
   11828:	83 c4 10             	add    $0x10,%esp
	j = 8192;
   1182b:	c7 44 24 0c 00 20 00 	movl   $0x2000,0xc(%esp)
   11832:	00 
	for (i=0 ; i<8 ; i++)
   11833:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1183a:	00 
   1183b:	83 7c 24 10 07       	cmpl   $0x7,0x10(%esp)
   11840:	7f 56                	jg     11898 <new_inode+0xba>
		if ((bh=sb->s_imap[i]))
   11842:	8b 44 24 18          	mov    0x18(%esp),%eax
   11846:	8b 54 24 10          	mov    0x10(%esp),%edx
   1184a:	8b 44 90 14          	mov    0x14(%eax,%edx,4),%eax
   1184e:	89 44 24 14          	mov    %eax,0x14(%esp)
   11852:	85 c0                	test   %eax,%eax
   11854:	74 3a                	je     11890 <new_inode+0xb2>
			if ((j=find_first_zero(bh->b_data))<8192)
   11856:	b9 00 00 00 00       	mov    $0x0,%ecx
   1185b:	8b 44 24 14          	mov    0x14(%esp),%eax
   1185f:	8b 30                	mov    (%eax),%esi
   11861:	fc                   	cld    
   11862:	ad                   	lods   %ds:(%esi),%eax
   11863:	f7 d0                	not    %eax
   11865:	0f bc d0             	bsf    %eax,%edx
   11868:	74 04                	je     1186e <new_inode+0x90>
   1186a:	01 d1                	add    %edx,%ecx
   1186c:	eb 0b                	jmp    11879 <new_inode+0x9b>
   1186e:	83 c1 20             	add    $0x20,%ecx
   11871:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
   11877:	7c e9                	jl     11862 <new_inode+0x84>
   11879:	89 c8                	mov    %ecx,%eax
   1187b:	89 44 24 08          	mov    %eax,0x8(%esp)
   1187f:	8b 44 24 08          	mov    0x8(%esp),%eax
   11883:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11887:	3d ff 1f 00 00       	cmp    $0x1fff,%eax
   1188c:	7f 02                	jg     11890 <new_inode+0xb2>
				break;
   1188e:	eb 08                	jmp    11898 <new_inode+0xba>
	for (i=0 ; i<8 ; i++)
   11890:	8d 44 24 10          	lea    0x10(%esp),%eax
   11894:	ff 00                	incl   (%eax)
   11896:	eb a3                	jmp    1183b <new_inode+0x5d>
	if (!bh || j >= 8192 || j+i*8192 > sb->s_ninodes) {
   11898:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1189d:	74 24                	je     118c3 <new_inode+0xe5>
   1189f:	81 7c 24 0c ff 1f 00 	cmpl   $0x1fff,0xc(%esp)
   118a6:	00 
   118a7:	7f 1a                	jg     118c3 <new_inode+0xe5>
   118a9:	8b 44 24 10          	mov    0x10(%esp),%eax
   118ad:	c1 e0 0d             	shl    $0xd,%eax
   118b0:	89 c2                	mov    %eax,%edx
   118b2:	03 54 24 0c          	add    0xc(%esp),%edx
   118b6:	8b 44 24 18          	mov    0x18(%esp),%eax
   118ba:	0f b7 00             	movzwl (%eax),%eax
   118bd:	39 c2                	cmp    %eax,%edx
   118bf:	7f 02                	jg     118c3 <new_inode+0xe5>
   118c1:	eb 1c                	jmp    118df <new_inode+0x101>
		iput(inode);
   118c3:	83 ec 0c             	sub    $0xc,%esp
   118c6:	ff 74 24 28          	pushl  0x28(%esp)
   118ca:	e8 7e 9f ff ff       	call   b84d <iput>
   118cf:	83 c4 10             	add    $0x10,%esp
		return NULL;
   118d2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   118d9:	00 
   118da:	e9 e2 00 00 00       	jmp    119c1 <new_inode+0x1e3>
	}
	if (set_bit(j,bh->b_data))
   118df:	b9 00 00 00 00       	mov    $0x0,%ecx
   118e4:	8b 54 24 0c          	mov    0xc(%esp),%edx
   118e8:	8b 44 24 14          	mov    0x14(%esp),%eax
   118ec:	8b 00                	mov    (%eax),%eax
   118ee:	89 04 24             	mov    %eax,(%esp)
   118f1:	89 c8                	mov    %ecx,%eax
   118f3:	8b 1c 24             	mov    (%esp),%ebx
   118f6:	0f ab 13             	bts    %edx,(%ebx)
   118f9:	0f 92 c0             	setb   %al
   118fc:	89 04 24             	mov    %eax,(%esp)
   118ff:	83 3c 24 00          	cmpl   $0x0,(%esp)
   11903:	74 10                	je     11915 <new_inode+0x137>
		panic("new_inode: bit already set");
   11905:	83 ec 0c             	sub    $0xc,%esp
   11908:	68 f5 92 01 00       	push   $0x192f5
   1190d:	e8 07 6a ff ff       	call   8319 <panic>
   11912:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
   11915:	8b 44 24 14          	mov    0x14(%esp),%eax
   11919:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	inode->i_count=1;
   1191d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11921:	66 c7 40 30 01 00    	movw   $0x1,0x30(%eax)
	inode->i_nlinks=1;
   11927:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1192b:	c6 40 0d 01          	movb   $0x1,0xd(%eax)
	inode->i_dev=dev;
   1192f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   11933:	8b 44 24 30          	mov    0x30(%esp),%eax
   11937:	66 89 42 2c          	mov    %ax,0x2c(%edx)
	inode->i_uid=current->euid;
   1193b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1193f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   11944:	66 8b 80 42 02 00 00 	mov    0x242(%eax),%ax
   1194b:	66 89 42 02          	mov    %ax,0x2(%edx)
	inode->i_gid=current->egid;
   1194f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   11953:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   11958:	66 8b 80 48 02 00 00 	mov    0x248(%eax),%ax
   1195f:	88 42 0c             	mov    %al,0xc(%edx)
	inode->i_dirt=1;
   11962:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11966:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_num = j + i*8192;
   1196a:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   1196e:	8b 44 24 10          	mov    0x10(%esp),%eax
   11972:	89 c2                	mov    %eax,%edx
   11974:	c1 e2 0d             	shl    $0xd,%edx
   11977:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1197b:	8d 04 02             	lea    (%edx,%eax,1),%eax
   1197e:	66 89 41 2e          	mov    %ax,0x2e(%ecx)
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
   11982:	8b 74 24 1c          	mov    0x1c(%esp),%esi
   11986:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
   1198a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
   1198e:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   11994:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   11999:	f7 e9                	imul   %ecx
   1199b:	c1 fa 05             	sar    $0x5,%edx
   1199e:	89 c8                	mov    %ecx,%eax
   119a0:	c1 f8 1f             	sar    $0x1f,%eax
   119a3:	29 c2                	sub    %eax,%edx
   119a5:	89 d0                	mov    %edx,%eax
   119a7:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   119ad:	89 43 28             	mov    %eax,0x28(%ebx)
   119b0:	8b 43 28             	mov    0x28(%ebx),%eax
   119b3:	89 47 24             	mov    %eax,0x24(%edi)
   119b6:	89 46 08             	mov    %eax,0x8(%esi)
	return inode;
   119b9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   119bd:	89 44 24 04          	mov    %eax,0x4(%esp)
}
   119c1:	8b 44 24 04          	mov    0x4(%esp),%eax
   119c5:	83 c4 20             	add    $0x20,%esp
   119c8:	5b                   	pop    %ebx
   119c9:	5e                   	pop    %esi
   119ca:	5f                   	pop    %edi
   119cb:	c3                   	ret    

000119cc <dupfd>:
#include <sys/stat.h>

extern int sys_close(int fd);

static int dupfd(unsigned int fd, unsigned int arg)
{
   119cc:	53                   	push   %ebx
   119cd:	83 ec 04             	sub    $0x4,%esp
	if (fd >= NR_OPEN || !current->filp[fd])
   119d0:	83 7c 24 0c 13       	cmpl   $0x13,0xc(%esp)
   119d5:	77 14                	ja     119eb <dupfd+0x1f>
   119d7:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   119dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
   119e1:	83 bc 82 80 02 00 00 	cmpl   $0x0,0x280(%edx,%eax,4)
   119e8:	00 
   119e9:	75 0c                	jne    119f7 <dupfd+0x2b>
		return -EBADF;
   119eb:	c7 04 24 f7 ff ff ff 	movl   $0xfffffff7,(%esp)
   119f2:	e9 98 00 00 00       	jmp    11a8f <dupfd+0xc3>
	if (arg >= NR_OPEN)
   119f7:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   119fc:	76 0c                	jbe    11a0a <dupfd+0x3e>
		return -EINVAL;
   119fe:	c7 04 24 ea ff ff ff 	movl   $0xffffffea,(%esp)
   11a05:	e9 85 00 00 00       	jmp    11a8f <dupfd+0xc3>
	while (arg < NR_OPEN)
   11a0a:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   11a0f:	77 1c                	ja     11a2d <dupfd+0x61>
		if (current->filp[arg])
   11a11:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   11a17:	8b 44 24 10          	mov    0x10(%esp),%eax
   11a1b:	83 bc 82 80 02 00 00 	cmpl   $0x0,0x280(%edx,%eax,4)
   11a22:	00 
   11a23:	74 08                	je     11a2d <dupfd+0x61>
			arg++;
   11a25:	8d 44 24 10          	lea    0x10(%esp),%eax
   11a29:	ff 00                	incl   (%eax)
   11a2b:	eb dd                	jmp    11a0a <dupfd+0x3e>
		else
			break;
	if (arg >= NR_OPEN)
   11a2d:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   11a32:	76 09                	jbe    11a3d <dupfd+0x71>
		return -EMFILE;
   11a34:	c7 04 24 e8 ff ff ff 	movl   $0xffffffe8,(%esp)
   11a3b:	eb 52                	jmp    11a8f <dupfd+0xc3>
	current->close_on_exec &= ~(1<<arg);
   11a3d:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
   11a43:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   11a49:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   11a4d:	b8 01 00 00 00       	mov    $0x1,%eax
   11a52:	d3 e0                	shl    %cl,%eax
   11a54:	f7 d0                	not    %eax
   11a56:	23 82 7c 02 00 00    	and    0x27c(%edx),%eax
   11a5c:	89 83 7c 02 00 00    	mov    %eax,0x27c(%ebx)
	(current->filp[arg] = current->filp[fd])->f_count++;
   11a62:	8b 0d 20 bc 01 00    	mov    0x1bc20,%ecx
   11a68:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   11a6c:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   11a72:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11a76:	8b 84 82 80 02 00 00 	mov    0x280(%edx,%eax,4),%eax
   11a7d:	89 84 99 80 02 00 00 	mov    %eax,0x280(%ecx,%ebx,4)
   11a84:	66 ff 40 04          	incw   0x4(%eax)
	return arg;
   11a88:	8b 44 24 10          	mov    0x10(%esp),%eax
   11a8c:	89 04 24             	mov    %eax,(%esp)
}
   11a8f:	8b 04 24             	mov    (%esp),%eax
   11a92:	83 c4 04             	add    $0x4,%esp
   11a95:	5b                   	pop    %ebx
   11a96:	c3                   	ret    

00011a97 <sys_dup2>:

int sys_dup2(unsigned int oldfd, unsigned int newfd)
{
   11a97:	83 ec 0c             	sub    $0xc,%esp
	sys_close(newfd);
   11a9a:	83 ec 0c             	sub    $0xc,%esp
   11a9d:	ff 74 24 20          	pushl  0x20(%esp)
   11aa1:	e8 11 93 ff ff       	call   adb7 <sys_close>
   11aa6:	83 c4 10             	add    $0x10,%esp
	return dupfd(oldfd,newfd);
   11aa9:	ff 74 24 14          	pushl  0x14(%esp)
   11aad:	ff 74 24 14          	pushl  0x14(%esp)
   11ab1:	e8 16 ff ff ff       	call   119cc <dupfd>
   11ab6:	83 c4 08             	add    $0x8,%esp
}
   11ab9:	83 c4 0c             	add    $0xc,%esp
   11abc:	c3                   	ret    

00011abd <sys_dup>:

int sys_dup(unsigned int fildes)
{
	return dupfd(fildes,0);
   11abd:	6a 00                	push   $0x0
   11abf:	ff 74 24 08          	pushl  0x8(%esp)
   11ac3:	e8 04 ff ff ff       	call   119cc <dupfd>
   11ac8:	83 c4 08             	add    $0x8,%esp
}
   11acb:	c3                   	ret    

00011acc <sys_fcntl>:

int sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg)
{	
   11acc:	53                   	push   %ebx
   11acd:	83 ec 08             	sub    $0x8,%esp
	struct file * filp;

	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
   11ad0:	83 7c 24 10 13       	cmpl   $0x13,0x10(%esp)
   11ad5:	77 18                	ja     11aef <sys_fcntl+0x23>
   11ad7:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   11adc:	8b 54 24 10          	mov    0x10(%esp),%edx
   11ae0:	8b 84 90 80 02 00 00 	mov    0x280(%eax,%edx,4),%eax
   11ae7:	89 44 24 04          	mov    %eax,0x4(%esp)
   11aeb:	85 c0                	test   %eax,%eax
   11aed:	75 0c                	jne    11afb <sys_fcntl+0x2f>
		return -EBADF;
   11aef:	c7 04 24 f7 ff ff ff 	movl   $0xfffffff7,(%esp)
   11af6:	e9 fe 00 00 00       	jmp    11bf9 <sys_fcntl+0x12d>
	switch (cmd) {
   11afb:	83 7c 24 14 07       	cmpl   $0x7,0x14(%esp)
   11b00:	0f 87 ec 00 00 00    	ja     11bf2 <sys_fcntl+0x126>
   11b06:	8b 44 24 14          	mov    0x14(%esp),%eax
   11b0a:	c1 e0 02             	shl    $0x2,%eax
   11b0d:	8b 80 10 93 01 00    	mov    0x19310(%eax),%eax
   11b13:	ff e0                	jmp    *%eax
		case F_DUPFD:
			return dupfd(fd,arg);
   11b15:	ff 74 24 18          	pushl  0x18(%esp)
   11b19:	ff 74 24 14          	pushl  0x14(%esp)
   11b1d:	e8 aa fe ff ff       	call   119cc <dupfd>
   11b22:	83 c4 08             	add    $0x8,%esp
   11b25:	89 04 24             	mov    %eax,(%esp)
   11b28:	e9 cc 00 00 00       	jmp    11bf9 <sys_fcntl+0x12d>
		case F_GETFD:
			return (current->close_on_exec>>fd)&1;
   11b2d:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   11b32:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   11b36:	8b 80 7c 02 00 00    	mov    0x27c(%eax),%eax
   11b3c:	d3 e8                	shr    %cl,%eax
   11b3e:	83 e0 01             	and    $0x1,%eax
   11b41:	89 04 24             	mov    %eax,(%esp)
   11b44:	e9 b0 00 00 00       	jmp    11bf9 <sys_fcntl+0x12d>
		case F_SETFD:
			if (arg&1)
   11b49:	8b 44 24 18          	mov    0x18(%esp),%eax
   11b4d:	83 e0 01             	and    $0x1,%eax
   11b50:	85 c0                	test   %eax,%eax
   11b52:	74 25                	je     11b79 <sys_fcntl+0xad>
				current->close_on_exec |= (1<<fd);
   11b54:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
   11b5a:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   11b60:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   11b64:	b8 01 00 00 00       	mov    $0x1,%eax
   11b69:	d3 e0                	shl    %cl,%eax
   11b6b:	0b 82 7c 02 00 00    	or     0x27c(%edx),%eax
   11b71:	89 83 7c 02 00 00    	mov    %eax,0x27c(%ebx)
   11b77:	eb 25                	jmp    11b9e <sys_fcntl+0xd2>
			else
				current->close_on_exec &= ~(1<<fd);
   11b79:	8b 1d 20 bc 01 00    	mov    0x1bc20,%ebx
   11b7f:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   11b85:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   11b89:	b8 01 00 00 00       	mov    $0x1,%eax
   11b8e:	d3 e0                	shl    %cl,%eax
   11b90:	f7 d0                	not    %eax
   11b92:	23 82 7c 02 00 00    	and    0x27c(%edx),%eax
   11b98:	89 83 7c 02 00 00    	mov    %eax,0x27c(%ebx)
			return 0;
   11b9e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   11ba5:	eb 52                	jmp    11bf9 <sys_fcntl+0x12d>
		case F_GETFL:
			return filp->f_flags;
   11ba7:	8b 44 24 04          	mov    0x4(%esp),%eax
   11bab:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   11baf:	89 04 24             	mov    %eax,(%esp)
   11bb2:	eb 45                	jmp    11bf9 <sys_fcntl+0x12d>
		case F_SETFL:
			filp->f_flags &= ~(O_APPEND | O_NONBLOCK);
   11bb4:	8b 54 24 04          	mov    0x4(%esp),%edx
   11bb8:	8b 44 24 04          	mov    0x4(%esp),%eax
   11bbc:	66 8b 40 02          	mov    0x2(%eax),%ax
   11bc0:	80 e4 f3             	and    $0xf3,%ah
   11bc3:	66 89 42 02          	mov    %ax,0x2(%edx)
			filp->f_flags |= arg & (O_APPEND | O_NONBLOCK);
   11bc7:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   11bcb:	8b 54 24 04          	mov    0x4(%esp),%edx
   11bcf:	8b 44 24 18          	mov    0x18(%esp),%eax
   11bd3:	25 00 0c 00 00       	and    $0xc00,%eax
   11bd8:	66 0b 42 02          	or     0x2(%edx),%ax
   11bdc:	66 89 41 02          	mov    %ax,0x2(%ecx)
			return 0;
   11be0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   11be7:	eb 10                	jmp    11bf9 <sys_fcntl+0x12d>
		case F_GETLK:	case F_SETLK:	case F_SETLKW:
			return -1;
   11be9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
   11bf0:	eb 07                	jmp    11bf9 <sys_fcntl+0x12d>
		default:
			return -1;
   11bf2:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
	}
}
   11bf9:	8b 04 24             	mov    (%esp),%eax
   11bfc:	83 c4 08             	add    $0x8,%esp
   11bff:	5b                   	pop    %ebx
   11c00:	c3                   	ret    

00011c01 <sys_ioctl>:
	NULL,		/* /dev/lp */
	NULL};		/* named pipes */
	

int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
{	
   11c01:	83 ec 1c             	sub    $0x1c,%esp
	struct file * filp;
	int dev,mode;

	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
   11c04:	83 7c 24 20 13       	cmpl   $0x13,0x20(%esp)
   11c09:	77 18                	ja     11c23 <sys_ioctl+0x22>
   11c0b:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   11c10:	8b 54 24 20          	mov    0x20(%esp),%edx
   11c14:	8b 84 90 80 02 00 00 	mov    0x280(%eax,%edx,4),%eax
   11c1b:	89 44 24 18          	mov    %eax,0x18(%esp)
   11c1f:	85 c0                	test   %eax,%eax
   11c21:	75 0d                	jne    11c30 <sys_ioctl+0x2f>
		return -EBADF;
   11c23:	c7 44 24 0c f7 ff ff 	movl   $0xfffffff7,0xc(%esp)
   11c2a:	ff 
   11c2b:	e9 9e 00 00 00       	jmp    11cce <sys_ioctl+0xcd>
	mode=filp->f_inode->i_mode;
   11c30:	8b 44 24 18          	mov    0x18(%esp),%eax
   11c34:	8b 40 08             	mov    0x8(%eax),%eax
   11c37:	0f b7 00             	movzwl (%eax),%eax
   11c3a:	89 44 24 10          	mov    %eax,0x10(%esp)
	if (!S_ISCHR(mode) && !S_ISBLK(mode))
   11c3e:	8b 44 24 10          	mov    0x10(%esp),%eax
   11c42:	25 00 f0 00 00       	and    $0xf000,%eax
   11c47:	3d 00 20 00 00       	cmp    $0x2000,%eax
   11c4c:	74 1a                	je     11c68 <sys_ioctl+0x67>
   11c4e:	8b 44 24 10          	mov    0x10(%esp),%eax
   11c52:	25 00 f0 00 00       	and    $0xf000,%eax
   11c57:	3d 00 60 00 00       	cmp    $0x6000,%eax
   11c5c:	74 0a                	je     11c68 <sys_ioctl+0x67>
		return -EINVAL;
   11c5e:	c7 44 24 0c ea ff ff 	movl   $0xffffffea,0xc(%esp)
   11c65:	ff 
   11c66:	eb 66                	jmp    11cce <sys_ioctl+0xcd>
	dev = filp->f_inode->i_zone[0];
   11c68:	8b 44 24 18          	mov    0x18(%esp),%eax
   11c6c:	8b 40 08             	mov    0x8(%eax),%eax
   11c6f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   11c73:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (MAJOR(dev) >= NRDEVS)
   11c77:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c7b:	c1 e8 08             	shr    $0x8,%eax
   11c7e:	83 f8 07             	cmp    $0x7,%eax
   11c81:	76 0a                	jbe    11c8d <sys_ioctl+0x8c>
		return -ENODEV;
   11c83:	c7 44 24 0c ed ff ff 	movl   $0xffffffed,0xc(%esp)
   11c8a:	ff 
   11c8b:	eb 41                	jmp    11cce <sys_ioctl+0xcd>
	if (!ioctl_table[MAJOR(dev)])
   11c8d:	8b 44 24 14          	mov    0x14(%esp),%eax
   11c91:	c1 e8 08             	shr    $0x8,%eax
   11c94:	83 3c 85 20 be 01 00 	cmpl   $0x0,0x1be20(,%eax,4)
   11c9b:	00 
   11c9c:	75 0a                	jne    11ca8 <sys_ioctl+0xa7>
		return -ENOTTY;
   11c9e:	c7 44 24 0c e7 ff ff 	movl   $0xffffffe7,0xc(%esp)
   11ca5:	ff 
   11ca6:	eb 26                	jmp    11cce <sys_ioctl+0xcd>
	return ioctl_table[MAJOR(dev)](dev,cmd,arg);
   11ca8:	83 ec 04             	sub    $0x4,%esp
   11cab:	8b 44 24 18          	mov    0x18(%esp),%eax
   11caf:	c1 e8 08             	shr    $0x8,%eax
   11cb2:	ff 74 24 2c          	pushl  0x2c(%esp)
   11cb6:	ff 74 24 2c          	pushl  0x2c(%esp)
   11cba:	ff 74 24 20          	pushl  0x20(%esp)
   11cbe:	8b 04 85 20 be 01 00 	mov    0x1be20(,%eax,4),%eax
   11cc5:	ff d0                	call   *%eax
   11cc7:	83 c4 10             	add    $0x10,%esp
   11cca:	89 44 24 0c          	mov    %eax,0xc(%esp)
}
   11cce:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11cd2:	83 c4 1c             	add    $0x1c,%esp
   11cd5:	c3                   	ret    

00011cd6 <free_ind>:
#include <linux/sched.h>

#include <sys/stat.h>

static void free_ind(int dev,int block)
{
   11cd6:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * bh;
	unsigned short * p;
	int i;

	if (!block)
   11cd9:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   11cde:	75 05                	jne    11ce5 <free_ind+0xf>
		return;
   11ce0:	e9 88 00 00 00       	jmp    11d6d <free_ind+0x97>
	if ((bh=bread(dev,block))) {
   11ce5:	83 ec 08             	sub    $0x8,%esp
   11ce8:	ff 74 24 1c          	pushl  0x1c(%esp)
   11cec:	ff 74 24 1c          	pushl  0x1c(%esp)
   11cf0:	e8 0e aa ff ff       	call   c703 <bread>
   11cf5:	83 c4 10             	add    $0x10,%esp
   11cf8:	89 44 24 08          	mov    %eax,0x8(%esp)
   11cfc:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   11d01:	74 57                	je     11d5a <free_ind+0x84>
		p = (unsigned short *) bh->b_data;
   11d03:	8b 44 24 08          	mov    0x8(%esp),%eax
   11d07:	8b 00                	mov    (%eax),%eax
   11d09:	89 44 24 04          	mov    %eax,0x4(%esp)
		for (i=0;i<512;i++,p++)
   11d0d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   11d14:	81 3c 24 ff 01 00 00 	cmpl   $0x1ff,(%esp)
   11d1b:	7f 2e                	jg     11d4b <free_ind+0x75>
			if (*p)
   11d1d:	8b 44 24 04          	mov    0x4(%esp),%eax
   11d21:	66 83 38 00          	cmpw   $0x0,(%eax)
   11d25:	74 17                	je     11d3e <free_ind+0x68>
				free_block(dev,*p);
   11d27:	83 ec 08             	sub    $0x8,%esp
   11d2a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11d2e:	0f b7 00             	movzwl (%eax),%eax
   11d31:	50                   	push   %eax
   11d32:	ff 74 24 1c          	pushl  0x1c(%esp)
   11d36:	e8 99 f5 ff ff       	call   112d4 <free_block>
   11d3b:	83 c4 10             	add    $0x10,%esp
		for (i=0;i<512;i++,p++)
   11d3e:	89 e0                	mov    %esp,%eax
   11d40:	ff 00                	incl   (%eax)
   11d42:	8d 44 24 04          	lea    0x4(%esp),%eax
   11d46:	83 00 02             	addl   $0x2,(%eax)
   11d49:	eb c9                	jmp    11d14 <free_ind+0x3e>
		brelse(bh);
   11d4b:	83 ec 0c             	sub    $0xc,%esp
   11d4e:	ff 74 24 14          	pushl  0x14(%esp)
   11d52:	e8 60 a9 ff ff       	call   c6b7 <brelse>
   11d57:	83 c4 10             	add    $0x10,%esp
	}
	free_block(dev,block);
   11d5a:	83 ec 08             	sub    $0x8,%esp
   11d5d:	ff 74 24 1c          	pushl  0x1c(%esp)
   11d61:	ff 74 24 1c          	pushl  0x1c(%esp)
   11d65:	e8 6a f5 ff ff       	call   112d4 <free_block>
   11d6a:	83 c4 10             	add    $0x10,%esp
}
   11d6d:	83 c4 0c             	add    $0xc,%esp
   11d70:	c3                   	ret    

00011d71 <free_dind>:

static void free_dind(int dev,int block)
{
   11d71:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * bh;
	unsigned short * p;
	int i;

	if (!block)
   11d74:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   11d79:	75 05                	jne    11d80 <free_dind+0xf>
		return;
   11d7b:	e9 88 00 00 00       	jmp    11e08 <free_dind+0x97>
	if ((bh=bread(dev,block))) {
   11d80:	83 ec 08             	sub    $0x8,%esp
   11d83:	ff 74 24 1c          	pushl  0x1c(%esp)
   11d87:	ff 74 24 1c          	pushl  0x1c(%esp)
   11d8b:	e8 73 a9 ff ff       	call   c703 <bread>
   11d90:	83 c4 10             	add    $0x10,%esp
   11d93:	89 44 24 08          	mov    %eax,0x8(%esp)
   11d97:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   11d9c:	74 57                	je     11df5 <free_dind+0x84>
		p = (unsigned short *) bh->b_data;
   11d9e:	8b 44 24 08          	mov    0x8(%esp),%eax
   11da2:	8b 00                	mov    (%eax),%eax
   11da4:	89 44 24 04          	mov    %eax,0x4(%esp)
		for (i=0;i<512;i++,p++)
   11da8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   11daf:	81 3c 24 ff 01 00 00 	cmpl   $0x1ff,(%esp)
   11db6:	7f 2e                	jg     11de6 <free_dind+0x75>
			if (*p)
   11db8:	8b 44 24 04          	mov    0x4(%esp),%eax
   11dbc:	66 83 38 00          	cmpw   $0x0,(%eax)
   11dc0:	74 17                	je     11dd9 <free_dind+0x68>
				free_ind(dev,*p);
   11dc2:	83 ec 08             	sub    $0x8,%esp
   11dc5:	8b 44 24 0c          	mov    0xc(%esp),%eax
   11dc9:	0f b7 00             	movzwl (%eax),%eax
   11dcc:	50                   	push   %eax
   11dcd:	ff 74 24 1c          	pushl  0x1c(%esp)
   11dd1:	e8 00 ff ff ff       	call   11cd6 <free_ind>
   11dd6:	83 c4 10             	add    $0x10,%esp
		for (i=0;i<512;i++,p++)
   11dd9:	89 e0                	mov    %esp,%eax
   11ddb:	ff 00                	incl   (%eax)
   11ddd:	8d 44 24 04          	lea    0x4(%esp),%eax
   11de1:	83 00 02             	addl   $0x2,(%eax)
   11de4:	eb c9                	jmp    11daf <free_dind+0x3e>
		brelse(bh);
   11de6:	83 ec 0c             	sub    $0xc,%esp
   11de9:	ff 74 24 14          	pushl  0x14(%esp)
   11ded:	e8 c5 a8 ff ff       	call   c6b7 <brelse>
   11df2:	83 c4 10             	add    $0x10,%esp
	}
	free_block(dev,block);
   11df5:	83 ec 08             	sub    $0x8,%esp
   11df8:	ff 74 24 1c          	pushl  0x1c(%esp)
   11dfc:	ff 74 24 1c          	pushl  0x1c(%esp)
   11e00:	e8 cf f4 ff ff       	call   112d4 <free_block>
   11e05:	83 c4 10             	add    $0x10,%esp
}
   11e08:	83 c4 0c             	add    $0xc,%esp
   11e0b:	c3                   	ret    

00011e0c <truncate>:

void truncate(struct m_inode * inode)
{
   11e0c:	56                   	push   %esi
   11e0d:	53                   	push   %ebx
   11e0e:	83 ec 04             	sub    $0x4,%esp
	int i;

	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
   11e11:	8b 44 24 10          	mov    0x10(%esp),%eax
   11e15:	0f b7 00             	movzwl (%eax),%eax
   11e18:	25 00 f0 00 00       	and    $0xf000,%eax
   11e1d:	3d 00 80 00 00       	cmp    $0x8000,%eax
   11e22:	74 18                	je     11e3c <truncate+0x30>
   11e24:	8b 44 24 10          	mov    0x10(%esp),%eax
   11e28:	0f b7 00             	movzwl (%eax),%eax
   11e2b:	25 00 f0 00 00       	and    $0xf000,%eax
   11e30:	3d 00 40 00 00       	cmp    $0x4000,%eax
   11e35:	74 05                	je     11e3c <truncate+0x30>
		return;
   11e37:	e9 e3 00 00 00       	jmp    11f1f <truncate+0x113>
	for (i=0;i<7;i++)
   11e3c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   11e43:	83 3c 24 06          	cmpl   $0x6,(%esp)
   11e47:	7f 45                	jg     11e8e <truncate+0x82>
		if (inode->i_zone[i]) {
   11e49:	8b 54 24 10          	mov    0x10(%esp),%edx
   11e4d:	8b 04 24             	mov    (%esp),%eax
   11e50:	66 83 7c 42 0e 00    	cmpw   $0x0,0xe(%edx,%eax,2)
   11e56:	74 30                	je     11e88 <truncate+0x7c>
			free_block(inode->i_dev,inode->i_zone[i]);
   11e58:	83 ec 08             	sub    $0x8,%esp
   11e5b:	8b 54 24 18          	mov    0x18(%esp),%edx
   11e5f:	8b 44 24 08          	mov    0x8(%esp),%eax
   11e63:	0f b7 44 42 0e       	movzwl 0xe(%edx,%eax,2),%eax
   11e68:	50                   	push   %eax
   11e69:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11e6d:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11e71:	50                   	push   %eax
   11e72:	e8 5d f4 ff ff       	call   112d4 <free_block>
   11e77:	83 c4 10             	add    $0x10,%esp
			inode->i_zone[i]=0;
   11e7a:	8b 54 24 10          	mov    0x10(%esp),%edx
   11e7e:	8b 04 24             	mov    (%esp),%eax
   11e81:	66 c7 44 42 0e 00 00 	movw   $0x0,0xe(%edx,%eax,2)
	for (i=0;i<7;i++)
   11e88:	89 e0                	mov    %esp,%eax
   11e8a:	ff 00                	incl   (%eax)
   11e8c:	eb b5                	jmp    11e43 <truncate+0x37>
		}
	free_ind(inode->i_dev,inode->i_zone[7]);
   11e8e:	83 ec 08             	sub    $0x8,%esp
   11e91:	8b 44 24 18          	mov    0x18(%esp),%eax
   11e95:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   11e99:	50                   	push   %eax
   11e9a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11e9e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11ea2:	50                   	push   %eax
   11ea3:	e8 2e fe ff ff       	call   11cd6 <free_ind>
   11ea8:	83 c4 10             	add    $0x10,%esp
	free_dind(inode->i_dev,inode->i_zone[8]);
   11eab:	83 ec 08             	sub    $0x8,%esp
   11eae:	8b 44 24 18          	mov    0x18(%esp),%eax
   11eb2:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
   11eb6:	50                   	push   %eax
   11eb7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   11ebb:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   11ebf:	50                   	push   %eax
   11ec0:	e8 ac fe ff ff       	call   11d71 <free_dind>
   11ec5:	83 c4 10             	add    $0x10,%esp
	inode->i_zone[7] = inode->i_zone[8] = 0;
   11ec8:	8b 54 24 10          	mov    0x10(%esp),%edx
   11ecc:	8b 44 24 10          	mov    0x10(%esp),%eax
   11ed0:	66 c7 40 1e 00 00    	movw   $0x0,0x1e(%eax)
   11ed6:	66 c7 42 1c 00 00    	movw   $0x0,0x1c(%edx)
	inode->i_size = 0;
   11edc:	8b 44 24 10          	mov    0x10(%esp),%eax
   11ee0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	inode->i_dirt = 1;
   11ee7:	8b 44 24 10          	mov    0x10(%esp),%eax
   11eeb:	c6 40 33 01          	movb   $0x1,0x33(%eax)
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
   11eef:	8b 74 24 10          	mov    0x10(%esp),%esi
   11ef3:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   11ef7:	8b 0d c0 e9 01 00    	mov    0x1e9c0,%ecx
   11efd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
   11f02:	f7 e9                	imul   %ecx
   11f04:	c1 fa 05             	sar    $0x5,%edx
   11f07:	89 c8                	mov    %ecx,%eax
   11f09:	c1 f8 1f             	sar    $0x1f,%eax
   11f0c:	29 c2                	sub    %eax,%edx
   11f0e:	89 d0                	mov    %edx,%eax
   11f10:	03 05 c4 e9 01 00    	add    0x1e9c4,%eax
   11f16:	89 43 28             	mov    %eax,0x28(%ebx)
   11f19:	8b 43 28             	mov    0x28(%ebx),%eax
   11f1c:	89 46 08             	mov    %eax,0x8(%esi)
}
   11f1f:	83 c4 04             	add    $0x4,%esp
   11f22:	5b                   	pop    %ebx
   11f23:	5e                   	pop    %esi
   11f24:	c3                   	ret    

00011f25 <make_request>:
	tmp->next=req;
	sti();
}

static void make_request(int major,int rw, struct buffer_head * bh)
{
   11f25:	55                   	push   %ebp
   11f26:	57                   	push   %edi
   11f27:	56                   	push   %esi
   11f28:	53                   	push   %ebx
   11f29:	83 ec 0c             	sub    $0xc,%esp
   11f2c:	8b 7c 24 24          	mov    0x24(%esp),%edi
	struct request * req;
	int rw_ahead;

/* WRITEA/READA is special case - it is not really needed, so if the */
/* buffer is locked, we just forget about it, else it's a normal read */
	if ((rw_ahead = (rw == READA || rw == WRITEA))) {
   11f30:	8d 6f fe             	lea    -0x2(%edi),%ebp
   11f33:	83 fd 01             	cmp    $0x1,%ebp
   11f36:	0f 96 c0             	setbe  %al
   11f39:	0f b6 e8             	movzbl %al,%ebp
   11f3c:	85 ed                	test   %ebp,%ebp
   11f3e:	74 17                	je     11f57 <make_request+0x32>
		if (bh->b_lock)
   11f40:	8b 44 24 28          	mov    0x28(%esp),%eax
   11f44:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   11f48:	0f 85 e7 01 00 00    	jne    12135 <make_request+0x210>
			return;
		if (rw == READA)
			rw = READ;
   11f4e:	83 ff 02             	cmp    $0x2,%edi
   11f51:	0f 95 c0             	setne  %al
   11f54:	0f b6 f8             	movzbl %al,%edi
		else
			rw = WRITE;
	}
	if (rw!=READ && rw!=WRITE)
   11f57:	83 ff 01             	cmp    $0x1,%edi
   11f5a:	76 10                	jbe    11f6c <make_request+0x47>
		panic("Bad block dev command, must be R/W/RA/WA");
   11f5c:	83 ec 0c             	sub    $0xc,%esp
   11f5f:	68 30 93 01 00       	push   $0x19330
   11f64:	e8 b0 63 ff ff       	call   8319 <panic>
   11f69:	83 c4 10             	add    $0x10,%esp
{
   11f6c:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	cli();
   11f70:	fa                   	cli    
		sleep_on(&bh->b_wait);
   11f71:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   11f75:	74 15                	je     11f8c <make_request+0x67>
   11f77:	8d 73 10             	lea    0x10(%ebx),%esi
   11f7a:	83 ec 0c             	sub    $0xc,%esp
   11f7d:	56                   	push   %esi
   11f7e:	e8 02 4d ff ff       	call   6c85 <sleep_on>
   11f83:	83 c4 10             	add    $0x10,%esp
   11f86:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   11f8a:	75 ee                	jne    11f7a <make_request+0x55>
	bh->b_lock=1;
   11f8c:	c6 43 0d 01          	movb   $0x1,0xd(%ebx)
	sti();
   11f90:	fb                   	sti    
	lock_buffer(bh);
	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
   11f91:	83 ff 01             	cmp    $0x1,%edi
   11f94:	75 0a                	jne    11fa0 <make_request+0x7b>
   11f96:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   11f9a:	80 79 0b 00          	cmpb   $0x0,0xb(%ecx)
   11f9e:	74 0e                	je     11fae <make_request+0x89>
   11fa0:	85 ff                	test   %edi,%edi
   11fa2:	75 45                	jne    11fe9 <make_request+0xc4>
   11fa4:	8b 44 24 28          	mov    0x28(%esp),%eax
   11fa8:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
   11fac:	74 32                	je     11fe0 <make_request+0xbb>
{
   11fae:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	if (!bh->b_lock)
   11fb2:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   11fb6:	75 10                	jne    11fc8 <make_request+0xa3>
		printk("ll_rw_block.c: buffer not locked\n\r");
   11fb8:	83 ec 0c             	sub    $0xc,%esp
   11fbb:	68 5c 93 01 00       	push   $0x1935c
   11fc0:	e8 8e 63 ff ff       	call   8353 <printk>
   11fc5:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   11fc8:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   11fcc:	83 ec 0c             	sub    $0xc,%esp
   11fcf:	8d 43 10             	lea    0x10(%ebx),%eax
   11fd2:	50                   	push   %eax
   11fd3:	e8 cb 4f ff ff       	call   6fa3 <wake_up>
   11fd8:	83 c4 10             	add    $0x10,%esp
		unlock_buffer(bh);
		return;
   11fdb:	e9 55 01 00 00       	jmp    12135 <make_request+0x210>
/* we don't allow the write-requests to fill up the queue completely:
 * we want some room for reads: they take precedence. The last third
 * of the requests are only for reads.
 */
	if (rw == READ)
		req = request+NR_REQUEST;
   11fe0:	ba 60 2e 02 00       	mov    $0x22e60,%edx
	if (rw == READ)
   11fe5:	85 ff                	test   %edi,%edi
   11fe7:	74 05                	je     11fee <make_request+0xc9>
	else
		req = request+((NR_REQUEST*2)/3);
   11fe9:	ba d4 2c 02 00       	mov    $0x22cd4,%edx
/* find an empty request */
	while (--req >= request)
		if (req->dev<0)
			break;
   11fee:	83 ea 24             	sub    $0x24,%edx
   11ff1:	81 fa e0 29 02 00    	cmp    $0x229e0,%edx
   11ff7:	72 1a                	jb     12013 <make_request+0xee>
		if (req->dev<0)
   11ff9:	83 3a 00             	cmpl   $0x0,(%edx)
   11ffc:	78 0d                	js     1200b <make_request+0xe6>
			break;
   11ffe:	83 ea 24             	sub    $0x24,%edx
   12001:	81 fa e0 29 02 00    	cmp    $0x229e0,%edx
   12007:	73 f0                	jae    11ff9 <make_request+0xd4>
   12009:	eb 08                	jmp    12013 <make_request+0xee>
/* if none found, sleep on new requests: check for rw_ahead */
	if (req < request) {
   1200b:	81 fa e0 29 02 00    	cmp    $0x229e0,%edx
   12011:	73 48                	jae    1205b <make_request+0x136>
		if (rw_ahead) {
   12013:	85 ed                	test   %ebp,%ebp
   12015:	74 32                	je     12049 <make_request+0x124>
{
   12017:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	if (!bh->b_lock)
   1201b:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   1201f:	75 10                	jne    12031 <make_request+0x10c>
		printk("ll_rw_block.c: buffer not locked\n\r");
   12021:	83 ec 0c             	sub    $0xc,%esp
   12024:	68 5c 93 01 00       	push   $0x1935c
   12029:	e8 25 63 ff ff       	call   8353 <printk>
   1202e:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   12031:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   12035:	83 ec 0c             	sub    $0xc,%esp
   12038:	8d 43 10             	lea    0x10(%ebx),%eax
   1203b:	50                   	push   %eax
   1203c:	e8 62 4f ff ff       	call   6fa3 <wake_up>
   12041:	83 c4 10             	add    $0x10,%esp
			unlock_buffer(bh);
			return;
   12044:	e9 ec 00 00 00       	jmp    12135 <make_request+0x210>
		}
		sleep_on(&wait_for_request);
   12049:	83 ec 0c             	sub    $0xc,%esp
   1204c:	68 80 0b 02 00       	push   $0x20b80
   12051:	e8 2f 4c ff ff       	call   6c85 <sleep_on>
		goto repeat;
   12056:	83 c4 10             	add    $0x10,%esp
   12059:	eb 85                	jmp    11fe0 <make_request+0xbb>
	}
/* fill up the request-info, and add it to the queue */
	req->dev = bh->b_dev;
   1205b:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   1205f:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
   12063:	89 02                	mov    %eax,(%edx)
	req->cmd = rw;
   12065:	89 7a 04             	mov    %edi,0x4(%edx)
	req->errors=0;
   12068:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	req->sector = bh->b_blocknr<<1;
   1206f:	8b 41 04             	mov    0x4(%ecx),%eax
   12072:	d1 e0                	shl    %eax
   12074:	89 42 0c             	mov    %eax,0xc(%edx)
	req->nr_sectors = 2;
   12077:	c7 42 10 02 00 00 00 	movl   $0x2,0x10(%edx)
	req->buffer = bh->b_data;
   1207e:	8b 01                	mov    (%ecx),%eax
   12080:	89 42 14             	mov    %eax,0x14(%edx)
	req->waiting = NULL;
   12083:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	req->bh = bh;
   1208a:	89 4a 1c             	mov    %ecx,0x1c(%edx)
	req->next = NULL;
   1208d:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
{
   12094:	8b 44 24 20          	mov    0x20(%esp),%eax
   12098:	8d 04 c5 a0 0b 02 00 	lea    0x20ba0(,%eax,8),%eax
   1209f:	89 d3                	mov    %edx,%ebx
	cli();
   120a1:	fa                   	cli    
	if (req->bh)
   120a2:	85 c9                	test   %ecx,%ecx
   120a4:	74 04                	je     120aa <make_request+0x185>
		req->bh->b_dirt = 0;
   120a6:	c6 41 0b 00          	movb   $0x0,0xb(%ecx)
	if (!(tmp = dev->current_request)) {
   120aa:	8b 50 04             	mov    0x4(%eax),%edx
   120ad:	85 d2                	test   %edx,%edx
   120af:	75 08                	jne    120b9 <make_request+0x194>
		dev->current_request = req;
   120b1:	89 58 04             	mov    %ebx,0x4(%eax)
		sti();
   120b4:	fb                   	sti    
		(dev->request_fn)();
   120b5:	ff 10                	call   *(%eax)
   120b7:	eb 7c                	jmp    12135 <make_request+0x210>
	for ( ; tmp->next ; tmp=tmp->next)
   120b9:	83 7a 20 00          	cmpl   $0x0,0x20(%edx)
   120bd:	74 6c                	je     1212b <make_request+0x206>
		if ((IN_ORDER(tmp,req) || 
   120bf:	8b 42 04             	mov    0x4(%edx),%eax
   120c2:	3b 43 04             	cmp    0x4(%ebx),%eax
   120c5:	7c 39                	jl     12100 <make_request+0x1db>
   120c7:	3b 43 04             	cmp    0x4(%ebx),%eax
   120ca:	75 12                	jne    120de <make_request+0x1b9>
   120cc:	8b 02                	mov    (%edx),%eax
   120ce:	3b 03                	cmp    (%ebx),%eax
   120d0:	7c 2e                	jl     12100 <make_request+0x1db>
   120d2:	3b 03                	cmp    (%ebx),%eax
   120d4:	75 08                	jne    120de <make_request+0x1b9>
   120d6:	8b 42 0c             	mov    0xc(%edx),%eax
   120d9:	3b 43 0c             	cmp    0xc(%ebx),%eax
   120dc:	72 22                	jb     12100 <make_request+0x1db>
   120de:	8b 4a 20             	mov    0x20(%edx),%ecx
   120e1:	8b 42 04             	mov    0x4(%edx),%eax
   120e4:	3b 41 04             	cmp    0x4(%ecx),%eax
   120e7:	7c 39                	jl     12122 <make_request+0x1fd>
   120e9:	3b 41 04             	cmp    0x4(%ecx),%eax
   120ec:	75 12                	jne    12100 <make_request+0x1db>
   120ee:	8b 02                	mov    (%edx),%eax
   120f0:	3b 01                	cmp    (%ecx),%eax
   120f2:	7c 2e                	jl     12122 <make_request+0x1fd>
   120f4:	3b 01                	cmp    (%ecx),%eax
   120f6:	75 08                	jne    12100 <make_request+0x1db>
   120f8:	8b 42 0c             	mov    0xc(%edx),%eax
   120fb:	3b 41 0c             	cmp    0xc(%ecx),%eax
   120fe:	72 22                	jb     12122 <make_request+0x1fd>
   12100:	8b 4a 20             	mov    0x20(%edx),%ecx
   12103:	8b 43 04             	mov    0x4(%ebx),%eax
   12106:	3b 41 04             	cmp    0x4(%ecx),%eax
   12109:	7c 20                	jl     1212b <make_request+0x206>
   1210b:	3b 41 04             	cmp    0x4(%ecx),%eax
   1210e:	75 12                	jne    12122 <make_request+0x1fd>
   12110:	8b 03                	mov    (%ebx),%eax
   12112:	3b 01                	cmp    (%ecx),%eax
   12114:	7c 15                	jl     1212b <make_request+0x206>
   12116:	3b 01                	cmp    (%ecx),%eax
   12118:	75 08                	jne    12122 <make_request+0x1fd>
   1211a:	8b 43 0c             	mov    0xc(%ebx),%eax
   1211d:	3b 41 0c             	cmp    0xc(%ecx),%eax
   12120:	72 09                	jb     1212b <make_request+0x206>
	for ( ; tmp->next ; tmp=tmp->next)
   12122:	8b 52 20             	mov    0x20(%edx),%edx
   12125:	83 7a 20 00          	cmpl   $0x0,0x20(%edx)
   12129:	75 94                	jne    120bf <make_request+0x19a>
	req->next=tmp->next;
   1212b:	8b 42 20             	mov    0x20(%edx),%eax
   1212e:	89 43 20             	mov    %eax,0x20(%ebx)
	tmp->next=req;
   12131:	89 5a 20             	mov    %ebx,0x20(%edx)
	sti();
   12134:	fb                   	sti    
	add_request(major+blk_dev,req);
}
   12135:	83 c4 0c             	add    $0xc,%esp
   12138:	5b                   	pop    %ebx
   12139:	5e                   	pop    %esi
   1213a:	5f                   	pop    %edi
   1213b:	5d                   	pop    %ebp
   1213c:	c3                   	ret    

0001213d <ll_rw_block>:

void ll_rw_block(int rw, struct buffer_head * bh)
{
   1213d:	83 ec 0c             	sub    $0xc,%esp
   12140:	8b 54 24 14          	mov    0x14(%esp),%edx
	unsigned int major;

	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
   12144:	0f b6 42 09          	movzbl 0x9(%edx),%eax
   12148:	83 f8 06             	cmp    $0x6,%eax
   1214b:	77 0a                	ja     12157 <ll_rw_block+0x1a>
   1214d:	83 3c c5 a0 0b 02 00 	cmpl   $0x0,0x20ba0(,%eax,8)
   12154:	00 
   12155:	75 12                	jne    12169 <ll_rw_block+0x2c>
	!(blk_dev[major].request_fn)) {
		printk("Trying to read nonexistent block-device\n\r");
   12157:	83 ec 0c             	sub    $0xc,%esp
   1215a:	68 80 93 01 00       	push   $0x19380
   1215f:	e8 ef 61 ff ff       	call   8353 <printk>
		return;
   12164:	83 c4 10             	add    $0x10,%esp
   12167:	eb 11                	jmp    1217a <ll_rw_block+0x3d>
	}
	make_request(major,rw,bh);
   12169:	83 ec 04             	sub    $0x4,%esp
   1216c:	52                   	push   %edx
   1216d:	ff 74 24 18          	pushl  0x18(%esp)
   12171:	50                   	push   %eax
   12172:	e8 ae fd ff ff       	call   11f25 <make_request>
   12177:	83 c4 10             	add    $0x10,%esp
}
   1217a:	83 c4 0c             	add    $0xc,%esp
   1217d:	c3                   	ret    

0001217e <blk_dev_init>:

void blk_dev_init(void)
{
	int i;

	for (i=0 ; i<NR_REQUEST ; i++) {
   1217e:	ba 00 00 00 00       	mov    $0x0,%edx
   12183:	b8 00 00 00 00       	mov    $0x0,%eax
		request[i].dev = -1;
   12188:	c7 80 e0 29 02 00 ff 	movl   $0xffffffff,0x229e0(%eax)
   1218f:	ff ff ff 
		request[i].next = NULL;
   12192:	c7 80 00 2a 02 00 00 	movl   $0x0,0x22a00(%eax)
   12199:	00 00 00 
	for (i=0 ; i<NR_REQUEST ; i++) {
   1219c:	42                   	inc    %edx
   1219d:	83 c0 24             	add    $0x24,%eax
   121a0:	83 fa 1f             	cmp    $0x1f,%edx
   121a3:	7e e3                	jle    12188 <blk_dev_init+0xa>
	}
}
   121a5:	c3                   	ret    

000121a6 <floppy_deselect>:
static unsigned char command = 0;
unsigned char selected = 0;
struct task_struct * wait_on_floppy_select = NULL;

void floppy_deselect(unsigned int nr)
{
   121a6:	83 ec 0c             	sub    $0xc,%esp
	if (nr != (current_DOR & 3))
   121a9:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   121b0:	83 e0 03             	and    $0x3,%eax
   121b3:	3b 44 24 10          	cmp    0x10(%esp),%eax
   121b7:	74 10                	je     121c9 <floppy_deselect+0x23>
		printk("floppy_deselect: drive not selected\n\r");
   121b9:	83 ec 0c             	sub    $0xc,%esp
   121bc:	68 ac 93 01 00       	push   $0x193ac
   121c1:	e8 8d 61 ff ff       	call   8353 <printk>
   121c6:	83 c4 10             	add    $0x10,%esp
	selected = 0;
   121c9:	c6 05 dc 0b 02 00 00 	movb   $0x0,0x20bdc
	wake_up(&wait_on_floppy_select);
   121d0:	83 ec 0c             	sub    $0xc,%esp
   121d3:	68 e0 0b 02 00       	push   $0x20be0
   121d8:	e8 c6 4d ff ff       	call   6fa3 <wake_up>
}
   121dd:	83 c4 1c             	add    $0x1c,%esp
   121e0:	c3                   	ret    

000121e1 <floppy_change>:
 * here, sleep etc. Note that floppy-on tries to set current_DOR to point
 * to the desired drive, but it will probably not survive the sleep if
 * several floppies are used at the same time: thus the loop.
 */
int floppy_change(unsigned int nr)
{
   121e1:	53                   	push   %ebx
   121e2:	83 ec 08             	sub    $0x8,%esp
   121e5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
repeat:
	floppy_on(nr);
   121e9:	83 ec 0c             	sub    $0xc,%esp
   121ec:	53                   	push   %ebx
   121ed:	e8 63 4e ff ff       	call   7055 <floppy_on>
	while ((current_DOR & 3) != nr && selected)
   121f2:	83 c4 10             	add    $0x10,%esp
		interruptible_sleep_on(&wait_on_floppy_select);
   121f5:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   121fc:	83 e0 03             	and    $0x3,%eax
   121ff:	39 d8                	cmp    %ebx,%eax
   12201:	74 30                	je     12233 <floppy_change+0x52>
   12203:	80 3d dc 0b 02 00 00 	cmpb   $0x0,0x20bdc
   1220a:	74 27                	je     12233 <floppy_change+0x52>
   1220c:	83 ec 0c             	sub    $0xc,%esp
   1220f:	68 e0 0b 02 00       	push   $0x20be0
   12214:	e8 fa 4b ff ff       	call   6e13 <interruptible_sleep_on>
   12219:	83 c4 10             	add    $0x10,%esp
   1221c:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   12223:	83 e0 03             	and    $0x3,%eax
   12226:	39 d8                	cmp    %ebx,%eax
   12228:	74 09                	je     12233 <floppy_change+0x52>
   1222a:	80 3d dc 0b 02 00 00 	cmpb   $0x0,0x20bdc
   12231:	75 d9                	jne    1220c <floppy_change+0x2b>
	if ((current_DOR & 3) != nr)
   12233:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   1223a:	83 e0 03             	and    $0x3,%eax
   1223d:	39 d8                	cmp    %ebx,%eax
   1223f:	75 a8                	jne    121e9 <floppy_change+0x8>
		goto repeat;
	if (inb(FD_DIR) & 0x80) {
   12241:	ba f7 03 00 00       	mov    $0x3f7,%edx
   12246:	ec                   	in     (%dx),%al
   12247:	84 c0                	test   %al,%al
   12249:	79 13                	jns    1225e <floppy_change+0x7d>
		floppy_off(nr);
   1224b:	83 ec 0c             	sub    $0xc,%esp
   1224e:	53                   	push   %ebx
   1224f:	e8 bd 4e ff ff       	call   7111 <floppy_off>
		return 1;
   12254:	b8 01 00 00 00       	mov    $0x1,%eax
   12259:	83 c4 10             	add    $0x10,%esp
   1225c:	eb 11                	jmp    1226f <floppy_change+0x8e>
	}
	floppy_off(nr);
   1225e:	83 ec 0c             	sub    $0xc,%esp
   12261:	53                   	push   %ebx
   12262:	e8 aa 4e ff ff       	call   7111 <floppy_off>
	return 0;
   12267:	b8 00 00 00 00       	mov    $0x0,%eax
   1226c:	83 c4 10             	add    $0x10,%esp
}
   1226f:	83 c4 08             	add    $0x8,%esp
   12272:	5b                   	pop    %ebx
   12273:	c3                   	ret    

00012274 <bad_flp_intr>:
	printk("Getstatus times out\n\r");
	return -1;
}

static void bad_flp_intr(void)
{
   12274:	53                   	push   %ebx
   12275:	83 ec 08             	sub    $0x8,%esp
	CURRENT->errors++;
   12278:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   1227d:	ff 40 08             	incl   0x8(%eax)
	if (CURRENT->errors > MAX_ERRORS) {
   12280:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12285:	83 78 08 08          	cmpl   $0x8,0x8(%eax)
   12289:	0f 8e fd 00 00 00    	jle    1238c <bad_flp_intr+0x118>
{
   1228f:	0f b6 15 f0 0b 02 00 	movzbl 0x20bf0,%edx
	if (nr != (current_DOR & 3))
   12296:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   1229d:	83 e0 03             	and    $0x3,%eax
   122a0:	39 d0                	cmp    %edx,%eax
   122a2:	74 10                	je     122b4 <bad_flp_intr+0x40>
		printk("floppy_deselect: drive not selected\n\r");
   122a4:	83 ec 0c             	sub    $0xc,%esp
   122a7:	68 ac 93 01 00       	push   $0x193ac
   122ac:	e8 a2 60 ff ff       	call   8353 <printk>
   122b1:	83 c4 10             	add    $0x10,%esp
	selected = 0;
   122b4:	c6 05 dc 0b 02 00 00 	movb   $0x0,0x20bdc
	wake_up(&wait_on_floppy_select);
   122bb:	83 ec 0c             	sub    $0xc,%esp
   122be:	68 e0 0b 02 00       	push   $0x20be0
   122c3:	e8 db 4c ff ff       	call   6fa3 <wake_up>
	wake_up(&bh->b_wait);
}

static inline void end_request(int uptodate)
{
	DEVICE_OFF(CURRENT->dev);
   122c8:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   122cd:	8b 00                	mov    (%eax),%eax
   122cf:	83 e0 03             	and    $0x3,%eax
   122d2:	89 04 24             	mov    %eax,(%esp)
   122d5:	e8 37 4e ff ff       	call   7111 <floppy_off>
   122da:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {
   122dd:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   122e2:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   122e6:	74 38                	je     12320 <bad_flp_intr+0xac>
		CURRENT->bh->b_uptodate = uptodate;
   122e8:	8b 40 1c             	mov    0x1c(%eax),%eax
   122eb:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   122ef:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   122f4:	8b 58 1c             	mov    0x1c(%eax),%ebx
	if (!bh->b_lock)
   122f7:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   122fb:	75 10                	jne    1230d <bad_flp_intr+0x99>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   122fd:	83 ec 0c             	sub    $0xc,%esp
   12300:	68 d4 93 01 00       	push   $0x193d4
   12305:	e8 49 60 ff ff       	call   8353 <printk>
   1230a:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   1230d:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   12311:	83 ec 0c             	sub    $0xc,%esp
   12314:	8d 43 10             	lea    0x10(%ebx),%eax
   12317:	50                   	push   %eax
   12318:	e8 86 4c ff ff       	call   6fa3 <wake_up>
   1231d:	83 c4 10             	add    $0x10,%esp
		unlock_buffer(CURRENT->bh);
	}
	if (!uptodate) {
   12320:	b8 00 00 00 00       	mov    $0x0,%eax
   12325:	85 c0                	test   %eax,%eax
   12327:	75 2b                	jne    12354 <bad_flp_intr+0xe0>
		printk(DEVICE_NAME " I/O error\n\r");
   12329:	83 ec 0c             	sub    $0xc,%esp
   1232c:	68 37 94 01 00       	push   $0x19437
   12331:	e8 1d 60 ff ff       	call   8353 <printk>
   12336:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   12339:	8b 15 b4 0b 02 00    	mov    0x20bb4,%edx
   1233f:	8b 42 1c             	mov    0x1c(%edx),%eax
   12342:	ff 70 04             	pushl  0x4(%eax)
   12345:	ff 32                	pushl  (%edx)
   12347:	68 4a 94 01 00       	push   $0x1944a
   1234c:	e8 02 60 ff ff       	call   8353 <printk>
   12351:	83 c4 10             	add    $0x10,%esp
			CURRENT->bh->b_blocknr);
	}
	wake_up(&CURRENT->waiting);
   12354:	83 ec 0c             	sub    $0xc,%esp
   12357:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   1235c:	83 c0 18             	add    $0x18,%eax
   1235f:	50                   	push   %eax
   12360:	e8 3e 4c ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   12365:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   1236c:	e8 32 4c ff ff       	call   6fa3 <wake_up>
   12371:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   12374:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12379:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   1237f:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12384:	8b 40 20             	mov    0x20(%eax),%eax
   12387:	a3 b4 0b 02 00       	mov    %eax,0x20bb4
		floppy_deselect(current_drive);
		end_request(0);
	}
	if (CURRENT->errors > MAX_ERRORS/2)
   1238c:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12391:	83 78 08 04          	cmpl   $0x4,0x8(%eax)
   12395:	7e 0c                	jle    123a3 <bad_flp_intr+0x12f>
		reset = 1;
   12397:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1239e:	00 00 00 
   123a1:	eb 0a                	jmp    123ad <bad_flp_intr+0x139>
	else
		recalibrate = 1;
   123a3:	c7 05 e4 0b 02 00 01 	movl   $0x1,0x20be4
   123aa:	00 00 00 
}	
   123ad:	83 c4 08             	add    $0x8,%esp
   123b0:	5b                   	pop    %ebx
   123b1:	c3                   	ret    

000123b2 <rw_interrupt>:
/*
 * Ok, this interrupt is called after a DMA read/write has succeeded,
 * so we check the results, and copy any buffers.
 */
static void rw_interrupt(void)
{
   123b2:	57                   	push   %edi
   123b3:	56                   	push   %esi
   123b4:	53                   	push   %ebx
   123b5:	83 ec 10             	sub    $0x10,%esp
	int i = 0, counter, status;
   123b8:	be 00 00 00 00       	mov    $0x0,%esi
	if (reset)
   123bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   123c2:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   123c9:	75 72                	jne    1243d <rw_interrupt+0x8b>
   123cb:	eb 04                	jmp    123d1 <rw_interrupt+0x1f>
		if (status == STATUS_READY)
   123cd:	89 f0                	mov    %esi,%eax
   123cf:	eb 6c                	jmp    1243d <rw_interrupt+0x8b>
	for (counter = 0 ; counter < 10000 ; counter++) {
   123d1:	b9 00 00 00 00       	mov    $0x0,%ecx
   123d6:	bb f4 03 00 00       	mov    $0x3f4,%ebx
   123db:	bf f5 03 00 00       	mov    $0x3f5,%edi
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   123e0:	89 da                	mov    %ebx,%edx
   123e2:	ec                   	in     (%dx),%al
   123e3:	eb 00                	jmp    123e5 <rw_interrupt+0x33>
   123e5:	eb 00                	jmp    123e7 <rw_interrupt+0x35>
   123e7:	25 d0 00 00 00       	and    $0xd0,%eax
		if (status == STATUS_READY)
   123ec:	3d 80 00 00 00       	cmp    $0x80,%eax
   123f1:	74 da                	je     123cd <rw_interrupt+0x1b>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   123f3:	3d d0 00 00 00       	cmp    $0xd0,%eax
   123f8:	75 1b                	jne    12415 <rw_interrupt+0x63>
			if (i >= MAX_REPLIES)
   123fa:	83 fe 06             	cmp    $0x6,%esi
   123fd:	7f 1f                	jg     1241e <rw_interrupt+0x6c>
			reply_buffer[i++] = inb_p(FD_DATA);
   123ff:	89 74 24 0c          	mov    %esi,0xc(%esp)
   12403:	89 fa                	mov    %edi,%edx
   12405:	ec                   	in     (%dx),%al
   12406:	eb 00                	jmp    12408 <rw_interrupt+0x56>
   12408:	eb 00                	jmp    1240a <rw_interrupt+0x58>
   1240a:	46                   	inc    %esi
   1240b:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1240f:	88 82 f6 0b 02 00    	mov    %al,0x20bf6(%edx)
	for (counter = 0 ; counter < 10000 ; counter++) {
   12415:	41                   	inc    %ecx
   12416:	81 f9 0f 27 00 00    	cmp    $0x270f,%ecx
   1241c:	7e c2                	jle    123e0 <rw_interrupt+0x2e>
	reset = 1;
   1241e:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12425:	00 00 00 
	printk("Getstatus times out\n\r");
   12428:	83 ec 0c             	sub    $0xc,%esp
   1242b:	68 5f 94 01 00       	push   $0x1945f
   12430:	e8 1e 5f ff ff       	call   8353 <printk>
   12435:	83 c4 10             	add    $0x10,%esp
   12438:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
   1243d:	83 f8 07             	cmp    $0x7,%eax
   12440:	75 21                	jne    12463 <rw_interrupt+0xb1>
   12442:	f6 05 f6 0b 02 00 f8 	testb  $0xf8,0x20bf6
   12449:	75 18                	jne    12463 <rw_interrupt+0xb1>
   1244b:	f6 05 f7 0b 02 00 bf 	testb  $0xbf,0x20bf7
   12452:	75 0f                	jne    12463 <rw_interrupt+0xb1>
   12454:	0f b6 05 f8 0b 02 00 	movzbl 0x20bf8,%eax
   1245b:	a8 73                	test   $0x73,%al
   1245d:	0f 84 33 01 00 00    	je     12596 <rw_interrupt+0x1e4>
	if (result() != 7 || (ST0 & 0xf8) || (ST1 & 0xbf) || (ST2 & 0x73)) {
		if (ST1 & 0x02) {
   12463:	f6 05 f7 0b 02 00 02 	testb  $0x2,0x20bf7
   1246a:	0f 84 17 01 00 00    	je     12587 <rw_interrupt+0x1d5>
			printk("Drive %d is write protected\n\r",current_drive);
   12470:	83 ec 08             	sub    $0x8,%esp
   12473:	0f b6 05 f0 0b 02 00 	movzbl 0x20bf0,%eax
   1247a:	50                   	push   %eax
   1247b:	68 75 94 01 00       	push   $0x19475
   12480:	e8 ce 5e ff ff       	call   8353 <printk>
{
   12485:	83 c4 10             	add    $0x10,%esp
   12488:	0f b6 0d f0 0b 02 00 	movzbl 0x20bf0,%ecx
	if (nr != (current_DOR & 3))
   1248f:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   12496:	83 e0 03             	and    $0x3,%eax
   12499:	39 c8                	cmp    %ecx,%eax
   1249b:	74 10                	je     124ad <rw_interrupt+0xfb>
		printk("floppy_deselect: drive not selected\n\r");
   1249d:	83 ec 0c             	sub    $0xc,%esp
   124a0:	68 ac 93 01 00       	push   $0x193ac
   124a5:	e8 a9 5e ff ff       	call   8353 <printk>
   124aa:	83 c4 10             	add    $0x10,%esp
	selected = 0;
   124ad:	c6 05 dc 0b 02 00 00 	movb   $0x0,0x20bdc
	wake_up(&wait_on_floppy_select);
   124b4:	83 ec 0c             	sub    $0xc,%esp
   124b7:	68 e0 0b 02 00       	push   $0x20be0
   124bc:	e8 e2 4a ff ff       	call   6fa3 <wake_up>
	DEVICE_OFF(CURRENT->dev);
   124c1:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   124c6:	8b 00                	mov    (%eax),%eax
   124c8:	83 e0 03             	and    $0x3,%eax
   124cb:	89 04 24             	mov    %eax,(%esp)
   124ce:	e8 3e 4c ff ff       	call   7111 <floppy_off>
   124d3:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {
   124d6:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   124db:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   124df:	74 38                	je     12519 <rw_interrupt+0x167>
		CURRENT->bh->b_uptodate = uptodate;
   124e1:	8b 40 1c             	mov    0x1c(%eax),%eax
   124e4:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   124e8:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   124ed:	8b 70 1c             	mov    0x1c(%eax),%esi
	if (!bh->b_lock)
   124f0:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   124f4:	75 10                	jne    12506 <rw_interrupt+0x154>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   124f6:	83 ec 0c             	sub    $0xc,%esp
   124f9:	68 d4 93 01 00       	push   $0x193d4
   124fe:	e8 50 5e ff ff       	call   8353 <printk>
   12503:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   12506:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	wake_up(&bh->b_wait);
   1250a:	83 ec 0c             	sub    $0xc,%esp
   1250d:	8d 46 10             	lea    0x10(%esi),%eax
   12510:	50                   	push   %eax
   12511:	e8 8d 4a ff ff       	call   6fa3 <wake_up>
   12516:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   12519:	b8 00 00 00 00       	mov    $0x0,%eax
   1251e:	85 c0                	test   %eax,%eax
   12520:	75 2b                	jne    1254d <rw_interrupt+0x19b>
		printk(DEVICE_NAME " I/O error\n\r");
   12522:	83 ec 0c             	sub    $0xc,%esp
   12525:	68 37 94 01 00       	push   $0x19437
   1252a:	e8 24 5e ff ff       	call   8353 <printk>
   1252f:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   12532:	8b 0d b4 0b 02 00    	mov    0x20bb4,%ecx
   12538:	8b 41 1c             	mov    0x1c(%ecx),%eax
   1253b:	ff 70 04             	pushl  0x4(%eax)
   1253e:	ff 31                	pushl  (%ecx)
   12540:	68 4a 94 01 00       	push   $0x1944a
   12545:	e8 09 5e ff ff       	call   8353 <printk>
   1254a:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   1254d:	83 ec 0c             	sub    $0xc,%esp
   12550:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12555:	83 c0 18             	add    $0x18,%eax
   12558:	50                   	push   %eax
   12559:	e8 45 4a ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   1255e:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   12565:	e8 39 4a ff ff       	call   6fa3 <wake_up>
   1256a:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   1256d:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12572:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   12578:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   1257d:	8b 40 20             	mov    0x20(%eax),%eax
   12580:	a3 b4 0b 02 00       	mov    %eax,0x20bb4
   12585:	eb 05                	jmp    1258c <rw_interrupt+0x1da>
			floppy_deselect(current_drive);
			end_request(0);
		} else
			bad_flp_intr();
   12587:	e8 e8 fc ff ff       	call   12274 <bad_flp_intr>
		do_fd_request();
   1258c:	e8 22 14 00 00       	call   139b3 <do_fd_request>
		return;
   12591:	e9 29 01 00 00       	jmp    126bf <rw_interrupt+0x30d>
	}
	if (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)
   12596:	80 3d f5 0b 02 00 e6 	cmpb   $0xe6,0x20bf5
   1259d:	75 1e                	jne    125bd <rw_interrupt+0x20b>
   1259f:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   125a4:	81 78 14 ff ff 0f 00 	cmpl   $0xfffff,0x14(%eax)
   125ab:	76 10                	jbe    125bd <rw_interrupt+0x20b>
		copy_buffer(tmp_floppy_area,CURRENT->buffer);
   125ad:	b9 00 01 00 00       	mov    $0x100,%ecx
   125b2:	be 00 50 00 00       	mov    $0x5000,%esi
   125b7:	8b 78 14             	mov    0x14(%eax),%edi
   125ba:	fc                   	cld    
   125bb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
{
   125bd:	0f b6 0d f0 0b 02 00 	movzbl 0x20bf0,%ecx
	if (nr != (current_DOR & 3))
   125c4:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   125cb:	83 e0 03             	and    $0x3,%eax
   125ce:	39 c8                	cmp    %ecx,%eax
   125d0:	74 10                	je     125e2 <rw_interrupt+0x230>
		printk("floppy_deselect: drive not selected\n\r");
   125d2:	83 ec 0c             	sub    $0xc,%esp
   125d5:	68 ac 93 01 00       	push   $0x193ac
   125da:	e8 74 5d ff ff       	call   8353 <printk>
   125df:	83 c4 10             	add    $0x10,%esp
	selected = 0;
   125e2:	c6 05 dc 0b 02 00 00 	movb   $0x0,0x20bdc
	wake_up(&wait_on_floppy_select);
   125e9:	83 ec 0c             	sub    $0xc,%esp
   125ec:	68 e0 0b 02 00       	push   $0x20be0
   125f1:	e8 ad 49 ff ff       	call   6fa3 <wake_up>
	DEVICE_OFF(CURRENT->dev);
   125f6:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   125fb:	8b 00                	mov    (%eax),%eax
   125fd:	83 e0 03             	and    $0x3,%eax
   12600:	89 04 24             	mov    %eax,(%esp)
   12603:	e8 09 4b ff ff       	call   7111 <floppy_off>
   12608:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {
   1260b:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12610:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   12614:	74 38                	je     1264e <rw_interrupt+0x29c>
		CURRENT->bh->b_uptodate = uptodate;
   12616:	8b 40 1c             	mov    0x1c(%eax),%eax
   12619:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
{
   1261d:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12622:	8b 70 1c             	mov    0x1c(%eax),%esi
	if (!bh->b_lock)
   12625:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   12629:	75 10                	jne    1263b <rw_interrupt+0x289>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   1262b:	83 ec 0c             	sub    $0xc,%esp
   1262e:	68 d4 93 01 00       	push   $0x193d4
   12633:	e8 1b 5d ff ff       	call   8353 <printk>
   12638:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   1263b:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	wake_up(&bh->b_wait);
   1263f:	83 ec 0c             	sub    $0xc,%esp
   12642:	8d 46 10             	lea    0x10(%esi),%eax
   12645:	50                   	push   %eax
   12646:	e8 58 49 ff ff       	call   6fa3 <wake_up>
   1264b:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   1264e:	b8 01 00 00 00       	mov    $0x1,%eax
   12653:	85 c0                	test   %eax,%eax
   12655:	75 2b                	jne    12682 <rw_interrupt+0x2d0>
		printk(DEVICE_NAME " I/O error\n\r");
   12657:	83 ec 0c             	sub    $0xc,%esp
   1265a:	68 37 94 01 00       	push   $0x19437
   1265f:	e8 ef 5c ff ff       	call   8353 <printk>
   12664:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   12667:	8b 0d b4 0b 02 00    	mov    0x20bb4,%ecx
   1266d:	8b 41 1c             	mov    0x1c(%ecx),%eax
   12670:	ff 70 04             	pushl  0x4(%eax)
   12673:	ff 31                	pushl  (%ecx)
   12675:	68 4a 94 01 00       	push   $0x1944a
   1267a:	e8 d4 5c ff ff       	call   8353 <printk>
   1267f:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   12682:	83 ec 0c             	sub    $0xc,%esp
   12685:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   1268a:	83 c0 18             	add    $0x18,%eax
   1268d:	50                   	push   %eax
   1268e:	e8 10 49 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   12693:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   1269a:	e8 04 49 ff ff       	call   6fa3 <wake_up>
   1269f:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   126a2:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   126a7:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   126ad:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   126b2:	8b 40 20             	mov    0x20(%eax),%eax
   126b5:	a3 b4 0b 02 00       	mov    %eax,0x20bb4
	floppy_deselect(current_drive);
	end_request(1);
	do_fd_request();
   126ba:	e8 f4 12 00 00       	call   139b3 <do_fd_request>
}
   126bf:	83 c4 10             	add    $0x10,%esp
   126c2:	5b                   	pop    %ebx
   126c3:	5e                   	pop    %esi
   126c4:	5f                   	pop    %edi
   126c5:	c3                   	ret    

000126c6 <setup_rw_floppy>:

inline void setup_rw_floppy(void)
{
   126c6:	57                   	push   %edi
   126c7:	56                   	push   %esi
   126c8:	53                   	push   %ebx
	long addr = (long) CURRENT->buffer;
   126c9:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   126ce:	8b 50 14             	mov    0x14(%eax),%edx
	cli();
   126d1:	fa                   	cli    
	if (addr >= 0x100000) {
   126d2:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
   126d8:	7e 1b                	jle    126f5 <setup_rw_floppy+0x2f>
		addr = (long) tmp_floppy_area;
   126da:	ba 00 50 00 00       	mov    $0x5000,%edx
		if (command == FD_WRITE)
   126df:	80 3d f5 0b 02 00 c5 	cmpb   $0xc5,0x20bf5
   126e6:	75 0d                	jne    126f5 <setup_rw_floppy+0x2f>
			copy_buffer(CURRENT->buffer,tmp_floppy_area);
   126e8:	b9 00 01 00 00       	mov    $0x100,%ecx
   126ed:	8b 70 14             	mov    0x14(%eax),%esi
   126f0:	89 d7                	mov    %edx,%edi
   126f2:	fc                   	cld    
   126f3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	immoutb_p(4|2,10);
   126f5:	b0 06                	mov    $0x6,%al
   126f7:	e6 0a                	out    %al,$0xa
   126f9:	eb 00                	jmp    126fb <setup_rw_floppy+0x35>
   126fb:	eb 00                	jmp    126fd <setup_rw_floppy+0x37>
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   126fd:	b0 46                	mov    $0x46,%al
   126ff:	80 3d f5 0b 02 00 e6 	cmpb   $0xe6,0x20bf5
   12706:	74 79                	je     12781 <setup_rw_floppy+0xbb>
   12708:	eb 75                	jmp    1277f <setup_rw_floppy+0xb9>
			outb(byte,FD_DATA);
   1270a:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1270f:	88 d8                	mov    %bl,%al
   12711:	ee                   	out    %al,(%dx)
   12712:	e9 05 01 00 00       	jmp    1281c <setup_rw_floppy+0x156>
   12717:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1271c:	88 d8                	mov    %bl,%al
   1271e:	ee                   	out    %al,(%dx)
   1271f:	e9 52 01 00 00       	jmp    12876 <setup_rw_floppy+0x1b0>
   12724:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12729:	88 d8                	mov    %bl,%al
   1272b:	ee                   	out    %al,(%dx)
   1272c:	e9 93 01 00 00       	jmp    128c4 <setup_rw_floppy+0x1fe>
   12731:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12736:	88 d8                	mov    %bl,%al
   12738:	ee                   	out    %al,(%dx)
   12739:	e9 d4 01 00 00       	jmp    12912 <setup_rw_floppy+0x24c>
   1273e:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12743:	88 d8                	mov    %bl,%al
   12745:	ee                   	out    %al,(%dx)
   12746:	e9 15 02 00 00       	jmp    12960 <setup_rw_floppy+0x29a>
   1274b:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12750:	88 d8                	mov    %bl,%al
   12752:	ee                   	out    %al,(%dx)
   12753:	e9 52 02 00 00       	jmp    129aa <setup_rw_floppy+0x2e4>
   12758:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1275d:	88 d8                	mov    %bl,%al
   1275f:	ee                   	out    %al,(%dx)
   12760:	e9 95 02 00 00       	jmp    129fa <setup_rw_floppy+0x334>
   12765:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1276a:	88 d8                	mov    %bl,%al
   1276c:	ee                   	out    %al,(%dx)
   1276d:	e9 d8 02 00 00       	jmp    12a4a <setup_rw_floppy+0x384>
   12772:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12777:	88 d8                	mov    %bl,%al
   12779:	ee                   	out    %al,(%dx)
   1277a:	e9 15 03 00 00       	jmp    12a94 <setup_rw_floppy+0x3ce>
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   1277f:	b0 4a                	mov    $0x4a,%al
   12781:	e6 0c                	out    %al,$0xc
   12783:	eb 00                	jmp    12785 <setup_rw_floppy+0xbf>
   12785:	eb 00                	jmp    12787 <setup_rw_floppy+0xc1>
   12787:	e6 0b                	out    %al,$0xb
   12789:	eb 00                	jmp    1278b <setup_rw_floppy+0xc5>
   1278b:	eb 00                	jmp    1278d <setup_rw_floppy+0xc7>
	immoutb_p(addr,4);
   1278d:	88 d0                	mov    %dl,%al
   1278f:	e6 04                	out    %al,$0x4
   12791:	eb 00                	jmp    12793 <setup_rw_floppy+0xcd>
   12793:	eb 00                	jmp    12795 <setup_rw_floppy+0xcf>
	addr >>= 8;
   12795:	c1 fa 08             	sar    $0x8,%edx
	immoutb_p(addr,4);
   12798:	88 d0                	mov    %dl,%al
   1279a:	e6 04                	out    %al,$0x4
   1279c:	eb 00                	jmp    1279e <setup_rw_floppy+0xd8>
   1279e:	eb 00                	jmp    127a0 <setup_rw_floppy+0xda>
	addr >>= 8;
   127a0:	c1 fa 08             	sar    $0x8,%edx
	immoutb_p(addr,0x81);
   127a3:	88 d0                	mov    %dl,%al
   127a5:	e6 81                	out    %al,$0x81
   127a7:	eb 00                	jmp    127a9 <setup_rw_floppy+0xe3>
   127a9:	eb 00                	jmp    127ab <setup_rw_floppy+0xe5>
	immoutb_p(0xff,5);
   127ab:	b0 ff                	mov    $0xff,%al
   127ad:	e6 05                	out    %al,$0x5
   127af:	eb 00                	jmp    127b1 <setup_rw_floppy+0xeb>
   127b1:	eb 00                	jmp    127b3 <setup_rw_floppy+0xed>
	immoutb_p(3,5);
   127b3:	b0 03                	mov    $0x3,%al
   127b5:	e6 05                	out    %al,$0x5
   127b7:	eb 00                	jmp    127b9 <setup_rw_floppy+0xf3>
   127b9:	eb 00                	jmp    127bb <setup_rw_floppy+0xf5>
	immoutb_p(0|2,10);
   127bb:	b0 02                	mov    $0x2,%al
   127bd:	e6 0a                	out    %al,$0xa
   127bf:	eb 00                	jmp    127c1 <setup_rw_floppy+0xfb>
   127c1:	eb 00                	jmp    127c3 <setup_rw_floppy+0xfd>
	sti();
   127c3:	fb                   	sti    
	setup_DMA();
	do_floppy = rw_interrupt;
   127c4:	c7 05 d8 0b 02 00 b2 	movl   $0x123b2,0x20bd8
   127cb:	23 01 00 
{
   127ce:	8a 1d f5 0b 02 00    	mov    0x20bf5,%bl
	if (reset)
   127d4:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   127db:	75 3f                	jne    1281c <setup_rw_floppy+0x156>
	for(counter = 0 ; counter < 10000 ; counter++) {
   127dd:	be 00 00 00 00       	mov    $0x0,%esi
   127e2:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   127e7:	89 ca                	mov    %ecx,%edx
   127e9:	ec                   	in     (%dx),%al
   127ea:	eb 00                	jmp    127ec <setup_rw_floppy+0x126>
   127ec:	eb 00                	jmp    127ee <setup_rw_floppy+0x128>
   127ee:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   127f1:	3c 80                	cmp    $0x80,%al
   127f3:	0f 84 11 ff ff ff    	je     1270a <setup_rw_floppy+0x44>
	for(counter = 0 ; counter < 10000 ; counter++) {
   127f9:	46                   	inc    %esi
   127fa:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12800:	7e e5                	jle    127e7 <setup_rw_floppy+0x121>
	reset = 1;
   12802:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12809:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1280c:	83 ec 0c             	sub    $0xc,%esp
   1280f:	68 93 94 01 00       	push   $0x19493
   12814:	e8 3a 5b ff ff       	call   8353 <printk>
   12819:	83 c4 10             	add    $0x10,%esp
{
   1281c:	0f b6 05 f2 0b 02 00 	movzbl 0x20bf2,%eax
   12823:	c1 e0 02             	shl    $0x2,%eax
   12826:	8a 1d f0 0b 02 00    	mov    0x20bf0,%bl
   1282c:	09 c3                	or     %eax,%ebx
	if (reset)
   1282e:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12835:	75 3f                	jne    12876 <setup_rw_floppy+0x1b0>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12837:	be 00 00 00 00       	mov    $0x0,%esi
   1283c:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12841:	89 ca                	mov    %ecx,%edx
   12843:	ec                   	in     (%dx),%al
   12844:	eb 00                	jmp    12846 <setup_rw_floppy+0x180>
   12846:	eb 00                	jmp    12848 <setup_rw_floppy+0x182>
   12848:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1284b:	3c 80                	cmp    $0x80,%al
   1284d:	0f 84 c4 fe ff ff    	je     12717 <setup_rw_floppy+0x51>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12853:	46                   	inc    %esi
   12854:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   1285a:	7e e5                	jle    12841 <setup_rw_floppy+0x17b>
	reset = 1;
   1285c:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12863:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12866:	83 ec 0c             	sub    $0xc,%esp
   12869:	68 93 94 01 00       	push   $0x19493
   1286e:	e8 e0 5a ff ff       	call   8353 <printk>
   12873:	83 c4 10             	add    $0x10,%esp
{
   12876:	8a 1d f3 0b 02 00    	mov    0x20bf3,%bl
	if (reset)
   1287c:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12883:	75 3f                	jne    128c4 <setup_rw_floppy+0x1fe>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12885:	be 00 00 00 00       	mov    $0x0,%esi
   1288a:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1288f:	89 ca                	mov    %ecx,%edx
   12891:	ec                   	in     (%dx),%al
   12892:	eb 00                	jmp    12894 <setup_rw_floppy+0x1ce>
   12894:	eb 00                	jmp    12896 <setup_rw_floppy+0x1d0>
   12896:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12899:	3c 80                	cmp    $0x80,%al
   1289b:	0f 84 83 fe ff ff    	je     12724 <setup_rw_floppy+0x5e>
	for(counter = 0 ; counter < 10000 ; counter++) {
   128a1:	46                   	inc    %esi
   128a2:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   128a8:	7e e5                	jle    1288f <setup_rw_floppy+0x1c9>
	reset = 1;
   128aa:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   128b1:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   128b4:	83 ec 0c             	sub    $0xc,%esp
   128b7:	68 93 94 01 00       	push   $0x19493
   128bc:	e8 92 5a ff ff       	call   8353 <printk>
   128c1:	83 c4 10             	add    $0x10,%esp
{
   128c4:	8a 1d f2 0b 02 00    	mov    0x20bf2,%bl
	if (reset)
   128ca:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   128d1:	75 3f                	jne    12912 <setup_rw_floppy+0x24c>
	for(counter = 0 ; counter < 10000 ; counter++) {
   128d3:	be 00 00 00 00       	mov    $0x0,%esi
   128d8:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   128dd:	89 ca                	mov    %ecx,%edx
   128df:	ec                   	in     (%dx),%al
   128e0:	eb 00                	jmp    128e2 <setup_rw_floppy+0x21c>
   128e2:	eb 00                	jmp    128e4 <setup_rw_floppy+0x21e>
   128e4:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   128e7:	3c 80                	cmp    $0x80,%al
   128e9:	0f 84 42 fe ff ff    	je     12731 <setup_rw_floppy+0x6b>
	for(counter = 0 ; counter < 10000 ; counter++) {
   128ef:	46                   	inc    %esi
   128f0:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   128f6:	7e e5                	jle    128dd <setup_rw_floppy+0x217>
	reset = 1;
   128f8:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   128ff:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12902:	83 ec 0c             	sub    $0xc,%esp
   12905:	68 93 94 01 00       	push   $0x19493
   1290a:	e8 44 5a ff ff       	call   8353 <printk>
   1290f:	83 c4 10             	add    $0x10,%esp
{
   12912:	8a 1d f1 0b 02 00    	mov    0x20bf1,%bl
	if (reset)
   12918:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1291f:	75 3f                	jne    12960 <setup_rw_floppy+0x29a>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12921:	be 00 00 00 00       	mov    $0x0,%esi
   12926:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1292b:	89 ca                	mov    %ecx,%edx
   1292d:	ec                   	in     (%dx),%al
   1292e:	eb 00                	jmp    12930 <setup_rw_floppy+0x26a>
   12930:	eb 00                	jmp    12932 <setup_rw_floppy+0x26c>
   12932:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12935:	3c 80                	cmp    $0x80,%al
   12937:	0f 84 01 fe ff ff    	je     1273e <setup_rw_floppy+0x78>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1293d:	46                   	inc    %esi
   1293e:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12944:	7e e5                	jle    1292b <setup_rw_floppy+0x265>
	reset = 1;
   12946:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1294d:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12950:	83 ec 0c             	sub    $0xc,%esp
   12953:	68 93 94 01 00       	push   $0x19493
   12958:	e8 f6 59 ff ff       	call   8353 <printk>
   1295d:	83 c4 10             	add    $0x10,%esp
{
   12960:	b3 02                	mov    $0x2,%bl
	if (reset)
   12962:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12969:	75 3f                	jne    129aa <setup_rw_floppy+0x2e4>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1296b:	be 00 00 00 00       	mov    $0x0,%esi
   12970:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12975:	89 ca                	mov    %ecx,%edx
   12977:	ec                   	in     (%dx),%al
   12978:	eb 00                	jmp    1297a <setup_rw_floppy+0x2b4>
   1297a:	eb 00                	jmp    1297c <setup_rw_floppy+0x2b6>
   1297c:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1297f:	3c 80                	cmp    $0x80,%al
   12981:	0f 84 c4 fd ff ff    	je     1274b <setup_rw_floppy+0x85>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12987:	46                   	inc    %esi
   12988:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   1298e:	7e e5                	jle    12975 <setup_rw_floppy+0x2af>
	reset = 1;
   12990:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12997:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1299a:	83 ec 0c             	sub    $0xc,%esp
   1299d:	68 93 94 01 00       	push   $0x19493
   129a2:	e8 ac 59 ff ff       	call   8353 <printk>
   129a7:	83 c4 10             	add    $0x10,%esp
{
   129aa:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   129af:	8a 58 04             	mov    0x4(%eax),%bl
	if (reset)
   129b2:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   129b9:	75 3f                	jne    129fa <setup_rw_floppy+0x334>
	for(counter = 0 ; counter < 10000 ; counter++) {
   129bb:	be 00 00 00 00       	mov    $0x0,%esi
   129c0:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   129c5:	89 ca                	mov    %ecx,%edx
   129c7:	ec                   	in     (%dx),%al
   129c8:	eb 00                	jmp    129ca <setup_rw_floppy+0x304>
   129ca:	eb 00                	jmp    129cc <setup_rw_floppy+0x306>
   129cc:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   129cf:	3c 80                	cmp    $0x80,%al
   129d1:	0f 84 81 fd ff ff    	je     12758 <setup_rw_floppy+0x92>
	for(counter = 0 ; counter < 10000 ; counter++) {
   129d7:	46                   	inc    %esi
   129d8:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   129de:	7e e5                	jle    129c5 <setup_rw_floppy+0x2ff>
	reset = 1;
   129e0:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   129e7:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   129ea:	83 ec 0c             	sub    $0xc,%esp
   129ed:	68 93 94 01 00       	push   $0x19493
   129f2:	e8 5c 59 ff ff       	call   8353 <printk>
   129f7:	83 c4 10             	add    $0x10,%esp
{
   129fa:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   129ff:	8a 58 14             	mov    0x14(%eax),%bl
	if (reset)
   12a02:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12a09:	75 3f                	jne    12a4a <setup_rw_floppy+0x384>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12a0b:	be 00 00 00 00       	mov    $0x0,%esi
   12a10:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12a15:	89 ca                	mov    %ecx,%edx
   12a17:	ec                   	in     (%dx),%al
   12a18:	eb 00                	jmp    12a1a <setup_rw_floppy+0x354>
   12a1a:	eb 00                	jmp    12a1c <setup_rw_floppy+0x356>
   12a1c:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12a1f:	3c 80                	cmp    $0x80,%al
   12a21:	0f 84 3e fd ff ff    	je     12765 <setup_rw_floppy+0x9f>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12a27:	46                   	inc    %esi
   12a28:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12a2e:	7e e5                	jle    12a15 <setup_rw_floppy+0x34f>
	reset = 1;
   12a30:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12a37:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12a3a:	83 ec 0c             	sub    $0xc,%esp
   12a3d:	68 93 94 01 00       	push   $0x19493
   12a42:	e8 0c 59 ff ff       	call   8353 <printk>
   12a47:	83 c4 10             	add    $0x10,%esp
{
   12a4a:	b3 ff                	mov    $0xff,%bl
	if (reset)
   12a4c:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12a53:	75 48                	jne    12a9d <setup_rw_floppy+0x3d7>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12a55:	be 00 00 00 00       	mov    $0x0,%esi
   12a5a:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12a5f:	89 ca                	mov    %ecx,%edx
   12a61:	ec                   	in     (%dx),%al
   12a62:	eb 00                	jmp    12a64 <setup_rw_floppy+0x39e>
   12a64:	eb 00                	jmp    12a66 <setup_rw_floppy+0x3a0>
   12a66:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12a69:	3c 80                	cmp    $0x80,%al
   12a6b:	0f 84 01 fd ff ff    	je     12772 <setup_rw_floppy+0xac>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12a71:	46                   	inc    %esi
   12a72:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12a78:	7e e5                	jle    12a5f <setup_rw_floppy+0x399>
	reset = 1;
   12a7a:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12a81:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12a84:	83 ec 0c             	sub    $0xc,%esp
   12a87:	68 93 94 01 00       	push   $0x19493
   12a8c:	e8 c2 58 ff ff       	call   8353 <printk>
   12a91:	83 c4 10             	add    $0x10,%esp
	output_byte(sector);
	output_byte(2);		/* sector size = 512 */
	output_byte(floppy->sect);
	output_byte(floppy->gap);
	output_byte(0xFF);	/* sector size (0xff when n!=0 ?) */
	if (reset)
   12a94:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12a9b:	74 05                	je     12aa2 <setup_rw_floppy+0x3dc>
		do_fd_request();
   12a9d:	e8 11 0f 00 00       	call   139b3 <do_fd_request>
}
   12aa2:	5b                   	pop    %ebx
   12aa3:	5e                   	pop    %esi
   12aa4:	5f                   	pop    %edi
   12aa5:	c3                   	ret    

00012aa6 <seek_interrupt>:
 * This is the routine called after every seek (or recalibrate) interrupt
 * from the floppy controller. Note that the "unexpected interrupt" routine
 * also does a recalibrate, but doesn't come here.
 */
static void seek_interrupt(void)
{
   12aa6:	55                   	push   %ebp
   12aa7:	57                   	push   %edi
   12aa8:	56                   	push   %esi
   12aa9:	53                   	push   %ebx
   12aaa:	83 ec 0c             	sub    $0xc,%esp
{
   12aad:	b3 08                	mov    $0x8,%bl
	if (reset)
   12aaf:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12ab6:	75 3b                	jne    12af3 <seek_interrupt+0x4d>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12ab8:	be 00 00 00 00       	mov    $0x0,%esi
   12abd:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12ac2:	89 ca                	mov    %ecx,%edx
   12ac4:	ec                   	in     (%dx),%al
   12ac5:	eb 00                	jmp    12ac7 <seek_interrupt+0x21>
   12ac7:	eb 00                	jmp    12ac9 <seek_interrupt+0x23>
   12ac9:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12acc:	3c 80                	cmp    $0x80,%al
   12ace:	74 38                	je     12b08 <seek_interrupt+0x62>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12ad0:	46                   	inc    %esi
   12ad1:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12ad7:	7e e9                	jle    12ac2 <seek_interrupt+0x1c>
	reset = 1;
   12ad9:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12ae0:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12ae3:	83 ec 0c             	sub    $0xc,%esp
   12ae6:	68 93 94 01 00       	push   $0x19493
   12aeb:	e8 63 58 ff ff       	call   8353 <printk>
   12af0:	83 c4 10             	add    $0x10,%esp
	int i = 0, counter, status;
   12af3:	bf 00 00 00 00       	mov    $0x0,%edi
	if (reset)
   12af8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12afd:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12b04:	75 76                	jne    12b7c <seek_interrupt+0xd6>
   12b06:	eb 0e                	jmp    12b16 <seek_interrupt+0x70>
			outb(byte,FD_DATA);
   12b08:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12b0d:	88 d8                	mov    %bl,%al
   12b0f:	ee                   	out    %al,(%dx)
   12b10:	eb e1                	jmp    12af3 <seek_interrupt+0x4d>
		if (status == STATUS_READY)
   12b12:	89 f8                	mov    %edi,%eax
   12b14:	eb 66                	jmp    12b7c <seek_interrupt+0xd6>
	for (counter = 0 ; counter < 10000 ; counter++) {
   12b16:	b9 00 00 00 00       	mov    $0x0,%ecx
   12b1b:	be f4 03 00 00       	mov    $0x3f4,%esi
   12b20:	bb f5 03 00 00       	mov    $0x3f5,%ebx
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   12b25:	89 f2                	mov    %esi,%edx
   12b27:	ec                   	in     (%dx),%al
   12b28:	eb 00                	jmp    12b2a <seek_interrupt+0x84>
   12b2a:	eb 00                	jmp    12b2c <seek_interrupt+0x86>
   12b2c:	25 d0 00 00 00       	and    $0xd0,%eax
		if (status == STATUS_READY)
   12b31:	3d 80 00 00 00       	cmp    $0x80,%eax
   12b36:	74 da                	je     12b12 <seek_interrupt+0x6c>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   12b38:	3d d0 00 00 00       	cmp    $0xd0,%eax
   12b3d:	75 15                	jne    12b54 <seek_interrupt+0xae>
			if (i >= MAX_REPLIES)
   12b3f:	83 ff 06             	cmp    $0x6,%edi
   12b42:	7f 19                	jg     12b5d <seek_interrupt+0xb7>
			reply_buffer[i++] = inb_p(FD_DATA);
   12b44:	89 fd                	mov    %edi,%ebp
   12b46:	89 da                	mov    %ebx,%edx
   12b48:	ec                   	in     (%dx),%al
   12b49:	eb 00                	jmp    12b4b <seek_interrupt+0xa5>
   12b4b:	eb 00                	jmp    12b4d <seek_interrupt+0xa7>
   12b4d:	47                   	inc    %edi
   12b4e:	88 85 f6 0b 02 00    	mov    %al,0x20bf6(%ebp)
	for (counter = 0 ; counter < 10000 ; counter++) {
   12b54:	41                   	inc    %ecx
   12b55:	81 f9 0f 27 00 00    	cmp    $0x270f,%ecx
   12b5b:	7e c8                	jle    12b25 <seek_interrupt+0x7f>
	reset = 1;
   12b5d:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12b64:	00 00 00 
	printk("Getstatus times out\n\r");
   12b67:	83 ec 0c             	sub    $0xc,%esp
   12b6a:	68 5f 94 01 00       	push   $0x1945f
   12b6f:	e8 df 57 ff ff       	call   8353 <printk>
   12b74:	83 c4 10             	add    $0x10,%esp
   12b77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
   12b7c:	83 f8 02             	cmp    $0x2,%eax
   12b7f:	75 1e                	jne    12b9f <seek_interrupt+0xf9>
   12b81:	0f b6 05 f6 0b 02 00 	movzbl 0x20bf6,%eax
   12b88:	25 f8 00 00 00       	and    $0xf8,%eax
   12b8d:	83 f8 20             	cmp    $0x20,%eax
   12b90:	75 0d                	jne    12b9f <seek_interrupt+0xf9>
   12b92:	a0 f7 0b 02 00       	mov    0x20bf7,%al
   12b97:	3a 05 f4 0b 02 00    	cmp    0x20bf4,%al
   12b9d:	74 0f                	je     12bae <seek_interrupt+0x108>
/* sense drive status */
	output_byte(FD_SENSEI);
	if (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {
		bad_flp_intr();
   12b9f:	e8 d0 f6 ff ff       	call   12274 <bad_flp_intr>
		do_fd_request();
   12ba4:	e8 0a 0e 00 00       	call   139b3 <do_fd_request>
		return;
   12ba9:	e9 e3 03 00 00       	jmp    12f91 <seek_interrupt+0x4eb>
	}
	current_track = ST1;
   12bae:	a0 f7 0b 02 00       	mov    0x20bf7,%al
   12bb3:	a2 0c bf 01 00       	mov    %al,0x1bf0c
	long addr = (long) CURRENT->buffer;
   12bb8:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   12bbd:	8b 50 14             	mov    0x14(%eax),%edx
	cli();
   12bc0:	fa                   	cli    
	if (addr >= 0x100000) {
   12bc1:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
   12bc7:	7e 1b                	jle    12be4 <seek_interrupt+0x13e>
		addr = (long) tmp_floppy_area;
   12bc9:	ba 00 50 00 00       	mov    $0x5000,%edx
		if (command == FD_WRITE)
   12bce:	80 3d f5 0b 02 00 c5 	cmpb   $0xc5,0x20bf5
   12bd5:	75 0d                	jne    12be4 <seek_interrupt+0x13e>
			copy_buffer(CURRENT->buffer,tmp_floppy_area);
   12bd7:	b9 00 01 00 00       	mov    $0x100,%ecx
   12bdc:	8b 70 14             	mov    0x14(%eax),%esi
   12bdf:	89 d7                	mov    %edx,%edi
   12be1:	fc                   	cld    
   12be2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	immoutb_p(4|2,10);
   12be4:	b0 06                	mov    $0x6,%al
   12be6:	e6 0a                	out    %al,$0xa
   12be8:	eb 00                	jmp    12bea <seek_interrupt+0x144>
   12bea:	eb 00                	jmp    12bec <seek_interrupt+0x146>
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   12bec:	b0 46                	mov    $0x46,%al
   12bee:	80 3d f5 0b 02 00 e6 	cmpb   $0xe6,0x20bf5
   12bf5:	74 79                	je     12c70 <seek_interrupt+0x1ca>
   12bf7:	eb 75                	jmp    12c6e <seek_interrupt+0x1c8>
			outb(byte,FD_DATA);
   12bf9:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12bfe:	88 d8                	mov    %bl,%al
   12c00:	ee                   	out    %al,(%dx)
   12c01:	e9 05 01 00 00       	jmp    12d0b <seek_interrupt+0x265>
   12c06:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c0b:	88 d8                	mov    %bl,%al
   12c0d:	ee                   	out    %al,(%dx)
   12c0e:	e9 52 01 00 00       	jmp    12d65 <seek_interrupt+0x2bf>
   12c13:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c18:	88 d8                	mov    %bl,%al
   12c1a:	ee                   	out    %al,(%dx)
   12c1b:	e9 93 01 00 00       	jmp    12db3 <seek_interrupt+0x30d>
   12c20:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c25:	88 d8                	mov    %bl,%al
   12c27:	ee                   	out    %al,(%dx)
   12c28:	e9 d4 01 00 00       	jmp    12e01 <seek_interrupt+0x35b>
   12c2d:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c32:	88 d8                	mov    %bl,%al
   12c34:	ee                   	out    %al,(%dx)
   12c35:	e9 15 02 00 00       	jmp    12e4f <seek_interrupt+0x3a9>
   12c3a:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c3f:	88 d8                	mov    %bl,%al
   12c41:	ee                   	out    %al,(%dx)
   12c42:	e9 52 02 00 00       	jmp    12e99 <seek_interrupt+0x3f3>
   12c47:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c4c:	88 d8                	mov    %bl,%al
   12c4e:	ee                   	out    %al,(%dx)
   12c4f:	e9 95 02 00 00       	jmp    12ee9 <seek_interrupt+0x443>
   12c54:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c59:	88 d8                	mov    %bl,%al
   12c5b:	ee                   	out    %al,(%dx)
   12c5c:	e9 d8 02 00 00       	jmp    12f39 <seek_interrupt+0x493>
   12c61:	ba f5 03 00 00       	mov    $0x3f5,%edx
   12c66:	88 d8                	mov    %bl,%al
   12c68:	ee                   	out    %al,(%dx)
   12c69:	e9 15 03 00 00       	jmp    12f83 <seek_interrupt+0x4dd>
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   12c6e:	b0 4a                	mov    $0x4a,%al
   12c70:	e6 0c                	out    %al,$0xc
   12c72:	eb 00                	jmp    12c74 <seek_interrupt+0x1ce>
   12c74:	eb 00                	jmp    12c76 <seek_interrupt+0x1d0>
   12c76:	e6 0b                	out    %al,$0xb
   12c78:	eb 00                	jmp    12c7a <seek_interrupt+0x1d4>
   12c7a:	eb 00                	jmp    12c7c <seek_interrupt+0x1d6>
	immoutb_p(addr,4);
   12c7c:	88 d0                	mov    %dl,%al
   12c7e:	e6 04                	out    %al,$0x4
   12c80:	eb 00                	jmp    12c82 <seek_interrupt+0x1dc>
   12c82:	eb 00                	jmp    12c84 <seek_interrupt+0x1de>
	addr >>= 8;
   12c84:	c1 fa 08             	sar    $0x8,%edx
	immoutb_p(addr,4);
   12c87:	88 d0                	mov    %dl,%al
   12c89:	e6 04                	out    %al,$0x4
   12c8b:	eb 00                	jmp    12c8d <seek_interrupt+0x1e7>
   12c8d:	eb 00                	jmp    12c8f <seek_interrupt+0x1e9>
	addr >>= 8;
   12c8f:	c1 fa 08             	sar    $0x8,%edx
	immoutb_p(addr,0x81);
   12c92:	88 d0                	mov    %dl,%al
   12c94:	e6 81                	out    %al,$0x81
   12c96:	eb 00                	jmp    12c98 <seek_interrupt+0x1f2>
   12c98:	eb 00                	jmp    12c9a <seek_interrupt+0x1f4>
	immoutb_p(0xff,5);
   12c9a:	b0 ff                	mov    $0xff,%al
   12c9c:	e6 05                	out    %al,$0x5
   12c9e:	eb 00                	jmp    12ca0 <seek_interrupt+0x1fa>
   12ca0:	eb 00                	jmp    12ca2 <seek_interrupt+0x1fc>
	immoutb_p(3,5);
   12ca2:	b0 03                	mov    $0x3,%al
   12ca4:	e6 05                	out    %al,$0x5
   12ca6:	eb 00                	jmp    12ca8 <seek_interrupt+0x202>
   12ca8:	eb 00                	jmp    12caa <seek_interrupt+0x204>
	immoutb_p(0|2,10);
   12caa:	b0 02                	mov    $0x2,%al
   12cac:	e6 0a                	out    %al,$0xa
   12cae:	eb 00                	jmp    12cb0 <seek_interrupt+0x20a>
   12cb0:	eb 00                	jmp    12cb2 <seek_interrupt+0x20c>
	sti();
   12cb2:	fb                   	sti    
	do_floppy = rw_interrupt;
   12cb3:	c7 05 d8 0b 02 00 b2 	movl   $0x123b2,0x20bd8
   12cba:	23 01 00 
{
   12cbd:	8a 1d f5 0b 02 00    	mov    0x20bf5,%bl
	if (reset)
   12cc3:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12cca:	75 3f                	jne    12d0b <seek_interrupt+0x265>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12ccc:	be 00 00 00 00       	mov    $0x0,%esi
   12cd1:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12cd6:	89 ca                	mov    %ecx,%edx
   12cd8:	ec                   	in     (%dx),%al
   12cd9:	eb 00                	jmp    12cdb <seek_interrupt+0x235>
   12cdb:	eb 00                	jmp    12cdd <seek_interrupt+0x237>
   12cdd:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12ce0:	3c 80                	cmp    $0x80,%al
   12ce2:	0f 84 11 ff ff ff    	je     12bf9 <seek_interrupt+0x153>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12ce8:	46                   	inc    %esi
   12ce9:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12cef:	7e e5                	jle    12cd6 <seek_interrupt+0x230>
	reset = 1;
   12cf1:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12cf8:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12cfb:	83 ec 0c             	sub    $0xc,%esp
   12cfe:	68 93 94 01 00       	push   $0x19493
   12d03:	e8 4b 56 ff ff       	call   8353 <printk>
   12d08:	83 c4 10             	add    $0x10,%esp
{
   12d0b:	0f b6 05 f2 0b 02 00 	movzbl 0x20bf2,%eax
   12d12:	c1 e0 02             	shl    $0x2,%eax
   12d15:	8a 1d f0 0b 02 00    	mov    0x20bf0,%bl
   12d1b:	09 c3                	or     %eax,%ebx
	if (reset)
   12d1d:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12d24:	75 3f                	jne    12d65 <seek_interrupt+0x2bf>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12d26:	be 00 00 00 00       	mov    $0x0,%esi
   12d2b:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12d30:	89 ca                	mov    %ecx,%edx
   12d32:	ec                   	in     (%dx),%al
   12d33:	eb 00                	jmp    12d35 <seek_interrupt+0x28f>
   12d35:	eb 00                	jmp    12d37 <seek_interrupt+0x291>
   12d37:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12d3a:	3c 80                	cmp    $0x80,%al
   12d3c:	0f 84 c4 fe ff ff    	je     12c06 <seek_interrupt+0x160>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12d42:	46                   	inc    %esi
   12d43:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12d49:	7e e5                	jle    12d30 <seek_interrupt+0x28a>
	reset = 1;
   12d4b:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12d52:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12d55:	83 ec 0c             	sub    $0xc,%esp
   12d58:	68 93 94 01 00       	push   $0x19493
   12d5d:	e8 f1 55 ff ff       	call   8353 <printk>
   12d62:	83 c4 10             	add    $0x10,%esp
{
   12d65:	8a 1d f3 0b 02 00    	mov    0x20bf3,%bl
	if (reset)
   12d6b:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12d72:	75 3f                	jne    12db3 <seek_interrupt+0x30d>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12d74:	be 00 00 00 00       	mov    $0x0,%esi
   12d79:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12d7e:	89 ca                	mov    %ecx,%edx
   12d80:	ec                   	in     (%dx),%al
   12d81:	eb 00                	jmp    12d83 <seek_interrupt+0x2dd>
   12d83:	eb 00                	jmp    12d85 <seek_interrupt+0x2df>
   12d85:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12d88:	3c 80                	cmp    $0x80,%al
   12d8a:	0f 84 83 fe ff ff    	je     12c13 <seek_interrupt+0x16d>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12d90:	46                   	inc    %esi
   12d91:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12d97:	7e e5                	jle    12d7e <seek_interrupt+0x2d8>
	reset = 1;
   12d99:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12da0:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12da3:	83 ec 0c             	sub    $0xc,%esp
   12da6:	68 93 94 01 00       	push   $0x19493
   12dab:	e8 a3 55 ff ff       	call   8353 <printk>
   12db0:	83 c4 10             	add    $0x10,%esp
{
   12db3:	8a 1d f2 0b 02 00    	mov    0x20bf2,%bl
	if (reset)
   12db9:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12dc0:	75 3f                	jne    12e01 <seek_interrupt+0x35b>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12dc2:	be 00 00 00 00       	mov    $0x0,%esi
   12dc7:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12dcc:	89 ca                	mov    %ecx,%edx
   12dce:	ec                   	in     (%dx),%al
   12dcf:	eb 00                	jmp    12dd1 <seek_interrupt+0x32b>
   12dd1:	eb 00                	jmp    12dd3 <seek_interrupt+0x32d>
   12dd3:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12dd6:	3c 80                	cmp    $0x80,%al
   12dd8:	0f 84 42 fe ff ff    	je     12c20 <seek_interrupt+0x17a>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12dde:	46                   	inc    %esi
   12ddf:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12de5:	7e e5                	jle    12dcc <seek_interrupt+0x326>
	reset = 1;
   12de7:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12dee:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12df1:	83 ec 0c             	sub    $0xc,%esp
   12df4:	68 93 94 01 00       	push   $0x19493
   12df9:	e8 55 55 ff ff       	call   8353 <printk>
   12dfe:	83 c4 10             	add    $0x10,%esp
{
   12e01:	8a 1d f1 0b 02 00    	mov    0x20bf1,%bl
	if (reset)
   12e07:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12e0e:	75 3f                	jne    12e4f <seek_interrupt+0x3a9>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12e10:	be 00 00 00 00       	mov    $0x0,%esi
   12e15:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12e1a:	89 ca                	mov    %ecx,%edx
   12e1c:	ec                   	in     (%dx),%al
   12e1d:	eb 00                	jmp    12e1f <seek_interrupt+0x379>
   12e1f:	eb 00                	jmp    12e21 <seek_interrupt+0x37b>
   12e21:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12e24:	3c 80                	cmp    $0x80,%al
   12e26:	0f 84 01 fe ff ff    	je     12c2d <seek_interrupt+0x187>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12e2c:	46                   	inc    %esi
   12e2d:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12e33:	7e e5                	jle    12e1a <seek_interrupt+0x374>
	reset = 1;
   12e35:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12e3c:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12e3f:	83 ec 0c             	sub    $0xc,%esp
   12e42:	68 93 94 01 00       	push   $0x19493
   12e47:	e8 07 55 ff ff       	call   8353 <printk>
   12e4c:	83 c4 10             	add    $0x10,%esp
{
   12e4f:	b3 02                	mov    $0x2,%bl
	if (reset)
   12e51:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12e58:	75 3f                	jne    12e99 <seek_interrupt+0x3f3>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12e5a:	be 00 00 00 00       	mov    $0x0,%esi
   12e5f:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12e64:	89 ca                	mov    %ecx,%edx
   12e66:	ec                   	in     (%dx),%al
   12e67:	eb 00                	jmp    12e69 <seek_interrupt+0x3c3>
   12e69:	eb 00                	jmp    12e6b <seek_interrupt+0x3c5>
   12e6b:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12e6e:	3c 80                	cmp    $0x80,%al
   12e70:	0f 84 c4 fd ff ff    	je     12c3a <seek_interrupt+0x194>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12e76:	46                   	inc    %esi
   12e77:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12e7d:	7e e5                	jle    12e64 <seek_interrupt+0x3be>
	reset = 1;
   12e7f:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12e86:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12e89:	83 ec 0c             	sub    $0xc,%esp
   12e8c:	68 93 94 01 00       	push   $0x19493
   12e91:	e8 bd 54 ff ff       	call   8353 <printk>
   12e96:	83 c4 10             	add    $0x10,%esp
{
   12e99:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   12e9e:	8a 58 04             	mov    0x4(%eax),%bl
	if (reset)
   12ea1:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12ea8:	75 3f                	jne    12ee9 <seek_interrupt+0x443>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12eaa:	be 00 00 00 00       	mov    $0x0,%esi
   12eaf:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12eb4:	89 ca                	mov    %ecx,%edx
   12eb6:	ec                   	in     (%dx),%al
   12eb7:	eb 00                	jmp    12eb9 <seek_interrupt+0x413>
   12eb9:	eb 00                	jmp    12ebb <seek_interrupt+0x415>
   12ebb:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12ebe:	3c 80                	cmp    $0x80,%al
   12ec0:	0f 84 81 fd ff ff    	je     12c47 <seek_interrupt+0x1a1>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12ec6:	46                   	inc    %esi
   12ec7:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12ecd:	7e e5                	jle    12eb4 <seek_interrupt+0x40e>
	reset = 1;
   12ecf:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12ed6:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12ed9:	83 ec 0c             	sub    $0xc,%esp
   12edc:	68 93 94 01 00       	push   $0x19493
   12ee1:	e8 6d 54 ff ff       	call   8353 <printk>
   12ee6:	83 c4 10             	add    $0x10,%esp
{
   12ee9:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   12eee:	8a 58 14             	mov    0x14(%eax),%bl
	if (reset)
   12ef1:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12ef8:	75 3f                	jne    12f39 <seek_interrupt+0x493>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12efa:	be 00 00 00 00       	mov    $0x0,%esi
   12eff:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12f04:	89 ca                	mov    %ecx,%edx
   12f06:	ec                   	in     (%dx),%al
   12f07:	eb 00                	jmp    12f09 <seek_interrupt+0x463>
   12f09:	eb 00                	jmp    12f0b <seek_interrupt+0x465>
   12f0b:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12f0e:	3c 80                	cmp    $0x80,%al
   12f10:	0f 84 3e fd ff ff    	je     12c54 <seek_interrupt+0x1ae>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12f16:	46                   	inc    %esi
   12f17:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12f1d:	7e e5                	jle    12f04 <seek_interrupt+0x45e>
	reset = 1;
   12f1f:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12f26:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12f29:	83 ec 0c             	sub    $0xc,%esp
   12f2c:	68 93 94 01 00       	push   $0x19493
   12f31:	e8 1d 54 ff ff       	call   8353 <printk>
   12f36:	83 c4 10             	add    $0x10,%esp
{
   12f39:	b3 ff                	mov    $0xff,%bl
	if (reset)
   12f3b:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12f42:	75 48                	jne    12f8c <seek_interrupt+0x4e6>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12f44:	be 00 00 00 00       	mov    $0x0,%esi
   12f49:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12f4e:	89 ca                	mov    %ecx,%edx
   12f50:	ec                   	in     (%dx),%al
   12f51:	eb 00                	jmp    12f53 <seek_interrupt+0x4ad>
   12f53:	eb 00                	jmp    12f55 <seek_interrupt+0x4af>
   12f55:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12f58:	3c 80                	cmp    $0x80,%al
   12f5a:	0f 84 01 fd ff ff    	je     12c61 <seek_interrupt+0x1bb>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12f60:	46                   	inc    %esi
   12f61:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12f67:	7e e5                	jle    12f4e <seek_interrupt+0x4a8>
	reset = 1;
   12f69:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12f70:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12f73:	83 ec 0c             	sub    $0xc,%esp
   12f76:	68 93 94 01 00       	push   $0x19493
   12f7b:	e8 d3 53 ff ff       	call   8353 <printk>
   12f80:	83 c4 10             	add    $0x10,%esp
	if (reset)
   12f83:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12f8a:	74 05                	je     12f91 <seek_interrupt+0x4eb>
		do_fd_request();
   12f8c:	e8 22 0a 00 00       	call   139b3 <do_fd_request>
	setup_rw_floppy();
}
   12f91:	83 c4 0c             	add    $0xc,%esp
   12f94:	5b                   	pop    %ebx
   12f95:	5e                   	pop    %esi
   12f96:	5f                   	pop    %edi
   12f97:	5d                   	pop    %ebp
   12f98:	c3                   	ret    

00012f99 <transfer>:
 * This routine is called when everything should be correctly set up
 * for the transfer (ie floppy motor is on and the correct floppy is
 * selected).
 */
static void transfer(void)
{
   12f99:	57                   	push   %edi
   12f9a:	56                   	push   %esi
   12f9b:	53                   	push   %ebx
	if (cur_spec1 != floppy->spec1) {
   12f9c:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   12fa1:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   12fa5:	3b 05 00 bf 01 00    	cmp    0x1bf00,%eax
   12fab:	0f 84 e3 00 00 00    	je     13094 <transfer+0xfb>
		cur_spec1 = floppy->spec1;
   12fb1:	a3 00 bf 01 00       	mov    %eax,0x1bf00
{
   12fb6:	b3 03                	mov    $0x3,%bl
	if (reset)
   12fb8:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   12fbf:	75 3f                	jne    13000 <transfer+0x67>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12fc1:	be 00 00 00 00       	mov    $0x0,%esi
   12fc6:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   12fcb:	89 ca                	mov    %ecx,%edx
   12fcd:	ec                   	in     (%dx),%al
   12fce:	eb 00                	jmp    12fd0 <transfer+0x37>
   12fd0:	eb 00                	jmp    12fd2 <transfer+0x39>
   12fd2:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   12fd5:	3c 80                	cmp    $0x80,%al
   12fd7:	0f 84 01 01 00 00    	je     130de <transfer+0x145>
	for(counter = 0 ; counter < 10000 ; counter++) {
   12fdd:	46                   	inc    %esi
   12fde:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   12fe4:	7e e5                	jle    12fcb <transfer+0x32>
	reset = 1;
   12fe6:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   12fed:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   12ff0:	83 ec 0c             	sub    $0xc,%esp
   12ff3:	68 93 94 01 00       	push   $0x19493
   12ff8:	e8 56 53 ff ff       	call   8353 <printk>
   12ffd:	83 c4 10             	add    $0x10,%esp
{
   13000:	8a 1d 00 bf 01 00    	mov    0x1bf00,%bl
	if (reset)
   13006:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1300d:	75 3f                	jne    1304e <transfer+0xb5>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1300f:	be 00 00 00 00       	mov    $0x0,%esi
   13014:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13019:	89 ca                	mov    %ecx,%edx
   1301b:	ec                   	in     (%dx),%al
   1301c:	eb 00                	jmp    1301e <transfer+0x85>
   1301e:	eb 00                	jmp    13020 <transfer+0x87>
   13020:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13023:	3c 80                	cmp    $0x80,%al
   13025:	0f 84 a6 00 00 00    	je     130d1 <transfer+0x138>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1302b:	46                   	inc    %esi
   1302c:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13032:	7e e5                	jle    13019 <transfer+0x80>
	reset = 1;
   13034:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1303b:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1303e:	83 ec 0c             	sub    $0xc,%esp
   13041:	68 93 94 01 00       	push   $0x19493
   13046:	e8 08 53 ff ff       	call   8353 <printk>
   1304b:	83 c4 10             	add    $0x10,%esp
{
   1304e:	b3 06                	mov    $0x6,%bl
	if (reset)
   13050:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13057:	75 3b                	jne    13094 <transfer+0xfb>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13059:	be 00 00 00 00       	mov    $0x0,%esi
   1305e:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13063:	89 ca                	mov    %ecx,%edx
   13065:	ec                   	in     (%dx),%al
   13066:	eb 00                	jmp    13068 <transfer+0xcf>
   13068:	eb 00                	jmp    1306a <transfer+0xd1>
   1306a:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1306d:	3c 80                	cmp    $0x80,%al
   1306f:	74 56                	je     130c7 <transfer+0x12e>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13071:	46                   	inc    %esi
   13072:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13078:	7e e9                	jle    13063 <transfer+0xca>
	reset = 1;
   1307a:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13081:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13084:	83 ec 0c             	sub    $0xc,%esp
   13087:	68 93 94 01 00       	push   $0x19493
   1308c:	e8 c2 52 ff ff       	call   8353 <printk>
   13091:	83 c4 10             	add    $0x10,%esp
		output_byte(FD_SPECIFY);
		output_byte(cur_spec1);		/* hut etc */
		output_byte(6);			/* Head load time =6ms, DMA */
	}
	if (cur_rate != floppy->rate)
   13094:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   13099:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   1309d:	3b 05 04 bf 01 00    	cmp    0x1bf04,%eax
   130a3:	74 0f                	je     130b4 <transfer+0x11b>
		outb_p(cur_rate = floppy->rate,FD_DCR);
   130a5:	a3 04 bf 01 00       	mov    %eax,0x1bf04
   130aa:	ba f7 03 00 00       	mov    $0x3f7,%edx
   130af:	ee                   	out    %al,(%dx)
   130b0:	eb 00                	jmp    130b2 <transfer+0x119>
   130b2:	eb 00                	jmp    130b4 <transfer+0x11b>
	if (reset) {
   130b4:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   130bb:	74 2e                	je     130eb <transfer+0x152>
		do_fd_request();
   130bd:	e8 f1 08 00 00       	call   139b3 <do_fd_request>
		return;
   130c2:	e9 06 06 00 00       	jmp    136cd <transfer+0x734>
			outb(byte,FD_DATA);
   130c7:	ba f5 03 00 00       	mov    $0x3f5,%edx
   130cc:	88 d8                	mov    %bl,%al
   130ce:	ee                   	out    %al,(%dx)
   130cf:	eb c3                	jmp    13094 <transfer+0xfb>
   130d1:	ba f5 03 00 00       	mov    $0x3f5,%edx
   130d6:	88 d8                	mov    %bl,%al
   130d8:	ee                   	out    %al,(%dx)
   130d9:	e9 70 ff ff ff       	jmp    1304e <transfer+0xb5>
   130de:	ba f5 03 00 00       	mov    $0x3f5,%edx
   130e3:	88 d8                	mov    %bl,%al
   130e5:	ee                   	out    %al,(%dx)
   130e6:	e9 15 ff ff ff       	jmp    13000 <transfer+0x67>
	}
	if (!seek) {
   130eb:	83 3d ec 0b 02 00 00 	cmpl   $0x0,0x20bec
   130f2:	0f 85 f9 03 00 00    	jne    134f1 <transfer+0x558>
	long addr = (long) CURRENT->buffer;
   130f8:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   130fd:	8b 50 14             	mov    0x14(%eax),%edx
	cli();
   13100:	fa                   	cli    
	if (addr >= 0x100000) {
   13101:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
   13107:	7e 1b                	jle    13124 <transfer+0x18b>
		addr = (long) tmp_floppy_area;
   13109:	ba 00 50 00 00       	mov    $0x5000,%edx
		if (command == FD_WRITE)
   1310e:	80 3d f5 0b 02 00 c5 	cmpb   $0xc5,0x20bf5
   13115:	75 0d                	jne    13124 <transfer+0x18b>
			copy_buffer(CURRENT->buffer,tmp_floppy_area);
   13117:	b9 00 01 00 00       	mov    $0x100,%ecx
   1311c:	8b 70 14             	mov    0x14(%eax),%esi
   1311f:	89 d7                	mov    %edx,%edi
   13121:	fc                   	cld    
   13122:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	immoutb_p(4|2,10);
   13124:	b0 06                	mov    $0x6,%al
   13126:	e6 0a                	out    %al,$0xa
   13128:	eb 00                	jmp    1312a <transfer+0x191>
   1312a:	eb 00                	jmp    1312c <transfer+0x193>
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   1312c:	b0 46                	mov    $0x46,%al
   1312e:	80 3d f5 0b 02 00 e6 	cmpb   $0xe6,0x20bf5
   13135:	74 79                	je     131b0 <transfer+0x217>
   13137:	eb 75                	jmp    131ae <transfer+0x215>
			outb(byte,FD_DATA);
   13139:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1313e:	88 d8                	mov    %bl,%al
   13140:	ee                   	out    %al,(%dx)
   13141:	e9 05 01 00 00       	jmp    1324b <transfer+0x2b2>
   13146:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1314b:	88 d8                	mov    %bl,%al
   1314d:	ee                   	out    %al,(%dx)
   1314e:	e9 52 01 00 00       	jmp    132a5 <transfer+0x30c>
   13153:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13158:	88 d8                	mov    %bl,%al
   1315a:	ee                   	out    %al,(%dx)
   1315b:	e9 93 01 00 00       	jmp    132f3 <transfer+0x35a>
   13160:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13165:	88 d8                	mov    %bl,%al
   13167:	ee                   	out    %al,(%dx)
   13168:	e9 d4 01 00 00       	jmp    13341 <transfer+0x3a8>
   1316d:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13172:	88 d8                	mov    %bl,%al
   13174:	ee                   	out    %al,(%dx)
   13175:	e9 15 02 00 00       	jmp    1338f <transfer+0x3f6>
   1317a:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1317f:	88 d8                	mov    %bl,%al
   13181:	ee                   	out    %al,(%dx)
   13182:	e9 52 02 00 00       	jmp    133d9 <transfer+0x440>
   13187:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1318c:	88 d8                	mov    %bl,%al
   1318e:	ee                   	out    %al,(%dx)
   1318f:	e9 95 02 00 00       	jmp    13429 <transfer+0x490>
   13194:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13199:	88 d8                	mov    %bl,%al
   1319b:	ee                   	out    %al,(%dx)
   1319c:	e9 d8 02 00 00       	jmp    13479 <transfer+0x4e0>
   131a1:	ba f5 03 00 00       	mov    $0x3f5,%edx
   131a6:	88 d8                	mov    %bl,%al
   131a8:	ee                   	out    %al,(%dx)
   131a9:	e9 15 03 00 00       	jmp    134c3 <transfer+0x52a>
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   131ae:	b0 4a                	mov    $0x4a,%al
   131b0:	e6 0c                	out    %al,$0xc
   131b2:	eb 00                	jmp    131b4 <transfer+0x21b>
   131b4:	eb 00                	jmp    131b6 <transfer+0x21d>
   131b6:	e6 0b                	out    %al,$0xb
   131b8:	eb 00                	jmp    131ba <transfer+0x221>
   131ba:	eb 00                	jmp    131bc <transfer+0x223>
	immoutb_p(addr,4);
   131bc:	88 d0                	mov    %dl,%al
   131be:	e6 04                	out    %al,$0x4
   131c0:	eb 00                	jmp    131c2 <transfer+0x229>
   131c2:	eb 00                	jmp    131c4 <transfer+0x22b>
	addr >>= 8;
   131c4:	c1 fa 08             	sar    $0x8,%edx
	immoutb_p(addr,4);
   131c7:	88 d0                	mov    %dl,%al
   131c9:	e6 04                	out    %al,$0x4
   131cb:	eb 00                	jmp    131cd <transfer+0x234>
   131cd:	eb 00                	jmp    131cf <transfer+0x236>
	addr >>= 8;
   131cf:	c1 fa 08             	sar    $0x8,%edx
	immoutb_p(addr,0x81);
   131d2:	88 d0                	mov    %dl,%al
   131d4:	e6 81                	out    %al,$0x81
   131d6:	eb 00                	jmp    131d8 <transfer+0x23f>
   131d8:	eb 00                	jmp    131da <transfer+0x241>
	immoutb_p(0xff,5);
   131da:	b0 ff                	mov    $0xff,%al
   131dc:	e6 05                	out    %al,$0x5
   131de:	eb 00                	jmp    131e0 <transfer+0x247>
   131e0:	eb 00                	jmp    131e2 <transfer+0x249>
	immoutb_p(3,5);
   131e2:	b0 03                	mov    $0x3,%al
   131e4:	e6 05                	out    %al,$0x5
   131e6:	eb 00                	jmp    131e8 <transfer+0x24f>
   131e8:	eb 00                	jmp    131ea <transfer+0x251>
	immoutb_p(0|2,10);
   131ea:	b0 02                	mov    $0x2,%al
   131ec:	e6 0a                	out    %al,$0xa
   131ee:	eb 00                	jmp    131f0 <transfer+0x257>
   131f0:	eb 00                	jmp    131f2 <transfer+0x259>
	sti();
   131f2:	fb                   	sti    
	do_floppy = rw_interrupt;
   131f3:	c7 05 d8 0b 02 00 b2 	movl   $0x123b2,0x20bd8
   131fa:	23 01 00 
{
   131fd:	8a 1d f5 0b 02 00    	mov    0x20bf5,%bl
	if (reset)
   13203:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1320a:	75 3f                	jne    1324b <transfer+0x2b2>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1320c:	be 00 00 00 00       	mov    $0x0,%esi
   13211:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13216:	89 ca                	mov    %ecx,%edx
   13218:	ec                   	in     (%dx),%al
   13219:	eb 00                	jmp    1321b <transfer+0x282>
   1321b:	eb 00                	jmp    1321d <transfer+0x284>
   1321d:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13220:	3c 80                	cmp    $0x80,%al
   13222:	0f 84 11 ff ff ff    	je     13139 <transfer+0x1a0>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13228:	46                   	inc    %esi
   13229:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   1322f:	7e e5                	jle    13216 <transfer+0x27d>
	reset = 1;
   13231:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13238:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1323b:	83 ec 0c             	sub    $0xc,%esp
   1323e:	68 93 94 01 00       	push   $0x19493
   13243:	e8 0b 51 ff ff       	call   8353 <printk>
   13248:	83 c4 10             	add    $0x10,%esp
{
   1324b:	0f b6 05 f2 0b 02 00 	movzbl 0x20bf2,%eax
   13252:	c1 e0 02             	shl    $0x2,%eax
   13255:	8a 1d f0 0b 02 00    	mov    0x20bf0,%bl
   1325b:	09 c3                	or     %eax,%ebx
	if (reset)
   1325d:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13264:	75 3f                	jne    132a5 <transfer+0x30c>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13266:	be 00 00 00 00       	mov    $0x0,%esi
   1326b:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13270:	89 ca                	mov    %ecx,%edx
   13272:	ec                   	in     (%dx),%al
   13273:	eb 00                	jmp    13275 <transfer+0x2dc>
   13275:	eb 00                	jmp    13277 <transfer+0x2de>
   13277:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1327a:	3c 80                	cmp    $0x80,%al
   1327c:	0f 84 c4 fe ff ff    	je     13146 <transfer+0x1ad>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13282:	46                   	inc    %esi
   13283:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13289:	7e e5                	jle    13270 <transfer+0x2d7>
	reset = 1;
   1328b:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13292:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13295:	83 ec 0c             	sub    $0xc,%esp
   13298:	68 93 94 01 00       	push   $0x19493
   1329d:	e8 b1 50 ff ff       	call   8353 <printk>
   132a2:	83 c4 10             	add    $0x10,%esp
{
   132a5:	8a 1d f3 0b 02 00    	mov    0x20bf3,%bl
	if (reset)
   132ab:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   132b2:	75 3f                	jne    132f3 <transfer+0x35a>
	for(counter = 0 ; counter < 10000 ; counter++) {
   132b4:	be 00 00 00 00       	mov    $0x0,%esi
   132b9:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   132be:	89 ca                	mov    %ecx,%edx
   132c0:	ec                   	in     (%dx),%al
   132c1:	eb 00                	jmp    132c3 <transfer+0x32a>
   132c3:	eb 00                	jmp    132c5 <transfer+0x32c>
   132c5:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   132c8:	3c 80                	cmp    $0x80,%al
   132ca:	0f 84 83 fe ff ff    	je     13153 <transfer+0x1ba>
	for(counter = 0 ; counter < 10000 ; counter++) {
   132d0:	46                   	inc    %esi
   132d1:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   132d7:	7e e5                	jle    132be <transfer+0x325>
	reset = 1;
   132d9:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   132e0:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   132e3:	83 ec 0c             	sub    $0xc,%esp
   132e6:	68 93 94 01 00       	push   $0x19493
   132eb:	e8 63 50 ff ff       	call   8353 <printk>
   132f0:	83 c4 10             	add    $0x10,%esp
{
   132f3:	8a 1d f2 0b 02 00    	mov    0x20bf2,%bl
	if (reset)
   132f9:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13300:	75 3f                	jne    13341 <transfer+0x3a8>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13302:	be 00 00 00 00       	mov    $0x0,%esi
   13307:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1330c:	89 ca                	mov    %ecx,%edx
   1330e:	ec                   	in     (%dx),%al
   1330f:	eb 00                	jmp    13311 <transfer+0x378>
   13311:	eb 00                	jmp    13313 <transfer+0x37a>
   13313:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13316:	3c 80                	cmp    $0x80,%al
   13318:	0f 84 42 fe ff ff    	je     13160 <transfer+0x1c7>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1331e:	46                   	inc    %esi
   1331f:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13325:	7e e5                	jle    1330c <transfer+0x373>
	reset = 1;
   13327:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1332e:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13331:	83 ec 0c             	sub    $0xc,%esp
   13334:	68 93 94 01 00       	push   $0x19493
   13339:	e8 15 50 ff ff       	call   8353 <printk>
   1333e:	83 c4 10             	add    $0x10,%esp
{
   13341:	8a 1d f1 0b 02 00    	mov    0x20bf1,%bl
	if (reset)
   13347:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1334e:	75 3f                	jne    1338f <transfer+0x3f6>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13350:	be 00 00 00 00       	mov    $0x0,%esi
   13355:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1335a:	89 ca                	mov    %ecx,%edx
   1335c:	ec                   	in     (%dx),%al
   1335d:	eb 00                	jmp    1335f <transfer+0x3c6>
   1335f:	eb 00                	jmp    13361 <transfer+0x3c8>
   13361:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13364:	3c 80                	cmp    $0x80,%al
   13366:	0f 84 01 fe ff ff    	je     1316d <transfer+0x1d4>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1336c:	46                   	inc    %esi
   1336d:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13373:	7e e5                	jle    1335a <transfer+0x3c1>
	reset = 1;
   13375:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1337c:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1337f:	83 ec 0c             	sub    $0xc,%esp
   13382:	68 93 94 01 00       	push   $0x19493
   13387:	e8 c7 4f ff ff       	call   8353 <printk>
   1338c:	83 c4 10             	add    $0x10,%esp
{
   1338f:	b3 02                	mov    $0x2,%bl
	if (reset)
   13391:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13398:	75 3f                	jne    133d9 <transfer+0x440>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1339a:	be 00 00 00 00       	mov    $0x0,%esi
   1339f:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   133a4:	89 ca                	mov    %ecx,%edx
   133a6:	ec                   	in     (%dx),%al
   133a7:	eb 00                	jmp    133a9 <transfer+0x410>
   133a9:	eb 00                	jmp    133ab <transfer+0x412>
   133ab:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   133ae:	3c 80                	cmp    $0x80,%al
   133b0:	0f 84 c4 fd ff ff    	je     1317a <transfer+0x1e1>
	for(counter = 0 ; counter < 10000 ; counter++) {
   133b6:	46                   	inc    %esi
   133b7:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   133bd:	7e e5                	jle    133a4 <transfer+0x40b>
	reset = 1;
   133bf:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   133c6:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   133c9:	83 ec 0c             	sub    $0xc,%esp
   133cc:	68 93 94 01 00       	push   $0x19493
   133d1:	e8 7d 4f ff ff       	call   8353 <printk>
   133d6:	83 c4 10             	add    $0x10,%esp
{
   133d9:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   133de:	8a 58 04             	mov    0x4(%eax),%bl
	if (reset)
   133e1:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   133e8:	75 3f                	jne    13429 <transfer+0x490>
	for(counter = 0 ; counter < 10000 ; counter++) {
   133ea:	be 00 00 00 00       	mov    $0x0,%esi
   133ef:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   133f4:	89 ca                	mov    %ecx,%edx
   133f6:	ec                   	in     (%dx),%al
   133f7:	eb 00                	jmp    133f9 <transfer+0x460>
   133f9:	eb 00                	jmp    133fb <transfer+0x462>
   133fb:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   133fe:	3c 80                	cmp    $0x80,%al
   13400:	0f 84 81 fd ff ff    	je     13187 <transfer+0x1ee>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13406:	46                   	inc    %esi
   13407:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   1340d:	7e e5                	jle    133f4 <transfer+0x45b>
	reset = 1;
   1340f:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13416:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13419:	83 ec 0c             	sub    $0xc,%esp
   1341c:	68 93 94 01 00       	push   $0x19493
   13421:	e8 2d 4f ff ff       	call   8353 <printk>
   13426:	83 c4 10             	add    $0x10,%esp
{
   13429:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   1342e:	8a 58 14             	mov    0x14(%eax),%bl
	if (reset)
   13431:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13438:	75 3f                	jne    13479 <transfer+0x4e0>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1343a:	be 00 00 00 00       	mov    $0x0,%esi
   1343f:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13444:	89 ca                	mov    %ecx,%edx
   13446:	ec                   	in     (%dx),%al
   13447:	eb 00                	jmp    13449 <transfer+0x4b0>
   13449:	eb 00                	jmp    1344b <transfer+0x4b2>
   1344b:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1344e:	3c 80                	cmp    $0x80,%al
   13450:	0f 84 3e fd ff ff    	je     13194 <transfer+0x1fb>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13456:	46                   	inc    %esi
   13457:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   1345d:	7e e5                	jle    13444 <transfer+0x4ab>
	reset = 1;
   1345f:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13466:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13469:	83 ec 0c             	sub    $0xc,%esp
   1346c:	68 93 94 01 00       	push   $0x19493
   13471:	e8 dd 4e ff ff       	call   8353 <printk>
   13476:	83 c4 10             	add    $0x10,%esp
{
   13479:	b3 ff                	mov    $0xff,%bl
	if (reset)
   1347b:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13482:	75 4c                	jne    134d0 <transfer+0x537>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13484:	be 00 00 00 00       	mov    $0x0,%esi
   13489:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1348e:	89 ca                	mov    %ecx,%edx
   13490:	ec                   	in     (%dx),%al
   13491:	eb 00                	jmp    13493 <transfer+0x4fa>
   13493:	eb 00                	jmp    13495 <transfer+0x4fc>
   13495:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13498:	3c 80                	cmp    $0x80,%al
   1349a:	0f 84 01 fd ff ff    	je     131a1 <transfer+0x208>
	for(counter = 0 ; counter < 10000 ; counter++) {
   134a0:	46                   	inc    %esi
   134a1:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   134a7:	7e e5                	jle    1348e <transfer+0x4f5>
	reset = 1;
   134a9:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   134b0:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   134b3:	83 ec 0c             	sub    $0xc,%esp
   134b6:	68 93 94 01 00       	push   $0x19493
   134bb:	e8 93 4e ff ff       	call   8353 <printk>
   134c0:	83 c4 10             	add    $0x10,%esp
	if (reset)
   134c3:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   134ca:	0f 84 fd 01 00 00    	je     136cd <transfer+0x734>
		do_fd_request();
   134d0:	e8 de 04 00 00       	call   139b3 <do_fd_request>
		setup_rw_floppy();
		return;
   134d5:	e9 f3 01 00 00       	jmp    136cd <transfer+0x734>
			outb(byte,FD_DATA);
   134da:	ba f5 03 00 00       	mov    $0x3f5,%edx
   134df:	88 d8                	mov    %bl,%al
   134e1:	ee                   	out    %al,(%dx)
   134e2:	eb 6a                	jmp    1354e <transfer+0x5b5>
   134e4:	ba f5 03 00 00       	mov    $0x3f5,%edx
   134e9:	88 d8                	mov    %bl,%al
   134eb:	ee                   	out    %al,(%dx)
   134ec:	e9 b7 00 00 00       	jmp    135a8 <transfer+0x60f>
	}
	do_floppy = seek_interrupt;
   134f1:	c7 05 d8 0b 02 00 a6 	movl   $0x12aa6,0x20bd8
   134f8:	2a 01 00 
	if (seek_track) {
   134fb:	80 3d f4 0b 02 00 00 	cmpb   $0x0,0x20bf4
   13502:	0f 84 17 01 00 00    	je     1361f <transfer+0x686>
{
   13508:	b3 0f                	mov    $0xf,%bl
	if (reset)
   1350a:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13511:	75 3b                	jne    1354e <transfer+0x5b5>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13513:	be 00 00 00 00       	mov    $0x0,%esi
   13518:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1351d:	89 ca                	mov    %ecx,%edx
   1351f:	ec                   	in     (%dx),%al
   13520:	eb 00                	jmp    13522 <transfer+0x589>
   13522:	eb 00                	jmp    13524 <transfer+0x58b>
   13524:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13527:	3c 80                	cmp    $0x80,%al
   13529:	74 af                	je     134da <transfer+0x541>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1352b:	46                   	inc    %esi
   1352c:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13532:	7e e9                	jle    1351d <transfer+0x584>
	reset = 1;
   13534:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1353b:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1353e:	83 ec 0c             	sub    $0xc,%esp
   13541:	68 93 94 01 00       	push   $0x19493
   13546:	e8 08 4e ff ff       	call   8353 <printk>
   1354b:	83 c4 10             	add    $0x10,%esp
{
   1354e:	0f b6 05 f2 0b 02 00 	movzbl 0x20bf2,%eax
   13555:	c1 e0 02             	shl    $0x2,%eax
   13558:	8a 1d f0 0b 02 00    	mov    0x20bf0,%bl
   1355e:	09 c3                	or     %eax,%ebx
	if (reset)
   13560:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13567:	75 3f                	jne    135a8 <transfer+0x60f>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13569:	be 00 00 00 00       	mov    $0x0,%esi
   1356e:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13573:	89 ca                	mov    %ecx,%edx
   13575:	ec                   	in     (%dx),%al
   13576:	eb 00                	jmp    13578 <transfer+0x5df>
   13578:	eb 00                	jmp    1357a <transfer+0x5e1>
   1357a:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1357d:	3c 80                	cmp    $0x80,%al
   1357f:	0f 84 5f ff ff ff    	je     134e4 <transfer+0x54b>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13585:	46                   	inc    %esi
   13586:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   1358c:	7e e5                	jle    13573 <transfer+0x5da>
	reset = 1;
   1358e:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13595:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13598:	83 ec 0c             	sub    $0xc,%esp
   1359b:	68 93 94 01 00       	push   $0x19493
   135a0:	e8 ae 4d ff ff       	call   8353 <printk>
   135a5:	83 c4 10             	add    $0x10,%esp
{
   135a8:	8a 1d f4 0b 02 00    	mov    0x20bf4,%bl
	if (reset)
   135ae:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   135b5:	0f 85 0d 01 00 00    	jne    136c8 <transfer+0x72f>
	for(counter = 0 ; counter < 10000 ; counter++) {
   135bb:	be 00 00 00 00       	mov    $0x0,%esi
   135c0:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   135c5:	89 ca                	mov    %ecx,%edx
   135c7:	ec                   	in     (%dx),%al
   135c8:	eb 00                	jmp    135ca <transfer+0x631>
   135ca:	eb 00                	jmp    135cc <transfer+0x633>
   135cc:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   135cf:	3c 80                	cmp    $0x80,%al
   135d1:	74 28                	je     135fb <transfer+0x662>
	for(counter = 0 ; counter < 10000 ; counter++) {
   135d3:	46                   	inc    %esi
   135d4:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   135da:	7e e9                	jle    135c5 <transfer+0x62c>
	reset = 1;
   135dc:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   135e3:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   135e6:	83 ec 0c             	sub    $0xc,%esp
   135e9:	68 93 94 01 00       	push   $0x19493
   135ee:	e8 60 4d ff ff       	call   8353 <printk>
   135f3:	83 c4 10             	add    $0x10,%esp
   135f6:	e9 c4 00 00 00       	jmp    136bf <transfer+0x726>
			outb(byte,FD_DATA);
   135fb:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13600:	88 d8                	mov    %bl,%al
   13602:	ee                   	out    %al,(%dx)
   13603:	e9 b7 00 00 00       	jmp    136bf <transfer+0x726>
   13608:	ba f5 03 00 00       	mov    $0x3f5,%edx
   1360d:	88 d8                	mov    %bl,%al
   1360f:	ee                   	out    %al,(%dx)
   13610:	eb 53                	jmp    13665 <transfer+0x6cc>
   13612:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13617:	88 d8                	mov    %bl,%al
   13619:	ee                   	out    %al,(%dx)
   1361a:	e9 a0 00 00 00       	jmp    136bf <transfer+0x726>
{
   1361f:	b3 07                	mov    $0x7,%bl
	if (reset)
   13621:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13628:	75 3b                	jne    13665 <transfer+0x6cc>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1362a:	be 00 00 00 00       	mov    $0x0,%esi
   1362f:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13634:	89 ca                	mov    %ecx,%edx
   13636:	ec                   	in     (%dx),%al
   13637:	eb 00                	jmp    13639 <transfer+0x6a0>
   13639:	eb 00                	jmp    1363b <transfer+0x6a2>
   1363b:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   1363e:	3c 80                	cmp    $0x80,%al
   13640:	74 c6                	je     13608 <transfer+0x66f>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13642:	46                   	inc    %esi
   13643:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13649:	7e e9                	jle    13634 <transfer+0x69b>
	reset = 1;
   1364b:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13652:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13655:	83 ec 0c             	sub    $0xc,%esp
   13658:	68 93 94 01 00       	push   $0x19493
   1365d:	e8 f1 4c ff ff       	call   8353 <printk>
   13662:	83 c4 10             	add    $0x10,%esp
{
   13665:	0f b6 05 f2 0b 02 00 	movzbl 0x20bf2,%eax
   1366c:	c1 e0 02             	shl    $0x2,%eax
   1366f:	8a 1d f0 0b 02 00    	mov    0x20bf0,%bl
   13675:	09 c3                	or     %eax,%ebx
	if (reset)
   13677:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1367e:	75 48                	jne    136c8 <transfer+0x72f>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13680:	be 00 00 00 00       	mov    $0x0,%esi
   13685:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1368a:	89 ca                	mov    %ecx,%edx
   1368c:	ec                   	in     (%dx),%al
   1368d:	eb 00                	jmp    1368f <transfer+0x6f6>
   1368f:	eb 00                	jmp    13691 <transfer+0x6f8>
   13691:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13694:	3c 80                	cmp    $0x80,%al
   13696:	0f 84 76 ff ff ff    	je     13612 <transfer+0x679>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1369c:	46                   	inc    %esi
   1369d:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   136a3:	7e e5                	jle    1368a <transfer+0x6f1>
	reset = 1;
   136a5:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   136ac:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   136af:	83 ec 0c             	sub    $0xc,%esp
   136b2:	68 93 94 01 00       	push   $0x19493
   136b7:	e8 97 4c ff ff       	call   8353 <printk>
   136bc:	83 c4 10             	add    $0x10,%esp
		output_byte(seek_track);
	} else {
		output_byte(FD_RECALIBRATE);
		output_byte(head<<2 | current_drive);
	}
	if (reset)
   136bf:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   136c6:	74 05                	je     136cd <transfer+0x734>
		do_fd_request();
   136c8:	e8 e6 02 00 00       	call   139b3 <do_fd_request>
}
   136cd:	5b                   	pop    %ebx
   136ce:	5e                   	pop    %esi
   136cf:	5f                   	pop    %edi
   136d0:	c3                   	ret    

000136d1 <unexpected_floppy_interrupt>:
		recalibrate = 0;
	do_fd_request();
}

void unexpected_floppy_interrupt(void)
{
   136d1:	55                   	push   %ebp
   136d2:	57                   	push   %edi
   136d3:	56                   	push   %esi
   136d4:	53                   	push   %ebx
   136d5:	83 ec 0c             	sub    $0xc,%esp
{
   136d8:	b3 08                	mov    $0x8,%bl
	if (reset)
   136da:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   136e1:	75 3b                	jne    1371e <unexpected_floppy_interrupt+0x4d>
	for(counter = 0 ; counter < 10000 ; counter++) {
   136e3:	be 00 00 00 00       	mov    $0x0,%esi
   136e8:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   136ed:	89 ca                	mov    %ecx,%edx
   136ef:	ec                   	in     (%dx),%al
   136f0:	eb 00                	jmp    136f2 <unexpected_floppy_interrupt+0x21>
   136f2:	eb 00                	jmp    136f4 <unexpected_floppy_interrupt+0x23>
   136f4:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   136f7:	3c 80                	cmp    $0x80,%al
   136f9:	74 38                	je     13733 <unexpected_floppy_interrupt+0x62>
	for(counter = 0 ; counter < 10000 ; counter++) {
   136fb:	46                   	inc    %esi
   136fc:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13702:	7e e9                	jle    136ed <unexpected_floppy_interrupt+0x1c>
	reset = 1;
   13704:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1370b:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   1370e:	83 ec 0c             	sub    $0xc,%esp
   13711:	68 93 94 01 00       	push   $0x19493
   13716:	e8 38 4c ff ff       	call   8353 <printk>
   1371b:	83 c4 10             	add    $0x10,%esp
	int i = 0, counter, status;
   1371e:	be 00 00 00 00       	mov    $0x0,%esi
	if (reset)
   13723:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13728:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1372f:	75 76                	jne    137a7 <unexpected_floppy_interrupt+0xd6>
   13731:	eb 0e                	jmp    13741 <unexpected_floppy_interrupt+0x70>
			outb(byte,FD_DATA);
   13733:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13738:	88 d8                	mov    %bl,%al
   1373a:	ee                   	out    %al,(%dx)
   1373b:	eb e1                	jmp    1371e <unexpected_floppy_interrupt+0x4d>
		if (status == STATUS_READY)
   1373d:	89 f0                	mov    %esi,%eax
   1373f:	eb 66                	jmp    137a7 <unexpected_floppy_interrupt+0xd6>
	for (counter = 0 ; counter < 10000 ; counter++) {
   13741:	b9 00 00 00 00       	mov    $0x0,%ecx
   13746:	bb f4 03 00 00       	mov    $0x3f4,%ebx
   1374b:	bf f5 03 00 00       	mov    $0x3f5,%edi
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   13750:	89 da                	mov    %ebx,%edx
   13752:	ec                   	in     (%dx),%al
   13753:	eb 00                	jmp    13755 <unexpected_floppy_interrupt+0x84>
   13755:	eb 00                	jmp    13757 <unexpected_floppy_interrupt+0x86>
   13757:	25 d0 00 00 00       	and    $0xd0,%eax
		if (status == STATUS_READY)
   1375c:	3d 80 00 00 00       	cmp    $0x80,%eax
   13761:	74 da                	je     1373d <unexpected_floppy_interrupt+0x6c>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   13763:	3d d0 00 00 00       	cmp    $0xd0,%eax
   13768:	75 15                	jne    1377f <unexpected_floppy_interrupt+0xae>
			if (i >= MAX_REPLIES)
   1376a:	83 fe 06             	cmp    $0x6,%esi
   1376d:	7f 19                	jg     13788 <unexpected_floppy_interrupt+0xb7>
			reply_buffer[i++] = inb_p(FD_DATA);
   1376f:	89 f5                	mov    %esi,%ebp
   13771:	89 fa                	mov    %edi,%edx
   13773:	ec                   	in     (%dx),%al
   13774:	eb 00                	jmp    13776 <unexpected_floppy_interrupt+0xa5>
   13776:	eb 00                	jmp    13778 <unexpected_floppy_interrupt+0xa7>
   13778:	46                   	inc    %esi
   13779:	88 85 f6 0b 02 00    	mov    %al,0x20bf6(%ebp)
	for (counter = 0 ; counter < 10000 ; counter++) {
   1377f:	41                   	inc    %ecx
   13780:	81 f9 0f 27 00 00    	cmp    $0x270f,%ecx
   13786:	7e c8                	jle    13750 <unexpected_floppy_interrupt+0x7f>
	reset = 1;
   13788:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1378f:	00 00 00 
	printk("Getstatus times out\n\r");
   13792:	83 ec 0c             	sub    $0xc,%esp
   13795:	68 5f 94 01 00       	push   $0x1945f
   1379a:	e8 b4 4b ff ff       	call   8353 <printk>
   1379f:	83 c4 10             	add    $0x10,%esp
   137a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
   137a7:	83 f8 02             	cmp    $0x2,%eax
   137aa:	75 11                	jne    137bd <unexpected_floppy_interrupt+0xec>
   137ac:	0f b6 05 f6 0b 02 00 	movzbl 0x20bf6,%eax
   137b3:	25 e0 00 00 00       	and    $0xe0,%eax
   137b8:	83 f8 60             	cmp    $0x60,%eax
   137bb:	75 0c                	jne    137c9 <unexpected_floppy_interrupt+0xf8>
	output_byte(FD_SENSEI);
	if (result()!=2 || (ST0 & 0xE0) == 0x60)
		reset = 1;
   137bd:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   137c4:	00 00 00 
   137c7:	eb 0a                	jmp    137d3 <unexpected_floppy_interrupt+0x102>
	else
		recalibrate = 1;
   137c9:	c7 05 e4 0b 02 00 01 	movl   $0x1,0x20be4
   137d0:	00 00 00 
}
   137d3:	83 c4 0c             	add    $0xc,%esp
   137d6:	5b                   	pop    %ebx
   137d7:	5e                   	pop    %esi
   137d8:	5f                   	pop    %edi
   137d9:	5d                   	pop    %ebp
   137da:	c3                   	ret    

000137db <reset_interrupt>:
	if (reset)
		do_fd_request();
}

static void reset_interrupt(void)
{
   137db:	55                   	push   %ebp
   137dc:	57                   	push   %edi
   137dd:	56                   	push   %esi
   137de:	53                   	push   %ebx
   137df:	83 ec 0c             	sub    $0xc,%esp
{
   137e2:	be 08 00 00 00       	mov    $0x8,%esi
	if (reset)
   137e7:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   137ee:	75 47                	jne    13837 <reset_interrupt+0x5c>
	for(counter = 0 ; counter < 10000 ; counter++) {
   137f0:	bf 00 00 00 00       	mov    $0x0,%edi
   137f5:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
   137fa:	bb f5 03 00 00       	mov    $0x3f5,%ebx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   137ff:	89 ca                	mov    %ecx,%edx
   13801:	ec                   	in     (%dx),%al
   13802:	eb 00                	jmp    13804 <reset_interrupt+0x29>
   13804:	eb 00                	jmp    13806 <reset_interrupt+0x2b>
   13806:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13809:	3c 80                	cmp    $0x80,%al
   1380b:	75 07                	jne    13814 <reset_interrupt+0x39>
			outb(byte,FD_DATA);
   1380d:	89 f0                	mov    %esi,%eax
   1380f:	89 da                	mov    %ebx,%edx
   13811:	ee                   	out    %al,(%dx)
   13812:	eb 23                	jmp    13837 <reset_interrupt+0x5c>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13814:	47                   	inc    %edi
   13815:	81 ff 0f 27 00 00    	cmp    $0x270f,%edi
   1381b:	7e e2                	jle    137ff <reset_interrupt+0x24>
	reset = 1;
   1381d:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13824:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13827:	83 ec 0c             	sub    $0xc,%esp
   1382a:	68 93 94 01 00       	push   $0x19493
   1382f:	e8 1f 4b ff ff       	call   8353 <printk>
   13834:	83 c4 10             	add    $0x10,%esp
	int i = 0, counter, status;
   13837:	be 00 00 00 00       	mov    $0x0,%esi
	if (reset)
   1383c:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13843:	75 61                	jne    138a6 <reset_interrupt+0xcb>
	for (counter = 0 ; counter < 10000 ; counter++) {
   13845:	b9 00 00 00 00       	mov    $0x0,%ecx
   1384a:	bb f4 03 00 00       	mov    $0x3f4,%ebx
   1384f:	bf f5 03 00 00       	mov    $0x3f5,%edi
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   13854:	89 da                	mov    %ebx,%edx
   13856:	ec                   	in     (%dx),%al
   13857:	eb 00                	jmp    13859 <reset_interrupt+0x7e>
   13859:	eb 00                	jmp    1385b <reset_interrupt+0x80>
   1385b:	25 d0 00 00 00       	and    $0xd0,%eax
		if (status == STATUS_READY)
   13860:	3d 80 00 00 00       	cmp    $0x80,%eax
   13865:	74 3f                	je     138a6 <reset_interrupt+0xcb>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   13867:	3d d0 00 00 00       	cmp    $0xd0,%eax
   1386c:	75 15                	jne    13883 <reset_interrupt+0xa8>
			if (i >= MAX_REPLIES)
   1386e:	83 fe 06             	cmp    $0x6,%esi
   13871:	7f 19                	jg     1388c <reset_interrupt+0xb1>
			reply_buffer[i++] = inb_p(FD_DATA);
   13873:	89 f5                	mov    %esi,%ebp
   13875:	89 fa                	mov    %edi,%edx
   13877:	ec                   	in     (%dx),%al
   13878:	eb 00                	jmp    1387a <reset_interrupt+0x9f>
   1387a:	eb 00                	jmp    1387c <reset_interrupt+0xa1>
   1387c:	46                   	inc    %esi
   1387d:	88 85 f6 0b 02 00    	mov    %al,0x20bf6(%ebp)
	for (counter = 0 ; counter < 10000 ; counter++) {
   13883:	41                   	inc    %ecx
   13884:	81 f9 0f 27 00 00    	cmp    $0x270f,%ecx
   1388a:	7e c8                	jle    13854 <reset_interrupt+0x79>
	reset = 1;
   1388c:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13893:	00 00 00 
	printk("Getstatus times out\n\r");
   13896:	83 ec 0c             	sub    $0xc,%esp
   13899:	68 5f 94 01 00       	push   $0x1945f
   1389e:	e8 b0 4a ff ff       	call   8353 <printk>
   138a3:	83 c4 10             	add    $0x10,%esp
{
   138a6:	be 03 00 00 00       	mov    $0x3,%esi
	if (reset)
   138ab:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   138b2:	75 47                	jne    138fb <reset_interrupt+0x120>
	for(counter = 0 ; counter < 10000 ; counter++) {
   138b4:	bf 00 00 00 00       	mov    $0x0,%edi
   138b9:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
   138be:	bb f5 03 00 00       	mov    $0x3f5,%ebx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   138c3:	89 ca                	mov    %ecx,%edx
   138c5:	ec                   	in     (%dx),%al
   138c6:	eb 00                	jmp    138c8 <reset_interrupt+0xed>
   138c8:	eb 00                	jmp    138ca <reset_interrupt+0xef>
   138ca:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   138cd:	3c 80                	cmp    $0x80,%al
   138cf:	75 07                	jne    138d8 <reset_interrupt+0xfd>
			outb(byte,FD_DATA);
   138d1:	89 f0                	mov    %esi,%eax
   138d3:	89 da                	mov    %ebx,%edx
   138d5:	ee                   	out    %al,(%dx)
   138d6:	eb 23                	jmp    138fb <reset_interrupt+0x120>
	for(counter = 0 ; counter < 10000 ; counter++) {
   138d8:	47                   	inc    %edi
   138d9:	81 ff 0f 27 00 00    	cmp    $0x270f,%edi
   138df:	7e e2                	jle    138c3 <reset_interrupt+0xe8>
	reset = 1;
   138e1:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   138e8:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   138eb:	83 ec 0c             	sub    $0xc,%esp
   138ee:	68 93 94 01 00       	push   $0x19493
   138f3:	e8 5b 4a ff ff       	call   8353 <printk>
   138f8:	83 c4 10             	add    $0x10,%esp
{
   138fb:	8a 1d 00 bf 01 00    	mov    0x1bf00,%bl
	if (reset)
   13901:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13908:	75 47                	jne    13951 <reset_interrupt+0x176>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1390a:	bf 00 00 00 00       	mov    $0x0,%edi
   1390f:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
   13914:	be f5 03 00 00       	mov    $0x3f5,%esi
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13919:	89 ca                	mov    %ecx,%edx
   1391b:	ec                   	in     (%dx),%al
   1391c:	eb 00                	jmp    1391e <reset_interrupt+0x143>
   1391e:	eb 00                	jmp    13920 <reset_interrupt+0x145>
   13920:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13923:	3c 80                	cmp    $0x80,%al
   13925:	75 07                	jne    1392e <reset_interrupt+0x153>
			outb(byte,FD_DATA);
   13927:	88 d8                	mov    %bl,%al
   13929:	89 f2                	mov    %esi,%edx
   1392b:	ee                   	out    %al,(%dx)
   1392c:	eb 23                	jmp    13951 <reset_interrupt+0x176>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1392e:	47                   	inc    %edi
   1392f:	81 ff 0f 27 00 00    	cmp    $0x270f,%edi
   13935:	7e e2                	jle    13919 <reset_interrupt+0x13e>
	reset = 1;
   13937:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   1393e:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13941:	83 ec 0c             	sub    $0xc,%esp
   13944:	68 93 94 01 00       	push   $0x19493
   13949:	e8 05 4a ff ff       	call   8353 <printk>
   1394e:	83 c4 10             	add    $0x10,%esp
{
   13951:	be 06 00 00 00       	mov    $0x6,%esi
	if (reset)
   13956:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   1395d:	75 47                	jne    139a6 <reset_interrupt+0x1cb>
	for(counter = 0 ; counter < 10000 ; counter++) {
   1395f:	bf 00 00 00 00       	mov    $0x0,%edi
   13964:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
   13969:	bb f5 03 00 00       	mov    $0x3f5,%ebx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   1396e:	89 ca                	mov    %ecx,%edx
   13970:	ec                   	in     (%dx),%al
   13971:	eb 00                	jmp    13973 <reset_interrupt+0x198>
   13973:	eb 00                	jmp    13975 <reset_interrupt+0x19a>
   13975:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13978:	3c 80                	cmp    $0x80,%al
   1397a:	75 07                	jne    13983 <reset_interrupt+0x1a8>
			outb(byte,FD_DATA);
   1397c:	89 f0                	mov    %esi,%eax
   1397e:	89 da                	mov    %ebx,%edx
   13980:	ee                   	out    %al,(%dx)
   13981:	eb 23                	jmp    139a6 <reset_interrupt+0x1cb>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13983:	47                   	inc    %edi
   13984:	81 ff 0f 27 00 00    	cmp    $0x270f,%edi
   1398a:	7e e2                	jle    1396e <reset_interrupt+0x193>
	reset = 1;
   1398c:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13993:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13996:	83 ec 0c             	sub    $0xc,%esp
   13999:	68 93 94 01 00       	push   $0x19493
   1399e:	e8 b0 49 ff ff       	call   8353 <printk>
   139a3:	83 c4 10             	add    $0x10,%esp
	output_byte(FD_SENSEI);
	(void) result();
	output_byte(FD_SPECIFY);
	output_byte(cur_spec1);		/* hut etc */
	output_byte(6);			/* Head load time =6ms, DMA */
	do_fd_request();
   139a6:	e8 08 00 00 00       	call   139b3 <do_fd_request>
}
   139ab:	83 c4 0c             	add    $0xc,%esp
   139ae:	5b                   	pop    %ebx
   139af:	5e                   	pop    %esi
   139b0:	5f                   	pop    %edi
   139b1:	5d                   	pop    %ebp
   139b2:	c3                   	ret    

000139b3 <do_fd_request>:
	} else
		transfer();
}

void do_fd_request(void)
{
   139b3:	56                   	push   %esi
   139b4:	53                   	push   %ebx
   139b5:	83 ec 14             	sub    $0x14,%esp
	unsigned int block;

	seek = 0;
   139b8:	c7 05 ec 0b 02 00 00 	movl   $0x0,0x20bec
   139bf:	00 00 00 
	if (reset) {
   139c2:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   139c9:	0f 84 88 00 00 00    	je     13a57 <do_fd_request+0xa4>
	reset = 0;
   139cf:	c7 05 e8 0b 02 00 00 	movl   $0x0,0x20be8
   139d6:	00 00 00 
	cur_spec1 = -1;
   139d9:	c7 05 00 bf 01 00 ff 	movl   $0xffffffff,0x1bf00
   139e0:	ff ff ff 
	cur_rate = -1;
   139e3:	c7 05 04 bf 01 00 ff 	movl   $0xffffffff,0x1bf04
   139ea:	ff ff ff 
	recalibrate = 1;
   139ed:	c7 05 e4 0b 02 00 01 	movl   $0x1,0x20be4
   139f4:	00 00 00 
	printk("Reset-floppy called\n\r");
   139f7:	83 ec 0c             	sub    $0xc,%esp
   139fa:	68 b0 94 01 00       	push   $0x194b0
   139ff:	e8 4f 49 ff ff       	call   8353 <printk>
   13a04:	83 c4 10             	add    $0x10,%esp
	cli();
   13a07:	fa                   	cli    
	do_floppy = reset_interrupt;
   13a08:	c7 05 d8 0b 02 00 db 	movl   $0x137db,0x20bd8
   13a0f:	37 01 00 
	outb_p(current_DOR & ~0x04,FD_DOR);
   13a12:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   13a19:	83 e0 fb             	and    $0xfffffffb,%eax
   13a1c:	ba f2 03 00 00       	mov    $0x3f2,%edx
   13a21:	ee                   	out    %al,(%dx)
   13a22:	eb 00                	jmp    13a24 <do_fd_request+0x71>
   13a24:	eb 00                	jmp    13a26 <do_fd_request+0x73>
   13a26:	b8 63 00 00 00       	mov    $0x63,%eax
		__asm__("nop");
   13a2b:	90                   	nop
   13a2c:	48                   	dec    %eax
   13a2d:	79 fc                	jns    13a2b <do_fd_request+0x78>
	outb(current_DOR,FD_DOR);
   13a2f:	a0 48 bd 01 00       	mov    0x1bd48,%al
   13a34:	ba f2 03 00 00       	mov    $0x3f2,%edx
   13a39:	ee                   	out    %al,(%dx)
	sti();
   13a3a:	fb                   	sti    
		reset_floppy();
		return;
   13a3b:	e9 20 03 00 00       	jmp    13d60 <do_fd_request+0x3ad>
			outb(byte,FD_DATA);
   13a40:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13a45:	88 d8                	mov    %bl,%al
   13a47:	ee                   	out    %al,(%dx)
   13a48:	eb 7b                	jmp    13ac5 <do_fd_request+0x112>
   13a4a:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13a4f:	88 d8                	mov    %bl,%al
   13a51:	ee                   	out    %al,(%dx)
   13a52:	e9 c8 00 00 00       	jmp    13b1f <do_fd_request+0x16c>
	}
	if (recalibrate) {
   13a57:	83 3d e4 0b 02 00 00 	cmpl   $0x0,0x20be4
   13a5e:	0f 84 d2 00 00 00    	je     13b36 <do_fd_request+0x183>
	recalibrate = 0;
   13a64:	c7 05 e4 0b 02 00 00 	movl   $0x0,0x20be4
   13a6b:	00 00 00 
	current_track = 0;
   13a6e:	c6 05 0c bf 01 00 00 	movb   $0x0,0x1bf0c
	do_floppy = recal_interrupt;
   13a75:	c7 05 d8 0b 02 00 bb 	movl   $0x13dbb,0x20bd8
   13a7c:	3d 01 00 
{
   13a7f:	b3 07                	mov    $0x7,%bl
	if (reset)
   13a81:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13a88:	75 3b                	jne    13ac5 <do_fd_request+0x112>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13a8a:	be 00 00 00 00       	mov    $0x0,%esi
   13a8f:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13a94:	89 ca                	mov    %ecx,%edx
   13a96:	ec                   	in     (%dx),%al
   13a97:	eb 00                	jmp    13a99 <do_fd_request+0xe6>
   13a99:	eb 00                	jmp    13a9b <do_fd_request+0xe8>
   13a9b:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13a9e:	3c 80                	cmp    $0x80,%al
   13aa0:	74 9e                	je     13a40 <do_fd_request+0x8d>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13aa2:	46                   	inc    %esi
   13aa3:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13aa9:	7e e9                	jle    13a94 <do_fd_request+0xe1>
	reset = 1;
   13aab:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13ab2:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13ab5:	83 ec 0c             	sub    $0xc,%esp
   13ab8:	68 93 94 01 00       	push   $0x19493
   13abd:	e8 91 48 ff ff       	call   8353 <printk>
   13ac2:	83 c4 10             	add    $0x10,%esp
{
   13ac5:	0f b6 05 f2 0b 02 00 	movzbl 0x20bf2,%eax
   13acc:	c1 e0 02             	shl    $0x2,%eax
   13acf:	8a 1d f0 0b 02 00    	mov    0x20bf0,%bl
   13ad5:	09 c3                	or     %eax,%ebx
	if (reset)
   13ad7:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13ade:	75 4c                	jne    13b2c <do_fd_request+0x179>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13ae0:	be 00 00 00 00       	mov    $0x0,%esi
   13ae5:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13aea:	89 ca                	mov    %ecx,%edx
   13aec:	ec                   	in     (%dx),%al
   13aed:	eb 00                	jmp    13aef <do_fd_request+0x13c>
   13aef:	eb 00                	jmp    13af1 <do_fd_request+0x13e>
   13af1:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13af4:	3c 80                	cmp    $0x80,%al
   13af6:	0f 84 4e ff ff ff    	je     13a4a <do_fd_request+0x97>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13afc:	46                   	inc    %esi
   13afd:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13b03:	7e e5                	jle    13aea <do_fd_request+0x137>
	reset = 1;
   13b05:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13b0c:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13b0f:	83 ec 0c             	sub    $0xc,%esp
   13b12:	68 93 94 01 00       	push   $0x19493
   13b17:	e8 37 48 ff ff       	call   8353 <printk>
   13b1c:	83 c4 10             	add    $0x10,%esp
	if (reset)
   13b1f:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13b26:	0f 84 34 02 00 00    	je     13d60 <do_fd_request+0x3ad>
		do_fd_request();
   13b2c:	e8 82 fe ff ff       	call   139b3 <do_fd_request>
		recalibrate_floppy();
		return;
   13b31:	e9 2a 02 00 00       	jmp    13d60 <do_fd_request+0x3ad>
	}
	INIT_REQUEST;
   13b36:	83 3d b4 0b 02 00 00 	cmpl   $0x0,0x20bb4
   13b3d:	0f 84 1d 02 00 00    	je     13d60 <do_fd_request+0x3ad>
   13b43:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13b48:	8b 00                	mov    (%eax),%eax
   13b4a:	c1 e8 08             	shr    $0x8,%eax
   13b4d:	83 f8 02             	cmp    $0x2,%eax
   13b50:	74 10                	je     13b62 <do_fd_request+0x1af>
   13b52:	83 ec 0c             	sub    $0xc,%esp
   13b55:	68 f8 93 01 00       	push   $0x193f8
   13b5a:	e8 ba 47 ff ff       	call   8319 <panic>
   13b5f:	83 c4 10             	add    $0x10,%esp
   13b62:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13b67:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   13b6b:	74 19                	je     13b86 <do_fd_request+0x1d3>
   13b6d:	8b 40 1c             	mov    0x1c(%eax),%eax
   13b70:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   13b74:	75 10                	jne    13b86 <do_fd_request+0x1d3>
   13b76:	83 ec 0c             	sub    $0xc,%esp
   13b79:	68 c6 94 01 00       	push   $0x194c6
   13b7e:	e8 96 47 ff ff       	call   8319 <panic>
   13b83:	83 c4 10             	add    $0x10,%esp
	floppy = (MINOR(CURRENT->dev)>>2) + floppy_type;
   13b86:	8b 0d b4 0b 02 00    	mov    0x20bb4,%ecx
   13b8c:	0f b6 01             	movzbl (%ecx),%eax
   13b8f:	c1 f8 02             	sar    $0x2,%eax
   13b92:	8d 04 40             	lea    (%eax,%eax,2),%eax
   13b95:	8d 04 c5 40 be 01 00 	lea    0x1be40(,%eax,8),%eax
   13b9c:	a3 08 bf 01 00       	mov    %eax,0x1bf08
	if (current_drive != CURRENT_DEV)
   13ba1:	0f b6 15 f0 0b 02 00 	movzbl 0x20bf0,%edx
   13ba8:	8b 01                	mov    (%ecx),%eax
   13baa:	83 e0 03             	and    $0x3,%eax
   13bad:	39 c2                	cmp    %eax,%edx
   13baf:	74 0a                	je     13bbb <do_fd_request+0x208>
		seek = 1;
   13bb1:	c7 05 ec 0b 02 00 01 	movl   $0x1,0x20bec
   13bb8:	00 00 00 
	current_drive = CURRENT_DEV;
   13bbb:	8b 0d b4 0b 02 00    	mov    0x20bb4,%ecx
   13bc1:	8a 01                	mov    (%ecx),%al
   13bc3:	83 e0 03             	and    $0x3,%eax
   13bc6:	a2 f0 0b 02 00       	mov    %al,0x20bf0
	block = CURRENT->sector;
   13bcb:	8b 59 0c             	mov    0xc(%ecx),%ebx
	if (block+2 > floppy->size) {
   13bce:	8d 53 02             	lea    0x2(%ebx),%edx
   13bd1:	a1 08 bf 01 00       	mov    0x1bf08,%eax
   13bd6:	3b 10                	cmp    (%eax),%edx
   13bd8:	0f 86 c5 00 00 00    	jbe    13ca3 <do_fd_request+0x2f0>
	DEVICE_OFF(CURRENT->dev);
   13bde:	83 ec 0c             	sub    $0xc,%esp
   13be1:	8b 01                	mov    (%ecx),%eax
   13be3:	83 e0 03             	and    $0x3,%eax
   13be6:	50                   	push   %eax
   13be7:	e8 25 35 ff ff       	call   7111 <floppy_off>
   13bec:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {
   13bef:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13bf4:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   13bf8:	74 38                	je     13c32 <do_fd_request+0x27f>
		CURRENT->bh->b_uptodate = uptodate;
   13bfa:	8b 40 1c             	mov    0x1c(%eax),%eax
   13bfd:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   13c01:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13c06:	8b 58 1c             	mov    0x1c(%eax),%ebx
	if (!bh->b_lock)
   13c09:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   13c0d:	75 10                	jne    13c1f <do_fd_request+0x26c>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   13c0f:	83 ec 0c             	sub    $0xc,%esp
   13c12:	68 d4 93 01 00       	push   $0x193d4
   13c17:	e8 37 47 ff ff       	call   8353 <printk>
   13c1c:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   13c1f:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   13c23:	83 ec 0c             	sub    $0xc,%esp
   13c26:	8d 43 10             	lea    0x10(%ebx),%eax
   13c29:	50                   	push   %eax
   13c2a:	e8 74 33 ff ff       	call   6fa3 <wake_up>
   13c2f:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   13c32:	b8 00 00 00 00       	mov    $0x0,%eax
   13c37:	85 c0                	test   %eax,%eax
   13c39:	75 2b                	jne    13c66 <do_fd_request+0x2b3>
		printk(DEVICE_NAME " I/O error\n\r");
   13c3b:	83 ec 0c             	sub    $0xc,%esp
   13c3e:	68 37 94 01 00       	push   $0x19437
   13c43:	e8 0b 47 ff ff       	call   8353 <printk>
   13c48:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   13c4b:	8b 15 b4 0b 02 00    	mov    0x20bb4,%edx
   13c51:	8b 42 1c             	mov    0x1c(%edx),%eax
   13c54:	ff 70 04             	pushl  0x4(%eax)
   13c57:	ff 32                	pushl  (%edx)
   13c59:	68 4a 94 01 00       	push   $0x1944a
   13c5e:	e8 f0 46 ff ff       	call   8353 <printk>
   13c63:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   13c66:	83 ec 0c             	sub    $0xc,%esp
   13c69:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13c6e:	83 c0 18             	add    $0x18,%eax
   13c71:	50                   	push   %eax
   13c72:	e8 2c 33 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   13c77:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   13c7e:	e8 20 33 ff ff       	call   6fa3 <wake_up>
   13c83:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   13c86:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13c8b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   13c91:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13c96:	8b 40 20             	mov    0x20(%eax),%eax
   13c99:	a3 b4 0b 02 00       	mov    %eax,0x20bb4
		end_request(0);
		goto repeat;
   13c9e:	e9 93 fe ff ff       	jmp    13b36 <do_fd_request+0x183>
	}
	sector = block % floppy->sect;
   13ca3:	8b 0d 08 bf 01 00    	mov    0x1bf08,%ecx
   13ca9:	89 d8                	mov    %ebx,%eax
   13cab:	ba 00 00 00 00       	mov    $0x0,%edx
   13cb0:	f7 71 04             	divl   0x4(%ecx)
   13cb3:	88 15 f1 0b 02 00    	mov    %dl,0x20bf1
	block /= floppy->sect;
   13cb9:	89 d8                	mov    %ebx,%eax
   13cbb:	ba 00 00 00 00       	mov    $0x0,%edx
   13cc0:	f7 71 04             	divl   0x4(%ecx)
   13cc3:	89 c3                	mov    %eax,%ebx
	head = block % floppy->head;
   13cc5:	ba 00 00 00 00       	mov    $0x0,%edx
   13cca:	f7 71 08             	divl   0x8(%ecx)
   13ccd:	88 15 f2 0b 02 00    	mov    %dl,0x20bf2
	track = block / floppy->head;
   13cd3:	89 d8                	mov    %ebx,%eax
   13cd5:	ba 00 00 00 00       	mov    $0x0,%edx
   13cda:	f7 71 08             	divl   0x8(%ecx)
   13cdd:	a2 f3 0b 02 00       	mov    %al,0x20bf3
	seek_track = track << floppy->stretch;
   13ce2:	0f b6 d0             	movzbl %al,%edx
   13ce5:	8b 49 10             	mov    0x10(%ecx),%ecx
   13ce8:	d3 e2                	shl    %cl,%edx
   13cea:	88 15 f4 0b 02 00    	mov    %dl,0x20bf4
	if (seek_track != current_track)
   13cf0:	38 15 0c bf 01 00    	cmp    %dl,0x1bf0c
   13cf6:	74 0a                	je     13d02 <do_fd_request+0x34f>
		seek = 1;
   13cf8:	c7 05 ec 0b 02 00 01 	movl   $0x1,0x20bec
   13cff:	00 00 00 
	sector++;
   13d02:	fe 05 f1 0b 02 00    	incb   0x20bf1
	if (CURRENT->cmd == READ)
   13d08:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13d0d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   13d11:	75 09                	jne    13d1c <do_fd_request+0x369>
		command = FD_READ;
   13d13:	c6 05 f5 0b 02 00 e6 	movb   $0xe6,0x20bf5
   13d1a:	eb 24                	jmp    13d40 <do_fd_request+0x38d>
	else if (CURRENT->cmd == WRITE)
   13d1c:	a1 b4 0b 02 00       	mov    0x20bb4,%eax
   13d21:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   13d25:	75 09                	jne    13d30 <do_fd_request+0x37d>
		command = FD_WRITE;
   13d27:	c6 05 f5 0b 02 00 c5 	movb   $0xc5,0x20bf5
   13d2e:	eb 10                	jmp    13d40 <do_fd_request+0x38d>
	else
		panic("do_fd_request: unknown command");
   13d30:	83 ec 0c             	sub    $0xc,%esp
   13d33:	68 18 94 01 00       	push   $0x19418
   13d38:	e8 dc 45 ff ff       	call   8319 <panic>
   13d3d:	83 c4 10             	add    $0x10,%esp
	add_timer(ticks_to_floppy_on(current_drive),&floppy_on_interrupt);
   13d40:	83 ec 08             	sub    $0x8,%esp
   13d43:	68 66 3d 01 00       	push   $0x13d66
   13d48:	0f b6 05 f0 0b 02 00 	movzbl 0x20bf0,%eax
   13d4f:	50                   	push   %eax
   13d50:	e8 6a 32 ff ff       	call   6fbf <ticks_to_floppy_on>
   13d55:	89 04 24             	mov    %eax,(%esp)
   13d58:	e8 52 34 ff ff       	call   71af <add_timer>
   13d5d:	83 c4 10             	add    $0x10,%esp
}
   13d60:	83 c4 14             	add    $0x14,%esp
   13d63:	5b                   	pop    %ebx
   13d64:	5e                   	pop    %esi
   13d65:	c3                   	ret    

00013d66 <floppy_on_interrupt>:
{
   13d66:	83 ec 0c             	sub    $0xc,%esp
	selected = 1;
   13d69:	c6 05 dc 0b 02 00 01 	movb   $0x1,0x20bdc
	if (current_drive != (current_DOR & 3)) {
   13d70:	0f b6 15 f0 0b 02 00 	movzbl 0x20bf0,%edx
   13d77:	0f b6 05 48 bd 01 00 	movzbl 0x1bd48,%eax
   13d7e:	83 e0 03             	and    $0x3,%eax
   13d81:	39 c2                	cmp    %eax,%edx
   13d83:	74 2d                	je     13db2 <floppy_on_interrupt+0x4c>
		current_DOR &= 0xFC;
   13d85:	a0 48 bd 01 00       	mov    0x1bd48,%al
   13d8a:	83 e0 fc             	and    $0xfffffffc,%eax
		current_DOR |= current_drive;
   13d8d:	0a 05 f0 0b 02 00    	or     0x20bf0,%al
   13d93:	a2 48 bd 01 00       	mov    %al,0x1bd48
		outb(current_DOR,FD_DOR);
   13d98:	ba f2 03 00 00       	mov    $0x3f2,%edx
   13d9d:	ee                   	out    %al,(%dx)
		add_timer(2,&transfer);
   13d9e:	83 ec 08             	sub    $0x8,%esp
   13da1:	68 99 2f 01 00       	push   $0x12f99
   13da6:	6a 02                	push   $0x2
   13da8:	e8 02 34 ff ff       	call   71af <add_timer>
   13dad:	83 c4 10             	add    $0x10,%esp
   13db0:	eb 05                	jmp    13db7 <floppy_on_interrupt+0x51>
		transfer();
   13db2:	e8 e2 f1 ff ff       	call   12f99 <transfer>
}
   13db7:	83 c4 0c             	add    $0xc,%esp
   13dba:	c3                   	ret    

00013dbb <recal_interrupt>:
{
   13dbb:	55                   	push   %ebp
   13dbc:	57                   	push   %edi
   13dbd:	56                   	push   %esi
   13dbe:	53                   	push   %ebx
   13dbf:	83 ec 0c             	sub    $0xc,%esp
{
   13dc2:	b3 08                	mov    $0x8,%bl
	if (reset)
   13dc4:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13dcb:	75 3b                	jne    13e08 <recal_interrupt+0x4d>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13dcd:	be 00 00 00 00       	mov    $0x0,%esi
   13dd2:	b9 f4 03 00 00       	mov    $0x3f4,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   13dd7:	89 ca                	mov    %ecx,%edx
   13dd9:	ec                   	in     (%dx),%al
   13dda:	eb 00                	jmp    13ddc <recal_interrupt+0x21>
   13ddc:	eb 00                	jmp    13dde <recal_interrupt+0x23>
   13dde:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   13de1:	3c 80                	cmp    $0x80,%al
   13de3:	74 38                	je     13e1d <recal_interrupt+0x62>
	for(counter = 0 ; counter < 10000 ; counter++) {
   13de5:	46                   	inc    %esi
   13de6:	81 fe 0f 27 00 00    	cmp    $0x270f,%esi
   13dec:	7e e9                	jle    13dd7 <recal_interrupt+0x1c>
	reset = 1;
   13dee:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13df5:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   13df8:	83 ec 0c             	sub    $0xc,%esp
   13dfb:	68 93 94 01 00       	push   $0x19493
   13e00:	e8 4e 45 ff ff       	call   8353 <printk>
   13e05:	83 c4 10             	add    $0x10,%esp
	int i = 0, counter, status;
   13e08:	be 00 00 00 00       	mov    $0x0,%esi
	if (reset)
   13e0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13e12:	83 3d e8 0b 02 00 00 	cmpl   $0x0,0x20be8
   13e19:	75 76                	jne    13e91 <recal_interrupt+0xd6>
   13e1b:	eb 0e                	jmp    13e2b <recal_interrupt+0x70>
			outb(byte,FD_DATA);
   13e1d:	ba f5 03 00 00       	mov    $0x3f5,%edx
   13e22:	88 d8                	mov    %bl,%al
   13e24:	ee                   	out    %al,(%dx)
   13e25:	eb e1                	jmp    13e08 <recal_interrupt+0x4d>
		if (status == STATUS_READY)
   13e27:	89 f0                	mov    %esi,%eax
   13e29:	eb 66                	jmp    13e91 <recal_interrupt+0xd6>
	for (counter = 0 ; counter < 10000 ; counter++) {
   13e2b:	b9 00 00 00 00       	mov    $0x0,%ecx
   13e30:	bb f4 03 00 00       	mov    $0x3f4,%ebx
   13e35:	bf f5 03 00 00       	mov    $0x3f5,%edi
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   13e3a:	89 da                	mov    %ebx,%edx
   13e3c:	ec                   	in     (%dx),%al
   13e3d:	eb 00                	jmp    13e3f <recal_interrupt+0x84>
   13e3f:	eb 00                	jmp    13e41 <recal_interrupt+0x86>
   13e41:	25 d0 00 00 00       	and    $0xd0,%eax
		if (status == STATUS_READY)
   13e46:	3d 80 00 00 00       	cmp    $0x80,%eax
   13e4b:	74 da                	je     13e27 <recal_interrupt+0x6c>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   13e4d:	3d d0 00 00 00       	cmp    $0xd0,%eax
   13e52:	75 15                	jne    13e69 <recal_interrupt+0xae>
			if (i >= MAX_REPLIES)
   13e54:	83 fe 06             	cmp    $0x6,%esi
   13e57:	7f 19                	jg     13e72 <recal_interrupt+0xb7>
			reply_buffer[i++] = inb_p(FD_DATA);
   13e59:	89 f5                	mov    %esi,%ebp
   13e5b:	89 fa                	mov    %edi,%edx
   13e5d:	ec                   	in     (%dx),%al
   13e5e:	eb 00                	jmp    13e60 <recal_interrupt+0xa5>
   13e60:	eb 00                	jmp    13e62 <recal_interrupt+0xa7>
   13e62:	46                   	inc    %esi
   13e63:	88 85 f6 0b 02 00    	mov    %al,0x20bf6(%ebp)
	for (counter = 0 ; counter < 10000 ; counter++) {
   13e69:	41                   	inc    %ecx
   13e6a:	81 f9 0f 27 00 00    	cmp    $0x270f,%ecx
   13e70:	7e c8                	jle    13e3a <recal_interrupt+0x7f>
	reset = 1;
   13e72:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13e79:	00 00 00 
	printk("Getstatus times out\n\r");
   13e7c:	83 ec 0c             	sub    $0xc,%esp
   13e7f:	68 5f 94 01 00       	push   $0x1945f
   13e84:	e8 ca 44 ff ff       	call   8353 <printk>
   13e89:	83 c4 10             	add    $0x10,%esp
   13e8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
   13e91:	83 f8 02             	cmp    $0x2,%eax
   13e94:	75 11                	jne    13ea7 <recal_interrupt+0xec>
   13e96:	0f b6 05 f6 0b 02 00 	movzbl 0x20bf6,%eax
   13e9d:	25 e0 00 00 00       	and    $0xe0,%eax
   13ea2:	83 f8 60             	cmp    $0x60,%eax
   13ea5:	75 0c                	jne    13eb3 <recal_interrupt+0xf8>
		reset = 1;
   13ea7:	c7 05 e8 0b 02 00 01 	movl   $0x1,0x20be8
   13eae:	00 00 00 
   13eb1:	eb 0a                	jmp    13ebd <recal_interrupt+0x102>
		recalibrate = 0;
   13eb3:	c7 05 e4 0b 02 00 00 	movl   $0x0,0x20be4
   13eba:	00 00 00 
	do_fd_request();
   13ebd:	e8 f1 fa ff ff       	call   139b3 <do_fd_request>
}
   13ec2:	83 c4 0c             	add    $0xc,%esp
   13ec5:	5b                   	pop    %ebx
   13ec6:	5e                   	pop    %esi
   13ec7:	5f                   	pop    %edi
   13ec8:	5d                   	pop    %ebp
   13ec9:	c3                   	ret    

00013eca <floppy_init>:

void floppy_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   13eca:	c7 05 b0 0b 02 00 b3 	movl   $0x139b3,0x20bb0
   13ed1:	39 01 00 
	set_trap_gate(0x26,&floppy_interrupt);
   13ed4:	ba dc 77 00 00       	mov    $0x77dc,%edx
   13ed9:	b8 00 00 08 00       	mov    $0x80000,%eax
   13ede:	66 89 d0             	mov    %dx,%ax
   13ee1:	66 ba 00 8f          	mov    $0x8f00,%dx
   13ee5:	a3 e8 55 00 00       	mov    %eax,0x55e8
   13eea:	89 15 ec 55 00 00    	mov    %edx,0x55ec
	outb(inb_p(0x21)&~0x40,0x21);
   13ef0:	ba 21 00 00 00       	mov    $0x21,%edx
   13ef5:	ec                   	in     (%dx),%al
   13ef6:	eb 00                	jmp    13ef8 <floppy_init+0x2e>
   13ef8:	eb 00                	jmp    13efa <floppy_init+0x30>
   13efa:	25 bf 00 00 00       	and    $0xbf,%eax
   13eff:	ee                   	out    %al,(%dx)
}
   13f00:	c3                   	ret    

00013f01 <sys_setup>:
extern void hd_interrupt(void);
extern void rd_load(void);

/* This may be used only once, enforced by 'static int callable' */
int sys_setup(void * BIOS)
{
   13f01:	55                   	push   %ebp
   13f02:	57                   	push   %edi
   13f03:	56                   	push   %esi
   13f04:	53                   	push   %ebx
   13f05:	83 ec 0c             	sub    $0xc,%esp
   13f08:	8b 54 24 20          	mov    0x20(%esp),%edx
	unsigned char cmos_disks;
	struct partition *p;
	struct buffer_head * bh;

	if (!callable)
		return -1;
   13f0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (!callable)
   13f11:	83 3d 18 bf 01 00 00 	cmpl   $0x0,0x1bf18
   13f18:	0f 84 13 02 00 00    	je     14131 <sys_setup+0x230>
	callable = 0;
   13f1e:	c7 05 18 bf 01 00 00 	movl   $0x0,0x1bf18
   13f25:	00 00 00 
#ifndef HD_TYPE
	for (drive=0 ; drive<2 ; drive++) {
   13f28:	bf 00 00 00 00       	mov    $0x0,%edi
   13f2d:	b9 00 00 00 00       	mov    $0x0,%ecx
		hd_info[drive].cyl = *(unsigned short *) BIOS;
   13f32:	0f b7 02             	movzwl (%edx),%eax
   13f35:	89 81 28 0c 02 00    	mov    %eax,0x20c28(%ecx)
		hd_info[drive].head = *(unsigned char *) (2+BIOS);
   13f3b:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   13f3f:	89 81 20 0c 02 00    	mov    %eax,0x20c20(%ecx)
		hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);
   13f45:	0f b7 42 05          	movzwl 0x5(%edx),%eax
   13f49:	89 81 2c 0c 02 00    	mov    %eax,0x20c2c(%ecx)
		hd_info[drive].ctl = *(unsigned char *) (8+BIOS);
   13f4f:	0f b6 42 08          	movzbl 0x8(%edx),%eax
   13f53:	89 81 34 0c 02 00    	mov    %eax,0x20c34(%ecx)
		hd_info[drive].lzone = *(unsigned short *) (12+BIOS);
   13f59:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
   13f5d:	89 81 30 0c 02 00    	mov    %eax,0x20c30(%ecx)
		hd_info[drive].sect = *(unsigned char *) (14+BIOS);
   13f63:	0f b6 42 0e          	movzbl 0xe(%edx),%eax
   13f67:	89 81 24 0c 02 00    	mov    %eax,0x20c24(%ecx)
		BIOS += 16;
   13f6d:	83 c2 10             	add    $0x10,%edx
	for (drive=0 ; drive<2 ; drive++) {
   13f70:	47                   	inc    %edi
   13f71:	83 c1 18             	add    $0x18,%ecx
   13f74:	83 ff 01             	cmp    $0x1,%edi
   13f77:	7e b9                	jle    13f32 <sys_setup+0x31>
	}
	if (hd_info[1].cyl)
		NR_HD=2;
   13f79:	83 3d 40 0c 02 00 01 	cmpl   $0x1,0x20c40
   13f80:	19 c0                	sbb    %eax,%eax
   13f82:	83 c0 02             	add    $0x2,%eax
   13f85:	a3 50 0c 02 00       	mov    %eax,0x20c50
	else
		NR_HD=1;
#endif
	for (i=0 ; i<NR_HD ; i++) {
   13f8a:	bb 00 00 00 00       	mov    $0x0,%ebx
   13f8f:	39 c3                	cmp    %eax,%ebx
   13f91:	7d 3b                	jge    13fce <sys_setup+0xcd>
   13f93:	89 c6                	mov    %eax,%esi
   13f95:	ba 00 00 00 00       	mov    $0x0,%edx
   13f9a:	b9 00 00 00 00       	mov    $0x0,%ecx
		hd[i*5].start_sect = 0;
   13f9f:	c7 81 60 0c 02 00 00 	movl   $0x0,0x20c60(%ecx)
   13fa6:	00 00 00 
		hd[i*5].nr_sects = hd_info[i].head*
   13fa9:	8b 82 20 0c 02 00    	mov    0x20c20(%edx),%eax
   13faf:	0f af 82 24 0c 02 00 	imul   0x20c24(%edx),%eax
   13fb6:	0f af 82 28 0c 02 00 	imul   0x20c28(%edx),%eax
   13fbd:	89 81 64 0c 02 00    	mov    %eax,0x20c64(%ecx)
	for (i=0 ; i<NR_HD ; i++) {
   13fc3:	43                   	inc    %ebx
   13fc4:	83 c1 28             	add    $0x28,%ecx
   13fc7:	83 c2 18             	add    $0x18,%edx
   13fca:	39 f3                	cmp    %esi,%ebx
   13fcc:	7c d1                	jl     13f9f <sys_setup+0x9e>
		an AT controller hard disk for that drive.

		
	*/

	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
   13fce:	b8 92 00 00 00       	mov    $0x92,%eax
   13fd3:	ba 70 00 00 00       	mov    $0x70,%edx
   13fd8:	ee                   	out    %al,(%dx)
   13fd9:	eb 00                	jmp    13fdb <sys_setup+0xda>
   13fdb:	eb 00                	jmp    13fdd <sys_setup+0xdc>
   13fdd:	b2 71                	mov    $0x71,%dl
   13fdf:	ec                   	in     (%dx),%al
   13fe0:	eb 00                	jmp    13fe2 <sys_setup+0xe1>
   13fe2:	eb 00                	jmp    13fe4 <sys_setup+0xe3>
   13fe4:	a8 f0                	test   $0xf0,%al
   13fe6:	74 12                	je     13ffa <sys_setup+0xf9>
		if (cmos_disks & 0x0f)
   13fe8:	83 e0 0f             	and    $0xf,%eax
			NR_HD = 2;
   13feb:	83 f8 01             	cmp    $0x1,%eax
   13fee:	19 c0                	sbb    %eax,%eax
   13ff0:	83 c0 02             	add    $0x2,%eax
   13ff3:	a3 50 0c 02 00       	mov    %eax,0x20c50
		else
			NR_HD = 1;
   13ff8:	eb 0a                	jmp    14004 <sys_setup+0x103>
	else
		NR_HD = 0;
   13ffa:	c7 05 50 0c 02 00 00 	movl   $0x0,0x20c50
   14001:	00 00 00 
	for (i = NR_HD ; i < 2 ; i++) {
   14004:	8b 1d 50 0c 02 00    	mov    0x20c50,%ebx
   1400a:	83 fb 01             	cmp    $0x1,%ebx
   1400d:	7f 23                	jg     14032 <sys_setup+0x131>
   1400f:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
   14012:	c1 e0 03             	shl    $0x3,%eax
		hd[i*5].start_sect = 0;
   14015:	c7 80 60 0c 02 00 00 	movl   $0x0,0x20c60(%eax)
   1401c:	00 00 00 
		hd[i*5].nr_sects = 0;
   1401f:	c7 80 64 0c 02 00 00 	movl   $0x0,0x20c64(%eax)
   14026:	00 00 00 
	for (i = NR_HD ; i < 2 ; i++) {
   14029:	43                   	inc    %ebx
   1402a:	83 c0 28             	add    $0x28,%eax
   1402d:	83 fb 01             	cmp    $0x1,%ebx
   14030:	7e e3                	jle    14015 <sys_setup+0x114>
	}
	for (drive=0 ; drive<NR_HD ; drive++) {
   14032:	bf 00 00 00 00       	mov    $0x0,%edi
   14037:	3b 3d 50 0c 02 00    	cmp    0x20c50,%edi
   1403d:	0f 8d b2 00 00 00    	jge    140f5 <sys_setup+0x1f4>
   14043:	bd 00 03 00 00       	mov    $0x300,%ebp
		if (!(bh = bread(0x300 + drive*5,0))) {
   14048:	83 ec 08             	sub    $0x8,%esp
   1404b:	6a 00                	push   $0x0
   1404d:	55                   	push   %ebp
   1404e:	e8 b0 86 ff ff       	call   c703 <bread>
   14053:	89 c6                	mov    %eax,%esi
   14055:	83 c4 10             	add    $0x10,%esp
   14058:	85 c0                	test   %eax,%eax
   1405a:	75 1d                	jne    14079 <sys_setup+0x178>
			printk("Unable to read partition table of drive %d\n\r",
   1405c:	83 ec 08             	sub    $0x8,%esp
   1405f:	57                   	push   %edi
   14060:	68 e0 94 01 00       	push   $0x194e0
   14065:	e8 e9 42 ff ff       	call   8353 <printk>
				drive);
			panic("");
   1406a:	c7 04 24 81 86 01 00 	movl   $0x18681,(%esp)
   14071:	e8 a3 42 ff ff       	call   8319 <panic>
   14076:	83 c4 10             	add    $0x10,%esp
		}
		if (bh->b_data[510] != 0x55 || (unsigned char)
   14079:	8b 06                	mov    (%esi),%eax
   1407b:	80 b8 fe 01 00 00 55 	cmpb   $0x55,0x1fe(%eax)
   14082:	75 09                	jne    1408d <sys_setup+0x18c>
   14084:	80 b8 ff 01 00 00 aa 	cmpb   $0xaa,0x1ff(%eax)
   1408b:	74 1d                	je     140aa <sys_setup+0x1a9>
		    bh->b_data[511] != 0xAA) {
			printk("Bad partition table on drive %d\n\r",drive);
   1408d:	83 ec 08             	sub    $0x8,%esp
   14090:	57                   	push   %edi
   14091:	68 10 95 01 00       	push   $0x19510
   14096:	e8 b8 42 ff ff       	call   8353 <printk>
			panic("");
   1409b:	c7 04 24 81 86 01 00 	movl   $0x18681,(%esp)
   140a2:	e8 72 42 ff ff       	call   8319 <panic>
   140a7:	83 c4 10             	add    $0x10,%esp
		}
		p = 0x1BE + (void *)bh->b_data;
   140aa:	8b 0e                	mov    (%esi),%ecx
   140ac:	81 c1 be 01 00 00    	add    $0x1be,%ecx
		for (i=1;i<5;i++,p++) {
   140b2:	bb 01 00 00 00       	mov    $0x1,%ebx
   140b7:	8d 14 bf             	lea    (%edi,%edi,4),%edx
   140ba:	42                   	inc    %edx
			hd[i+5*drive].start_sect = p->start_sect;
   140bb:	8b 41 08             	mov    0x8(%ecx),%eax
   140be:	89 04 d5 60 0c 02 00 	mov    %eax,0x20c60(,%edx,8)
			hd[i+5*drive].nr_sects = p->nr_sects;
   140c5:	8b 41 0c             	mov    0xc(%ecx),%eax
   140c8:	89 04 d5 64 0c 02 00 	mov    %eax,0x20c64(,%edx,8)
		for (i=1;i<5;i++,p++) {
   140cf:	43                   	inc    %ebx
   140d0:	42                   	inc    %edx
   140d1:	83 c1 10             	add    $0x10,%ecx
   140d4:	83 fb 04             	cmp    $0x4,%ebx
   140d7:	7e e2                	jle    140bb <sys_setup+0x1ba>
		}
		brelse(bh);
   140d9:	83 ec 0c             	sub    $0xc,%esp
   140dc:	56                   	push   %esi
   140dd:	e8 d5 85 ff ff       	call   c6b7 <brelse>
	for (drive=0 ; drive<NR_HD ; drive++) {
   140e2:	83 c4 10             	add    $0x10,%esp
   140e5:	47                   	inc    %edi
   140e6:	83 c5 05             	add    $0x5,%ebp
   140e9:	3b 3d 50 0c 02 00    	cmp    0x20c50,%edi
   140ef:	0f 8c 53 ff ff ff    	jl     14048 <sys_setup+0x147>
	}
	if (NR_HD)
   140f5:	83 3d 50 0c 02 00 00 	cmpl   $0x0,0x20c50
   140fc:	74 24                	je     14122 <sys_setup+0x221>
		printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
   140fe:	83 ec 08             	sub    $0x8,%esp
   14101:	b8 b5 88 01 00       	mov    $0x188b5,%eax
   14106:	83 3d 50 0c 02 00 01 	cmpl   $0x1,0x20c50
   1410d:	7f 05                	jg     14114 <sys_setup+0x213>
   1410f:	b8 81 86 01 00       	mov    $0x18681,%eax
   14114:	50                   	push   %eax
   14115:	68 a1 95 01 00       	push   $0x195a1
   1411a:	e8 34 42 ff ff       	call   8353 <printk>
   1411f:	83 c4 10             	add    $0x10,%esp
	rd_load();
   14122:	e8 76 0f 00 00       	call   1509d <rd_load>
	mount_root();
   14127:	e8 01 92 ff ff       	call   d32d <mount_root>
	return (0);
   1412c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14131:	83 c4 0c             	add    $0xc,%esp
   14134:	5b                   	pop    %ebx
   14135:	5e                   	pop    %esi
   14136:	5f                   	pop    %edi
   14137:	5d                   	pop    %ebp
   14138:	c3                   	ret    

00014139 <reset_hd>:
	if ((i = inb(HD_ERROR)) != 1)
		printk("HD-controller reset failed: %02x\n\r",i);
}

static void reset_hd(int nr)
{
   14139:	55                   	push   %ebp
   1413a:	57                   	push   %edi
   1413b:	56                   	push   %esi
   1413c:	53                   	push   %ebx
   1413d:	83 ec 0c             	sub    $0xc,%esp
	outb(4,HD_CMD);
   14140:	b8 04 00 00 00       	mov    $0x4,%eax
   14145:	ba f6 03 00 00       	mov    $0x3f6,%edx
   1414a:	ee                   	out    %al,(%dx)
   1414b:	b0 63                	mov    $0x63,%al
	for(i = 0; i < 100; i++) nop();
   1414d:	90                   	nop
   1414e:	48                   	dec    %eax
   1414f:	79 fc                	jns    1414d <reset_hd+0x14>
	outb(hd_info[0].ctl & 0x0f ,HD_CMD);
   14151:	a1 34 0c 02 00       	mov    0x20c34,%eax
   14156:	83 e0 0f             	and    $0xf,%eax
   14159:	ba f6 03 00 00       	mov    $0x3f6,%edx
   1415e:	ee                   	out    %al,(%dx)
	for (i = 0; i < 10000; i++)
   1415f:	bb 00 00 00 00       	mov    $0x0,%ebx
   14164:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
		if (READY_STAT == (inb_p(HD_STATUS) & (BUSY_STAT|READY_STAT)))
   14169:	89 ca                	mov    %ecx,%edx
   1416b:	ec                   	in     (%dx),%al
   1416c:	eb 00                	jmp    1416e <reset_hd+0x35>
   1416e:	eb 00                	jmp    14170 <reset_hd+0x37>
   14170:	25 c0 00 00 00       	and    $0xc0,%eax
   14175:	83 f8 40             	cmp    $0x40,%eax
   14178:	74 09                	je     14183 <reset_hd+0x4a>
	for (i = 0; i < 10000; i++)
   1417a:	43                   	inc    %ebx
   1417b:	81 fb 0f 27 00 00    	cmp    $0x270f,%ebx
   14181:	76 e6                	jbe    14169 <reset_hd+0x30>
	i = inb(HD_STATUS);
   14183:	ba f7 01 00 00       	mov    $0x1f7,%edx
   14188:	ec                   	in     (%dx),%al
	i &= BUSY_STAT | READY_STAT | SEEK_STAT;
   14189:	89 c3                	mov    %eax,%ebx
   1418b:	81 e3 d0 00 00 00    	and    $0xd0,%ebx
	if (i == (READY_STAT | SEEK_STAT))
   14191:	b8 00 00 00 00       	mov    $0x0,%eax
   14196:	83 fb 50             	cmp    $0x50,%ebx
   14199:	74 15                	je     141b0 <reset_hd+0x77>
	printk("HD controller times out\n\r");
   1419b:	83 ec 0c             	sub    $0xc,%esp
   1419e:	68 b9 95 01 00       	push   $0x195b9
   141a3:	e8 ab 41 ff ff       	call   8353 <printk>
   141a8:	83 c4 10             	add    $0x10,%esp
   141ab:	b8 01 00 00 00       	mov    $0x1,%eax
{
   141b0:	85 c0                	test   %eax,%eax
   141b2:	74 10                	je     141c4 <reset_hd+0x8b>
		printk("HD-controller still busy\n\r");
   141b4:	83 ec 0c             	sub    $0xc,%esp
   141b7:	68 d3 95 01 00       	push   $0x195d3
   141bc:	e8 92 41 ff ff       	call   8353 <printk>
   141c1:	83 c4 10             	add    $0x10,%esp
	if ((i = inb(HD_ERROR)) != 1)
   141c4:	ba f1 01 00 00       	mov    $0x1f1,%edx
   141c9:	ec                   	in     (%dx),%al
   141ca:	0f b6 c0             	movzbl %al,%eax
   141cd:	83 f8 01             	cmp    $0x1,%eax
   141d0:	74 11                	je     141e3 <reset_hd+0xaa>
		printk("HD-controller reset failed: %02x\n\r",i);
   141d2:	83 ec 08             	sub    $0x8,%esp
   141d5:	50                   	push   %eax
   141d6:	68 34 95 01 00       	push   $0x19534
   141db:	e8 73 41 ff ff       	call   8353 <printk>
   141e0:	83 c4 10             	add    $0x10,%esp
{
   141e3:	8b 5c 24 20          	mov    0x20(%esp),%ebx
   141e7:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
   141ea:	c1 e0 03             	shl    $0x3,%eax
   141ed:	8b b0 24 0c 02 00    	mov    0x20c24(%eax),%esi
   141f3:	89 f5                	mov    %esi,%ebp
   141f5:	8b 90 20 0c 02 00    	mov    0x20c20(%eax),%edx
   141fb:	4a                   	dec    %edx
   141fc:	89 54 24 08          	mov    %edx,0x8(%esp)
   14200:	8b b8 28 0c 02 00    	mov    0x20c28(%eax),%edi
	if (drive>1 || head>15)
   14206:	83 fb 01             	cmp    $0x1,%ebx
   14209:	77 05                	ja     14210 <reset_hd+0xd7>
   1420b:	83 fa 0f             	cmp    $0xf,%edx
   1420e:	76 10                	jbe    14220 <reset_hd+0xe7>
		panic("Trying to write bad sector");
   14210:	83 ec 0c             	sub    $0xc,%esp
   14213:	68 ee 95 01 00       	push   $0x195ee
   14218:	e8 fc 40 ff ff       	call   8319 <panic>
   1421d:	83 c4 10             	add    $0x10,%esp
	int retries=10000;
   14220:	c7 44 24 04 10 27 00 	movl   $0x2710,0x4(%esp)
   14227:	00 
   14228:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
	while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
   1422d:	ff 4c 24 04          	decl   0x4(%esp)
   14231:	74 18                	je     1424b <reset_hd+0x112>
   14233:	89 ca                	mov    %ecx,%edx
   14235:	ec                   	in     (%dx),%al
   14236:	eb 00                	jmp    14238 <reset_hd+0xff>
   14238:	eb 00                	jmp    1423a <reset_hd+0x101>
   1423a:	25 c0 00 00 00       	and    $0xc0,%eax
   1423f:	83 f8 40             	cmp    $0x40,%eax
   14242:	75 e9                	jne    1422d <reset_hd+0xf4>
{
   14244:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   14249:	75 10                	jne    1425b <reset_hd+0x122>
		panic("HD controller not ready");
   1424b:	83 ec 0c             	sub    $0xc,%esp
   1424e:	68 09 96 01 00       	push   $0x19609
   14253:	e8 c1 40 ff ff       	call   8319 <panic>
   14258:	83 c4 10             	add    $0x10,%esp
	do_hd = intr_addr;
   1425b:	c7 05 00 0c 02 00 23 	movl   $0x14723,0x20c00
   14262:	47 01 00 
	outb_p(hd_info[drive].ctl,HD_CMD);
   14265:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
   14268:	c1 e0 03             	shl    $0x3,%eax
   1426b:	89 04 24             	mov    %eax,(%esp)
   1426e:	8b 88 34 0c 02 00    	mov    0x20c34(%eax),%ecx
   14274:	ba f6 03 00 00       	mov    $0x3f6,%edx
   14279:	89 c8                	mov    %ecx,%eax
   1427b:	ee                   	out    %al,(%dx)
   1427c:	eb 00                	jmp    1427e <reset_hd+0x145>
   1427e:	eb 00                	jmp    14280 <reset_hd+0x147>
	outb_p(hd_info[drive].wpcom>>2,++port);
   14280:	8b 14 24             	mov    (%esp),%edx
   14283:	8b 82 2c 0c 02 00    	mov    0x20c2c(%edx),%eax
   14289:	c1 f8 02             	sar    $0x2,%eax
   1428c:	ba f1 01 00 00       	mov    $0x1f1,%edx
   14291:	ee                   	out    %al,(%dx)
   14292:	eb 00                	jmp    14294 <reset_hd+0x15b>
   14294:	eb 00                	jmp    14296 <reset_hd+0x15d>
	outb_p(nsect,++port);
   14296:	42                   	inc    %edx
   14297:	89 f0                	mov    %esi,%eax
   14299:	ee                   	out    %al,(%dx)
   1429a:	eb 00                	jmp    1429c <reset_hd+0x163>
   1429c:	eb 00                	jmp    1429e <reset_hd+0x165>
	outb_p(sect,++port);
   1429e:	42                   	inc    %edx
   1429f:	89 e8                	mov    %ebp,%eax
   142a1:	ee                   	out    %al,(%dx)
   142a2:	eb 00                	jmp    142a4 <reset_hd+0x16b>
   142a4:	eb 00                	jmp    142a6 <reset_hd+0x16d>
	outb_p(cyl,++port);
   142a6:	42                   	inc    %edx
   142a7:	89 f8                	mov    %edi,%eax
   142a9:	ee                   	out    %al,(%dx)
   142aa:	eb 00                	jmp    142ac <reset_hd+0x173>
   142ac:	eb 00                	jmp    142ae <reset_hd+0x175>
	outb_p(cyl>>8,++port);
   142ae:	c1 e8 08             	shr    $0x8,%eax
   142b1:	42                   	inc    %edx
   142b2:	ee                   	out    %al,(%dx)
   142b3:	eb 00                	jmp    142b5 <reset_hd+0x17c>
   142b5:	eb 00                	jmp    142b7 <reset_hd+0x17e>
	outb_p(0xA0|(drive<<4)|head,++port);
   142b7:	89 d8                	mov    %ebx,%eax
   142b9:	c1 e0 04             	shl    $0x4,%eax
   142bc:	0b 44 24 08          	or     0x8(%esp),%eax
   142c0:	0c a0                	or     $0xa0,%al
   142c2:	42                   	inc    %edx
   142c3:	ee                   	out    %al,(%dx)
   142c4:	eb 00                	jmp    142c6 <reset_hd+0x18d>
   142c6:	eb 00                	jmp    142c8 <reset_hd+0x18f>
	outb(cmd,++port);
   142c8:	42                   	inc    %edx
   142c9:	b8 91 00 00 00       	mov    $0x91,%eax
   142ce:	ee                   	out    %al,(%dx)
	reset_controller();
	hd_out(nr,hd_info[nr].sect,hd_info[nr].sect,hd_info[nr].head-1,
		hd_info[nr].cyl,WIN_SPECIFY,&recal_intr);
}
   142cf:	83 c4 0c             	add    $0xc,%esp
   142d2:	5b                   	pop    %ebx
   142d3:	5e                   	pop    %esi
   142d4:	5f                   	pop    %edi
   142d5:	5d                   	pop    %ebp
   142d6:	c3                   	ret    

000142d7 <unexpected_hd_interrupt>:

void unexpected_hd_interrupt(void)
{
   142d7:	83 ec 18             	sub    $0x18,%esp
	printk("Unexpected HD interrupt\n\r");
   142da:	68 21 96 01 00       	push   $0x19621
   142df:	e8 6f 40 ff ff       	call   8353 <printk>
}
   142e4:	83 c4 1c             	add    $0x1c,%esp
   142e7:	c3                   	ret    

000142e8 <read_intr>:
	if (CURRENT->errors > MAX_ERRORS/2)
		reset = 1;
}

static void read_intr(void)
{
   142e8:	57                   	push   %edi
   142e9:	83 ec 08             	sub    $0x8,%esp
	int i=inb_p(HD_STATUS);
   142ec:	ba f7 01 00 00       	mov    $0x1f7,%edx
   142f1:	ec                   	in     (%dx),%al
   142f2:	eb 00                	jmp    142f4 <read_intr+0xc>
   142f4:	eb 00                	jmp    142f6 <read_intr+0xe>
   142f6:	0f b6 d0             	movzbl %al,%edx
	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   142f9:	89 d0                	mov    %edx,%eax
   142fb:	25 f1 00 00 00       	and    $0xf1,%eax
   14300:	b9 00 00 00 00       	mov    $0x0,%ecx
   14305:	83 f8 50             	cmp    $0x50,%eax
   14308:	74 10                	je     1431a <read_intr+0x32>
	if (i&1) i=inb(HD_ERROR);
   1430a:	f6 c2 01             	test   $0x1,%dl
   1430d:	74 06                	je     14315 <read_intr+0x2d>
   1430f:	ba f1 01 00 00       	mov    $0x1f1,%edx
   14314:	ec                   	in     (%dx),%al
   14315:	b9 01 00 00 00       	mov    $0x1,%ecx
{
   1431a:	85 c9                	test   %ecx,%ecx
   1431c:	0f 84 e0 00 00 00    	je     14402 <read_intr+0x11a>
	if (++CURRENT->errors >= MAX_ERRORS)
   14322:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14327:	ff 40 08             	incl   0x8(%eax)
   1432a:	83 78 08 06          	cmpl   $0x6,0x8(%eax)
   1432e:	0f 8e af 00 00 00    	jle    143e3 <read_intr+0xfb>
	if (CURRENT->bh) {
   14334:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14339:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   1433d:	74 38                	je     14377 <read_intr+0x8f>
		CURRENT->bh->b_uptodate = uptodate;
   1433f:	8b 40 1c             	mov    0x1c(%eax),%eax
   14342:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   14346:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1434b:	8b 78 1c             	mov    0x1c(%eax),%edi
	if (!bh->b_lock)
   1434e:	80 7f 0d 00          	cmpb   $0x0,0xd(%edi)
   14352:	75 10                	jne    14364 <read_intr+0x7c>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   14354:	83 ec 0c             	sub    $0xc,%esp
   14357:	68 58 95 01 00       	push   $0x19558
   1435c:	e8 f2 3f ff ff       	call   8353 <printk>
   14361:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   14364:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
	wake_up(&bh->b_wait);
   14368:	83 ec 0c             	sub    $0xc,%esp
   1436b:	8d 47 10             	lea    0x10(%edi),%eax
   1436e:	50                   	push   %eax
   1436f:	e8 2f 2c ff ff       	call   6fa3 <wake_up>
   14374:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   14377:	b8 00 00 00 00       	mov    $0x0,%eax
   1437c:	85 c0                	test   %eax,%eax
   1437e:	75 2b                	jne    143ab <read_intr+0xc3>
		printk(DEVICE_NAME " I/O error\n\r");
   14380:	83 ec 0c             	sub    $0xc,%esp
   14383:	68 3b 96 01 00       	push   $0x1963b
   14388:	e8 c6 3f ff ff       	call   8353 <printk>
   1438d:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   14390:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   14396:	8b 42 1c             	mov    0x1c(%edx),%eax
   14399:	ff 70 04             	pushl  0x4(%eax)
   1439c:	ff 32                	pushl  (%edx)
   1439e:	68 4a 94 01 00       	push   $0x1944a
   143a3:	e8 ab 3f ff ff       	call   8353 <printk>
   143a8:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   143ab:	83 ec 0c             	sub    $0xc,%esp
   143ae:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   143b3:	83 c0 18             	add    $0x18,%eax
   143b6:	50                   	push   %eax
   143b7:	e8 e7 2b ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   143bc:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   143c3:	e8 db 2b ff ff       	call   6fa3 <wake_up>
   143c8:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   143cb:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   143d0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   143d6:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   143db:	8b 40 20             	mov    0x20(%eax),%eax
   143de:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
	if (CURRENT->errors > MAX_ERRORS/2)
   143e3:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   143e8:	83 78 08 03          	cmpl   $0x3,0x8(%eax)
   143ec:	7e 0a                	jle    143f8 <read_intr+0x110>
		reset = 1;
   143ee:	c7 05 14 bf 01 00 01 	movl   $0x1,0x1bf14
   143f5:	00 00 00 
	if (win_result()) {
		bad_rw_intr();
		do_hd_request();
   143f8:	e8 40 04 00 00       	call   1483d <do_hd_request>
		return;
   143fd:	e9 02 01 00 00       	jmp    14504 <read_intr+0x21c>
	}
	port_read(HD_DATA,CURRENT->buffer,256);
   14402:	ba f0 01 00 00       	mov    $0x1f0,%edx
   14407:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1440c:	8b 78 14             	mov    0x14(%eax),%edi
   1440f:	b9 00 01 00 00       	mov    $0x100,%ecx
   14414:	fc                   	cld    
   14415:	f3 66 6d             	rep insw (%dx),%es:(%edi)
	CURRENT->errors = 0;
   14418:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	CURRENT->buffer += 512;
   1441f:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14424:	81 40 14 00 02 00 00 	addl   $0x200,0x14(%eax)
	CURRENT->sector++;
   1442b:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14430:	ff 40 0c             	incl   0xc(%eax)
	if (--CURRENT->nr_sectors) {
   14433:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14438:	ff 48 10             	decl   0x10(%eax)
   1443b:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   1443f:	74 0f                	je     14450 <read_intr+0x168>
		do_hd = &read_intr;
   14441:	c7 05 00 0c 02 00 e8 	movl   $0x142e8,0x20c00
   14448:	42 01 00 
		return;
   1444b:	e9 b4 00 00 00       	jmp    14504 <read_intr+0x21c>
	if (CURRENT->bh) {
   14450:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14455:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14459:	74 38                	je     14493 <read_intr+0x1ab>
		CURRENT->bh->b_uptodate = uptodate;
   1445b:	8b 40 1c             	mov    0x1c(%eax),%eax
   1445e:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
{
   14462:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14467:	8b 78 1c             	mov    0x1c(%eax),%edi
	if (!bh->b_lock)
   1446a:	80 7f 0d 00          	cmpb   $0x0,0xd(%edi)
   1446e:	75 10                	jne    14480 <read_intr+0x198>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   14470:	83 ec 0c             	sub    $0xc,%esp
   14473:	68 58 95 01 00       	push   $0x19558
   14478:	e8 d6 3e ff ff       	call   8353 <printk>
   1447d:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   14480:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
	wake_up(&bh->b_wait);
   14484:	83 ec 0c             	sub    $0xc,%esp
   14487:	8d 47 10             	lea    0x10(%edi),%eax
   1448a:	50                   	push   %eax
   1448b:	e8 13 2b ff ff       	call   6fa3 <wake_up>
   14490:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   14493:	b8 01 00 00 00       	mov    $0x1,%eax
   14498:	85 c0                	test   %eax,%eax
   1449a:	75 2b                	jne    144c7 <read_intr+0x1df>
		printk(DEVICE_NAME " I/O error\n\r");
   1449c:	83 ec 0c             	sub    $0xc,%esp
   1449f:	68 3b 96 01 00       	push   $0x1963b
   144a4:	e8 aa 3e ff ff       	call   8353 <printk>
   144a9:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   144ac:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   144b2:	8b 42 1c             	mov    0x1c(%edx),%eax
   144b5:	ff 70 04             	pushl  0x4(%eax)
   144b8:	ff 32                	pushl  (%edx)
   144ba:	68 4a 94 01 00       	push   $0x1944a
   144bf:	e8 8f 3e ff ff       	call   8353 <printk>
   144c4:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   144c7:	83 ec 0c             	sub    $0xc,%esp
   144ca:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   144cf:	83 c0 18             	add    $0x18,%eax
   144d2:	50                   	push   %eax
   144d3:	e8 cb 2a ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   144d8:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   144df:	e8 bf 2a ff ff       	call   6fa3 <wake_up>
   144e4:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   144e7:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   144ec:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   144f2:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   144f7:	8b 40 20             	mov    0x20(%eax),%eax
   144fa:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
	}
	end_request(1);
	do_hd_request();
   144ff:	e8 39 03 00 00       	call   1483d <do_hd_request>
}
   14504:	83 c4 08             	add    $0x8,%esp
   14507:	5f                   	pop    %edi
   14508:	c3                   	ret    

00014509 <write_intr>:

static void write_intr(void)
{
   14509:	56                   	push   %esi
   1450a:	83 ec 08             	sub    $0x8,%esp
	int i=inb_p(HD_STATUS);
   1450d:	ba f7 01 00 00       	mov    $0x1f7,%edx
   14512:	ec                   	in     (%dx),%al
   14513:	eb 00                	jmp    14515 <write_intr+0xc>
   14515:	eb 00                	jmp    14517 <write_intr+0xe>
   14517:	0f b6 d0             	movzbl %al,%edx
	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   1451a:	89 d0                	mov    %edx,%eax
   1451c:	25 f1 00 00 00       	and    $0xf1,%eax
   14521:	b9 00 00 00 00       	mov    $0x0,%ecx
   14526:	83 f8 50             	cmp    $0x50,%eax
   14529:	74 10                	je     1453b <write_intr+0x32>
	if (i&1) i=inb(HD_ERROR);
   1452b:	f6 c2 01             	test   $0x1,%dl
   1452e:	74 06                	je     14536 <write_intr+0x2d>
   14530:	ba f1 01 00 00       	mov    $0x1f1,%edx
   14535:	ec                   	in     (%dx),%al
   14536:	b9 01 00 00 00       	mov    $0x1,%ecx
{
   1453b:	85 c9                	test   %ecx,%ecx
   1453d:	0f 84 e0 00 00 00    	je     14623 <write_intr+0x11a>
	if (++CURRENT->errors >= MAX_ERRORS)
   14543:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14548:	ff 40 08             	incl   0x8(%eax)
   1454b:	83 78 08 06          	cmpl   $0x6,0x8(%eax)
   1454f:	0f 8e af 00 00 00    	jle    14604 <write_intr+0xfb>
	if (CURRENT->bh) {
   14555:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1455a:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   1455e:	74 38                	je     14598 <write_intr+0x8f>
		CURRENT->bh->b_uptodate = uptodate;
   14560:	8b 40 1c             	mov    0x1c(%eax),%eax
   14563:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   14567:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1456c:	8b 70 1c             	mov    0x1c(%eax),%esi
	if (!bh->b_lock)
   1456f:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   14573:	75 10                	jne    14585 <write_intr+0x7c>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   14575:	83 ec 0c             	sub    $0xc,%esp
   14578:	68 58 95 01 00       	push   $0x19558
   1457d:	e8 d1 3d ff ff       	call   8353 <printk>
   14582:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   14585:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	wake_up(&bh->b_wait);
   14589:	83 ec 0c             	sub    $0xc,%esp
   1458c:	8d 46 10             	lea    0x10(%esi),%eax
   1458f:	50                   	push   %eax
   14590:	e8 0e 2a ff ff       	call   6fa3 <wake_up>
   14595:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   14598:	b8 00 00 00 00       	mov    $0x0,%eax
   1459d:	85 c0                	test   %eax,%eax
   1459f:	75 2b                	jne    145cc <write_intr+0xc3>
		printk(DEVICE_NAME " I/O error\n\r");
   145a1:	83 ec 0c             	sub    $0xc,%esp
   145a4:	68 3b 96 01 00       	push   $0x1963b
   145a9:	e8 a5 3d ff ff       	call   8353 <printk>
   145ae:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   145b1:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   145b7:	8b 42 1c             	mov    0x1c(%edx),%eax
   145ba:	ff 70 04             	pushl  0x4(%eax)
   145bd:	ff 32                	pushl  (%edx)
   145bf:	68 4a 94 01 00       	push   $0x1944a
   145c4:	e8 8a 3d ff ff       	call   8353 <printk>
   145c9:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   145cc:	83 ec 0c             	sub    $0xc,%esp
   145cf:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   145d4:	83 c0 18             	add    $0x18,%eax
   145d7:	50                   	push   %eax
   145d8:	e8 c6 29 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   145dd:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   145e4:	e8 ba 29 ff ff       	call   6fa3 <wake_up>
   145e9:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   145ec:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   145f1:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   145f7:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   145fc:	8b 40 20             	mov    0x20(%eax),%eax
   145ff:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
	if (CURRENT->errors > MAX_ERRORS/2)
   14604:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14609:	83 78 08 03          	cmpl   $0x3,0x8(%eax)
   1460d:	7e 0a                	jle    14619 <write_intr+0x110>
		reset = 1;
   1460f:	c7 05 14 bf 01 00 01 	movl   $0x1,0x1bf14
   14616:	00 00 00 
	if (win_result()) {
		bad_rw_intr();
		do_hd_request();
   14619:	e8 1f 02 00 00       	call   1483d <do_hd_request>
		return;
   1461e:	e9 fb 00 00 00       	jmp    1471e <write_intr+0x215>
	}
	if (--CURRENT->nr_sectors) {
   14623:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14628:	ff 48 10             	decl   0x10(%eax)
   1462b:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   1462f:	74 39                	je     1466a <write_intr+0x161>
		CURRENT->sector++;
   14631:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14636:	ff 40 0c             	incl   0xc(%eax)
		CURRENT->buffer += 512;
   14639:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1463e:	81 40 14 00 02 00 00 	addl   $0x200,0x14(%eax)
		do_hd = &write_intr;
   14645:	c7 05 00 0c 02 00 09 	movl   $0x14509,0x20c00
   1464c:	45 01 00 
		port_write(HD_DATA,CURRENT->buffer,256);
   1464f:	ba f0 01 00 00       	mov    $0x1f0,%edx
   14654:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14659:	8b 70 14             	mov    0x14(%eax),%esi
   1465c:	b9 00 01 00 00       	mov    $0x100,%ecx
   14661:	fc                   	cld    
   14662:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
		return;
   14665:	e9 b4 00 00 00       	jmp    1471e <write_intr+0x215>
	if (CURRENT->bh) {
   1466a:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1466f:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14673:	74 38                	je     146ad <write_intr+0x1a4>
		CURRENT->bh->b_uptodate = uptodate;
   14675:	8b 40 1c             	mov    0x1c(%eax),%eax
   14678:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
{
   1467c:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14681:	8b 70 1c             	mov    0x1c(%eax),%esi
	if (!bh->b_lock)
   14684:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   14688:	75 10                	jne    1469a <write_intr+0x191>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   1468a:	83 ec 0c             	sub    $0xc,%esp
   1468d:	68 58 95 01 00       	push   $0x19558
   14692:	e8 bc 3c ff ff       	call   8353 <printk>
   14697:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   1469a:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	wake_up(&bh->b_wait);
   1469e:	83 ec 0c             	sub    $0xc,%esp
   146a1:	8d 46 10             	lea    0x10(%esi),%eax
   146a4:	50                   	push   %eax
   146a5:	e8 f9 28 ff ff       	call   6fa3 <wake_up>
   146aa:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   146ad:	b8 01 00 00 00       	mov    $0x1,%eax
   146b2:	85 c0                	test   %eax,%eax
   146b4:	75 2b                	jne    146e1 <write_intr+0x1d8>
		printk(DEVICE_NAME " I/O error\n\r");
   146b6:	83 ec 0c             	sub    $0xc,%esp
   146b9:	68 3b 96 01 00       	push   $0x1963b
   146be:	e8 90 3c ff ff       	call   8353 <printk>
   146c3:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   146c6:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   146cc:	8b 42 1c             	mov    0x1c(%edx),%eax
   146cf:	ff 70 04             	pushl  0x4(%eax)
   146d2:	ff 32                	pushl  (%edx)
   146d4:	68 4a 94 01 00       	push   $0x1944a
   146d9:	e8 75 3c ff ff       	call   8353 <printk>
   146de:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   146e1:	83 ec 0c             	sub    $0xc,%esp
   146e4:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   146e9:	83 c0 18             	add    $0x18,%eax
   146ec:	50                   	push   %eax
   146ed:	e8 b1 28 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   146f2:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   146f9:	e8 a5 28 ff ff       	call   6fa3 <wake_up>
   146fe:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   14701:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14706:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   1470c:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14711:	8b 40 20             	mov    0x20(%eax),%eax
   14714:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
	}
	end_request(1);
	do_hd_request();
   14719:	e8 1f 01 00 00       	call   1483d <do_hd_request>
}
   1471e:	83 c4 08             	add    $0x8,%esp
   14721:	5e                   	pop    %esi
   14722:	c3                   	ret    

00014723 <recal_intr>:

static void recal_intr(void)
{
   14723:	53                   	push   %ebx
   14724:	83 ec 08             	sub    $0x8,%esp
	int i=inb_p(HD_STATUS);
   14727:	ba f7 01 00 00       	mov    $0x1f7,%edx
   1472c:	ec                   	in     (%dx),%al
   1472d:	eb 00                	jmp    1472f <recal_intr+0xc>
   1472f:	eb 00                	jmp    14731 <recal_intr+0xe>
   14731:	0f b6 d0             	movzbl %al,%edx
	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   14734:	89 d0                	mov    %edx,%eax
   14736:	25 f1 00 00 00       	and    $0xf1,%eax
   1473b:	b9 00 00 00 00       	mov    $0x0,%ecx
   14740:	83 f8 50             	cmp    $0x50,%eax
   14743:	74 10                	je     14755 <recal_intr+0x32>
	if (i&1) i=inb(HD_ERROR);
   14745:	f6 c2 01             	test   $0x1,%dl
   14748:	74 06                	je     14750 <recal_intr+0x2d>
   1474a:	ba f1 01 00 00       	mov    $0x1f1,%edx
   1474f:	ec                   	in     (%dx),%al
   14750:	b9 01 00 00 00       	mov    $0x1,%ecx
{
   14755:	85 c9                	test   %ecx,%ecx
   14757:	0f 84 d6 00 00 00    	je     14833 <recal_intr+0x110>
	if (++CURRENT->errors >= MAX_ERRORS)
   1475d:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14762:	ff 40 08             	incl   0x8(%eax)
   14765:	83 78 08 06          	cmpl   $0x6,0x8(%eax)
   14769:	0f 8e af 00 00 00    	jle    1481e <recal_intr+0xfb>
	if (CURRENT->bh) {
   1476f:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14774:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14778:	74 38                	je     147b2 <recal_intr+0x8f>
		CURRENT->bh->b_uptodate = uptodate;
   1477a:	8b 40 1c             	mov    0x1c(%eax),%eax
   1477d:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   14781:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14786:	8b 58 1c             	mov    0x1c(%eax),%ebx
	if (!bh->b_lock)
   14789:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   1478d:	75 10                	jne    1479f <recal_intr+0x7c>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   1478f:	83 ec 0c             	sub    $0xc,%esp
   14792:	68 58 95 01 00       	push   $0x19558
   14797:	e8 b7 3b ff ff       	call   8353 <printk>
   1479c:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   1479f:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   147a3:	83 ec 0c             	sub    $0xc,%esp
   147a6:	8d 43 10             	lea    0x10(%ebx),%eax
   147a9:	50                   	push   %eax
   147aa:	e8 f4 27 ff ff       	call   6fa3 <wake_up>
   147af:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   147b2:	b8 00 00 00 00       	mov    $0x0,%eax
   147b7:	85 c0                	test   %eax,%eax
   147b9:	75 2b                	jne    147e6 <recal_intr+0xc3>
		printk(DEVICE_NAME " I/O error\n\r");
   147bb:	83 ec 0c             	sub    $0xc,%esp
   147be:	68 3b 96 01 00       	push   $0x1963b
   147c3:	e8 8b 3b ff ff       	call   8353 <printk>
   147c8:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   147cb:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   147d1:	8b 42 1c             	mov    0x1c(%edx),%eax
   147d4:	ff 70 04             	pushl  0x4(%eax)
   147d7:	ff 32                	pushl  (%edx)
   147d9:	68 4a 94 01 00       	push   $0x1944a
   147de:	e8 70 3b ff ff       	call   8353 <printk>
   147e3:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   147e6:	83 ec 0c             	sub    $0xc,%esp
   147e9:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   147ee:	83 c0 18             	add    $0x18,%eax
   147f1:	50                   	push   %eax
   147f2:	e8 ac 27 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   147f7:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   147fe:	e8 a0 27 ff ff       	call   6fa3 <wake_up>
   14803:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   14806:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1480b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   14811:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14816:	8b 40 20             	mov    0x20(%eax),%eax
   14819:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
	if (CURRENT->errors > MAX_ERRORS/2)
   1481e:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14823:	83 78 08 03          	cmpl   $0x3,0x8(%eax)
   14827:	7e 0a                	jle    14833 <recal_intr+0x110>
		reset = 1;
   14829:	c7 05 14 bf 01 00 01 	movl   $0x1,0x1bf14
   14830:	00 00 00 
	if (win_result())
		bad_rw_intr();
	do_hd_request();
   14833:	e8 05 00 00 00       	call   1483d <do_hd_request>
}
   14838:	83 c4 08             	add    $0x8,%esp
   1483b:	5b                   	pop    %ebx
   1483c:	c3                   	ret    

0001483d <do_hd_request>:

void do_hd_request(void)
{
   1483d:	55                   	push   %ebp
   1483e:	57                   	push   %edi
   1483f:	56                   	push   %esi
   14840:	53                   	push   %ebx
   14841:	83 ec 1c             	sub    $0x1c,%esp
	int i,r = 0;
	unsigned int block,dev;
	unsigned int sec,head,cyl;
	unsigned int nsect;

	INIT_REQUEST;
   14844:	83 3d bc 0b 02 00 00 	cmpl   $0x0,0x20bbc
   1484b:	0f 84 8d 05 00 00    	je     14dde <do_hd_request+0x5a1>
   14851:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14856:	8b 00                	mov    (%eax),%eax
   14858:	c1 e8 08             	shr    $0x8,%eax
   1485b:	83 f8 03             	cmp    $0x3,%eax
   1485e:	74 10                	je     14870 <do_hd_request+0x33>
   14860:	83 ec 0c             	sub    $0xc,%esp
   14863:	68 80 95 01 00       	push   $0x19580
   14868:	e8 ac 3a ff ff       	call   8319 <panic>
   1486d:	83 c4 10             	add    $0x10,%esp
   14870:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14875:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14879:	74 19                	je     14894 <do_hd_request+0x57>
   1487b:	8b 40 1c             	mov    0x1c(%eax),%eax
   1487e:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   14882:	75 10                	jne    14894 <do_hd_request+0x57>
   14884:	83 ec 0c             	sub    $0xc,%esp
   14887:	68 50 96 01 00       	push   $0x19650
   1488c:	e8 88 3a ff ff       	call   8319 <panic>
   14891:	83 c4 10             	add    $0x10,%esp
	dev = MINOR(CURRENT->dev);
   14894:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14899:	0f b6 18             	movzbl (%eax),%ebx
	block = CURRENT->sector;
   1489c:	8b 70 0c             	mov    0xc(%eax),%esi
	if (dev >= 5*NR_HD || block+2 > hd[dev].nr_sects) {
   1489f:	a1 50 0c 02 00       	mov    0x20c50,%eax
   148a4:	8d 04 80             	lea    (%eax,%eax,4),%eax
   148a7:	39 d8                	cmp    %ebx,%eax
   148a9:	76 10                	jbe    148bb <do_hd_request+0x7e>
   148ab:	8d 46 02             	lea    0x2(%esi),%eax
   148ae:	3b 04 dd 64 0c 02 00 	cmp    0x20c64(,%ebx,8),%eax
   148b5:	0f 86 b4 00 00 00    	jbe    1496f <do_hd_request+0x132>
	if (CURRENT->bh) {
   148bb:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   148c0:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   148c4:	74 38                	je     148fe <do_hd_request+0xc1>
		CURRENT->bh->b_uptodate = uptodate;
   148c6:	8b 40 1c             	mov    0x1c(%eax),%eax
   148c9:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   148cd:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   148d2:	8b 58 1c             	mov    0x1c(%eax),%ebx
	if (!bh->b_lock)
   148d5:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   148d9:	75 10                	jne    148eb <do_hd_request+0xae>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   148db:	83 ec 0c             	sub    $0xc,%esp
   148de:	68 58 95 01 00       	push   $0x19558
   148e3:	e8 6b 3a ff ff       	call   8353 <printk>
   148e8:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   148eb:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   148ef:	83 ec 0c             	sub    $0xc,%esp
   148f2:	8d 43 10             	lea    0x10(%ebx),%eax
   148f5:	50                   	push   %eax
   148f6:	e8 a8 26 ff ff       	call   6fa3 <wake_up>
   148fb:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   148fe:	b8 00 00 00 00       	mov    $0x0,%eax
   14903:	85 c0                	test   %eax,%eax
   14905:	75 2b                	jne    14932 <do_hd_request+0xf5>
		printk(DEVICE_NAME " I/O error\n\r");
   14907:	83 ec 0c             	sub    $0xc,%esp
   1490a:	68 3b 96 01 00       	push   $0x1963b
   1490f:	e8 3f 3a ff ff       	call   8353 <printk>
   14914:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   14917:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   1491d:	8b 42 1c             	mov    0x1c(%edx),%eax
   14920:	ff 70 04             	pushl  0x4(%eax)
   14923:	ff 32                	pushl  (%edx)
   14925:	68 4a 94 01 00       	push   $0x1944a
   1492a:	e8 24 3a ff ff       	call   8353 <printk>
   1492f:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   14932:	83 ec 0c             	sub    $0xc,%esp
   14935:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   1493a:	83 c0 18             	add    $0x18,%eax
   1493d:	50                   	push   %eax
   1493e:	e8 60 26 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   14943:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   1494a:	e8 54 26 ff ff       	call   6fa3 <wake_up>
   1494f:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   14952:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14957:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   1495d:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14962:	8b 40 20             	mov    0x20(%eax),%eax
   14965:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
		end_request(0);
		goto repeat;
   1496a:	e9 d5 fe ff ff       	jmp    14844 <do_hd_request+0x7>
	}
	block += hd[dev].start_sect;
   1496f:	03 34 dd 60 0c 02 00 	add    0x20c60(,%ebx,8),%esi
	dev /= 5;
   14976:	b8 cd cc cc cc       	mov    $0xcccccccd,%eax
   1497b:	f7 e3                	mul    %ebx
   1497d:	89 d3                	mov    %edx,%ebx
   1497f:	c1 eb 02             	shr    $0x2,%ebx
	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
   14982:	bd 00 00 00 00       	mov    $0x0,%ebp
   14987:	8d 0c 5b             	lea    (%ebx,%ebx,2),%ecx
   1498a:	c1 e1 03             	shl    $0x3,%ecx
   1498d:	8b b9 24 0c 02 00    	mov    0x20c24(%ecx),%edi
   14993:	89 f0                	mov    %esi,%eax
   14995:	89 ea                	mov    %ebp,%edx
   14997:	f7 f7                	div    %edi
   14999:	89 d7                	mov    %edx,%edi
		"r" (hd_info[dev].sect));
	__asm__("divl %4":"=a" (cyl),"=d" (head):"0" (block),"1" (0),
   1499b:	8b 89 20 0c 02 00    	mov    0x20c20(%ecx),%ecx
   149a1:	89 ea                	mov    %ebp,%edx
   149a3:	f7 f1                	div    %ecx
   149a5:	89 c6                	mov    %eax,%esi
		"r" (hd_info[dev].head));
	sec++;
   149a7:	47                   	inc    %edi
	nsect = CURRENT->nr_sectors;
   149a8:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   149ad:	8b 48 10             	mov    0x10(%eax),%ecx
	if (reset) {
   149b0:	83 3d 14 bf 01 00 00 	cmpl   $0x0,0x1bf14
   149b7:	74 33                	je     149ec <do_hd_request+0x1af>
		reset = 0;
   149b9:	c7 05 14 bf 01 00 00 	movl   $0x0,0x1bf14
   149c0:	00 00 00 
		recalibrate = 1;
   149c3:	c7 05 10 bf 01 00 01 	movl   $0x1,0x1bf10
   149ca:	00 00 00 
		reset_hd(CURRENT_DEV);
   149cd:	83 ec 0c             	sub    $0xc,%esp
   149d0:	0f b6 10             	movzbl (%eax),%edx
   149d3:	b8 67 66 66 66       	mov    $0x66666667,%eax
   149d8:	f7 ea                	imul   %edx
   149da:	89 d0                	mov    %edx,%eax
   149dc:	d1 f8                	sar    %eax
   149de:	50                   	push   %eax
   149df:	e8 55 f7 ff ff       	call   14139 <reset_hd>
		return;
   149e4:	83 c4 10             	add    $0x10,%esp
   149e7:	e9 f2 03 00 00       	jmp    14dde <do_hd_request+0x5a1>
	}
	if (recalibrate) {
   149ec:	83 3d 10 bf 01 00 00 	cmpl   $0x0,0x1bf10
   149f3:	0f 84 ed 00 00 00    	je     14ae6 <do_hd_request+0x2a9>
		recalibrate = 0;
   149f9:	c7 05 10 bf 01 00 00 	movl   $0x0,0x1bf10
   14a00:	00 00 00 
{
   14a03:	89 de                	mov    %ebx,%esi
   14a05:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14a0a:	0f b6 10             	movzbl (%eax),%edx
   14a0d:	b8 67 66 66 66       	mov    $0x66666667,%eax
   14a12:	f7 ea                	imul   %edx
   14a14:	89 d0                	mov    %edx,%eax
   14a16:	d1 f8                	sar    %eax
   14a18:	8d 04 40             	lea    (%eax,%eax,2),%eax
   14a1b:	8b 2c c5 24 0c 02 00 	mov    0x20c24(,%eax,8),%ebp
   14a22:	bf 00 00 00 00       	mov    $0x0,%edi
	if (drive>1 || head>15)
   14a27:	83 fb 01             	cmp    $0x1,%ebx
   14a2a:	76 10                	jbe    14a3c <do_hd_request+0x1ff>
		panic("Trying to write bad sector");
   14a2c:	83 ec 0c             	sub    $0xc,%esp
   14a2f:	68 ee 95 01 00       	push   $0x195ee
   14a34:	e8 e0 38 ff ff       	call   8319 <panic>
   14a39:	83 c4 10             	add    $0x10,%esp
	int retries=10000;
   14a3c:	bb 10 27 00 00       	mov    $0x2710,%ebx
   14a41:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
	while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
   14a46:	4b                   	dec    %ebx
   14a47:	74 15                	je     14a5e <do_hd_request+0x221>
   14a49:	89 ca                	mov    %ecx,%edx
   14a4b:	ec                   	in     (%dx),%al
   14a4c:	eb 00                	jmp    14a4e <do_hd_request+0x211>
   14a4e:	eb 00                	jmp    14a50 <do_hd_request+0x213>
   14a50:	25 c0 00 00 00       	and    $0xc0,%eax
   14a55:	83 f8 40             	cmp    $0x40,%eax
   14a58:	75 ec                	jne    14a46 <do_hd_request+0x209>
{
   14a5a:	85 db                	test   %ebx,%ebx
   14a5c:	75 10                	jne    14a6e <do_hd_request+0x231>
		panic("HD controller not ready");
   14a5e:	83 ec 0c             	sub    $0xc,%esp
   14a61:	68 09 96 01 00       	push   $0x19609
   14a66:	e8 ae 38 ff ff       	call   8319 <panic>
   14a6b:	83 c4 10             	add    $0x10,%esp
	do_hd = intr_addr;
   14a6e:	c7 05 00 0c 02 00 23 	movl   $0x14723,0x20c00
   14a75:	47 01 00 
	outb_p(hd_info[drive].ctl,HD_CMD);
   14a78:	8d 04 76             	lea    (%esi,%esi,2),%eax
   14a7b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
   14a82:	8b 8b 34 0c 02 00    	mov    0x20c34(%ebx),%ecx
   14a88:	ba f6 03 00 00       	mov    $0x3f6,%edx
   14a8d:	89 c8                	mov    %ecx,%eax
   14a8f:	ee                   	out    %al,(%dx)
   14a90:	eb 00                	jmp    14a92 <do_hd_request+0x255>
   14a92:	eb 00                	jmp    14a94 <do_hd_request+0x257>
	outb_p(hd_info[drive].wpcom>>2,++port);
   14a94:	8b 83 2c 0c 02 00    	mov    0x20c2c(%ebx),%eax
   14a9a:	c1 f8 02             	sar    $0x2,%eax
   14a9d:	66 ba f1 01          	mov    $0x1f1,%dx
   14aa1:	ee                   	out    %al,(%dx)
   14aa2:	eb 00                	jmp    14aa4 <do_hd_request+0x267>
   14aa4:	eb 00                	jmp    14aa6 <do_hd_request+0x269>
	outb_p(nsect,++port);
   14aa6:	42                   	inc    %edx
   14aa7:	89 e8                	mov    %ebp,%eax
   14aa9:	ee                   	out    %al,(%dx)
   14aaa:	eb 00                	jmp    14aac <do_hd_request+0x26f>
   14aac:	eb 00                	jmp    14aae <do_hd_request+0x271>
	outb_p(sect,++port);
   14aae:	42                   	inc    %edx
   14aaf:	b8 00 00 00 00       	mov    $0x0,%eax
   14ab4:	ee                   	out    %al,(%dx)
   14ab5:	eb 00                	jmp    14ab7 <do_hd_request+0x27a>
   14ab7:	eb 00                	jmp    14ab9 <do_hd_request+0x27c>
	outb_p(cyl,++port);
   14ab9:	42                   	inc    %edx
   14aba:	89 f8                	mov    %edi,%eax
   14abc:	ee                   	out    %al,(%dx)
   14abd:	eb 00                	jmp    14abf <do_hd_request+0x282>
   14abf:	eb 00                	jmp    14ac1 <do_hd_request+0x284>
	outb_p(cyl>>8,++port);
   14ac1:	c1 e8 08             	shr    $0x8,%eax
   14ac4:	42                   	inc    %edx
   14ac5:	ee                   	out    %al,(%dx)
   14ac6:	eb 00                	jmp    14ac8 <do_hd_request+0x28b>
   14ac8:	eb 00                	jmp    14aca <do_hd_request+0x28d>
	outb_p(0xA0|(drive<<4)|head,++port);
   14aca:	89 f0                	mov    %esi,%eax
   14acc:	c1 e0 04             	shl    $0x4,%eax
   14acf:	80 cc 00             	or     $0x0,%ah
   14ad2:	0c a0                	or     $0xa0,%al
   14ad4:	42                   	inc    %edx
   14ad5:	ee                   	out    %al,(%dx)
   14ad6:	eb 00                	jmp    14ad8 <do_hd_request+0x29b>
   14ad8:	eb 00                	jmp    14ada <do_hd_request+0x29d>
	outb(cmd,++port);
   14ada:	42                   	inc    %edx
   14adb:	b8 10 00 00 00       	mov    $0x10,%eax
   14ae0:	ee                   	out    %al,(%dx)
		hd_out(dev,hd_info[CURRENT_DEV].sect,0,0,0,
			WIN_RESTORE,&recal_intr);
		return;
   14ae1:	e9 f8 02 00 00       	jmp    14dde <do_hd_request+0x5a1>
	}	
	if (CURRENT->cmd == WRITE) {
   14ae6:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14aeb:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   14aef:	0f 85 f7 01 00 00    	jne    14cec <do_hd_request+0x4af>
{
   14af5:	89 dd                	mov    %ebx,%ebp
   14af7:	89 4c 24 18          	mov    %ecx,0x18(%esp)
   14afb:	89 54 24 14          	mov    %edx,0x14(%esp)
	if (drive>1 || head>15)
   14aff:	83 fb 01             	cmp    $0x1,%ebx
   14b02:	77 05                	ja     14b09 <do_hd_request+0x2cc>
   14b04:	83 fa 0f             	cmp    $0xf,%edx
   14b07:	76 10                	jbe    14b19 <do_hd_request+0x2dc>
		panic("Trying to write bad sector");
   14b09:	83 ec 0c             	sub    $0xc,%esp
   14b0c:	68 ee 95 01 00       	push   $0x195ee
   14b11:	e8 03 38 ff ff       	call   8319 <panic>
   14b16:	83 c4 10             	add    $0x10,%esp
	int retries=10000;
   14b19:	bb 10 27 00 00       	mov    $0x2710,%ebx
   14b1e:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
	while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
   14b23:	4b                   	dec    %ebx
   14b24:	74 15                	je     14b3b <do_hd_request+0x2fe>
   14b26:	89 ca                	mov    %ecx,%edx
   14b28:	ec                   	in     (%dx),%al
   14b29:	eb 00                	jmp    14b2b <do_hd_request+0x2ee>
   14b2b:	eb 00                	jmp    14b2d <do_hd_request+0x2f0>
   14b2d:	25 c0 00 00 00       	and    $0xc0,%eax
   14b32:	83 f8 40             	cmp    $0x40,%eax
   14b35:	75 ec                	jne    14b23 <do_hd_request+0x2e6>
{
   14b37:	85 db                	test   %ebx,%ebx
   14b39:	75 10                	jne    14b4b <do_hd_request+0x30e>
		panic("HD controller not ready");
   14b3b:	83 ec 0c             	sub    $0xc,%esp
   14b3e:	68 09 96 01 00       	push   $0x19609
   14b43:	e8 d1 37 ff ff       	call   8319 <panic>
   14b48:	83 c4 10             	add    $0x10,%esp
	do_hd = intr_addr;
   14b4b:	c7 05 00 0c 02 00 09 	movl   $0x14509,0x20c00
   14b52:	45 01 00 
	outb_p(hd_info[drive].ctl,HD_CMD);
   14b55:	8d 44 6d 00          	lea    0x0(%ebp,%ebp,2),%eax
   14b59:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
   14b60:	8b 8b 34 0c 02 00    	mov    0x20c34(%ebx),%ecx
   14b66:	ba f6 03 00 00       	mov    $0x3f6,%edx
   14b6b:	89 c8                	mov    %ecx,%eax
   14b6d:	ee                   	out    %al,(%dx)
   14b6e:	eb 00                	jmp    14b70 <do_hd_request+0x333>
   14b70:	eb 00                	jmp    14b72 <do_hd_request+0x335>
	outb_p(hd_info[drive].wpcom>>2,++port);
   14b72:	8b 83 2c 0c 02 00    	mov    0x20c2c(%ebx),%eax
   14b78:	c1 f8 02             	sar    $0x2,%eax
   14b7b:	66 ba f1 01          	mov    $0x1f1,%dx
   14b7f:	ee                   	out    %al,(%dx)
   14b80:	eb 00                	jmp    14b82 <do_hd_request+0x345>
   14b82:	eb 00                	jmp    14b84 <do_hd_request+0x347>
	outb_p(nsect,++port);
   14b84:	42                   	inc    %edx
   14b85:	8b 44 24 18          	mov    0x18(%esp),%eax
   14b89:	ee                   	out    %al,(%dx)
   14b8a:	eb 00                	jmp    14b8c <do_hd_request+0x34f>
   14b8c:	eb 00                	jmp    14b8e <do_hd_request+0x351>
	outb_p(sect,++port);
   14b8e:	42                   	inc    %edx
   14b8f:	89 f8                	mov    %edi,%eax
   14b91:	ee                   	out    %al,(%dx)
   14b92:	eb 00                	jmp    14b94 <do_hd_request+0x357>
   14b94:	eb 00                	jmp    14b96 <do_hd_request+0x359>
	outb_p(cyl,++port);
   14b96:	42                   	inc    %edx
   14b97:	89 f0                	mov    %esi,%eax
   14b99:	ee                   	out    %al,(%dx)
   14b9a:	eb 00                	jmp    14b9c <do_hd_request+0x35f>
   14b9c:	eb 00                	jmp    14b9e <do_hd_request+0x361>
	outb_p(cyl>>8,++port);
   14b9e:	c1 e8 08             	shr    $0x8,%eax
   14ba1:	42                   	inc    %edx
   14ba2:	ee                   	out    %al,(%dx)
   14ba3:	eb 00                	jmp    14ba5 <do_hd_request+0x368>
   14ba5:	eb 00                	jmp    14ba7 <do_hd_request+0x36a>
	outb_p(0xA0|(drive<<4)|head,++port);
   14ba7:	89 e8                	mov    %ebp,%eax
   14ba9:	c1 e0 04             	shl    $0x4,%eax
   14bac:	0b 44 24 14          	or     0x14(%esp),%eax
   14bb0:	0c a0                	or     $0xa0,%al
   14bb2:	42                   	inc    %edx
   14bb3:	ee                   	out    %al,(%dx)
   14bb4:	eb 00                	jmp    14bb6 <do_hd_request+0x379>
   14bb6:	eb 00                	jmp    14bb8 <do_hd_request+0x37b>
	outb(cmd,++port);
   14bb8:	42                   	inc    %edx
   14bb9:	b8 30 00 00 00       	mov    $0x30,%eax
   14bbe:	ee                   	out    %al,(%dx)
		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);
		for(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)
   14bbf:	b9 00 00 00 00       	mov    $0x0,%ecx
   14bc4:	ec                   	in     (%dx),%al
   14bc5:	eb 00                	jmp    14bc7 <do_hd_request+0x38a>
   14bc7:	eb 00                	jmp    14bc9 <do_hd_request+0x38c>
   14bc9:	83 e0 08             	and    $0x8,%eax
   14bcc:	0f 85 ff 00 00 00    	jne    14cd1 <do_hd_request+0x494>
   14bd2:	41                   	inc    %ecx
   14bd3:	81 f9 b7 0b 00 00    	cmp    $0xbb7,%ecx
   14bd9:	7f 0f                	jg     14bea <do_hd_request+0x3ad>
   14bdb:	ec                   	in     (%dx),%al
   14bdc:	eb 00                	jmp    14bde <do_hd_request+0x3a1>
   14bde:	eb 00                	jmp    14be0 <do_hd_request+0x3a3>
   14be0:	83 e0 08             	and    $0x8,%eax
   14be3:	74 ed                	je     14bd2 <do_hd_request+0x395>
   14be5:	e9 e7 00 00 00       	jmp    14cd1 <do_hd_request+0x494>
			/* nothing */ ;
		if (!r) {
   14bea:	85 c0                	test   %eax,%eax
   14bec:	0f 85 df 00 00 00    	jne    14cd1 <do_hd_request+0x494>
	if (++CURRENT->errors >= MAX_ERRORS)
   14bf2:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14bf7:	ff 40 08             	incl   0x8(%eax)
   14bfa:	83 78 08 06          	cmpl   $0x6,0x8(%eax)
   14bfe:	0f 8e af 00 00 00    	jle    14cb3 <do_hd_request+0x476>
	if (CURRENT->bh) {
   14c04:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14c09:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14c0d:	74 38                	je     14c47 <do_hd_request+0x40a>
		CURRENT->bh->b_uptodate = uptodate;
   14c0f:	8b 40 1c             	mov    0x1c(%eax),%eax
   14c12:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   14c16:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14c1b:	8b 58 1c             	mov    0x1c(%eax),%ebx
	if (!bh->b_lock)
   14c1e:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   14c22:	75 10                	jne    14c34 <do_hd_request+0x3f7>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   14c24:	83 ec 0c             	sub    $0xc,%esp
   14c27:	68 58 95 01 00       	push   $0x19558
   14c2c:	e8 22 37 ff ff       	call   8353 <printk>
   14c31:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   14c34:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   14c38:	83 ec 0c             	sub    $0xc,%esp
   14c3b:	8d 43 10             	lea    0x10(%ebx),%eax
   14c3e:	50                   	push   %eax
   14c3f:	e8 5f 23 ff ff       	call   6fa3 <wake_up>
   14c44:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   14c47:	b8 00 00 00 00       	mov    $0x0,%eax
   14c4c:	85 c0                	test   %eax,%eax
   14c4e:	75 2b                	jne    14c7b <do_hd_request+0x43e>
		printk(DEVICE_NAME " I/O error\n\r");
   14c50:	83 ec 0c             	sub    $0xc,%esp
   14c53:	68 3b 96 01 00       	push   $0x1963b
   14c58:	e8 f6 36 ff ff       	call   8353 <printk>
   14c5d:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   14c60:	8b 15 bc 0b 02 00    	mov    0x20bbc,%edx
   14c66:	8b 42 1c             	mov    0x1c(%edx),%eax
   14c69:	ff 70 04             	pushl  0x4(%eax)
   14c6c:	ff 32                	pushl  (%edx)
   14c6e:	68 4a 94 01 00       	push   $0x1944a
   14c73:	e8 db 36 ff ff       	call   8353 <printk>
   14c78:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   14c7b:	83 ec 0c             	sub    $0xc,%esp
   14c7e:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14c83:	83 c0 18             	add    $0x18,%eax
   14c86:	50                   	push   %eax
   14c87:	e8 17 23 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   14c8c:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   14c93:	e8 0b 23 ff ff       	call   6fa3 <wake_up>
   14c98:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   14c9b:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14ca0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   14ca6:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14cab:	8b 40 20             	mov    0x20(%eax),%eax
   14cae:	a3 bc 0b 02 00       	mov    %eax,0x20bbc
	if (CURRENT->errors > MAX_ERRORS/2)
   14cb3:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14cb8:	83 78 08 03          	cmpl   $0x3,0x8(%eax)
   14cbc:	0f 8e 82 fb ff ff    	jle    14844 <do_hd_request+0x7>
		reset = 1;
   14cc2:	c7 05 14 bf 01 00 01 	movl   $0x1,0x1bf14
   14cc9:	00 00 00 
			bad_rw_intr();
			goto repeat;
   14ccc:	e9 73 fb ff ff       	jmp    14844 <do_hd_request+0x7>
		}
		port_write(HD_DATA,CURRENT->buffer,256);
   14cd1:	ba f0 01 00 00       	mov    $0x1f0,%edx
   14cd6:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14cdb:	8b 70 14             	mov    0x14(%eax),%esi
   14cde:	b9 00 01 00 00       	mov    $0x100,%ecx
   14ce3:	fc                   	cld    
   14ce4:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
   14ce7:	e9 f2 00 00 00       	jmp    14dde <do_hd_request+0x5a1>
	} else if (CURRENT->cmd == READ) {
   14cec:	a1 bc 0b 02 00       	mov    0x20bbc,%eax
   14cf1:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   14cf5:	0f 85 d3 00 00 00    	jne    14dce <do_hd_request+0x591>
{
   14cfb:	89 cd                	mov    %ecx,%ebp
   14cfd:	89 54 24 10          	mov    %edx,0x10(%esp)
	if (drive>1 || head>15)
   14d01:	83 fb 01             	cmp    $0x1,%ebx
   14d04:	77 05                	ja     14d0b <do_hd_request+0x4ce>
   14d06:	83 fa 0f             	cmp    $0xf,%edx
   14d09:	76 10                	jbe    14d1b <do_hd_request+0x4de>
		panic("Trying to write bad sector");
   14d0b:	83 ec 0c             	sub    $0xc,%esp
   14d0e:	68 ee 95 01 00       	push   $0x195ee
   14d13:	e8 01 36 ff ff       	call   8319 <panic>
   14d18:	83 c4 10             	add    $0x10,%esp
	int retries=10000;
   14d1b:	c7 44 24 0c 10 27 00 	movl   $0x2710,0xc(%esp)
   14d22:	00 
   14d23:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
	while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
   14d28:	ff 4c 24 0c          	decl   0xc(%esp)
   14d2c:	74 18                	je     14d46 <do_hd_request+0x509>
   14d2e:	89 ca                	mov    %ecx,%edx
   14d30:	ec                   	in     (%dx),%al
   14d31:	eb 00                	jmp    14d33 <do_hd_request+0x4f6>
   14d33:	eb 00                	jmp    14d35 <do_hd_request+0x4f8>
   14d35:	25 c0 00 00 00       	and    $0xc0,%eax
   14d3a:	83 f8 40             	cmp    $0x40,%eax
   14d3d:	75 e9                	jne    14d28 <do_hd_request+0x4eb>
{
   14d3f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   14d44:	75 10                	jne    14d56 <do_hd_request+0x519>
		panic("HD controller not ready");
   14d46:	83 ec 0c             	sub    $0xc,%esp
   14d49:	68 09 96 01 00       	push   $0x19609
   14d4e:	e8 c6 35 ff ff       	call   8319 <panic>
   14d53:	83 c4 10             	add    $0x10,%esp
	do_hd = intr_addr;
   14d56:	c7 05 00 0c 02 00 e8 	movl   $0x142e8,0x20c00
   14d5d:	42 01 00 
	outb_p(hd_info[drive].ctl,HD_CMD);
   14d60:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
   14d63:	c1 e0 03             	shl    $0x3,%eax
   14d66:	89 44 24 08          	mov    %eax,0x8(%esp)
   14d6a:	8b 88 34 0c 02 00    	mov    0x20c34(%eax),%ecx
   14d70:	ba f6 03 00 00       	mov    $0x3f6,%edx
   14d75:	89 c8                	mov    %ecx,%eax
   14d77:	ee                   	out    %al,(%dx)
   14d78:	eb 00                	jmp    14d7a <do_hd_request+0x53d>
   14d7a:	eb 00                	jmp    14d7c <do_hd_request+0x53f>
	outb_p(hd_info[drive].wpcom>>2,++port);
   14d7c:	8b 54 24 08          	mov    0x8(%esp),%edx
   14d80:	8b 82 2c 0c 02 00    	mov    0x20c2c(%edx),%eax
   14d86:	c1 f8 02             	sar    $0x2,%eax
   14d89:	ba f1 01 00 00       	mov    $0x1f1,%edx
   14d8e:	ee                   	out    %al,(%dx)
   14d8f:	eb 00                	jmp    14d91 <do_hd_request+0x554>
   14d91:	eb 00                	jmp    14d93 <do_hd_request+0x556>
	outb_p(nsect,++port);
   14d93:	42                   	inc    %edx
   14d94:	89 e8                	mov    %ebp,%eax
   14d96:	ee                   	out    %al,(%dx)
   14d97:	eb 00                	jmp    14d99 <do_hd_request+0x55c>
   14d99:	eb 00                	jmp    14d9b <do_hd_request+0x55e>
	outb_p(sect,++port);
   14d9b:	42                   	inc    %edx
   14d9c:	89 f8                	mov    %edi,%eax
   14d9e:	ee                   	out    %al,(%dx)
   14d9f:	eb 00                	jmp    14da1 <do_hd_request+0x564>
   14da1:	eb 00                	jmp    14da3 <do_hd_request+0x566>
	outb_p(cyl,++port);
   14da3:	42                   	inc    %edx
   14da4:	89 f0                	mov    %esi,%eax
   14da6:	ee                   	out    %al,(%dx)
   14da7:	eb 00                	jmp    14da9 <do_hd_request+0x56c>
   14da9:	eb 00                	jmp    14dab <do_hd_request+0x56e>
	outb_p(cyl>>8,++port);
   14dab:	c1 e8 08             	shr    $0x8,%eax
   14dae:	42                   	inc    %edx
   14daf:	ee                   	out    %al,(%dx)
   14db0:	eb 00                	jmp    14db2 <do_hd_request+0x575>
   14db2:	eb 00                	jmp    14db4 <do_hd_request+0x577>
	outb_p(0xA0|(drive<<4)|head,++port);
   14db4:	89 d8                	mov    %ebx,%eax
   14db6:	c1 e0 04             	shl    $0x4,%eax
   14db9:	0b 44 24 10          	or     0x10(%esp),%eax
   14dbd:	0c a0                	or     $0xa0,%al
   14dbf:	42                   	inc    %edx
   14dc0:	ee                   	out    %al,(%dx)
   14dc1:	eb 00                	jmp    14dc3 <do_hd_request+0x586>
   14dc3:	eb 00                	jmp    14dc5 <do_hd_request+0x588>
	outb(cmd,++port);
   14dc5:	42                   	inc    %edx
   14dc6:	b8 20 00 00 00       	mov    $0x20,%eax
   14dcb:	ee                   	out    %al,(%dx)
   14dcc:	eb 10                	jmp    14dde <do_hd_request+0x5a1>
		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
	} else
		panic("unknown hd-command");
   14dce:	83 ec 0c             	sub    $0xc,%esp
   14dd1:	68 6b 96 01 00       	push   $0x1966b
   14dd6:	e8 3e 35 ff ff       	call   8319 <panic>
   14ddb:	83 c4 10             	add    $0x10,%esp
}
   14dde:	83 c4 1c             	add    $0x1c,%esp
   14de1:	5b                   	pop    %ebx
   14de2:	5e                   	pop    %esi
   14de3:	5f                   	pop    %edi
   14de4:	5d                   	pop    %ebp
   14de5:	c3                   	ret    

00014de6 <hd_init>:

void hd_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   14de6:	c7 05 b8 0b 02 00 3d 	movl   $0x1483d,0x20bb8
   14ded:	48 01 00 
	set_intr_gate(0x2E,&hd_interrupt);
   14df0:	ba a0 77 00 00       	mov    $0x77a0,%edx
   14df5:	b8 00 00 08 00       	mov    $0x80000,%eax
   14dfa:	66 89 d0             	mov    %dx,%ax
   14dfd:	66 ba 00 8e          	mov    $0x8e00,%dx
   14e01:	a3 28 56 00 00       	mov    %eax,0x5628
   14e06:	89 15 2c 56 00 00    	mov    %edx,0x562c
	outb_p(inb_p(0x21)&0xfb,0x21);
   14e0c:	ba 21 00 00 00       	mov    $0x21,%edx
   14e11:	ec                   	in     (%dx),%al
   14e12:	eb 00                	jmp    14e14 <hd_init+0x2e>
   14e14:	eb 00                	jmp    14e16 <hd_init+0x30>
   14e16:	25 fb 00 00 00       	and    $0xfb,%eax
   14e1b:	ee                   	out    %al,(%dx)
   14e1c:	eb 00                	jmp    14e1e <hd_init+0x38>
   14e1e:	eb 00                	jmp    14e20 <hd_init+0x3a>
	outb(inb_p(0xA1)&0xbf,0xA1);
   14e20:	b2 a1                	mov    $0xa1,%dl
   14e22:	ec                   	in     (%dx),%al
   14e23:	eb 00                	jmp    14e25 <hd_init+0x3f>
   14e25:	eb 00                	jmp    14e27 <hd_init+0x41>
   14e27:	25 bf 00 00 00       	and    $0xbf,%eax
   14e2c:	ee                   	out    %al,(%dx)
}
   14e2d:	c3                   	ret    

00014e2e <do_rd_request>:

char	*rd_start;
int	rd_length = 0;

void do_rd_request(void)
{
   14e2e:	55                   	push   %ebp
   14e2f:	57                   	push   %edi
   14e30:	56                   	push   %esi
   14e31:	53                   	push   %ebx
   14e32:	83 ec 0c             	sub    $0xc,%esp
	int	len;
	char	*addr;

	INIT_REQUEST;
   14e35:	83 3d ac 0b 02 00 00 	cmpl   $0x0,0x20bac
   14e3c:	0f 84 21 02 00 00    	je     15063 <do_rd_request+0x235>
   14e42:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14e47:	8b 00                	mov    (%eax),%eax
   14e49:	c1 e8 08             	shr    $0x8,%eax
   14e4c:	83 f8 01             	cmp    $0x1,%eax
   14e4f:	74 10                	je     14e61 <do_rd_request+0x33>
   14e51:	83 ec 0c             	sub    $0xc,%esp
   14e54:	68 80 96 01 00       	push   $0x19680
   14e59:	e8 bb 34 ff ff       	call   8319 <panic>
   14e5e:	83 c4 10             	add    $0x10,%esp
   14e61:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14e66:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14e6a:	74 19                	je     14e85 <do_rd_request+0x57>
   14e6c:	8b 40 1c             	mov    0x1c(%eax),%eax
   14e6f:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   14e73:	75 10                	jne    14e85 <do_rd_request+0x57>
   14e75:	83 ec 0c             	sub    $0xc,%esp
   14e78:	68 98 97 01 00       	push   $0x19798
   14e7d:	e8 97 34 ff ff       	call   8319 <panic>
   14e82:	83 c4 10             	add    $0x10,%esp
	addr = rd_start + (CURRENT->sector << 9);
   14e85:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14e8a:	8b 50 0c             	mov    0xc(%eax),%edx
   14e8d:	89 d5                	mov    %edx,%ebp
   14e8f:	c1 e5 09             	shl    $0x9,%ebp
   14e92:	8b 0d 60 2e 02 00    	mov    0x22e60,%ecx
   14e98:	01 cd                	add    %ecx,%ebp
	len = CURRENT->nr_sectors << 9;
   14e9a:	8b 50 10             	mov    0x10(%eax),%edx
   14e9d:	89 d3                	mov    %edx,%ebx
   14e9f:	c1 e3 09             	shl    $0x9,%ebx
	if ((MINOR(CURRENT->dev) != 1) || (addr+len > rd_start+rd_length)) {
   14ea2:	80 38 01             	cmpb   $0x1,(%eax)
   14ea5:	75 14                	jne    14ebb <do_rd_request+0x8d>
   14ea7:	8d 54 1d 00          	lea    0x0(%ebp,%ebx,1),%edx
   14eab:	89 c8                	mov    %ecx,%eax
   14ead:	03 05 b0 0c 02 00    	add    0x20cb0,%eax
   14eb3:	39 c2                	cmp    %eax,%edx
   14eb5:	0f 86 b4 00 00 00    	jbe    14f6f <do_rd_request+0x141>
	if (CURRENT->bh) {
   14ebb:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14ec0:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14ec4:	74 38                	je     14efe <do_rd_request+0xd0>
		CURRENT->bh->b_uptodate = uptodate;
   14ec6:	8b 40 1c             	mov    0x1c(%eax),%eax
   14ec9:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
{
   14ecd:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14ed2:	8b 70 1c             	mov    0x1c(%eax),%esi
	if (!bh->b_lock)
   14ed5:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   14ed9:	75 10                	jne    14eeb <do_rd_request+0xbd>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   14edb:	83 ec 0c             	sub    $0xc,%esp
   14ede:	68 a0 96 01 00       	push   $0x196a0
   14ee3:	e8 6b 34 ff ff       	call   8353 <printk>
   14ee8:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   14eeb:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	wake_up(&bh->b_wait);
   14eef:	83 ec 0c             	sub    $0xc,%esp
   14ef2:	8d 46 10             	lea    0x10(%esi),%eax
   14ef5:	50                   	push   %eax
   14ef6:	e8 a8 20 ff ff       	call   6fa3 <wake_up>
   14efb:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   14efe:	b8 00 00 00 00       	mov    $0x0,%eax
   14f03:	85 c0                	test   %eax,%eax
   14f05:	75 2b                	jne    14f32 <do_rd_request+0x104>
		printk(DEVICE_NAME " I/O error\n\r");
   14f07:	83 ec 0c             	sub    $0xc,%esp
   14f0a:	68 b2 97 01 00       	push   $0x197b2
   14f0f:	e8 3f 34 ff ff       	call   8353 <printk>
   14f14:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   14f17:	8b 15 ac 0b 02 00    	mov    0x20bac,%edx
   14f1d:	8b 42 1c             	mov    0x1c(%edx),%eax
   14f20:	ff 70 04             	pushl  0x4(%eax)
   14f23:	ff 32                	pushl  (%edx)
   14f25:	68 4a 94 01 00       	push   $0x1944a
   14f2a:	e8 24 34 ff ff       	call   8353 <printk>
   14f2f:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   14f32:	83 ec 0c             	sub    $0xc,%esp
   14f35:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14f3a:	83 c0 18             	add    $0x18,%eax
   14f3d:	50                   	push   %eax
   14f3e:	e8 60 20 ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   14f43:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   14f4a:	e8 54 20 ff ff       	call   6fa3 <wake_up>
   14f4f:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   14f52:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14f57:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   14f5d:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14f62:	8b 40 20             	mov    0x20(%eax),%eax
   14f65:	a3 ac 0b 02 00       	mov    %eax,0x20bac
		end_request(0);
		goto repeat;
   14f6a:	e9 c6 fe ff ff       	jmp    14e35 <do_rd_request+0x7>
	}
	if (CURRENT-> cmd == WRITE) {
   14f6f:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14f74:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   14f78:	75 0e                	jne    14f88 <do_rd_request+0x15a>
		(void ) memcpy(addr,
   14f7a:	8b 40 14             	mov    0x14(%eax),%eax
   14f7d:	89 ef                	mov    %ebp,%edi
   14f7f:	89 c6                	mov    %eax,%esi
   14f81:	89 d9                	mov    %ebx,%ecx
   14f83:	fc                   	cld    
   14f84:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   14f86:	eb 27                	jmp    14faf <do_rd_request+0x181>
			      CURRENT->buffer,
			      len);
	} else if (CURRENT->cmd == READ) {
   14f88:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14f8d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   14f91:	75 0c                	jne    14f9f <do_rd_request+0x171>
		(void) memcpy(CURRENT->buffer, 
   14f93:	8b 78 14             	mov    0x14(%eax),%edi
   14f96:	89 ee                	mov    %ebp,%esi
   14f98:	89 d9                	mov    %ebx,%ecx
   14f9a:	fc                   	cld    
   14f9b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   14f9d:	eb 10                	jmp    14faf <do_rd_request+0x181>
			      addr,
			      len);
	} else
		panic("unknown ramdisk-command");
   14f9f:	83 ec 0c             	sub    $0xc,%esp
   14fa2:	68 c6 97 01 00       	push   $0x197c6
   14fa7:	e8 6d 33 ff ff       	call   8319 <panic>
   14fac:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->bh) {
   14faf:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14fb4:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   14fb8:	74 38                	je     14ff2 <do_rd_request+0x1c4>
		CURRENT->bh->b_uptodate = uptodate;
   14fba:	8b 40 1c             	mov    0x1c(%eax),%eax
   14fbd:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
{
   14fc1:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   14fc6:	8b 58 1c             	mov    0x1c(%eax),%ebx
	if (!bh->b_lock)
   14fc9:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
   14fcd:	75 10                	jne    14fdf <do_rd_request+0x1b1>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   14fcf:	83 ec 0c             	sub    $0xc,%esp
   14fd2:	68 a0 96 01 00       	push   $0x196a0
   14fd7:	e8 77 33 ff ff       	call   8353 <printk>
   14fdc:	83 c4 10             	add    $0x10,%esp
	bh->b_lock=0;
   14fdf:	c6 43 0d 00          	movb   $0x0,0xd(%ebx)
	wake_up(&bh->b_wait);
   14fe3:	83 ec 0c             	sub    $0xc,%esp
   14fe6:	8d 43 10             	lea    0x10(%ebx),%eax
   14fe9:	50                   	push   %eax
   14fea:	e8 b4 1f ff ff       	call   6fa3 <wake_up>
   14fef:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {
   14ff2:	b8 01 00 00 00       	mov    $0x1,%eax
   14ff7:	85 c0                	test   %eax,%eax
   14ff9:	75 2b                	jne    15026 <do_rd_request+0x1f8>
		printk(DEVICE_NAME " I/O error\n\r");
   14ffb:	83 ec 0c             	sub    $0xc,%esp
   14ffe:	68 b2 97 01 00       	push   $0x197b2
   15003:	e8 4b 33 ff ff       	call   8353 <printk>
   15008:	83 c4 0c             	add    $0xc,%esp
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   1500b:	8b 15 ac 0b 02 00    	mov    0x20bac,%edx
   15011:	8b 42 1c             	mov    0x1c(%edx),%eax
   15014:	ff 70 04             	pushl  0x4(%eax)
   15017:	ff 32                	pushl  (%edx)
   15019:	68 4a 94 01 00       	push   $0x1944a
   1501e:	e8 30 33 ff ff       	call   8353 <printk>
   15023:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);
   15026:	83 ec 0c             	sub    $0xc,%esp
   15029:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   1502e:	83 c0 18             	add    $0x18,%eax
   15031:	50                   	push   %eax
   15032:	e8 6c 1f ff ff       	call   6fa3 <wake_up>
	wake_up(&wait_for_request);
   15037:	c7 04 24 80 0b 02 00 	movl   $0x20b80,(%esp)
   1503e:	e8 60 1f ff ff       	call   6fa3 <wake_up>
   15043:	83 c4 10             	add    $0x10,%esp
	CURRENT->dev = -1;
   15046:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   1504b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;
   15051:	a1 ac 0b 02 00       	mov    0x20bac,%eax
   15056:	8b 40 20             	mov    0x20(%eax),%eax
   15059:	a3 ac 0b 02 00       	mov    %eax,0x20bac
	end_request(1);
	goto repeat;
   1505e:	e9 d2 fd ff ff       	jmp    14e35 <do_rd_request+0x7>
}
   15063:	83 c4 0c             	add    $0xc,%esp
   15066:	5b                   	pop    %ebx
   15067:	5e                   	pop    %esi
   15068:	5f                   	pop    %edi
   15069:	5d                   	pop    %ebp
   1506a:	c3                   	ret    

0001506b <rd_init>:

/*
 * Returns amount of memory which needs to be reserved.
 */
long rd_init(long mem_start, int length)
{
   1506b:	8b 44 24 04          	mov    0x4(%esp),%eax
   1506f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	int	i;
	char	*cp;

	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   15073:	c7 05 a8 0b 02 00 2e 	movl   $0x14e2e,0x20ba8
   1507a:	4e 01 00 
	rd_start = (char *) mem_start;
   1507d:	a3 60 2e 02 00       	mov    %eax,0x22e60
	rd_length = length;
   15082:	89 0d b0 0c 02 00    	mov    %ecx,0x20cb0
	cp = rd_start;
	for (i=0; i < length; i++)
   15088:	ba 00 00 00 00       	mov    $0x0,%edx
   1508d:	39 ca                	cmp    %ecx,%edx
   1508f:	7d 09                	jge    1509a <rd_init+0x2f>
		*cp++ = '\0';
   15091:	c6 00 00             	movb   $0x0,(%eax)
   15094:	40                   	inc    %eax
	for (i=0; i < length; i++)
   15095:	42                   	inc    %edx
   15096:	39 ca                	cmp    %ecx,%edx
   15098:	7c f7                	jl     15091 <rd_init+0x26>
	return(length);
}
   1509a:	89 c8                	mov    %ecx,%eax
   1509c:	c3                   	ret    

0001509d <rd_load>:
 * If the root device is the ram disk, try to load it.
 * In order to do this, the root device is originally set to the
 * floppy, and we later change it to be ram disk.
 */
void rd_load(void)
{
   1509d:	55                   	push   %ebp
   1509e:	57                   	push   %edi
   1509f:	56                   	push   %esi
   150a0:	53                   	push   %ebx
   150a1:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	struct buffer_head *bh;
	struct super_block	s;
	int		block = 256;	/* Start at block 256 */
   150a7:	bb 00 01 00 00       	mov    $0x100,%ebx
	int		i = 1;
   150ac:	bd 01 00 00 00       	mov    $0x1,%ebp
	int		nblocks;
	char		*cp;		/* Move pointer */
	
	if (!rd_length)
   150b1:	83 3d b0 0c 02 00 00 	cmpl   $0x0,0x20cb0
   150b8:	0f 84 93 01 00 00    	je     15251 <rd_load+0x1b4>
		return;
	printk("Ram disk: %d bytes, starting at 0x%x\n", rd_length,
   150be:	83 ec 04             	sub    $0x4,%esp
   150c1:	ff 35 60 2e 02 00    	pushl  0x22e60
   150c7:	ff 35 b0 0c 02 00    	pushl  0x20cb0
   150cd:	68 c8 96 01 00       	push   $0x196c8
   150d2:	e8 7c 32 ff ff       	call   8353 <printk>
		(int) rd_start);
	if (MAJOR(ROOT_DEV) != 2)
   150d7:	8b 15 6c 0b 02 00    	mov    0x20b6c,%edx
   150dd:	89 d0                	mov    %edx,%eax
   150df:	c1 e8 08             	shr    $0x8,%eax
   150e2:	83 c4 10             	add    $0x10,%esp
   150e5:	83 f8 02             	cmp    $0x2,%eax
   150e8:	0f 85 63 01 00 00    	jne    15251 <rd_load+0x1b4>
		return;
	bh = breada(ROOT_DEV,block+1,block,block+2,-1);
   150ee:	83 ec 0c             	sub    $0xc,%esp
   150f1:	6a ff                	push   $0xffffffff
   150f3:	68 02 01 00 00       	push   $0x102
   150f8:	68 00 01 00 00       	push   $0x100
   150fd:	68 01 01 00 00       	push   $0x101
   15102:	52                   	push   %edx
   15103:	e8 a9 77 ff ff       	call   c8b1 <breada>
	if (!bh) {
   15108:	83 c4 20             	add    $0x20,%esp
   1510b:	85 c0                	test   %eax,%eax
   1510d:	75 15                	jne    15124 <rd_load+0x87>
		printk("Disk error while looking for ramdisk!\n");
   1510f:	83 ec 0c             	sub    $0xc,%esp
   15112:	68 f0 96 01 00       	push   $0x196f0
   15117:	e8 37 32 ff ff       	call   8353 <printk>
		return;
   1511c:	83 c4 10             	add    $0x10,%esp
   1511f:	e9 2d 01 00 00       	jmp    15251 <rd_load+0x1b4>
	}
	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
   15124:	8b 30                	mov    (%eax),%esi
   15126:	8d 7c 24 20          	lea    0x20(%esp),%edi
   1512a:	fc                   	cld    
   1512b:	b9 05 00 00 00       	mov    $0x5,%ecx
   15130:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	brelse(bh);
   15132:	83 ec 0c             	sub    $0xc,%esp
   15135:	50                   	push   %eax
   15136:	e8 7c 75 ff ff       	call   c6b7 <brelse>
	if (s.s_magic != SUPER_MAGIC)
   1513b:	83 c4 10             	add    $0x10,%esp
   1513e:	66 81 7c 24 30 7f 13 	cmpw   $0x137f,0x30(%esp)
   15145:	0f 85 06 01 00 00    	jne    15251 <rd_load+0x1b4>
		/* No ram disk image present, assume normal floppy boot */
		return;
	nblocks = s.s_nzones << s.s_log_zone_size;
   1514b:	0f b7 44 24 22       	movzwl 0x22(%esp),%eax
   15150:	0f b7 4c 24 2a       	movzwl 0x2a(%esp),%ecx
   15155:	d3 e0                	shl    %cl,%eax
   15157:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
   1515b:	a1 b0 0c 02 00       	mov    0x20cb0,%eax
   15160:	c1 f8 0a             	sar    $0xa,%eax
   15163:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   15167:	7d 30                	jge    15199 <rd_load+0xfc>
		printk("Ram disk image too big!  (%d blocks, %d avail)\n", 
   15169:	83 ec 04             	sub    $0x4,%esp
   1516c:	50                   	push   %eax
   1516d:	ff 74 24 14          	pushl  0x14(%esp)
   15171:	68 18 97 01 00       	push   $0x19718
   15176:	e8 d8 31 ff ff       	call   8353 <printk>
			nblocks, rd_length >> BLOCK_SIZE_BITS);
		return;
   1517b:	83 c4 10             	add    $0x10,%esp
   1517e:	e9 ce 00 00 00       	jmp    15251 <rd_load+0x1b4>
		if (nblocks > 2) 
			bh = breada(ROOT_DEV, block, block+1, block+2, -1);
		else
			bh = bread(ROOT_DEV, block);
		if (!bh) {
			printk("I/O error on block %d, aborting load\n", 
   15183:	83 ec 08             	sub    $0x8,%esp
   15186:	53                   	push   %ebx
   15187:	68 48 97 01 00       	push   $0x19748
   1518c:	e8 c2 31 ff ff       	call   8353 <printk>
				block);
			return;
   15191:	83 c4 10             	add    $0x10,%esp
   15194:	e9 b8 00 00 00       	jmp    15251 <rd_load+0x1b4>
	printk("Loading %d bytes into ram disk... 0000k", 
   15199:	83 ec 08             	sub    $0x8,%esp
   1519c:	8b 44 24 14          	mov    0x14(%esp),%eax
   151a0:	c1 e0 0a             	shl    $0xa,%eax
   151a3:	50                   	push   %eax
   151a4:	68 70 97 01 00       	push   $0x19770
   151a9:	e8 a5 31 ff ff       	call   8353 <printk>
	cp = rd_start;
   151ae:	8b 3d 60 2e 02 00    	mov    0x22e60,%edi
   151b4:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
	while (nblocks) {
   151b8:	83 c4 10             	add    $0x10,%esp
		brelse(bh);
		printk("\010\010\010\010\010%4dk",i);
		cp += BLOCK_SIZE;
		block++;
		nblocks--;
		i++;
   151bb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   151c0:	74 75                	je     15237 <rd_load+0x19a>
		if (nblocks > 2) 
   151c2:	83 7c 24 0c 02       	cmpl   $0x2,0xc(%esp)
   151c7:	7e 1e                	jle    151e7 <rd_load+0x14a>
			bh = breada(ROOT_DEV, block, block+1, block+2, -1);
   151c9:	83 ec 0c             	sub    $0xc,%esp
   151cc:	6a ff                	push   $0xffffffff
   151ce:	8d 43 02             	lea    0x2(%ebx),%eax
   151d1:	50                   	push   %eax
   151d2:	8d 43 01             	lea    0x1(%ebx),%eax
   151d5:	50                   	push   %eax
   151d6:	53                   	push   %ebx
   151d7:	ff 35 6c 0b 02 00    	pushl  0x20b6c
   151dd:	e8 cf 76 ff ff       	call   c8b1 <breada>
   151e2:	83 c4 20             	add    $0x20,%esp
   151e5:	eb 12                	jmp    151f9 <rd_load+0x15c>
			bh = bread(ROOT_DEV, block);
   151e7:	83 ec 08             	sub    $0x8,%esp
   151ea:	53                   	push   %ebx
   151eb:	ff 35 6c 0b 02 00    	pushl  0x20b6c
   151f1:	e8 0d 75 ff ff       	call   c703 <bread>
   151f6:	83 c4 10             	add    $0x10,%esp
		if (!bh) {
   151f9:	85 c0                	test   %eax,%eax
   151fb:	74 86                	je     15183 <rd_load+0xe6>
		(void) memcpy(cp, bh->b_data, BLOCK_SIZE);
   151fd:	8b 30                	mov    (%eax),%esi
   151ff:	b9 00 04 00 00       	mov    $0x400,%ecx
   15204:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
   15208:	fc                   	cld    
   15209:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		brelse(bh);
   1520b:	83 ec 0c             	sub    $0xc,%esp
   1520e:	50                   	push   %eax
   1520f:	e8 a3 74 ff ff       	call   c6b7 <brelse>
		printk("\010\010\010\010\010%4dk",i);
   15214:	83 c4 08             	add    $0x8,%esp
   15217:	55                   	push   %ebp
   15218:	68 de 97 01 00       	push   $0x197de
   1521d:	e8 31 31 ff ff       	call   8353 <printk>
		cp += BLOCK_SIZE;
   15222:	81 c7 00 04 00 00    	add    $0x400,%edi
   15228:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
		block++;
   1522c:	43                   	inc    %ebx
		i++;
   1522d:	45                   	inc    %ebp
   1522e:	83 c4 10             	add    $0x10,%esp
   15231:	ff 4c 24 0c          	decl   0xc(%esp)
   15235:	75 8b                	jne    151c2 <rd_load+0x125>
	}
	printk("\010\010\010\010\010done \n");
   15237:	83 ec 0c             	sub    $0xc,%esp
   1523a:	68 e8 97 01 00       	push   $0x197e8
   1523f:	e8 0f 31 ff ff       	call   8353 <printk>
	ROOT_DEV=0x0101;
   15244:	c7 05 6c 0b 02 00 01 	movl   $0x101,0x20b6c
   1524b:	01 00 00 
   1524e:	83 c4 10             	add    $0x10,%esp
}
   15251:	81 c4 9c 00 00 00    	add    $0x9c,%esp
   15257:	5b                   	pop    %ebx
   15258:	5e                   	pop    %esi
   15259:	5f                   	pop    %edi
   1525a:	5d                   	pop    %ebp
   1525b:	c3                   	ret    

0001525c <tty_init>:
	&tty_table[1].read_q, &tty_table[1].write_q,
	&tty_table[2].read_q, &tty_table[2].write_q
	};

void tty_init(void)
{
   1525c:	83 ec 0c             	sub    $0xc,%esp
	rs_init();
   1525f:	e8 7e 2a 00 00       	call   17ce2 <rs_init>
	con_init();
   15264:	e8 93 20 00 00       	call   172fc <con_init>
}
   15269:	83 c4 0c             	add    $0xc,%esp
   1526c:	c3                   	ret    

0001526d <tty_intr>:

void tty_intr(struct tty_struct * tty, int mask)
{
   1526d:	57                   	push   %edi
   1526e:	56                   	push   %esi
   1526f:	53                   	push   %ebx
   15270:	8b 74 24 10          	mov    0x10(%esp),%esi
   15274:	8b 7c 24 14          	mov    0x14(%esp),%edi
	int i;

	if (tty->pgrp <= 0)
   15278:	83 7e 24 00          	cmpl   $0x0,0x24(%esi)
   1527c:	7e 27                	jle    152a5 <tty_intr+0x38>
		return;
	for (i=0;i<NR_TASKS;i++)
   1527e:	b9 00 00 00 00       	mov    $0x0,%ecx
   15283:	bb 40 bc 01 00       	mov    $0x1bc40,%ebx
		if (task[i] && task[i]->pgrp==tty->pgrp)
   15288:	83 3c 8b 00          	cmpl   $0x0,(%ebx,%ecx,4)
   1528c:	74 11                	je     1529f <tty_intr+0x32>
   1528e:	8b 14 8b             	mov    (%ebx,%ecx,4),%edx
   15291:	8b 82 34 02 00 00    	mov    0x234(%edx),%eax
   15297:	3b 46 24             	cmp    0x24(%esi),%eax
   1529a:	75 03                	jne    1529f <tty_intr+0x32>
			task[i]->signal |= mask;
   1529c:	09 7a 0c             	or     %edi,0xc(%edx)
	for (i=0;i<NR_TASKS;i++)
   1529f:	41                   	inc    %ecx
   152a0:	83 f9 3f             	cmp    $0x3f,%ecx
   152a3:	7e e3                	jle    15288 <tty_intr+0x1b>
}
   152a5:	5b                   	pop    %ebx
   152a6:	5e                   	pop    %esi
   152a7:	5f                   	pop    %edi
   152a8:	c3                   	ret    

000152a9 <wait_for_keypress>:
		interruptible_sleep_on(&queue->proc_list);
	sti();
}

void wait_for_keypress(void)
{
   152a9:	56                   	push   %esi
   152aa:	53                   	push   %ebx
   152ab:	83 ec 04             	sub    $0x4,%esp
{
   152ae:	bb 70 c7 01 00       	mov    $0x1c770,%ebx
	cli();
   152b3:	fa                   	cli    
		interruptible_sleep_on(&queue->proc_list);
   152b4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   152b9:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   152bd:	75 2f                	jne    152ee <wait_for_keypress+0x45>
   152bf:	a1 74 c7 01 00       	mov    0x1c774,%eax
   152c4:	3b 05 78 c7 01 00    	cmp    0x1c778,%eax
   152ca:	75 22                	jne    152ee <wait_for_keypress+0x45>
   152cc:	8d 73 0c             	lea    0xc(%ebx),%esi
   152cf:	83 ec 0c             	sub    $0xc,%esp
   152d2:	56                   	push   %esi
   152d3:	e8 3b 1b ff ff       	call   6e13 <interruptible_sleep_on>
   152d8:	83 c4 10             	add    $0x10,%esp
   152db:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   152e0:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   152e4:	75 08                	jne    152ee <wait_for_keypress+0x45>
   152e6:	8b 43 04             	mov    0x4(%ebx),%eax
   152e9:	3b 43 08             	cmp    0x8(%ebx),%eax
   152ec:	74 e1                	je     152cf <wait_for_keypress+0x26>
	sti();
   152ee:	fb                   	sti    
	sleep_if_empty(&tty_table[0].secondary);
}
   152ef:	83 c4 04             	add    $0x4,%esp
   152f2:	5b                   	pop    %ebx
   152f3:	5e                   	pop    %esi
   152f4:	c3                   	ret    

000152f5 <copy_to_cooked>:

void copy_to_cooked(struct tty_struct * tty)
{
   152f5:	55                   	push   %ebp
   152f6:	57                   	push   %edi
   152f7:	56                   	push   %esi
   152f8:	53                   	push   %ebx
   152f9:	83 ec 0c             	sub    $0xc,%esp
   152fc:	8b 74 24 20          	mov    0x20(%esp),%esi
				}
			} else
				PUTCH(c,tty->write_q);
			tty->write(tty);
		}
		PUTCH(c,tty->secondary);
   15300:	8b 46 34             	mov    0x34(%esi),%eax
   15303:	3b 46 38             	cmp    0x38(%esi),%eax
   15306:	0f 84 a0 03 00 00    	je     156ac <copy_to_cooked+0x3b7>
   1530c:	8b 86 58 08 00 00    	mov    0x858(%esi),%eax
   15312:	2b 86 54 08 00 00    	sub    0x854(%esi),%eax
   15318:	48                   	dec    %eax
   15319:	a9 ff 03 00 00       	test   $0x3ff,%eax
   1531e:	0f 84 88 03 00 00    	je     156ac <copy_to_cooked+0x3b7>
		GETCH(tty->read_q,c);
   15324:	8b 46 38             	mov    0x38(%esi),%eax
   15327:	8a 5c 30 40          	mov    0x40(%eax,%esi,1),%bl
   1532b:	40                   	inc    %eax
   1532c:	25 ff 03 00 00       	and    $0x3ff,%eax
   15331:	89 46 38             	mov    %eax,0x38(%esi)
		if (c==13)
   15334:	80 fb 0d             	cmp    $0xd,%bl
   15337:	75 15                	jne    1534e <copy_to_cooked+0x59>
			if (I_CRNL(tty))
   15339:	f6 46 01 01          	testb  $0x1,0x1(%esi)
   1533d:	74 04                	je     15343 <copy_to_cooked+0x4e>
				c=10;
   1533f:	b3 0a                	mov    $0xa,%bl
   15341:	eb 17                	jmp    1535a <copy_to_cooked+0x65>
			else if (I_NOCR(tty))
   15343:	80 3e 00             	cmpb   $0x0,(%esi)
   15346:	0f 88 40 03 00 00    	js     1568c <copy_to_cooked+0x397>
				continue;
   1534c:	eb 0c                	jmp    1535a <copy_to_cooked+0x65>
		else if (c==10 && I_NLCR(tty))
   1534e:	80 fb 0a             	cmp    $0xa,%bl
   15351:	75 07                	jne    1535a <copy_to_cooked+0x65>
   15353:	f6 06 40             	testb  $0x40,(%esi)
   15356:	74 02                	je     1535a <copy_to_cooked+0x65>
			c=13;
   15358:	b3 0d                	mov    $0xd,%bl
		if (I_UCLC(tty))
   1535a:	f6 46 01 02          	testb  $0x2,0x1(%esi)
   1535e:	74 1b                	je     1537b <copy_to_cooked+0x86>
			c=tolower(c);
   15360:	88 1d 64 2e 02 00    	mov    %bl,0x22e64
   15366:	0f be c3             	movsbl %bl,%eax
   15369:	8d 58 20             	lea    0x20(%eax),%ebx
   1536c:	f6 80 81 e4 01 00 01 	testb  $0x1,0x1e481(%eax)
   15373:	75 06                	jne    1537b <copy_to_cooked+0x86>
   15375:	8a 1d 64 2e 02 00    	mov    0x22e64,%bl
		if (L_CANON(tty)) {
   1537b:	f6 46 0c 02          	testb  $0x2,0xc(%esi)
   1537f:	0f 84 ab 01 00 00    	je     15530 <copy_to_cooked+0x23b>
			if (c==KILL_CHAR(tty)) {
   15385:	0f be d3             	movsbl %bl,%edx
   15388:	0f b6 46 14          	movzbl 0x14(%esi),%eax
   1538c:	39 c2                	cmp    %eax,%edx
   1538e:	0f 85 c8 00 00 00    	jne    1545c <copy_to_cooked+0x167>
					DEC(tty->secondary.head);
   15394:	8b 86 54 08 00 00    	mov    0x854(%esi),%eax
   1539a:	3b 86 58 08 00 00    	cmp    0x858(%esi),%eax
   153a0:	0f 84 e6 02 00 00    	je     1568c <copy_to_cooked+0x397>
   153a6:	48                   	dec    %eax
   153a7:	25 ff 03 00 00       	and    $0x3ff,%eax
   153ac:	8a 9c 30 60 08 00 00 	mov    0x860(%eax,%esi,1),%bl
   153b3:	80 fb 0a             	cmp    $0xa,%bl
   153b6:	0f 84 d0 02 00 00    	je     1568c <copy_to_cooked+0x397>
   153bc:	0f be d3             	movsbl %bl,%edx
   153bf:	0f b6 46 15          	movzbl 0x15(%esi),%eax
   153c3:	39 c2                	cmp    %eax,%edx
   153c5:	0f 84 c1 02 00 00    	je     1568c <copy_to_cooked+0x397>
					if (L_ECHO(tty)) {
   153cb:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
   153cf:	74 43                	je     15414 <copy_to_cooked+0x11f>
						if (c<32)
   153d1:	80 fb 1f             	cmp    $0x1f,%bl
   153d4:	7f 1a                	jg     153f0 <copy_to_cooked+0xfb>
							PUTCH(127,tty->write_q);
   153d6:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   153dc:	c6 84 30 50 04 00 00 	movb   $0x7f,0x450(%eax,%esi,1)
   153e3:	7f 
   153e4:	40                   	inc    %eax
   153e5:	25 ff 03 00 00       	and    $0x3ff,%eax
   153ea:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
						PUTCH(127,tty->write_q);
   153f0:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   153f6:	c6 84 30 50 04 00 00 	movb   $0x7f,0x450(%eax,%esi,1)
   153fd:	7f 
   153fe:	40                   	inc    %eax
   153ff:	25 ff 03 00 00       	and    $0x3ff,%eax
   15404:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
						tty->write(tty);
   1540a:	83 ec 0c             	sub    $0xc,%esp
   1540d:	56                   	push   %esi
   1540e:	ff 56 2c             	call   *0x2c(%esi)
   15411:	83 c4 10             	add    $0x10,%esp
					DEC(tty->secondary.head);
   15414:	8b 86 54 08 00 00    	mov    0x854(%esi),%eax
   1541a:	48                   	dec    %eax
   1541b:	25 ff 03 00 00       	and    $0x3ff,%eax
   15420:	89 86 54 08 00 00    	mov    %eax,0x854(%esi)
   15426:	3b 86 58 08 00 00    	cmp    0x858(%esi),%eax
   1542c:	0f 84 5a 02 00 00    	je     1568c <copy_to_cooked+0x397>
   15432:	48                   	dec    %eax
   15433:	25 ff 03 00 00       	and    $0x3ff,%eax
   15438:	8a 9c 30 60 08 00 00 	mov    0x860(%eax,%esi,1),%bl
   1543f:	80 fb 0a             	cmp    $0xa,%bl
   15442:	0f 84 44 02 00 00    	je     1568c <copy_to_cooked+0x397>
   15448:	0f be d3             	movsbl %bl,%edx
   1544b:	0f b6 46 15          	movzbl 0x15(%esi),%eax
   1544f:	39 c2                	cmp    %eax,%edx
   15451:	0f 85 74 ff ff ff    	jne    153cb <copy_to_cooked+0xd6>
				continue;
   15457:	e9 30 02 00 00       	jmp    1568c <copy_to_cooked+0x397>
			if (c==ERASE_CHAR(tty)) {
   1545c:	0f be d3             	movsbl %bl,%edx
   1545f:	0f b6 46 13          	movzbl 0x13(%esi),%eax
   15463:	39 c2                	cmp    %eax,%edx
   15465:	0f 85 97 00 00 00    	jne    15502 <copy_to_cooked+0x20d>
				if (EMPTY(tty->secondary) ||
   1546b:	8b 86 54 08 00 00    	mov    0x854(%esi),%eax
   15471:	3b 86 58 08 00 00    	cmp    0x858(%esi),%eax
   15477:	0f 84 0f 02 00 00    	je     1568c <copy_to_cooked+0x397>
   1547d:	48                   	dec    %eax
   1547e:	25 ff 03 00 00       	and    $0x3ff,%eax
   15483:	8a 9c 30 60 08 00 00 	mov    0x860(%eax,%esi,1),%bl
   1548a:	80 fb 0a             	cmp    $0xa,%bl
   1548d:	0f 84 f9 01 00 00    	je     1568c <copy_to_cooked+0x397>
   15493:	0f be d3             	movsbl %bl,%edx
   15496:	0f b6 46 15          	movzbl 0x15(%esi),%eax
   1549a:	39 c2                	cmp    %eax,%edx
   1549c:	0f 84 ea 01 00 00    	je     1568c <copy_to_cooked+0x397>
				if (L_ECHO(tty)) {
   154a2:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
   154a6:	74 43                	je     154eb <copy_to_cooked+0x1f6>
					if (c<32)
   154a8:	80 fb 1f             	cmp    $0x1f,%bl
   154ab:	7f 1a                	jg     154c7 <copy_to_cooked+0x1d2>
						PUTCH(127,tty->write_q);
   154ad:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   154b3:	c6 84 30 50 04 00 00 	movb   $0x7f,0x450(%eax,%esi,1)
   154ba:	7f 
   154bb:	40                   	inc    %eax
   154bc:	25 ff 03 00 00       	and    $0x3ff,%eax
   154c1:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
					PUTCH(127,tty->write_q);
   154c7:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   154cd:	c6 84 30 50 04 00 00 	movb   $0x7f,0x450(%eax,%esi,1)
   154d4:	7f 
   154d5:	40                   	inc    %eax
   154d6:	25 ff 03 00 00       	and    $0x3ff,%eax
   154db:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
					tty->write(tty);
   154e1:	83 ec 0c             	sub    $0xc,%esp
   154e4:	56                   	push   %esi
   154e5:	ff 56 2c             	call   *0x2c(%esi)
   154e8:	83 c4 10             	add    $0x10,%esp
				DEC(tty->secondary.head);
   154eb:	8b 86 54 08 00 00    	mov    0x854(%esi),%eax
   154f1:	48                   	dec    %eax
   154f2:	25 ff 03 00 00       	and    $0x3ff,%eax
   154f7:	89 86 54 08 00 00    	mov    %eax,0x854(%esi)
				continue;
   154fd:	e9 8a 01 00 00       	jmp    1568c <copy_to_cooked+0x397>
			if (c==STOP_CHAR(tty)) {
   15502:	0f be d3             	movsbl %bl,%edx
   15505:	0f b6 46 1a          	movzbl 0x1a(%esi),%eax
   15509:	39 c2                	cmp    %eax,%edx
   1550b:	75 0c                	jne    15519 <copy_to_cooked+0x224>
				tty->stopped=1;
   1550d:	c7 46 28 01 00 00 00 	movl   $0x1,0x28(%esi)
				continue;
   15514:	e9 73 01 00 00       	jmp    1568c <copy_to_cooked+0x397>
			if (c==START_CHAR(tty)) {
   15519:	0f be d3             	movsbl %bl,%edx
   1551c:	0f b6 46 19          	movzbl 0x19(%esi),%eax
   15520:	39 c2                	cmp    %eax,%edx
   15522:	75 0c                	jne    15530 <copy_to_cooked+0x23b>
				tty->stopped=0;
   15524:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
				continue;
   1552b:	e9 5c 01 00 00       	jmp    1568c <copy_to_cooked+0x397>
		if (L_ISIG(tty)) {
   15530:	f6 46 0c 01          	testb  $0x1,0xc(%esi)
   15534:	0f 84 90 00 00 00    	je     155ca <copy_to_cooked+0x2d5>
			if (c==INTR_CHAR(tty)) {
   1553a:	0f be d3             	movsbl %bl,%edx
   1553d:	0f b6 46 11          	movzbl 0x11(%esi),%eax
   15541:	39 c2                	cmp    %eax,%edx
   15543:	75 3d                	jne    15582 <copy_to_cooked+0x28d>
{
   15545:	89 f7                	mov    %esi,%edi
   15547:	bd 02 00 00 00       	mov    $0x2,%ebp
	if (tty->pgrp <= 0)
   1554c:	83 7e 24 00          	cmpl   $0x0,0x24(%esi)
   15550:	0f 8e 36 01 00 00    	jle    1568c <copy_to_cooked+0x397>
	for (i=0;i<NR_TASKS;i++)
   15556:	b9 00 00 00 00       	mov    $0x0,%ecx
   1555b:	bb 40 bc 01 00       	mov    $0x1bc40,%ebx
		if (task[i] && task[i]->pgrp==tty->pgrp)
   15560:	83 3c 8b 00          	cmpl   $0x0,(%ebx,%ecx,4)
   15564:	74 11                	je     15577 <copy_to_cooked+0x282>
   15566:	8b 14 8b             	mov    (%ebx,%ecx,4),%edx
   15569:	8b 82 34 02 00 00    	mov    0x234(%edx),%eax
   1556f:	3b 47 24             	cmp    0x24(%edi),%eax
   15572:	75 03                	jne    15577 <copy_to_cooked+0x282>
			task[i]->signal |= mask;
   15574:	09 6a 0c             	or     %ebp,0xc(%edx)
	for (i=0;i<NR_TASKS;i++)
   15577:	41                   	inc    %ecx
   15578:	83 f9 3f             	cmp    $0x3f,%ecx
   1557b:	7e e3                	jle    15560 <copy_to_cooked+0x26b>
				continue;
   1557d:	e9 0a 01 00 00       	jmp    1568c <copy_to_cooked+0x397>
			if (c==QUIT_CHAR(tty)) {
   15582:	0f be d3             	movsbl %bl,%edx
   15585:	0f b6 46 12          	movzbl 0x12(%esi),%eax
   15589:	39 c2                	cmp    %eax,%edx
   1558b:	75 3d                	jne    155ca <copy_to_cooked+0x2d5>
{
   1558d:	89 f7                	mov    %esi,%edi
   1558f:	bd 04 00 00 00       	mov    $0x4,%ebp
	if (tty->pgrp <= 0)
   15594:	83 7e 24 00          	cmpl   $0x0,0x24(%esi)
   15598:	0f 8e ee 00 00 00    	jle    1568c <copy_to_cooked+0x397>
	for (i=0;i<NR_TASKS;i++)
   1559e:	b9 00 00 00 00       	mov    $0x0,%ecx
   155a3:	bb 40 bc 01 00       	mov    $0x1bc40,%ebx
		if (task[i] && task[i]->pgrp==tty->pgrp)
   155a8:	83 3c 8b 00          	cmpl   $0x0,(%ebx,%ecx,4)
   155ac:	74 11                	je     155bf <copy_to_cooked+0x2ca>
   155ae:	8b 14 8b             	mov    (%ebx,%ecx,4),%edx
   155b1:	8b 82 34 02 00 00    	mov    0x234(%edx),%eax
   155b7:	3b 47 24             	cmp    0x24(%edi),%eax
   155ba:	75 03                	jne    155bf <copy_to_cooked+0x2ca>
			task[i]->signal |= mask;
   155bc:	09 6a 0c             	or     %ebp,0xc(%edx)
	for (i=0;i<NR_TASKS;i++)
   155bf:	41                   	inc    %ecx
   155c0:	83 f9 3f             	cmp    $0x3f,%ecx
   155c3:	7e e3                	jle    155a8 <copy_to_cooked+0x2b3>
				continue;
   155c5:	e9 c2 00 00 00       	jmp    1568c <copy_to_cooked+0x397>
		if (c==10 || c==EOF_CHAR(tty))
   155ca:	80 fb 0a             	cmp    $0xa,%bl
   155cd:	74 0b                	je     155da <copy_to_cooked+0x2e5>
   155cf:	0f be d3             	movsbl %bl,%edx
   155d2:	0f b6 46 15          	movzbl 0x15(%esi),%eax
   155d6:	39 c2                	cmp    %eax,%edx
   155d8:	75 06                	jne    155e0 <copy_to_cooked+0x2eb>
			tty->secondary.data++;
   155da:	ff 86 50 08 00 00    	incl   0x850(%esi)
		if (L_ECHO(tty)) {
   155e0:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
   155e4:	0f 84 89 00 00 00    	je     15673 <copy_to_cooked+0x37e>
			if (c==10) {
   155ea:	80 fb 0a             	cmp    $0xa,%bl
   155ed:	75 2a                	jne    15619 <copy_to_cooked+0x324>
				PUTCH(10,tty->write_q);
   155ef:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   155f5:	c6 84 30 50 04 00 00 	movb   $0xa,0x450(%eax,%esi,1)
   155fc:	0a 
   155fd:	40                   	inc    %eax
   155fe:	25 ff 03 00 00       	and    $0x3ff,%eax
				PUTCH(13,tty->write_q);
   15603:	c6 84 30 50 04 00 00 	movb   $0xd,0x450(%eax,%esi,1)
   1560a:	0d 
   1560b:	40                   	inc    %eax
   1560c:	25 ff 03 00 00       	and    $0x3ff,%eax
   15611:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
   15617:	eb 50                	jmp    15669 <copy_to_cooked+0x374>
			} else if (c<32) {
   15619:	80 fb 1f             	cmp    $0x1f,%bl
   1561c:	7f 32                	jg     15650 <copy_to_cooked+0x35b>
				if (L_ECHOCTL(tty)) {
   1561e:	f6 46 0d 02          	testb  $0x2,0xd(%esi)
   15622:	74 45                	je     15669 <copy_to_cooked+0x374>
					PUTCH('^',tty->write_q);
   15624:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   1562a:	c6 84 30 50 04 00 00 	movb   $0x5e,0x450(%eax,%esi,1)
   15631:	5e 
   15632:	40                   	inc    %eax
   15633:	25 ff 03 00 00       	and    $0x3ff,%eax
					PUTCH(c+64,tty->write_q);
   15638:	8d 53 40             	lea    0x40(%ebx),%edx
   1563b:	88 94 30 50 04 00 00 	mov    %dl,0x450(%eax,%esi,1)
   15642:	40                   	inc    %eax
   15643:	25 ff 03 00 00       	and    $0x3ff,%eax
   15648:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
   1564e:	eb 19                	jmp    15669 <copy_to_cooked+0x374>
				PUTCH(c,tty->write_q);
   15650:	8b 86 44 04 00 00    	mov    0x444(%esi),%eax
   15656:	88 9c 30 50 04 00 00 	mov    %bl,0x450(%eax,%esi,1)
   1565d:	40                   	inc    %eax
   1565e:	25 ff 03 00 00       	and    $0x3ff,%eax
   15663:	89 86 44 04 00 00    	mov    %eax,0x444(%esi)
			tty->write(tty);
   15669:	83 ec 0c             	sub    $0xc,%esp
   1566c:	56                   	push   %esi
   1566d:	ff 56 2c             	call   *0x2c(%esi)
   15670:	83 c4 10             	add    $0x10,%esp
		PUTCH(c,tty->secondary);
   15673:	8b 86 54 08 00 00    	mov    0x854(%esi),%eax
   15679:	88 9c 30 60 08 00 00 	mov    %bl,0x860(%eax,%esi,1)
   15680:	40                   	inc    %eax
   15681:	25 ff 03 00 00       	and    $0x3ff,%eax
   15686:	89 86 54 08 00 00    	mov    %eax,0x854(%esi)
   1568c:	8b 46 34             	mov    0x34(%esi),%eax
   1568f:	3b 46 38             	cmp    0x38(%esi),%eax
   15692:	74 18                	je     156ac <copy_to_cooked+0x3b7>
   15694:	8b 86 58 08 00 00    	mov    0x858(%esi),%eax
   1569a:	2b 86 54 08 00 00    	sub    0x854(%esi),%eax
   156a0:	48                   	dec    %eax
   156a1:	a9 ff 03 00 00       	test   $0x3ff,%eax
   156a6:	0f 85 78 fc ff ff    	jne    15324 <copy_to_cooked+0x2f>
	}
	wake_up(&tty->secondary.proc_list);
   156ac:	83 ec 0c             	sub    $0xc,%esp
   156af:	8d 86 5c 08 00 00    	lea    0x85c(%esi),%eax
   156b5:	50                   	push   %eax
   156b6:	e8 e8 18 ff ff       	call   6fa3 <wake_up>
}
   156bb:	83 c4 1c             	add    $0x1c,%esp
   156be:	5b                   	pop    %ebx
   156bf:	5e                   	pop    %esi
   156c0:	5f                   	pop    %edi
   156c1:	5d                   	pop    %ebp
   156c2:	c3                   	ret    

000156c3 <tty_read>:

int tty_read(unsigned channel, char * buf, int nr)
{
   156c3:	55                   	push   %ebp
   156c4:	57                   	push   %edi
   156c5:	56                   	push   %esi
   156c6:	53                   	push   %ebx
   156c7:	83 ec 1c             	sub    $0x1c,%esp
   156ca:	8b 54 24 30          	mov    0x30(%esp),%edx
   156ce:	8b 74 24 38          	mov    0x38(%esp),%esi
	struct tty_struct * tty;
	char c, * b=buf;
   156d2:	8b 6c 24 34          	mov    0x34(%esp),%ebp
	int minimum,time,flag=0;
   156d6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   156dd:	00 
	long oldalarm;

	if (channel>2 || nr<0) return -1;
   156de:	83 fa 02             	cmp    $0x2,%edx
   156e1:	77 04                	ja     156e7 <tty_read+0x24>
   156e3:	85 f6                	test   %esi,%esi
   156e5:	79 15                	jns    156fc <tty_read+0x39>
   156e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   156ec:	e9 63 02 00 00       	jmp    15954 <tty_read+0x291>
	}
	if (minimum>nr)
		minimum=nr;
	while (nr>0) {
		if (flag && (current->signal & ALRMMASK)) {
			current->signal &= ~ALRMMASK;
   156f1:	80 e4 df             	and    $0xdf,%ah
   156f4:	89 42 0c             	mov    %eax,0xc(%edx)
			break;
   156f7:	e9 23 02 00 00       	jmp    1591f <tty_read+0x25c>
	tty = &tty_table[channel];
   156fc:	8d 04 92             	lea    (%edx,%edx,4),%eax
   156ff:	8d 04 80             	lea    (%eax,%eax,4),%eax
   15702:	c1 e0 02             	shl    $0x2,%eax
   15705:	29 d0                	sub    %edx,%eax
   15707:	c1 e0 05             	shl    $0x5,%eax
   1570a:	8d 98 20 bf 01 00    	lea    0x1bf20(%eax),%ebx
	oldalarm = current->alarm;
   15710:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   15715:	8b 80 4c 02 00 00    	mov    0x24c(%eax),%eax
   1571b:	89 44 24 0c          	mov    %eax,0xc(%esp)
	time = 10L*tty->termios.c_cc[VTIME];
   1571f:	0f b6 43 16          	movzbl 0x16(%ebx),%eax
   15723:	8d 04 80             	lea    (%eax,%eax,4),%eax
	minimum = tty->termios.c_cc[VMIN];
   15726:	0f b6 53 17          	movzbl 0x17(%ebx),%edx
   1572a:	89 54 24 18          	mov    %edx,0x18(%esp)
	if (time && !minimum) {
   1572e:	d1 e0                	shl    %eax
   15730:	89 44 24 14          	mov    %eax,0x14(%esp)
   15734:	74 4e                	je     15784 <tty_read+0xc1>
   15736:	85 d2                	test   %edx,%edx
   15738:	75 4a                	jne    15784 <tty_read+0xc1>
		minimum=1;
   1573a:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
   15741:	00 
		if ((flag=(!oldalarm || time+jiffies<oldalarm)))
   15742:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   15749:	00 
   1574a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   1574f:	74 0f                	je     15760 <tty_read+0x9d>
   15751:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
   15756:	03 44 24 14          	add    0x14(%esp),%eax
   1575a:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   1575e:	7d 08                	jge    15768 <tty_read+0xa5>
   15760:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
   15767:	00 
   15768:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1576d:	74 15                	je     15784 <tty_read+0xc1>
			current->alarm = time+jiffies;
   1576f:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
   15774:	03 44 24 14          	add    0x14(%esp),%eax
   15778:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   1577e:	89 82 4c 02 00 00    	mov    %eax,0x24c(%edx)
	if (minimum>nr)
   15784:	39 74 24 18          	cmp    %esi,0x18(%esp)
   15788:	7e 04                	jle    1578e <tty_read+0xcb>
		minimum=nr;
   1578a:	89 74 24 18          	mov    %esi,0x18(%esp)
		}
		if (L_CANON(tty)) {
			if (b-buf)
				break;
		} else if (b-buf >= minimum)
			break;
   1578e:	85 f6                	test   %esi,%esi
   15790:	0f 8e 89 01 00 00    	jle    1591f <tty_read+0x25c>
   15796:	8d 83 50 08 00 00    	lea    0x850(%ebx),%eax
   1579c:	89 44 24 04          	mov    %eax,0x4(%esp)
		if (flag && (current->signal & ALRMMASK)) {
   157a0:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   157a5:	74 12                	je     157b9 <tty_read+0xf6>
   157a7:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   157ad:	8b 42 0c             	mov    0xc(%edx),%eax
   157b0:	f6 c4 20             	test   $0x20,%ah
   157b3:	0f 85 38 ff ff ff    	jne    156f1 <tty_read+0x2e>
		if (current->signal)
   157b9:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   157be:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   157c2:	0f 85 57 01 00 00    	jne    1591f <tty_read+0x25c>
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   157c8:	8b 83 54 08 00 00    	mov    0x854(%ebx),%eax
   157ce:	3b 83 58 08 00 00    	cmp    0x858(%ebx),%eax
   157d4:	74 21                	je     157f7 <tty_read+0x134>
   157d6:	f6 43 0c 02          	testb  $0x2,0xc(%ebx)
   157da:	74 62                	je     1583e <tty_read+0x17b>
   157dc:	83 bb 50 08 00 00 00 	cmpl   $0x0,0x850(%ebx)
   157e3:	75 59                	jne    1583e <tty_read+0x17b>
   157e5:	f7 d0                	not    %eax
   157e7:	03 83 58 08 00 00    	add    0x858(%ebx),%eax
   157ed:	25 ff 03 00 00       	and    $0x3ff,%eax
   157f2:	83 f8 14             	cmp    $0x14,%eax
   157f5:	76 47                	jbe    1583e <tty_read+0x17b>
	cli();
   157f7:	8b 7c 24 04          	mov    0x4(%esp),%edi
   157fb:	fa                   	cli    
		interruptible_sleep_on(&queue->proc_list);
   157fc:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   15801:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   15805:	75 31                	jne    15838 <tty_read+0x175>
   15807:	8b 47 04             	mov    0x4(%edi),%eax
   1580a:	3b 47 08             	cmp    0x8(%edi),%eax
   1580d:	75 29                	jne    15838 <tty_read+0x175>
   1580f:	8d 57 0c             	lea    0xc(%edi),%edx
   15812:	89 54 24 08          	mov    %edx,0x8(%esp)
   15816:	83 ec 0c             	sub    $0xc,%esp
   15819:	ff 74 24 14          	pushl  0x14(%esp)
   1581d:	e8 f1 15 ff ff       	call   6e13 <interruptible_sleep_on>
   15822:	83 c4 10             	add    $0x10,%esp
   15825:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   1582a:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   1582e:	75 08                	jne    15838 <tty_read+0x175>
   15830:	8b 47 04             	mov    0x4(%edi),%eax
   15833:	3b 47 08             	cmp    0x8(%edi),%eax
   15836:	74 de                	je     15816 <tty_read+0x153>
	sti();
   15838:	fb                   	sti    
			continue;
   15839:	e9 d9 00 00 00       	jmp    15917 <tty_read+0x254>
			GETCH(tty->secondary,c);
   1583e:	8b 83 58 08 00 00    	mov    0x858(%ebx),%eax
   15844:	8a 8c 18 60 08 00 00 	mov    0x860(%eax,%ebx,1),%cl
   1584b:	40                   	inc    %eax
   1584c:	25 ff 03 00 00       	and    $0x3ff,%eax
   15851:	89 83 58 08 00 00    	mov    %eax,0x858(%ebx)
			if (c==EOF_CHAR(tty) || c==10)
   15857:	0f be d1             	movsbl %cl,%edx
   1585a:	0f b6 43 15          	movzbl 0x15(%ebx),%eax
   1585e:	39 c2                	cmp    %eax,%edx
   15860:	74 05                	je     15867 <tty_read+0x1a4>
   15862:	80 f9 0a             	cmp    $0xa,%cl
   15865:	75 06                	jne    1586d <tty_read+0x1aa>
				tty->secondary.data--;
   15867:	ff 8b 50 08 00 00    	decl   0x850(%ebx)
			if (c==EOF_CHAR(tty) && L_CANON(tty))
   1586d:	0f be d1             	movsbl %cl,%edx
   15870:	0f b6 43 15          	movzbl 0x15(%ebx),%eax
   15874:	39 c2                	cmp    %eax,%edx
   15876:	75 0a                	jne    15882 <tty_read+0x1bf>
   15878:	f6 43 0c 02          	testb  $0x2,0xc(%ebx)
   1587c:	0f 85 c4 00 00 00    	jne    15946 <tty_read+0x283>
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
	return _v;
}

static inline void put_fs_byte(char val,char *addr)
{
   15882:	89 e8                	mov    %ebp,%eax
   15884:	45                   	inc    %ebp
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
   15885:	64 88 08             	mov    %cl,%fs:(%eax)
				if (!--nr)
   15888:	4e                   	dec    %esi
   15889:	74 12                	je     1589d <tty_read+0x1da>
		} while (nr>0 && !EMPTY(tty->secondary));
   1588b:	85 f6                	test   %esi,%esi
   1588d:	7e 0e                	jle    1589d <tty_read+0x1da>
   1588f:	8b 83 54 08 00 00    	mov    0x854(%ebx),%eax
   15895:	3b 83 58 08 00 00    	cmp    0x858(%ebx),%eax
   1589b:	75 a1                	jne    1583e <tty_read+0x17b>
		if (time && !L_CANON(tty)) {
   1589d:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   158a2:	74 59                	je     158fd <tty_read+0x23a>
   158a4:	f6 43 0c 02          	testb  $0x2,0xc(%ebx)
   158a8:	75 53                	jne    158fd <tty_read+0x23a>
			if ((flag=(!oldalarm || time+jiffies<oldalarm)))
   158aa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   158b1:	00 
   158b2:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   158b7:	74 0f                	je     158c8 <tty_read+0x205>
   158b9:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
   158be:	03 44 24 14          	add    0x14(%esp),%eax
   158c2:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   158c6:	7d 08                	jge    158d0 <tty_read+0x20d>
   158c8:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
   158cf:	00 
   158d0:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   158d5:	74 17                	je     158ee <tty_read+0x22b>
				current->alarm = time+jiffies;
   158d7:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
   158dc:	03 44 24 14          	add    0x14(%esp),%eax
   158e0:	8b 15 20 bc 01 00    	mov    0x1bc20,%edx
   158e6:	89 82 4c 02 00 00    	mov    %eax,0x24c(%edx)
   158ec:	eb 0f                	jmp    158fd <tty_read+0x23a>
				current->alarm = oldalarm;
   158ee:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   158f3:	8b 54 24 0c          	mov    0xc(%esp),%edx
   158f7:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
		if (L_CANON(tty)) {
   158fd:	f6 43 0c 02          	testb  $0x2,0xc(%ebx)
   15901:	74 08                	je     1590b <tty_read+0x248>
			if (b-buf)
   15903:	3b 6c 24 34          	cmp    0x34(%esp),%ebp
   15907:	75 16                	jne    1591f <tty_read+0x25c>
				break;
   15909:	eb 0c                	jmp    15917 <tty_read+0x254>
		} else if (b-buf >= minimum)
   1590b:	89 e8                	mov    %ebp,%eax
   1590d:	2b 44 24 34          	sub    0x34(%esp),%eax
   15911:	3b 44 24 18          	cmp    0x18(%esp),%eax
   15915:	7d 08                	jge    1591f <tty_read+0x25c>
			break;
   15917:	85 f6                	test   %esi,%esi
   15919:	0f 8f 81 fe ff ff    	jg     157a0 <tty_read+0xdd>
	}
	current->alarm = oldalarm;
   1591f:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   15924:	8b 54 24 0c          	mov    0xc(%esp),%edx
   15928:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
	if (current->signal && !(b-buf))
   1592e:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   15933:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   15937:	74 15                	je     1594e <tty_read+0x28b>
		return -EINTR;
   15939:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	if (current->signal && !(b-buf))
   1593e:	3b 6c 24 34          	cmp    0x34(%esp),%ebp
   15942:	74 10                	je     15954 <tty_read+0x291>
   15944:	eb 08                	jmp    1594e <tty_read+0x28b>
				return (b-buf);
   15946:	89 e8                	mov    %ebp,%eax
   15948:	2b 44 24 34          	sub    0x34(%esp),%eax
   1594c:	eb 06                	jmp    15954 <tty_read+0x291>
	return (b-buf);
   1594e:	89 e8                	mov    %ebp,%eax
   15950:	2b 44 24 34          	sub    0x34(%esp),%eax
}
   15954:	83 c4 1c             	add    $0x1c,%esp
   15957:	5b                   	pop    %ebx
   15958:	5e                   	pop    %esi
   15959:	5f                   	pop    %edi
   1595a:	5d                   	pop    %ebp
   1595b:	c3                   	ret    

0001595c <tty_write>:

int tty_write(unsigned channel, char * buf, int nr)
{
   1595c:	55                   	push   %ebp
   1595d:	57                   	push   %edi
   1595e:	56                   	push   %esi
   1595f:	53                   	push   %ebx
   15960:	83 ec 0c             	sub    $0xc,%esp
   15963:	8b 54 24 20          	mov    0x20(%esp),%edx
   15967:	8b 74 24 28          	mov    0x28(%esp),%esi
	static int cr_flag=0;
	struct tty_struct * tty;
	char c, *b=buf;
   1596b:	8b 7c 24 24          	mov    0x24(%esp),%edi

	if (channel>2 || nr<0) return -1;
   1596f:	83 fa 02             	cmp    $0x2,%edx
   15972:	77 04                	ja     15978 <tty_write+0x1c>
   15974:	85 f6                	test   %esi,%esi
   15976:	79 0a                	jns    15982 <tty_write+0x26>
   15978:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1597d:	e9 8f 01 00 00       	jmp    15b11 <tty_write+0x1b5>
	tty = channel + tty_table;
   15982:	8d 04 92             	lea    (%edx,%edx,4),%eax
   15985:	8d 04 80             	lea    (%eax,%eax,4),%eax
   15988:	c1 e0 02             	shl    $0x2,%eax
   1598b:	29 d0                	sub    %edx,%eax
   1598d:	c1 e0 05             	shl    $0x5,%eax
   15990:	8d 98 20 bf 01 00    	lea    0x1bf20(%eax),%ebx
			cr_flag = 0;
			PUTCH(c,tty->write_q);
		}
		tty->write(tty);
		if (nr>0)
			schedule();
   15996:	85 f6                	test   %esi,%esi
   15998:	0f 8e 6d 01 00 00    	jle    15b0b <tty_write+0x1af>
   1599e:	8d 83 40 04 00 00    	lea    0x440(%ebx),%eax
   159a4:	89 44 24 08          	mov    %eax,0x8(%esp)
   159a8:	83 c0 0c             	add    $0xc,%eax
   159ab:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (!FULL(*queue))
   159af:	8b 54 24 08          	mov    0x8(%esp),%edx
   159b3:	8b 42 08             	mov    0x8(%edx),%eax
   159b6:	2b 42 04             	sub    0x4(%edx),%eax
   159b9:	48                   	dec    %eax
   159ba:	a9 ff 03 00 00       	test   $0x3ff,%eax
   159bf:	75 3d                	jne    159fe <tty_write+0xa2>
	cli();
   159c1:	fa                   	cli    
		interruptible_sleep_on(&queue->proc_list);
   159c2:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   159c7:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   159cb:	75 30                	jne    159fd <tty_write+0xa1>
   159cd:	8b 6c 24 04          	mov    0x4(%esp),%ebp
   159d1:	83 ec 0c             	sub    $0xc,%esp
   159d4:	55                   	push   %ebp
   159d5:	e8 39 14 ff ff       	call   6e13 <interruptible_sleep_on>
   159da:	83 c4 10             	add    $0x10,%esp
   159dd:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   159e2:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   159e6:	75 15                	jne    159fd <tty_write+0xa1>
   159e8:	8b 54 24 08          	mov    0x8(%esp),%edx
   159ec:	8b 42 08             	mov    0x8(%edx),%eax
   159ef:	2b 42 04             	sub    0x4(%edx),%eax
   159f2:	48                   	dec    %eax
   159f3:	25 ff 03 00 00       	and    $0x3ff,%eax
   159f8:	83 f8 7f             	cmp    $0x7f,%eax
   159fb:	76 d4                	jbe    159d1 <tty_write+0x75>
	sti();
   159fd:	fb                   	sti    
		if (current->signal)
   159fe:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   15a03:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   15a07:	0f 85 fe 00 00 00    	jne    15b0b <tty_write+0x1af>
			PUTCH(c,tty->write_q);
   15a0d:	85 f6                	test   %esi,%esi
   15a0f:	0f 8e de 00 00 00    	jle    15af3 <tty_write+0x197>
   15a15:	8b 83 48 04 00 00    	mov    0x448(%ebx),%eax
   15a1b:	2b 83 44 04 00 00    	sub    0x444(%ebx),%eax
   15a21:	48                   	dec    %eax
   15a22:	a9 ff 03 00 00       	test   $0x3ff,%eax
   15a27:	0f 84 c6 00 00 00    	je     15af3 <tty_write+0x197>
   15a2d:	8b 4b 04             	mov    0x4(%ebx),%ecx
   15a30:	89 cd                	mov    %ecx,%ebp
   15a32:	83 e5 08             	and    $0x8,%ebp
{
   15a35:	64 8a 17             	mov    %fs:(%edi),%dl
			if (O_POST(tty)) {
   15a38:	f6 c1 01             	test   $0x1,%cl
   15a3b:	74 75                	je     15ab2 <tty_write+0x156>
				if (c=='\r' && O_CRNL(tty))
   15a3d:	80 fa 0d             	cmp    $0xd,%dl
   15a40:	75 08                	jne    15a4a <tty_write+0xee>
   15a42:	85 ed                	test   %ebp,%ebp
   15a44:	74 04                	je     15a4a <tty_write+0xee>
					c='\n';
   15a46:	b2 0a                	mov    $0xa,%dl
   15a48:	eb 0d                	jmp    15a57 <tty_write+0xfb>
				else if (c=='\n' && O_NLRET(tty))
   15a4a:	80 fa 0a             	cmp    $0xa,%dl
   15a4d:	75 42                	jne    15a91 <tty_write+0x135>
   15a4f:	f6 43 04 20          	testb  $0x20,0x4(%ebx)
   15a53:	74 02                	je     15a57 <tty_write+0xfb>
					c='\r';
   15a55:	b2 0d                	mov    $0xd,%dl
				if (c=='\n' && !cr_flag && O_NLCR(tty)) {
   15a57:	80 fa 0a             	cmp    $0xa,%dl
   15a5a:	75 35                	jne    15a91 <tty_write+0x135>
   15a5c:	83 3d b4 0c 02 00 00 	cmpl   $0x0,0x20cb4
   15a63:	75 2c                	jne    15a91 <tty_write+0x135>
   15a65:	f6 43 04 04          	testb  $0x4,0x4(%ebx)
   15a69:	74 26                	je     15a91 <tty_write+0x135>
					cr_flag = 1;
   15a6b:	c7 05 b4 0c 02 00 01 	movl   $0x1,0x20cb4
   15a72:	00 00 00 
					PUTCH(13,tty->write_q);
   15a75:	8b 83 44 04 00 00    	mov    0x444(%ebx),%eax
   15a7b:	c6 84 18 50 04 00 00 	movb   $0xd,0x450(%eax,%ebx,1)
   15a82:	0d 
   15a83:	40                   	inc    %eax
   15a84:	25 ff 03 00 00       	and    $0x3ff,%eax
   15a89:	89 83 44 04 00 00    	mov    %eax,0x444(%ebx)
					continue;
   15a8f:	eb 46                	jmp    15ad7 <tty_write+0x17b>
				if (O_LCUC(tty))
   15a91:	f6 43 04 02          	testb  $0x2,0x4(%ebx)
   15a95:	74 1b                	je     15ab2 <tty_write+0x156>
					c=toupper(c);
   15a97:	88 15 64 2e 02 00    	mov    %dl,0x22e64
   15a9d:	0f be c2             	movsbl %dl,%eax
   15aa0:	8d 50 e0             	lea    -0x20(%eax),%edx
   15aa3:	f6 80 81 e4 01 00 02 	testb  $0x2,0x1e481(%eax)
   15aaa:	75 06                	jne    15ab2 <tty_write+0x156>
   15aac:	8a 15 64 2e 02 00    	mov    0x22e64,%dl
			b++; nr--;
   15ab2:	47                   	inc    %edi
   15ab3:	4e                   	dec    %esi
			cr_flag = 0;
   15ab4:	c7 05 b4 0c 02 00 00 	movl   $0x0,0x20cb4
   15abb:	00 00 00 
			PUTCH(c,tty->write_q);
   15abe:	8b 83 44 04 00 00    	mov    0x444(%ebx),%eax
   15ac4:	88 94 18 50 04 00 00 	mov    %dl,0x450(%eax,%ebx,1)
   15acb:	40                   	inc    %eax
   15acc:	25 ff 03 00 00       	and    $0x3ff,%eax
   15ad1:	89 83 44 04 00 00    	mov    %eax,0x444(%ebx)
   15ad7:	85 f6                	test   %esi,%esi
   15ad9:	7e 18                	jle    15af3 <tty_write+0x197>
   15adb:	8b 83 48 04 00 00    	mov    0x448(%ebx),%eax
   15ae1:	2b 83 44 04 00 00    	sub    0x444(%ebx),%eax
   15ae7:	48                   	dec    %eax
   15ae8:	a9 ff 03 00 00       	test   $0x3ff,%eax
   15aed:	0f 85 42 ff ff ff    	jne    15a35 <tty_write+0xd9>
		tty->write(tty);
   15af3:	83 ec 0c             	sub    $0xc,%esp
   15af6:	53                   	push   %ebx
   15af7:	ff 53 2c             	call   *0x2c(%ebx)
		if (nr>0)
   15afa:	83 c4 10             	add    $0x10,%esp
   15afd:	85 f6                	test   %esi,%esi
   15aff:	7e 0a                	jle    15b0b <tty_write+0x1af>
			schedule();
   15b01:	e8 75 0f ff ff       	call   6a7b <schedule>
   15b06:	e9 a4 fe ff ff       	jmp    159af <tty_write+0x53>
	}
	return (b-buf);
   15b0b:	89 f8                	mov    %edi,%eax
   15b0d:	2b 44 24 24          	sub    0x24(%esp),%eax
}
   15b11:	83 c4 0c             	add    $0xc,%esp
   15b14:	5b                   	pop    %ebx
   15b15:	5e                   	pop    %esi
   15b16:	5f                   	pop    %edi
   15b17:	5d                   	pop    %ebp
   15b18:	c3                   	ret    

00015b19 <do_tty_interrupt>:
 * I don't think we sleep here under normal circumstances
 * anyway, which is good, as the task sleeping might be
 * totally innocent.
 */
void do_tty_interrupt(int tty)
{
   15b19:	83 ec 18             	sub    $0x18,%esp
   15b1c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
	copy_to_cooked(tty_table+tty);
   15b20:	8d 04 92             	lea    (%edx,%edx,4),%eax
   15b23:	8d 04 80             	lea    (%eax,%eax,4),%eax
   15b26:	c1 e0 02             	shl    $0x2,%eax
   15b29:	29 d0                	sub    %edx,%eax
   15b2b:	c1 e0 05             	shl    $0x5,%eax
   15b2e:	05 20 bf 01 00       	add    $0x1bf20,%eax
   15b33:	50                   	push   %eax
   15b34:	e8 bc f7 ff ff       	call   152f5 <copy_to_cooked>
}
   15b39:	83 c4 1c             	add    $0x1c,%esp
   15b3c:	c3                   	ret    

00015b3d <chr_dev_init>:

void chr_dev_init(void)
{
   15b3d:	c3                   	ret    

00015b3e <csi_m>:

void csi_m(void)
{
	int i;

	for (i=0;i<=npar;i++)
   15b3e:	ba 00 00 00 00       	mov    $0x0,%edx
		switch (par[i]) {
   15b43:	b8 20 0d 02 00       	mov    $0x20d20,%eax
   15b48:	83 3c 90 1b          	cmpl   $0x1b,(%eax,%edx,4)
   15b4c:	77 35                	ja     15b83 <csi_m+0x45>
   15b4e:	8b 04 90             	mov    (%eax,%edx,4),%eax
   15b51:	ff 24 85 f4 97 01 00 	jmp    *0x197f4(,%eax,4)
			case 0:attr=0x07;break;
   15b58:	c6 05 58 e4 01 00 07 	movb   $0x7,0x1e458
   15b5f:	eb 22                	jmp    15b83 <csi_m+0x45>
			case 1:attr=0x0f;break;
   15b61:	c6 05 58 e4 01 00 0f 	movb   $0xf,0x1e458
   15b68:	eb 19                	jmp    15b83 <csi_m+0x45>
			case 4:attr=0x0f;break;
   15b6a:	c6 05 58 e4 01 00 0f 	movb   $0xf,0x1e458
   15b71:	eb 10                	jmp    15b83 <csi_m+0x45>
			case 7:attr=0x70;break;
   15b73:	c6 05 58 e4 01 00 70 	movb   $0x70,0x1e458
   15b7a:	eb 07                	jmp    15b83 <csi_m+0x45>
			case 27:attr=0x07;break;
   15b7c:	c6 05 58 e4 01 00 07 	movb   $0x7,0x1e458
	for (i=0;i<=npar;i++)
   15b83:	42                   	inc    %edx
   15b84:	3b 15 14 0d 02 00    	cmp    0x20d14,%edx
   15b8a:	76 b7                	jbe    15b43 <csi_m+0x5>
		}
}
   15b8c:	c3                   	ret    

00015b8d <con_write>:
{
	gotoxy(saved_x, saved_y);
}

void con_write(struct tty_struct * tty)
{
   15b8d:	55                   	push   %ebp
   15b8e:	57                   	push   %edi
   15b8f:	56                   	push   %esi
   15b90:	53                   	push   %ebx
   15b91:	81 ec cc 00 00 00    	sub    $0xcc,%esp
	int nr;
	char c;

	nr = CHARS(tty->write_q);
   15b97:	8b 94 24 e0 00 00 00 	mov    0xe0(%esp),%edx
   15b9e:	8b 82 44 04 00 00    	mov    0x444(%edx),%eax
   15ba4:	89 c5                	mov    %eax,%ebp
   15ba6:	2b aa 48 04 00 00    	sub    0x448(%edx),%ebp
   15bac:	81 e5 ff 03 00 00    	and    $0x3ff,%ebp
					case 's':
						save_cur();
						break;
					case 'u':
						restore_cur();
						break;
   15bb2:	4d                   	dec    %ebp
   15bb3:	83 fd ff             	cmp    $0xffffffff,%ebp
   15bb6:	0f 84 df 16 00 00    	je     1729b <con_write+0x170e>
		GETCH(tty->write_q,c);
   15bbc:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
   15bc3:	8b 81 48 04 00 00    	mov    0x448(%ecx),%eax
   15bc9:	8a 9c 08 50 04 00 00 	mov    0x450(%eax,%ecx,1),%bl
   15bd0:	88 9c 24 cb 00 00 00 	mov    %bl,0xcb(%esp)
   15bd7:	40                   	inc    %eax
   15bd8:	25 ff 03 00 00       	and    $0x3ff,%eax
   15bdd:	89 81 48 04 00 00    	mov    %eax,0x448(%ecx)
		switch(state) {
   15be3:	83 3d c4 0c 02 00 04 	cmpl   $0x4,0x20cc4
   15bea:	0f 87 a1 16 00 00    	ja     17291 <con_write+0x1704>
   15bf0:	a1 c4 0c 02 00       	mov    0x20cc4,%eax
   15bf5:	ff 24 85 64 98 01 00 	jmp    *0x19864(,%eax,4)
				if (c>31 && c<127) {
   15bfc:	80 bc 24 cb 00 00 00 	cmpb   $0x1f,0xcb(%esp)
   15c03:	1f 
   15c04:	0f 8e 5e 02 00 00    	jle    15e68 <con_write+0x2db>
   15c0a:	80 bc 24 cb 00 00 00 	cmpb   $0x7f,0xcb(%esp)
   15c11:	7f 
   15c12:	0f 84 50 02 00 00    	je     15e68 <con_write+0x2db>
					if (x>=video_num_columns) {
   15c18:	a1 04 0d 02 00       	mov    0x20d04,%eax
   15c1d:	3b 05 d8 0c 02 00    	cmp    0x20cd8,%eax
   15c23:	0f 82 16 02 00 00    	jb     15e3f <con_write+0x2b2>
						x -= video_num_columns;
   15c29:	2b 05 d8 0c 02 00    	sub    0x20cd8,%eax
   15c2f:	a3 04 0d 02 00       	mov    %eax,0x20d04
						pos -= video_size_row;
   15c34:	8b 0d dc 0c 02 00    	mov    0x20cdc,%ecx
   15c3a:	a1 00 0d 02 00       	mov    0x20d00,%eax
   15c3f:	29 c8                	sub    %ecx,%eax
   15c41:	a3 00 0d 02 00       	mov    %eax,0x20d00
	if (y+1<bottom) {
   15c46:	8b 15 08 0d 02 00    	mov    0x20d08,%edx
   15c4c:	42                   	inc    %edx
   15c4d:	3b 15 10 0d 02 00    	cmp    0x20d10,%edx
   15c53:	73 12                	jae    15c67 <con_write+0xda>
		y++;
   15c55:	89 15 08 0d 02 00    	mov    %edx,0x20d08
		pos += video_size_row;
   15c5b:	01 c8                	add    %ecx,%eax
   15c5d:	a3 00 0d 02 00       	mov    %eax,0x20d00
   15c62:	e9 d8 01 00 00       	jmp    15e3f <con_write+0x2b2>
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   15c67:	a0 d4 0c 02 00       	mov    0x20cd4,%al
   15c6c:	83 e8 20             	sub    $0x20,%eax
   15c6f:	3c 01                	cmp    $0x1,%al
   15c71:	0f 87 79 01 00 00    	ja     15df0 <con_write+0x263>
		if (!top && bottom == video_num_lines) {
   15c77:	83 3d 0c 0d 02 00 00 	cmpl   $0x0,0x20d0c
   15c7e:	0f 85 1b 01 00 00    	jne    15d9f <con_write+0x212>
   15c84:	8b 15 10 0d 02 00    	mov    0x20d10,%edx
   15c8a:	3b 15 e0 0c 02 00    	cmp    0x20ce0,%edx
   15c90:	0f 85 09 01 00 00    	jne    15d9f <con_write+0x212>
			origin += video_size_row;
   15c96:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   15c9b:	8b 35 f8 0c 02 00    	mov    0x20cf8,%esi
   15ca1:	01 c6                	add    %eax,%esi
   15ca3:	89 35 f8 0c 02 00    	mov    %esi,0x20cf8
			pos += video_size_row;
   15ca9:	8b 3d 00 0d 02 00    	mov    0x20d00,%edi
   15caf:	01 c7                	add    %eax,%edi
   15cb1:	89 bc 24 c4 00 00 00 	mov    %edi,0xc4(%esp)
   15cb8:	89 3d 00 0d 02 00    	mov    %edi,0x20d00
			scr_end += video_size_row;
   15cbe:	03 05 fc 0c 02 00    	add    0x20cfc,%eax
   15cc4:	89 84 24 c0 00 00 00 	mov    %eax,0xc0(%esp)
   15ccb:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
			if (scr_end > video_mem_end) {
   15cd0:	3b 05 ec 0c 02 00    	cmp    0x20cec,%eax
   15cd6:	76 4e                	jbe    15d26 <con_write+0x199>
				__asm__("cld\n\t"
   15cd8:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   15cde:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15ce1:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   15ce8:	d1 e9                	shr    %ecx
   15cea:	8b 1d e8 0c 02 00    	mov    0x20ce8,%ebx
   15cf0:	89 df                	mov    %ebx,%edi
   15cf2:	fc                   	cld    
   15cf3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15cf5:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   15cfb:	f3 66 ab             	rep stos %ax,%es:(%edi)
				scr_end -= origin-video_mem_start;
   15cfe:	89 f2                	mov    %esi,%edx
   15d00:	29 da                	sub    %ebx,%edx
   15d02:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
   15d09:	29 d0                	sub    %edx,%eax
   15d0b:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
				pos -= origin-video_mem_start;
   15d10:	8b 84 24 c4 00 00 00 	mov    0xc4(%esp),%eax
   15d17:	29 d0                	sub    %edx,%eax
   15d19:	a3 00 0d 02 00       	mov    %eax,0x20d00
				origin = video_mem_start;
   15d1e:	89 1d f8 0c 02 00    	mov    %ebx,0x20cf8
   15d24:	eb 1e                	jmp    15d44 <con_write+0x1b7>
				__asm__("cld\n\t"
   15d26:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   15d2c:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   15d32:	8b 15 fc 0c 02 00    	mov    0x20cfc,%edx
   15d38:	2b 15 dc 0c 02 00    	sub    0x20cdc,%edx
   15d3e:	89 d7                	mov    %edx,%edi
   15d40:	fc                   	cld    
   15d41:	f3 66 ab             	rep stos %ax,%es:(%edi)
	cli();
   15d44:	fa                   	cli    
	outb_p(12, video_port_reg);
   15d45:	b8 0c 00 00 00       	mov    $0xc,%eax
   15d4a:	66 8b 0d f0 0c 02 00 	mov    0x20cf0,%cx
   15d51:	89 ca                	mov    %ecx,%edx
   15d53:	ee                   	out    %al,(%dx)
   15d54:	eb 00                	jmp    15d56 <con_write+0x1c9>
   15d56:	eb 00                	jmp    15d58 <con_write+0x1cb>
	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
   15d58:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   15d5d:	89 c3                	mov    %eax,%ebx
   15d5f:	2b 1d e8 0c 02 00    	sub    0x20ce8,%ebx
   15d65:	89 d8                	mov    %ebx,%eax
   15d67:	c1 e8 09             	shr    $0x9,%eax
   15d6a:	25 ff 00 00 00       	and    $0xff,%eax
   15d6f:	66 8b 35 f2 0c 02 00 	mov    0x20cf2,%si
   15d76:	89 f2                	mov    %esi,%edx
   15d78:	ee                   	out    %al,(%dx)
   15d79:	eb 00                	jmp    15d7b <con_write+0x1ee>
   15d7b:	eb 00                	jmp    15d7d <con_write+0x1f0>
	outb_p(13, video_port_reg);
   15d7d:	b8 0d 00 00 00       	mov    $0xd,%eax
   15d82:	89 ca                	mov    %ecx,%edx
   15d84:	ee                   	out    %al,(%dx)
   15d85:	eb 00                	jmp    15d87 <con_write+0x1fa>
   15d87:	eb 00                	jmp    15d89 <con_write+0x1fc>
	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
   15d89:	89 d8                	mov    %ebx,%eax
   15d8b:	d1 e8                	shr    %eax
   15d8d:	25 ff 00 00 00       	and    $0xff,%eax
   15d92:	89 f2                	mov    %esi,%edx
   15d94:	ee                   	out    %al,(%dx)
   15d95:	eb 00                	jmp    15d97 <con_write+0x20a>
   15d97:	eb 00                	jmp    15d99 <con_write+0x20c>
	sti();
   15d99:	fb                   	sti    
   15d9a:	e9 a0 00 00 00       	jmp    15e3f <con_write+0x2b2>
			__asm__("cld\n\t"
   15d9f:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   15da6:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   15dac:	89 f1                	mov    %esi,%ecx
   15dae:	f7 d1                	not    %ecx
   15db0:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   15db6:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   15dbd:	d1 e9                	shr    %ecx
   15dbf:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   15dc4:	89 c3                	mov    %eax,%ebx
   15dc6:	0f af 1d 0c 0d 02 00 	imul   0x20d0c,%ebx
   15dcd:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   15dd2:	01 c3                	add    %eax,%ebx
   15dd4:	46                   	inc    %esi
   15dd5:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   15ddc:	01 c6                	add    %eax,%esi
   15dde:	89 d0                	mov    %edx,%eax
   15de0:	89 df                	mov    %ebx,%edi
   15de2:	fc                   	cld    
   15de3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15de5:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   15deb:	f3 66 ab             	rep stos %ax,%es:(%edi)
   15dee:	eb 4f                	jmp    15e3f <con_write+0x2b2>
		__asm__("cld\n\t"
   15df0:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   15df7:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   15dfd:	89 f1                	mov    %esi,%ecx
   15dff:	f7 d1                	not    %ecx
   15e01:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   15e07:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   15e0e:	d1 e9                	shr    %ecx
   15e10:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   15e15:	89 c3                	mov    %eax,%ebx
   15e17:	0f af 1d 0c 0d 02 00 	imul   0x20d0c,%ebx
   15e1e:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   15e23:	01 c3                	add    %eax,%ebx
   15e25:	46                   	inc    %esi
   15e26:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   15e2d:	01 c6                	add    %eax,%esi
   15e2f:	89 d0                	mov    %edx,%eax
   15e31:	89 df                	mov    %ebx,%edi
   15e33:	fc                   	cld    
   15e34:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15e36:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   15e3c:	f3 66 ab             	rep stos %ax,%es:(%edi)
					__asm__("movb attr,%%ah\n\t"
   15e3f:	8b 15 00 0d 02 00    	mov    0x20d00,%edx
   15e45:	8a 84 24 cb 00 00 00 	mov    0xcb(%esp),%al
   15e4c:	8a 25 58 e4 01 00    	mov    0x1e458,%ah
   15e52:	66 89 02             	mov    %ax,(%edx)
					pos += 2;
   15e55:	8d 42 02             	lea    0x2(%edx),%eax
   15e58:	a3 00 0d 02 00       	mov    %eax,0x20d00
					x++;
   15e5d:	ff 05 04 0d 02 00    	incl   0x20d04
   15e63:	e9 29 14 00 00       	jmp    17291 <con_write+0x1704>
				} else if (c==27)
   15e68:	80 bc 24 cb 00 00 00 	cmpb   $0x1b,0xcb(%esp)
   15e6f:	1b 
   15e70:	75 0f                	jne    15e81 <con_write+0x2f4>
					state=1;
   15e72:	c7 05 c4 0c 02 00 01 	movl   $0x1,0x20cc4
   15e79:	00 00 00 
   15e7c:	e9 10 14 00 00       	jmp    17291 <con_write+0x1704>
				else if (c==10 || c==11 || c==12)
   15e81:	8a 84 24 cb 00 00 00 	mov    0xcb(%esp),%al
   15e88:	83 e8 0a             	sub    $0xa,%eax
   15e8b:	3c 02                	cmp    $0x2,%al
   15e8d:	0f 87 2e 02 00 00    	ja     160c1 <con_write+0x534>
	if (y+1<bottom) {
   15e93:	a1 08 0d 02 00       	mov    0x20d08,%eax
   15e98:	40                   	inc    %eax
   15e99:	3b 05 10 0d 02 00    	cmp    0x20d10,%eax
   15e9f:	73 1a                	jae    15ebb <con_write+0x32e>
		y++;
   15ea1:	a3 08 0d 02 00       	mov    %eax,0x20d08
		pos += video_size_row;
   15ea6:	a1 00 0d 02 00       	mov    0x20d00,%eax
   15eab:	03 05 dc 0c 02 00    	add    0x20cdc,%eax
   15eb1:	a3 00 0d 02 00       	mov    %eax,0x20d00
   15eb6:	e9 d6 13 00 00       	jmp    17291 <con_write+0x1704>
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   15ebb:	a0 d4 0c 02 00       	mov    0x20cd4,%al
   15ec0:	83 e8 20             	sub    $0x20,%eax
   15ec3:	3c 01                	cmp    $0x1,%al
   15ec5:	0f 87 8f 01 00 00    	ja     1605a <con_write+0x4cd>
		if (!top && bottom == video_num_lines) {
   15ecb:	83 3d 0c 0d 02 00 00 	cmpl   $0x0,0x20d0c
   15ed2:	0f 85 1b 01 00 00    	jne    15ff3 <con_write+0x466>
   15ed8:	8b 15 10 0d 02 00    	mov    0x20d10,%edx
   15ede:	3b 15 e0 0c 02 00    	cmp    0x20ce0,%edx
   15ee4:	0f 85 09 01 00 00    	jne    15ff3 <con_write+0x466>
			origin += video_size_row;
   15eea:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   15eef:	8b 35 f8 0c 02 00    	mov    0x20cf8,%esi
   15ef5:	01 c6                	add    %eax,%esi
   15ef7:	89 35 f8 0c 02 00    	mov    %esi,0x20cf8
			pos += video_size_row;
   15efd:	8b 0d 00 0d 02 00    	mov    0x20d00,%ecx
   15f03:	01 c1                	add    %eax,%ecx
   15f05:	89 8c 24 bc 00 00 00 	mov    %ecx,0xbc(%esp)
   15f0c:	89 0d 00 0d 02 00    	mov    %ecx,0x20d00
			scr_end += video_size_row;
   15f12:	03 05 fc 0c 02 00    	add    0x20cfc,%eax
   15f18:	89 84 24 b8 00 00 00 	mov    %eax,0xb8(%esp)
   15f1f:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
			if (scr_end > video_mem_end) {
   15f24:	3b 05 ec 0c 02 00    	cmp    0x20cec,%eax
   15f2a:	76 4e                	jbe    15f7a <con_write+0x3ed>
				__asm__("cld\n\t"
   15f2c:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   15f32:	8d 4a ff             	lea    -0x1(%edx),%ecx
   15f35:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   15f3c:	d1 e9                	shr    %ecx
   15f3e:	8b 1d e8 0c 02 00    	mov    0x20ce8,%ebx
   15f44:	89 df                	mov    %ebx,%edi
   15f46:	fc                   	cld    
   15f47:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   15f49:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   15f4f:	f3 66 ab             	rep stos %ax,%es:(%edi)
				scr_end -= origin-video_mem_start;
   15f52:	89 f2                	mov    %esi,%edx
   15f54:	29 da                	sub    %ebx,%edx
   15f56:	8b 84 24 b8 00 00 00 	mov    0xb8(%esp),%eax
   15f5d:	29 d0                	sub    %edx,%eax
   15f5f:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
				pos -= origin-video_mem_start;
   15f64:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
   15f6b:	29 d0                	sub    %edx,%eax
   15f6d:	a3 00 0d 02 00       	mov    %eax,0x20d00
				origin = video_mem_start;
   15f72:	89 1d f8 0c 02 00    	mov    %ebx,0x20cf8
   15f78:	eb 1e                	jmp    15f98 <con_write+0x40b>
				__asm__("cld\n\t"
   15f7a:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   15f80:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   15f86:	8b 15 fc 0c 02 00    	mov    0x20cfc,%edx
   15f8c:	2b 15 dc 0c 02 00    	sub    0x20cdc,%edx
   15f92:	89 d7                	mov    %edx,%edi
   15f94:	fc                   	cld    
   15f95:	f3 66 ab             	rep stos %ax,%es:(%edi)
	cli();
   15f98:	fa                   	cli    
	outb_p(12, video_port_reg);
   15f99:	b8 0c 00 00 00       	mov    $0xc,%eax
   15f9e:	66 8b 0d f0 0c 02 00 	mov    0x20cf0,%cx
   15fa5:	89 ca                	mov    %ecx,%edx
   15fa7:	ee                   	out    %al,(%dx)
   15fa8:	eb 00                	jmp    15faa <con_write+0x41d>
   15faa:	eb 00                	jmp    15fac <con_write+0x41f>
	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
   15fac:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   15fb1:	89 c3                	mov    %eax,%ebx
   15fb3:	2b 1d e8 0c 02 00    	sub    0x20ce8,%ebx
   15fb9:	89 d8                	mov    %ebx,%eax
   15fbb:	c1 e8 09             	shr    $0x9,%eax
   15fbe:	25 ff 00 00 00       	and    $0xff,%eax
   15fc3:	66 8b 35 f2 0c 02 00 	mov    0x20cf2,%si
   15fca:	89 f2                	mov    %esi,%edx
   15fcc:	ee                   	out    %al,(%dx)
   15fcd:	eb 00                	jmp    15fcf <con_write+0x442>
   15fcf:	eb 00                	jmp    15fd1 <con_write+0x444>
	outb_p(13, video_port_reg);
   15fd1:	b8 0d 00 00 00       	mov    $0xd,%eax
   15fd6:	89 ca                	mov    %ecx,%edx
   15fd8:	ee                   	out    %al,(%dx)
   15fd9:	eb 00                	jmp    15fdb <con_write+0x44e>
   15fdb:	eb 00                	jmp    15fdd <con_write+0x450>
	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
   15fdd:	89 d8                	mov    %ebx,%eax
   15fdf:	d1 e8                	shr    %eax
   15fe1:	25 ff 00 00 00       	and    $0xff,%eax
   15fe6:	89 f2                	mov    %esi,%edx
   15fe8:	ee                   	out    %al,(%dx)
   15fe9:	eb 00                	jmp    15feb <con_write+0x45e>
   15feb:	eb 00                	jmp    15fed <con_write+0x460>
	sti();
   15fed:	fb                   	sti    
   15fee:	e9 9e 12 00 00       	jmp    17291 <con_write+0x1704>
			__asm__("cld\n\t"
   15ff3:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   15ffa:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   16000:	89 f1                	mov    %esi,%ecx
   16002:	f7 d1                	not    %ecx
   16004:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   1600a:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   16011:	d1 e9                	shr    %ecx
   16013:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   16018:	0f af 05 0c 0d 02 00 	imul   0x20d0c,%eax
   1601f:	89 84 24 b4 00 00 00 	mov    %eax,0xb4(%esp)
   16026:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   1602b:	8b 9c 24 b4 00 00 00 	mov    0xb4(%esp),%ebx
   16032:	01 c3                	add    %eax,%ebx
   16034:	89 9c 24 b0 00 00 00 	mov    %ebx,0xb0(%esp)
   1603b:	46                   	inc    %esi
   1603c:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   16043:	01 c6                	add    %eax,%esi
   16045:	89 d0                	mov    %edx,%eax
   16047:	89 df                	mov    %ebx,%edi
   16049:	fc                   	cld    
   1604a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1604c:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16052:	f3 66 ab             	rep stos %ax,%es:(%edi)
   16055:	e9 37 12 00 00       	jmp    17291 <con_write+0x1704>
		__asm__("cld\n\t"
   1605a:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   16061:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   16067:	89 f1                	mov    %esi,%ecx
   16069:	f7 d1                	not    %ecx
   1606b:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   16071:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   16078:	d1 e9                	shr    %ecx
   1607a:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   1607f:	0f af 05 0c 0d 02 00 	imul   0x20d0c,%eax
   16086:	89 84 24 ac 00 00 00 	mov    %eax,0xac(%esp)
   1608d:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   16092:	8b 9c 24 ac 00 00 00 	mov    0xac(%esp),%ebx
   16099:	01 c3                	add    %eax,%ebx
   1609b:	89 9c 24 a8 00 00 00 	mov    %ebx,0xa8(%esp)
   160a2:	46                   	inc    %esi
   160a3:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   160aa:	01 c6                	add    %eax,%esi
   160ac:	89 d0                	mov    %edx,%eax
   160ae:	89 df                	mov    %ebx,%edi
   160b0:	fc                   	cld    
   160b1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   160b3:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   160b9:	f3 66 ab             	rep stos %ax,%es:(%edi)
   160bc:	e9 d0 11 00 00       	jmp    17291 <con_write+0x1704>
				else if (c==13)
   160c1:	80 bc 24 cb 00 00 00 	cmpb   $0xd,0xcb(%esp)
   160c8:	0d 
   160c9:	75 1c                	jne    160e7 <con_write+0x55a>
	pos -= x<<1;
   160cb:	a1 04 0d 02 00       	mov    0x20d04,%eax
   160d0:	d1 e0                	shl    %eax
   160d2:	29 05 00 0d 02 00    	sub    %eax,0x20d00
	x=0;
   160d8:	c7 05 04 0d 02 00 00 	movl   $0x0,0x20d04
   160df:	00 00 00 
   160e2:	e9 aa 11 00 00       	jmp    17291 <con_write+0x1704>
				else if (c==ERASE_CHAR(tty))
   160e7:	0f be 94 24 cb 00 00 	movsbl 0xcb(%esp),%edx
   160ee:	00 
   160ef:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
   160f6:	0f b6 41 13          	movzbl 0x13(%ecx),%eax
   160fa:	39 c2                	cmp    %eax,%edx
   160fc:	75 31                	jne    1612f <con_write+0x5a2>
	if (x) {
   160fe:	83 3d 04 0d 02 00 00 	cmpl   $0x0,0x20d04
   16105:	0f 84 86 11 00 00    	je     17291 <con_write+0x1704>
		pos -= 2;
   1610b:	a1 00 0d 02 00       	mov    0x20d00,%eax
   16110:	8d 50 fe             	lea    -0x2(%eax),%edx
   16113:	89 15 00 0d 02 00    	mov    %edx,0x20d00
		x--;
   16119:	ff 0d 04 0d 02 00    	decl   0x20d04
		*(unsigned short *)pos = video_erase_char;
   1611f:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   16126:	66 89 50 fe          	mov    %dx,-0x2(%eax)
   1612a:	e9 62 11 00 00       	jmp    17291 <con_write+0x1704>
				else if (c==8) {
   1612f:	80 bc 24 cb 00 00 00 	cmpb   $0x8,0xcb(%esp)
   16136:	08 
   16137:	75 1f                	jne    16158 <con_write+0x5cb>
					if (x) {
   16139:	83 3d 04 0d 02 00 00 	cmpl   $0x0,0x20d04
   16140:	0f 84 4b 11 00 00    	je     17291 <con_write+0x1704>
						x--;
   16146:	ff 0d 04 0d 02 00    	decl   0x20d04
						pos -= 2;
   1614c:	83 2d 00 0d 02 00 02 	subl   $0x2,0x20d00
   16153:	e9 39 11 00 00       	jmp    17291 <con_write+0x1704>
				} else if (c==9) {
   16158:	80 bc 24 cb 00 00 00 	cmpb   $0x9,0xcb(%esp)
   1615f:	09 
   16160:	0f 85 52 02 00 00    	jne    163b8 <con_write+0x82b>
					c=8-(x&7);
   16166:	8b 0d 04 0d 02 00    	mov    0x20d04,%ecx
   1616c:	88 ca                	mov    %cl,%dl
   1616e:	83 e2 07             	and    $0x7,%edx
   16171:	b0 08                	mov    $0x8,%al
   16173:	28 d0                	sub    %dl,%al
					x += c;
   16175:	0f be d0             	movsbl %al,%edx
   16178:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
   1617b:	89 0d 04 0d 02 00    	mov    %ecx,0x20d04
					pos += c<<1;
   16181:	a1 00 0d 02 00       	mov    0x20d00,%eax
   16186:	8d 14 50             	lea    (%eax,%edx,2),%edx
   16189:	89 15 00 0d 02 00    	mov    %edx,0x20d00
					if (x>video_num_columns) {
   1618f:	3b 0d d8 0c 02 00    	cmp    0x20cd8,%ecx
   16195:	0f 86 f6 10 00 00    	jbe    17291 <con_write+0x1704>
						x -= video_num_columns;
   1619b:	89 c8                	mov    %ecx,%eax
   1619d:	2b 05 d8 0c 02 00    	sub    0x20cd8,%eax
   161a3:	a3 04 0d 02 00       	mov    %eax,0x20d04
						pos -= video_size_row;
   161a8:	8b 1d dc 0c 02 00    	mov    0x20cdc,%ebx
   161ae:	89 d0                	mov    %edx,%eax
   161b0:	29 d8                	sub    %ebx,%eax
   161b2:	a3 00 0d 02 00       	mov    %eax,0x20d00
	if (y+1<bottom) {
   161b7:	8b 0d 08 0d 02 00    	mov    0x20d08,%ecx
   161bd:	41                   	inc    %ecx
   161be:	3b 0d 10 0d 02 00    	cmp    0x20d10,%ecx
   161c4:	73 12                	jae    161d8 <con_write+0x64b>
		y++;
   161c6:	89 0d 08 0d 02 00    	mov    %ecx,0x20d08
		pos += video_size_row;
   161cc:	01 d8                	add    %ebx,%eax
   161ce:	a3 00 0d 02 00       	mov    %eax,0x20d00
   161d3:	e9 b9 10 00 00       	jmp    17291 <con_write+0x1704>
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   161d8:	a0 d4 0c 02 00       	mov    0x20cd4,%al
   161dd:	83 e8 20             	sub    $0x20,%eax
   161e0:	3c 01                	cmp    $0x1,%al
   161e2:	0f 87 7c 01 00 00    	ja     16364 <con_write+0x7d7>
		if (!top && bottom == video_num_lines) {
   161e8:	83 3d 0c 0d 02 00 00 	cmpl   $0x0,0x20d0c
   161ef:	0f 85 1b 01 00 00    	jne    16310 <con_write+0x783>
   161f5:	8b 15 10 0d 02 00    	mov    0x20d10,%edx
   161fb:	3b 15 e0 0c 02 00    	cmp    0x20ce0,%edx
   16201:	0f 85 09 01 00 00    	jne    16310 <con_write+0x783>
			origin += video_size_row;
   16207:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   1620c:	8b 35 f8 0c 02 00    	mov    0x20cf8,%esi
   16212:	01 c6                	add    %eax,%esi
   16214:	89 35 f8 0c 02 00    	mov    %esi,0x20cf8
			pos += video_size_row;
   1621a:	8b 1d 00 0d 02 00    	mov    0x20d00,%ebx
   16220:	01 c3                	add    %eax,%ebx
   16222:	89 9c 24 a4 00 00 00 	mov    %ebx,0xa4(%esp)
   16229:	89 1d 00 0d 02 00    	mov    %ebx,0x20d00
			scr_end += video_size_row;
   1622f:	03 05 fc 0c 02 00    	add    0x20cfc,%eax
   16235:	89 84 24 a0 00 00 00 	mov    %eax,0xa0(%esp)
   1623c:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
			if (scr_end > video_mem_end) {
   16241:	3b 05 ec 0c 02 00    	cmp    0x20cec,%eax
   16247:	76 4e                	jbe    16297 <con_write+0x70a>
				__asm__("cld\n\t"
   16249:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   1624f:	8d 4a ff             	lea    -0x1(%edx),%ecx
   16252:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   16259:	d1 e9                	shr    %ecx
   1625b:	8b 1d e8 0c 02 00    	mov    0x20ce8,%ebx
   16261:	89 df                	mov    %ebx,%edi
   16263:	fc                   	cld    
   16264:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   16266:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   1626c:	f3 66 ab             	rep stos %ax,%es:(%edi)
				scr_end -= origin-video_mem_start;
   1626f:	89 f2                	mov    %esi,%edx
   16271:	29 da                	sub    %ebx,%edx
   16273:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
   1627a:	29 d0                	sub    %edx,%eax
   1627c:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
				pos -= origin-video_mem_start;
   16281:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
   16288:	29 d0                	sub    %edx,%eax
   1628a:	a3 00 0d 02 00       	mov    %eax,0x20d00
				origin = video_mem_start;
   1628f:	89 1d f8 0c 02 00    	mov    %ebx,0x20cf8
   16295:	eb 1e                	jmp    162b5 <con_write+0x728>
				__asm__("cld\n\t"
   16297:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   1629d:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   162a3:	8b 15 fc 0c 02 00    	mov    0x20cfc,%edx
   162a9:	2b 15 dc 0c 02 00    	sub    0x20cdc,%edx
   162af:	89 d7                	mov    %edx,%edi
   162b1:	fc                   	cld    
   162b2:	f3 66 ab             	rep stos %ax,%es:(%edi)
	cli();
   162b5:	fa                   	cli    
	outb_p(12, video_port_reg);
   162b6:	b8 0c 00 00 00       	mov    $0xc,%eax
   162bb:	66 8b 0d f0 0c 02 00 	mov    0x20cf0,%cx
   162c2:	89 ca                	mov    %ecx,%edx
   162c4:	ee                   	out    %al,(%dx)
   162c5:	eb 00                	jmp    162c7 <con_write+0x73a>
   162c7:	eb 00                	jmp    162c9 <con_write+0x73c>
	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
   162c9:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   162ce:	89 c3                	mov    %eax,%ebx
   162d0:	2b 1d e8 0c 02 00    	sub    0x20ce8,%ebx
   162d6:	89 d8                	mov    %ebx,%eax
   162d8:	c1 e8 09             	shr    $0x9,%eax
   162db:	25 ff 00 00 00       	and    $0xff,%eax
   162e0:	66 8b 35 f2 0c 02 00 	mov    0x20cf2,%si
   162e7:	89 f2                	mov    %esi,%edx
   162e9:	ee                   	out    %al,(%dx)
   162ea:	eb 00                	jmp    162ec <con_write+0x75f>
   162ec:	eb 00                	jmp    162ee <con_write+0x761>
	outb_p(13, video_port_reg);
   162ee:	b8 0d 00 00 00       	mov    $0xd,%eax
   162f3:	89 ca                	mov    %ecx,%edx
   162f5:	ee                   	out    %al,(%dx)
   162f6:	eb 00                	jmp    162f8 <con_write+0x76b>
   162f8:	eb 00                	jmp    162fa <con_write+0x76d>
	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
   162fa:	89 d8                	mov    %ebx,%eax
   162fc:	d1 e8                	shr    %eax
   162fe:	25 ff 00 00 00       	and    $0xff,%eax
   16303:	89 f2                	mov    %esi,%edx
   16305:	ee                   	out    %al,(%dx)
   16306:	eb 00                	jmp    16308 <con_write+0x77b>
   16308:	eb 00                	jmp    1630a <con_write+0x77d>
	sti();
   1630a:	fb                   	sti    
   1630b:	e9 81 0f 00 00       	jmp    17291 <con_write+0x1704>
			__asm__("cld\n\t"
   16310:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   16317:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   1631d:	89 f1                	mov    %esi,%ecx
   1631f:	f7 d1                	not    %ecx
   16321:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   16327:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   1632e:	d1 e9                	shr    %ecx
   16330:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   16335:	89 c3                	mov    %eax,%ebx
   16337:	0f af 1d 0c 0d 02 00 	imul   0x20d0c,%ebx
   1633e:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   16343:	01 c3                	add    %eax,%ebx
   16345:	46                   	inc    %esi
   16346:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   1634d:	01 c6                	add    %eax,%esi
   1634f:	89 d0                	mov    %edx,%eax
   16351:	89 df                	mov    %ebx,%edi
   16353:	fc                   	cld    
   16354:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   16356:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   1635c:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1635f:	e9 2d 0f 00 00       	jmp    17291 <con_write+0x1704>
		__asm__("cld\n\t"
   16364:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   1636b:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   16371:	89 f1                	mov    %esi,%ecx
   16373:	f7 d1                	not    %ecx
   16375:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   1637b:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   16382:	d1 e9                	shr    %ecx
   16384:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   16389:	89 c3                	mov    %eax,%ebx
   1638b:	0f af 1d 0c 0d 02 00 	imul   0x20d0c,%ebx
   16392:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   16397:	01 c3                	add    %eax,%ebx
   16399:	46                   	inc    %esi
   1639a:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   163a1:	01 c6                	add    %eax,%esi
   163a3:	89 d0                	mov    %edx,%eax
   163a5:	89 df                	mov    %ebx,%edi
   163a7:	fc                   	cld    
   163a8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   163aa:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   163b0:	f3 66 ab             	rep stos %ax,%es:(%edi)
					c=9;
   163b3:	e9 d9 0e 00 00       	jmp    17291 <con_write+0x1704>
				} else if (c==7)
   163b8:	80 bc 24 cb 00 00 00 	cmpb   $0x7,0xcb(%esp)
   163bf:	07 
   163c0:	0f 85 cb 0e 00 00    	jne    17291 <con_write+0x1704>
					sysbeep();
   163c6:	e8 fd 10 00 00       	call   174c8 <sysbeep>
				break;
   163cb:	e9 c1 0e 00 00       	jmp    17291 <con_write+0x1704>
				state=0;
   163d0:	c7 05 c4 0c 02 00 00 	movl   $0x0,0x20cc4
   163d7:	00 00 00 
				if (c=='[')
   163da:	80 bc 24 cb 00 00 00 	cmpb   $0x5b,0xcb(%esp)
   163e1:	5b 
   163e2:	75 0f                	jne    163f3 <con_write+0x866>
					state=2;
   163e4:	c7 05 c4 0c 02 00 02 	movl   $0x2,0x20cc4
   163eb:	00 00 00 
   163ee:	e9 9e 0e 00 00       	jmp    17291 <con_write+0x1704>
				else if (c=='E')
   163f3:	80 bc 24 cb 00 00 00 	cmpb   $0x45,0xcb(%esp)
   163fa:	45 
   163fb:	75 38                	jne    16435 <con_write+0x8a8>
{
   163fd:	a1 08 0d 02 00       	mov    0x20d08,%eax
   16402:	40                   	inc    %eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16403:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16409:	0f 83 82 0e 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   1640f:	c7 05 04 0d 02 00 00 	movl   $0x0,0x20d04
   16416:	00 00 00 
	y=new_y;
   16419:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   1641e:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16425:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   1642b:	a3 00 0d 02 00       	mov    %eax,0x20d00
   16430:	e9 5c 0e 00 00       	jmp    17291 <con_write+0x1704>
				else if (c=='M')
   16435:	80 bc 24 cb 00 00 00 	cmpb   $0x4d,0xcb(%esp)
   1643c:	4d 
   1643d:	0f 85 e8 00 00 00    	jne    1652b <con_write+0x99e>
	if (y>top) {
   16443:	a1 08 0d 02 00       	mov    0x20d08,%eax
   16448:	3b 05 0c 0d 02 00    	cmp    0x20d0c,%eax
   1644e:	76 1b                	jbe    1646b <con_write+0x8de>
		y--;
   16450:	48                   	dec    %eax
   16451:	a3 08 0d 02 00       	mov    %eax,0x20d08
		pos -= video_size_row;
   16456:	a1 00 0d 02 00       	mov    0x20d00,%eax
   1645b:	2b 05 dc 0c 02 00    	sub    0x20cdc,%eax
   16461:	a3 00 0d 02 00       	mov    %eax,0x20d00
   16466:	e9 26 0e 00 00       	jmp    17291 <con_write+0x1704>
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   1646b:	a0 d4 0c 02 00       	mov    0x20cd4,%al
   16470:	83 e8 20             	sub    $0x20,%eax
   16473:	3c 01                	cmp    $0x1,%al
   16475:	77 5a                	ja     164d1 <con_write+0x944>
		__asm__("std\n\t"
   16477:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   1647e:	8b 35 10 0d 02 00    	mov    0x20d10,%esi
   16484:	89 f1                	mov    %esi,%ecx
   16486:	2b 0d 0c 0d 02 00    	sub    0x20d0c,%ecx
   1648c:	49                   	dec    %ecx
   1648d:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   16494:	d1 e9                	shr    %ecx
   16496:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   1649b:	89 c3                	mov    %eax,%ebx
   1649d:	0f af 1d 10 0d 02 00 	imul   0x20d10,%ebx
   164a4:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   164a9:	8d 5c 03 fc          	lea    -0x4(%ebx,%eax,1),%ebx
   164ad:	4e                   	dec    %esi
   164ae:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   164b5:	8d 74 06 fc          	lea    -0x4(%esi,%eax,1),%esi
   164b9:	89 d0                	mov    %edx,%eax
   164bb:	89 df                	mov    %ebx,%edi
   164bd:	fd                   	std    
   164be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   164c0:	83 c7 02             	add    $0x2,%edi
   164c3:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   164c9:	f3 66 ab             	rep stos %ax,%es:(%edi)
   164cc:	e9 c0 0d 00 00       	jmp    17291 <con_write+0x1704>
		__asm__("std\n\t"
   164d1:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   164d8:	8b 35 10 0d 02 00    	mov    0x20d10,%esi
   164de:	89 f1                	mov    %esi,%ecx
   164e0:	2b 0d 0c 0d 02 00    	sub    0x20d0c,%ecx
   164e6:	49                   	dec    %ecx
   164e7:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   164ee:	d1 e9                	shr    %ecx
   164f0:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   164f5:	89 c3                	mov    %eax,%ebx
   164f7:	0f af 1d 10 0d 02 00 	imul   0x20d10,%ebx
   164fe:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   16503:	8d 5c 03 fc          	lea    -0x4(%ebx,%eax,1),%ebx
   16507:	4e                   	dec    %esi
   16508:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   1650f:	8d 74 06 fc          	lea    -0x4(%esi,%eax,1),%esi
   16513:	89 d0                	mov    %edx,%eax
   16515:	89 df                	mov    %ebx,%edi
   16517:	fd                   	std    
   16518:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1651a:	83 c7 02             	add    $0x2,%edi
   1651d:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16523:	f3 66 ab             	rep stos %ax,%es:(%edi)
   16526:	e9 66 0d 00 00       	jmp    17291 <con_write+0x1704>
				else if (c=='D')
   1652b:	80 bc 24 cb 00 00 00 	cmpb   $0x44,0xcb(%esp)
   16532:	44 
   16533:	0f 85 08 02 00 00    	jne    16741 <con_write+0xbb4>
	if (y+1<bottom) {
   16539:	a1 08 0d 02 00       	mov    0x20d08,%eax
   1653e:	40                   	inc    %eax
   1653f:	3b 05 10 0d 02 00    	cmp    0x20d10,%eax
   16545:	73 1a                	jae    16561 <con_write+0x9d4>
		y++;
   16547:	a3 08 0d 02 00       	mov    %eax,0x20d08
		pos += video_size_row;
   1654c:	a1 00 0d 02 00       	mov    0x20d00,%eax
   16551:	03 05 dc 0c 02 00    	add    0x20cdc,%eax
   16557:	a3 00 0d 02 00       	mov    %eax,0x20d00
   1655c:	e9 30 0d 00 00       	jmp    17291 <con_write+0x1704>
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   16561:	a0 d4 0c 02 00       	mov    0x20cd4,%al
   16566:	83 e8 20             	sub    $0x20,%eax
   16569:	3c 01                	cmp    $0x1,%al
   1656b:	0f 87 7c 01 00 00    	ja     166ed <con_write+0xb60>
		if (!top && bottom == video_num_lines) {
   16571:	83 3d 0c 0d 02 00 00 	cmpl   $0x0,0x20d0c
   16578:	0f 85 1b 01 00 00    	jne    16699 <con_write+0xb0c>
   1657e:	8b 15 10 0d 02 00    	mov    0x20d10,%edx
   16584:	3b 15 e0 0c 02 00    	cmp    0x20ce0,%edx
   1658a:	0f 85 09 01 00 00    	jne    16699 <con_write+0xb0c>
			origin += video_size_row;
   16590:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   16595:	8b 35 f8 0c 02 00    	mov    0x20cf8,%esi
   1659b:	01 c6                	add    %eax,%esi
   1659d:	89 35 f8 0c 02 00    	mov    %esi,0x20cf8
			pos += video_size_row;
   165a3:	8b 0d 00 0d 02 00    	mov    0x20d00,%ecx
   165a9:	01 c1                	add    %eax,%ecx
   165ab:	89 8c 24 9c 00 00 00 	mov    %ecx,0x9c(%esp)
   165b2:	89 0d 00 0d 02 00    	mov    %ecx,0x20d00
			scr_end += video_size_row;
   165b8:	03 05 fc 0c 02 00    	add    0x20cfc,%eax
   165be:	89 84 24 98 00 00 00 	mov    %eax,0x98(%esp)
   165c5:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
			if (scr_end > video_mem_end) {
   165ca:	3b 05 ec 0c 02 00    	cmp    0x20cec,%eax
   165d0:	76 4e                	jbe    16620 <con_write+0xa93>
				__asm__("cld\n\t"
   165d2:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   165d8:	8d 4a ff             	lea    -0x1(%edx),%ecx
   165db:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   165e2:	d1 e9                	shr    %ecx
   165e4:	8b 1d e8 0c 02 00    	mov    0x20ce8,%ebx
   165ea:	89 df                	mov    %ebx,%edi
   165ec:	fc                   	cld    
   165ed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   165ef:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   165f5:	f3 66 ab             	rep stos %ax,%es:(%edi)
				scr_end -= origin-video_mem_start;
   165f8:	89 f2                	mov    %esi,%edx
   165fa:	29 da                	sub    %ebx,%edx
   165fc:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
   16603:	29 d0                	sub    %edx,%eax
   16605:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
				pos -= origin-video_mem_start;
   1660a:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
   16611:	29 d0                	sub    %edx,%eax
   16613:	a3 00 0d 02 00       	mov    %eax,0x20d00
				origin = video_mem_start;
   16618:	89 1d f8 0c 02 00    	mov    %ebx,0x20cf8
   1661e:	eb 1e                	jmp    1663e <con_write+0xab1>
				__asm__("cld\n\t"
   16620:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   16626:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   1662c:	8b 15 fc 0c 02 00    	mov    0x20cfc,%edx
   16632:	2b 15 dc 0c 02 00    	sub    0x20cdc,%edx
   16638:	89 d7                	mov    %edx,%edi
   1663a:	fc                   	cld    
   1663b:	f3 66 ab             	rep stos %ax,%es:(%edi)
	cli();
   1663e:	fa                   	cli    
	outb_p(12, video_port_reg);
   1663f:	b8 0c 00 00 00       	mov    $0xc,%eax
   16644:	66 8b 0d f0 0c 02 00 	mov    0x20cf0,%cx
   1664b:	89 ca                	mov    %ecx,%edx
   1664d:	ee                   	out    %al,(%dx)
   1664e:	eb 00                	jmp    16650 <con_write+0xac3>
   16650:	eb 00                	jmp    16652 <con_write+0xac5>
	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
   16652:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   16657:	89 c3                	mov    %eax,%ebx
   16659:	2b 1d e8 0c 02 00    	sub    0x20ce8,%ebx
   1665f:	89 d8                	mov    %ebx,%eax
   16661:	c1 e8 09             	shr    $0x9,%eax
   16664:	25 ff 00 00 00       	and    $0xff,%eax
   16669:	66 8b 35 f2 0c 02 00 	mov    0x20cf2,%si
   16670:	89 f2                	mov    %esi,%edx
   16672:	ee                   	out    %al,(%dx)
   16673:	eb 00                	jmp    16675 <con_write+0xae8>
   16675:	eb 00                	jmp    16677 <con_write+0xaea>
	outb_p(13, video_port_reg);
   16677:	b8 0d 00 00 00       	mov    $0xd,%eax
   1667c:	89 ca                	mov    %ecx,%edx
   1667e:	ee                   	out    %al,(%dx)
   1667f:	eb 00                	jmp    16681 <con_write+0xaf4>
   16681:	eb 00                	jmp    16683 <con_write+0xaf6>
	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
   16683:	89 d8                	mov    %ebx,%eax
   16685:	d1 e8                	shr    %eax
   16687:	25 ff 00 00 00       	and    $0xff,%eax
   1668c:	89 f2                	mov    %esi,%edx
   1668e:	ee                   	out    %al,(%dx)
   1668f:	eb 00                	jmp    16691 <con_write+0xb04>
   16691:	eb 00                	jmp    16693 <con_write+0xb06>
	sti();
   16693:	fb                   	sti    
   16694:	e9 f8 0b 00 00       	jmp    17291 <con_write+0x1704>
			__asm__("cld\n\t"
   16699:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   166a0:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   166a6:	89 f1                	mov    %esi,%ecx
   166a8:	f7 d1                	not    %ecx
   166aa:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   166b0:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   166b7:	d1 e9                	shr    %ecx
   166b9:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   166be:	89 c3                	mov    %eax,%ebx
   166c0:	0f af 1d 0c 0d 02 00 	imul   0x20d0c,%ebx
   166c7:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   166cc:	01 c3                	add    %eax,%ebx
   166ce:	46                   	inc    %esi
   166cf:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   166d6:	01 c6                	add    %eax,%esi
   166d8:	89 d0                	mov    %edx,%eax
   166da:	89 df                	mov    %ebx,%edi
   166dc:	fc                   	cld    
   166dd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   166df:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   166e5:	f3 66 ab             	rep stos %ax,%es:(%edi)
   166e8:	e9 a4 0b 00 00       	jmp    17291 <con_write+0x1704>
		__asm__("cld\n\t"
   166ed:	66 8b 15 f4 0c 02 00 	mov    0x20cf4,%dx
   166f4:	8b 35 0c 0d 02 00    	mov    0x20d0c,%esi
   166fa:	89 f1                	mov    %esi,%ecx
   166fc:	f7 d1                	not    %ecx
   166fe:	03 0d 10 0d 02 00    	add    0x20d10,%ecx
   16704:	0f af 0d d8 0c 02 00 	imul   0x20cd8,%ecx
   1670b:	d1 e9                	shr    %ecx
   1670d:	a1 dc 0c 02 00       	mov    0x20cdc,%eax
   16712:	89 c3                	mov    %eax,%ebx
   16714:	0f af 1d 0c 0d 02 00 	imul   0x20d0c,%ebx
   1671b:	a1 f8 0c 02 00       	mov    0x20cf8,%eax
   16720:	01 c3                	add    %eax,%ebx
   16722:	46                   	inc    %esi
   16723:	0f af 35 dc 0c 02 00 	imul   0x20cdc,%esi
   1672a:	01 c6                	add    %eax,%esi
   1672c:	89 d0                	mov    %edx,%eax
   1672e:	89 df                	mov    %ebx,%edi
   16730:	fc                   	cld    
   16731:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   16733:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16739:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1673c:	e9 50 0b 00 00       	jmp    17291 <con_write+0x1704>
				else if (c=='Z')
   16741:	80 bc 24 cb 00 00 00 	cmpb   $0x5a,0xcb(%esp)
   16748:	5a 
   16749:	75 40                	jne    1678b <con_write+0xbfe>
{
   1674b:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
	char * p = RESPONSE;
   16752:	bb c0 99 01 00       	mov    $0x199c0,%ebx
	cli();
   16757:	fa                   	cli    
		p++;
   16758:	80 3d c0 99 01 00 00 	cmpb   $0x0,0x199c0
   1675f:	74 18                	je     16779 <con_write+0xbec>
		PUTCH(*p,tty->read_q);
   16761:	8b 41 34             	mov    0x34(%ecx),%eax
   16764:	8a 13                	mov    (%ebx),%dl
   16766:	88 54 08 40          	mov    %dl,0x40(%eax,%ecx,1)
   1676a:	40                   	inc    %eax
   1676b:	25 ff 03 00 00       	and    $0x3ff,%eax
   16770:	89 41 34             	mov    %eax,0x34(%ecx)
		p++;
   16773:	43                   	inc    %ebx
   16774:	80 3b 00             	cmpb   $0x0,(%ebx)
   16777:	75 e8                	jne    16761 <con_write+0xbd4>
	sti();
   16779:	fb                   	sti    
	copy_to_cooked(tty);
   1677a:	83 ec 0c             	sub    $0xc,%esp
   1677d:	51                   	push   %ecx
   1677e:	e8 72 eb ff ff       	call   152f5 <copy_to_cooked>
   16783:	83 c4 10             	add    $0x10,%esp
   16786:	e9 06 0b 00 00       	jmp    17291 <con_write+0x1704>
				else if (x=='7')
   1678b:	83 3d 04 0d 02 00 37 	cmpl   $0x37,0x20d04
   16792:	75 19                	jne    167ad <con_write+0xc20>
	saved_x=x;
   16794:	c7 05 cc 0c 02 00 37 	movl   $0x37,0x20ccc
   1679b:	00 00 00 
	saved_y=y;
   1679e:	a1 08 0d 02 00       	mov    0x20d08,%eax
   167a3:	a3 d0 0c 02 00       	mov    %eax,0x20cd0
   167a8:	e9 e4 0a 00 00       	jmp    17291 <con_write+0x1704>
				else if (x=='8')
   167ad:	83 3d 04 0d 02 00 38 	cmpl   $0x38,0x20d04
   167b4:	0f 85 d7 0a 00 00    	jne    17291 <con_write+0x1704>
{
   167ba:	8b 15 cc 0c 02 00    	mov    0x20ccc,%edx
   167c0:	a1 d0 0c 02 00       	mov    0x20cd0,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   167c5:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   167cb:	0f 87 c0 0a 00 00    	ja     17291 <con_write+0x1704>
   167d1:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   167d7:	0f 83 b4 0a 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   167dd:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	y=new_y;
   167e3:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   167e8:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   167ef:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   167f5:	8d 04 50             	lea    (%eax,%edx,2),%eax
   167f8:	a3 00 0d 02 00       	mov    %eax,0x20d00
				break;
   167fd:	e9 8f 0a 00 00       	jmp    17291 <con_write+0x1704>
				for(npar=0;npar<NPAR;npar++)
   16802:	c7 05 14 0d 02 00 00 	movl   $0x0,0x20d14
   16809:	00 00 00 
   1680c:	ba 20 0d 02 00       	mov    $0x20d20,%edx
   16811:	b8 00 00 00 00       	mov    $0x0,%eax
					par[npar]=0;
   16816:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
				for(npar=0;npar<NPAR;npar++)
   1681d:	40                   	inc    %eax
   1681e:	83 f8 0f             	cmp    $0xf,%eax
   16821:	76 f3                	jbe    16816 <con_write+0xc89>
				npar=0;
   16823:	c7 05 14 0d 02 00 00 	movl   $0x0,0x20d14
   1682a:	00 00 00 
				state=3;
   1682d:	c7 05 c4 0c 02 00 03 	movl   $0x3,0x20cc4
   16834:	00 00 00 
				if ((ques=(c=='?')))
   16837:	80 bc 24 cb 00 00 00 	cmpb   $0x3f,0xcb(%esp)
   1683e:	3f 
   1683f:	0f 94 c0             	sete   %al
   16842:	0f b6 c0             	movzbl %al,%eax
   16845:	a3 c8 0c 02 00       	mov    %eax,0x20cc8
   1684a:	85 c0                	test   %eax,%eax
   1684c:	0f 85 3f 0a 00 00    	jne    17291 <con_write+0x1704>
				if (c==';' && npar<NPAR-1) {
   16852:	80 bc 24 cb 00 00 00 	cmpb   $0x3b,0xcb(%esp)
   16859:	3b 
   1685a:	75 14                	jne    16870 <con_write+0xce3>
   1685c:	83 3d 14 0d 02 00 0e 	cmpl   $0xe,0x20d14
   16863:	77 0b                	ja     16870 <con_write+0xce3>
					npar++;
   16865:	ff 05 14 0d 02 00    	incl   0x20d14
					break;
   1686b:	e9 21 0a 00 00       	jmp    17291 <con_write+0x1704>
				} else if (c>='0' && c<='9') {
   16870:	8a 84 24 cb 00 00 00 	mov    0xcb(%esp),%al
   16877:	83 e8 30             	sub    $0x30,%eax
   1687a:	3c 09                	cmp    $0x9,%al
   1687c:	77 25                	ja     168a3 <con_write+0xd16>
					par[npar]=10*par[npar]+c-'0';
   1687e:	8b 1d 14 0d 02 00    	mov    0x20d14,%ebx
   16884:	b9 20 0d 02 00       	mov    $0x20d20,%ecx
   16889:	8b 04 99             	mov    (%ecx,%ebx,4),%eax
   1688c:	8d 04 80             	lea    (%eax,%eax,4),%eax
   1688f:	0f be 94 24 cb 00 00 	movsbl 0xcb(%esp),%edx
   16896:	00 
   16897:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
   1689b:	89 04 99             	mov    %eax,(%ecx,%ebx,4)
					break;
   1689e:	e9 ee 09 00 00       	jmp    17291 <con_write+0x1704>
				} else state=4;
   168a3:	c7 05 c4 0c 02 00 04 	movl   $0x4,0x20cc4
   168aa:	00 00 00 
				state=0;
   168ad:	c7 05 c4 0c 02 00 00 	movl   $0x0,0x20cc4
   168b4:	00 00 00 
				switch(c) {
   168b7:	0f be 84 24 cb 00 00 	movsbl 0xcb(%esp),%eax
   168be:	00 
   168bf:	83 e8 40             	sub    $0x40,%eax
   168c2:	83 f8 35             	cmp    $0x35,%eax
   168c5:	0f 87 c6 09 00 00    	ja     17291 <con_write+0x1704>
   168cb:	ff 24 85 78 98 01 00 	jmp    *0x19878(,%eax,4)
						if (par[0]) par[0]--;
   168d2:	83 3d 20 0d 02 00 01 	cmpl   $0x1,0x20d20
   168d9:	a1 20 0d 02 00       	mov    0x20d20,%eax
   168de:	83 d0 ff             	adc    $0xffffffff,%eax
   168e1:	a3 20 0d 02 00       	mov    %eax,0x20d20
{
   168e6:	89 c2                	mov    %eax,%edx
   168e8:	a1 08 0d 02 00       	mov    0x20d08,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   168ed:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   168f3:	0f 87 98 09 00 00    	ja     17291 <con_write+0x1704>
   168f9:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   168ff:	0f 83 8c 09 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   16905:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	pos=origin + y*video_size_row + (x<<1);
   1690b:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16912:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16918:	8d 04 50             	lea    (%eax,%edx,2),%eax
   1691b:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16920:	e9 6c 09 00 00       	jmp    17291 <con_write+0x1704>
						if (!par[0]) par[0]++;
   16925:	83 3d 20 0d 02 00 00 	cmpl   $0x0,0x20d20
   1692c:	75 0a                	jne    16938 <con_write+0xdab>
   1692e:	c7 05 20 0d 02 00 01 	movl   $0x1,0x20d20
   16935:	00 00 00 
{
   16938:	8b 15 04 0d 02 00    	mov    0x20d04,%edx
   1693e:	a1 08 0d 02 00       	mov    0x20d08,%eax
   16943:	2b 05 20 0d 02 00    	sub    0x20d20,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16949:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   1694f:	0f 87 3c 09 00 00    	ja     17291 <con_write+0x1704>
   16955:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   1695b:	0f 83 30 09 00 00    	jae    17291 <con_write+0x1704>
	y=new_y;
   16961:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   16966:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   1696d:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16973:	8d 04 50             	lea    (%eax,%edx,2),%eax
   16976:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   1697b:	e9 11 09 00 00       	jmp    17291 <con_write+0x1704>
						if (!par[0]) par[0]++;
   16980:	83 3d 20 0d 02 00 00 	cmpl   $0x0,0x20d20
   16987:	75 0a                	jne    16993 <con_write+0xe06>
   16989:	c7 05 20 0d 02 00 01 	movl   $0x1,0x20d20
   16990:	00 00 00 
{
   16993:	8b 15 04 0d 02 00    	mov    0x20d04,%edx
   16999:	a1 20 0d 02 00       	mov    0x20d20,%eax
   1699e:	03 05 08 0d 02 00    	add    0x20d08,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   169a4:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   169aa:	0f 87 e1 08 00 00    	ja     17291 <con_write+0x1704>
   169b0:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   169b6:	0f 83 d5 08 00 00    	jae    17291 <con_write+0x1704>
	y=new_y;
   169bc:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   169c1:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   169c8:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   169ce:	8d 04 50             	lea    (%eax,%edx,2),%eax
   169d1:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   169d6:	e9 b6 08 00 00       	jmp    17291 <con_write+0x1704>
						if (!par[0]) par[0]++;
   169db:	83 3d 20 0d 02 00 00 	cmpl   $0x0,0x20d20
   169e2:	75 0a                	jne    169ee <con_write+0xe61>
   169e4:	c7 05 20 0d 02 00 01 	movl   $0x1,0x20d20
   169eb:	00 00 00 
{
   169ee:	a1 20 0d 02 00       	mov    0x20d20,%eax
   169f3:	89 c2                	mov    %eax,%edx
   169f5:	03 15 04 0d 02 00    	add    0x20d04,%edx
   169fb:	a1 08 0d 02 00       	mov    0x20d08,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16a00:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   16a06:	0f 87 85 08 00 00    	ja     17291 <con_write+0x1704>
   16a0c:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16a12:	0f 83 79 08 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   16a18:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	pos=origin + y*video_size_row + (x<<1);
   16a1e:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16a25:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16a2b:	8d 04 50             	lea    (%eax,%edx,2),%eax
   16a2e:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16a33:	e9 59 08 00 00       	jmp    17291 <con_write+0x1704>
						if (!par[0]) par[0]++;
   16a38:	83 3d 20 0d 02 00 00 	cmpl   $0x0,0x20d20
   16a3f:	75 0a                	jne    16a4b <con_write+0xebe>
   16a41:	c7 05 20 0d 02 00 01 	movl   $0x1,0x20d20
   16a48:	00 00 00 
{
   16a4b:	a1 04 0d 02 00       	mov    0x20d04,%eax
   16a50:	89 c2                	mov    %eax,%edx
   16a52:	2b 15 20 0d 02 00    	sub    0x20d20,%edx
   16a58:	a1 08 0d 02 00       	mov    0x20d08,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16a5d:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   16a63:	0f 87 28 08 00 00    	ja     17291 <con_write+0x1704>
   16a69:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16a6f:	0f 83 1c 08 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   16a75:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	pos=origin + y*video_size_row + (x<<1);
   16a7b:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16a82:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16a88:	8d 04 50             	lea    (%eax,%edx,2),%eax
   16a8b:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16a90:	e9 fc 07 00 00       	jmp    17291 <con_write+0x1704>
						if (!par[0]) par[0]++;
   16a95:	83 3d 20 0d 02 00 00 	cmpl   $0x0,0x20d20
   16a9c:	75 0a                	jne    16aa8 <con_write+0xf1b>
   16a9e:	c7 05 20 0d 02 00 01 	movl   $0x1,0x20d20
   16aa5:	00 00 00 
{
   16aa8:	a1 20 0d 02 00       	mov    0x20d20,%eax
   16aad:	03 05 08 0d 02 00    	add    0x20d08,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16ab3:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16ab9:	0f 83 d2 07 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   16abf:	c7 05 04 0d 02 00 00 	movl   $0x0,0x20d04
   16ac6:	00 00 00 
	y=new_y;
   16ac9:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   16ace:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16ad5:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16adb:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16ae0:	e9 ac 07 00 00       	jmp    17291 <con_write+0x1704>
						if (!par[0]) par[0]++;
   16ae5:	83 3d 20 0d 02 00 00 	cmpl   $0x0,0x20d20
   16aec:	75 0a                	jne    16af8 <con_write+0xf6b>
   16aee:	c7 05 20 0d 02 00 01 	movl   $0x1,0x20d20
   16af5:	00 00 00 
{
   16af8:	a1 08 0d 02 00       	mov    0x20d08,%eax
   16afd:	2b 05 20 0d 02 00    	sub    0x20d20,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16b03:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16b09:	0f 83 82 07 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   16b0f:	c7 05 04 0d 02 00 00 	movl   $0x0,0x20d04
   16b16:	00 00 00 
	y=new_y;
   16b19:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   16b1e:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16b25:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16b2b:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16b30:	e9 5c 07 00 00       	jmp    17291 <con_write+0x1704>
						if (par[0]) par[0]--;
   16b35:	83 3d 20 0d 02 00 01 	cmpl   $0x1,0x20d20
   16b3c:	a1 20 0d 02 00       	mov    0x20d20,%eax
   16b41:	83 d0 ff             	adc    $0xffffffff,%eax
   16b44:	a3 20 0d 02 00       	mov    %eax,0x20d20
{
   16b49:	8b 15 04 0d 02 00    	mov    0x20d04,%edx
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16b4f:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   16b55:	0f 87 36 07 00 00    	ja     17291 <con_write+0x1704>
   16b5b:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16b61:	0f 83 2a 07 00 00    	jae    17291 <con_write+0x1704>
	y=new_y;
   16b67:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   16b6c:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16b73:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16b79:	8d 04 50             	lea    (%eax,%edx,2),%eax
   16b7c:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16b81:	e9 0b 07 00 00       	jmp    17291 <con_write+0x1704>
						if (par[0]) par[0]--;
   16b86:	83 3d 20 0d 02 00 01 	cmpl   $0x1,0x20d20
   16b8d:	a1 20 0d 02 00       	mov    0x20d20,%eax
   16b92:	83 d0 ff             	adc    $0xffffffff,%eax
   16b95:	a3 20 0d 02 00       	mov    %eax,0x20d20
						if (par[1]) par[1]--;
   16b9a:	83 3d 24 0d 02 00 01 	cmpl   $0x1,0x20d24
   16ba1:	a1 24 0d 02 00       	mov    0x20d24,%eax
   16ba6:	83 d0 ff             	adc    $0xffffffff,%eax
   16ba9:	a3 24 0d 02 00       	mov    %eax,0x20d24
{
   16bae:	89 c2                	mov    %eax,%edx
   16bb0:	a1 20 0d 02 00       	mov    0x20d20,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   16bb5:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   16bbb:	0f 87 d0 06 00 00    	ja     17291 <con_write+0x1704>
   16bc1:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   16bc7:	0f 83 c4 06 00 00    	jae    17291 <con_write+0x1704>
	x=new_x;
   16bcd:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	y=new_y;
   16bd3:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   16bd8:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16bdf:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   16be5:	8d 04 50             	lea    (%eax,%edx,2),%eax
   16be8:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   16bed:	e9 9f 06 00 00       	jmp    17291 <con_write+0x1704>
{
   16bf2:	a1 20 0d 02 00       	mov    0x20d20,%eax
	switch (par) {
   16bf7:	83 f8 01             	cmp    $0x1,%eax
   16bfa:	74 2d                	je     16c29 <con_write+0x109c>
   16bfc:	83 f8 01             	cmp    $0x1,%eax
   16bff:	7f 09                	jg     16c0a <con_write+0x107d>
   16c01:	85 c0                	test   %eax,%eax
   16c03:	74 0f                	je     16c14 <con_write+0x1087>
   16c05:	e9 87 06 00 00       	jmp    17291 <con_write+0x1704>
   16c0a:	83 f8 02             	cmp    $0x2,%eax
   16c0d:	74 2f                	je     16c3e <con_write+0x10b1>
   16c0f:	e9 7d 06 00 00       	jmp    17291 <con_write+0x1704>
			count = (scr_end-pos)>>1;
   16c14:	8b 15 00 0d 02 00    	mov    0x20d00,%edx
   16c1a:	a1 fc 0c 02 00       	mov    0x20cfc,%eax
   16c1f:	89 c1                	mov    %eax,%ecx
   16c21:	29 d1                	sub    %edx,%ecx
   16c23:	d1 e9                	shr    %ecx
			start = pos;
   16c25:	89 d7                	mov    %edx,%edi
			break;
   16c27:	eb 29                	jmp    16c52 <con_write+0x10c5>
			count = (pos-origin)>>1;
   16c29:	8b 15 f8 0c 02 00    	mov    0x20cf8,%edx
   16c2f:	a1 00 0d 02 00       	mov    0x20d00,%eax
   16c34:	89 c1                	mov    %eax,%ecx
   16c36:	29 d1                	sub    %edx,%ecx
   16c38:	d1 e9                	shr    %ecx
			start = origin;
   16c3a:	89 d7                	mov    %edx,%edi
			break;
   16c3c:	eb 14                	jmp    16c52 <con_write+0x10c5>
			count = video_num_columns * video_num_lines;
   16c3e:	a1 d8 0c 02 00       	mov    0x20cd8,%eax
   16c43:	89 c1                	mov    %eax,%ecx
   16c45:	0f af 0d e0 0c 02 00 	imul   0x20ce0,%ecx
			start = origin;
   16c4c:	8b 3d f8 0c 02 00    	mov    0x20cf8,%edi
	__asm__("cld\n\t"
   16c52:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   16c58:	fc                   	cld    
   16c59:	f3 66 ab             	rep stos %ax,%es:(%edi)
						break;
   16c5c:	e9 30 06 00 00       	jmp    17291 <con_write+0x1704>
{
   16c61:	a1 20 0d 02 00       	mov    0x20d20,%eax
	switch (par) {
   16c66:	83 f8 01             	cmp    $0x1,%eax
   16c69:	74 3b                	je     16ca6 <con_write+0x1119>
   16c6b:	83 f8 01             	cmp    $0x1,%eax
   16c6e:	7f 09                	jg     16c79 <con_write+0x10ec>
   16c70:	85 c0                	test   %eax,%eax
   16c72:	74 0f                	je     16c83 <con_write+0x10f6>
   16c74:	e9 18 06 00 00       	jmp    17291 <con_write+0x1704>
   16c79:	83 f8 02             	cmp    $0x2,%eax
   16c7c:	74 48                	je     16cc6 <con_write+0x1139>
   16c7e:	e9 0e 06 00 00       	jmp    17291 <con_write+0x1704>
			if (x>=video_num_columns)
   16c83:	8b 15 04 0d 02 00    	mov    0x20d04,%edx
   16c89:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   16c8f:	0f 83 fc 05 00 00    	jae    17291 <con_write+0x1704>
			count = video_num_columns-x;
   16c95:	a1 d8 0c 02 00       	mov    0x20cd8,%eax
   16c9a:	89 c1                	mov    %eax,%ecx
   16c9c:	29 d1                	sub    %edx,%ecx
			start = pos;
   16c9e:	8b 3d 00 0d 02 00    	mov    0x20d00,%edi
			break;
   16ca4:	eb 37                	jmp    16cdd <con_write+0x1150>
			start = pos - (x<<1);
   16ca6:	8b 1d 04 0d 02 00    	mov    0x20d04,%ebx
   16cac:	8d 14 1b             	lea    (%ebx,%ebx,1),%edx
   16caf:	a1 00 0d 02 00       	mov    0x20d00,%eax
   16cb4:	89 c7                	mov    %eax,%edi
   16cb6:	29 d7                	sub    %edx,%edi
			count = (x<video_num_columns)?x:video_num_columns;
   16cb8:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16cbe:	39 d9                	cmp    %ebx,%ecx
   16cc0:	76 1b                	jbe    16cdd <con_write+0x1150>
   16cc2:	89 d9                	mov    %ebx,%ecx
			break;
   16cc4:	eb 17                	jmp    16cdd <con_write+0x1150>
			start = pos - (x<<1);
   16cc6:	a1 04 0d 02 00       	mov    0x20d04,%eax
   16ccb:	d1 e0                	shl    %eax
   16ccd:	8b 15 00 0d 02 00    	mov    0x20d00,%edx
   16cd3:	89 d7                	mov    %edx,%edi
   16cd5:	29 c7                	sub    %eax,%edi
			count = video_num_columns;
   16cd7:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
	__asm__("cld\n\t"
   16cdd:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   16ce3:	fc                   	cld    
   16ce4:	f3 66 ab             	rep stos %ax,%es:(%edi)
						break;
   16ce7:	e9 a5 05 00 00       	jmp    17291 <con_write+0x1704>
{
   16cec:	8b 1d 20 0d 02 00    	mov    0x20d20,%ebx
	if (nr > video_num_lines)
   16cf2:	3b 1d e0 0c 02 00    	cmp    0x20ce0,%ebx
   16cf8:	76 08                	jbe    16d02 <con_write+0x1175>
		nr = video_num_lines;
   16cfa:	8b 1d e0 0c 02 00    	mov    0x20ce0,%ebx
   16d00:	eb 06                	jmp    16d08 <con_write+0x117b>
	else if (!nr)
   16d02:	85 db                	test   %ebx,%ebx
   16d04:	75 02                	jne    16d08 <con_write+0x117b>
		nr = 1;
   16d06:	b3 01                	mov    $0x1,%bl
	bottom=oldbottom;
   16d08:	4b                   	dec    %ebx
   16d09:	83 fb ff             	cmp    $0xffffffff,%ebx
   16d0c:	0f 84 7f 05 00 00    	je     17291 <con_write+0x1704>
   16d12:	a1 08 0d 02 00       	mov    0x20d08,%eax
   16d17:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
   16d1e:	8b 15 e0 0c 02 00    	mov    0x20ce0,%edx
   16d24:	89 94 24 8c 00 00 00 	mov    %edx,0x8c(%esp)
   16d2b:	8a 0d d4 0c 02 00    	mov    0x20cd4,%cl
   16d31:	83 e9 20             	sub    $0x20,%ecx
   16d34:	88 8c 24 8b 00 00 00 	mov    %cl,0x8b(%esp)
   16d3b:	66 8b 35 f4 0c 02 00 	mov    0x20cf4,%si
   16d42:	66 89 b4 24 88 00 00 	mov    %si,0x88(%esp)
   16d49:	00 
   16d4a:	89 d0                	mov    %edx,%eax
   16d4c:	2b 84 24 90 00 00 00 	sub    0x90(%esp),%eax
   16d53:	48                   	dec    %eax
   16d54:	0f af 05 d8 0c 02 00 	imul   0x20cd8,%eax
   16d5b:	d1 e8                	shr    %eax
   16d5d:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
   16d64:	8b 3d f8 0c 02 00    	mov    0x20cf8,%edi
   16d6a:	89 7c 24 7c          	mov    %edi,0x7c(%esp)
   16d6e:	89 d0                	mov    %edx,%eax
   16d70:	48                   	dec    %eax
   16d71:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   16d78:	8d 44 38 fc          	lea    -0x4(%eax,%edi,1),%eax
   16d7c:	89 44 24 74          	mov    %eax,0x74(%esp)
   16d80:	8b 15 0c 0d 02 00    	mov    0x20d0c,%edx
   16d86:	a1 10 0d 02 00       	mov    0x20d10,%eax
   16d8b:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16d91:	89 4c 24 10          	mov    %ecx,0x10(%esp)
   16d95:	8b 35 dc 0c 02 00    	mov    0x20cdc,%esi
   16d9b:	89 74 24 0c          	mov    %esi,0xc(%esp)
	oldtop=top;
   16d9f:	89 54 24 08          	mov    %edx,0x8(%esp)
	oldbottom=bottom;
   16da3:	89 84 24 94 00 00 00 	mov    %eax,0x94(%esp)
	top=y;
   16daa:	8b 94 24 90 00 00 00 	mov    0x90(%esp),%edx
	bottom = video_num_lines;
   16db1:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   16db8:	80 bc 24 8b 00 00 00 	cmpb   $0x1,0x8b(%esp)
   16dbf:	01 
   16dc0:	77 30                	ja     16df2 <con_write+0x1265>
		__asm__("std\n\t"
   16dc2:	0f af 44 24 0c       	imul   0xc(%esp),%eax
   16dc7:	8b 7c 24 7c          	mov    0x7c(%esp),%edi
   16dcb:	8d 7c 38 fc          	lea    -0x4(%eax,%edi,1),%edi
   16dcf:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
   16dd6:	8b 8c 24 84 00 00 00 	mov    0x84(%esp),%ecx
   16ddd:	8b 74 24 74          	mov    0x74(%esp),%esi
   16de1:	fd                   	std    
   16de2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   16de4:	83 c7 02             	add    $0x2,%edi
   16de7:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16ded:	f3 66 ab             	rep stos %ax,%es:(%edi)
   16df0:	eb 3f                	jmp    16e31 <con_write+0x12a4>
		__asm__("std\n\t"
   16df2:	89 c6                	mov    %eax,%esi
   16df4:	89 c1                	mov    %eax,%ecx
   16df6:	29 d1                	sub    %edx,%ecx
   16df8:	49                   	dec    %ecx
   16df9:	0f af 4c 24 10       	imul   0x10(%esp),%ecx
   16dfe:	d1 e9                	shr    %ecx
   16e00:	0f af 44 24 0c       	imul   0xc(%esp),%eax
   16e05:	8b 7c 24 7c          	mov    0x7c(%esp),%edi
   16e09:	8d 7c 38 fc          	lea    -0x4(%eax,%edi,1),%edi
   16e0d:	4e                   	dec    %esi
   16e0e:	0f af 74 24 0c       	imul   0xc(%esp),%esi
   16e13:	8b 44 24 7c          	mov    0x7c(%esp),%eax
   16e17:	8d 74 06 fc          	lea    -0x4(%esi,%eax,1),%esi
   16e1b:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
   16e22:	fd                   	std    
   16e23:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   16e25:	83 c7 02             	add    $0x2,%edi
   16e28:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16e2e:	f3 66 ab             	rep stos %ax,%es:(%edi)
	top=oldtop;
   16e31:	8b 54 24 08          	mov    0x8(%esp),%edx
	bottom=oldbottom;
   16e35:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
   16e3c:	4b                   	dec    %ebx
   16e3d:	83 fb ff             	cmp    $0xffffffff,%ebx
   16e40:	0f 85 59 ff ff ff    	jne    16d9f <con_write+0x1212>
   16e46:	a3 10 0d 02 00       	mov    %eax,0x20d10
   16e4b:	89 15 0c 0d 02 00    	mov    %edx,0x20d0c
						break;
   16e51:	e9 3b 04 00 00       	jmp    17291 <con_write+0x1704>
{
   16e56:	8b 1d 20 0d 02 00    	mov    0x20d20,%ebx
	if (nr > video_num_lines)
   16e5c:	3b 1d e0 0c 02 00    	cmp    0x20ce0,%ebx
   16e62:	76 08                	jbe    16e6c <con_write+0x12df>
		nr = video_num_lines;
   16e64:	8b 1d e0 0c 02 00    	mov    0x20ce0,%ebx
   16e6a:	eb 06                	jmp    16e72 <con_write+0x12e5>
	else if (!nr)
   16e6c:	85 db                	test   %ebx,%ebx
   16e6e:	75 02                	jne    16e72 <con_write+0x12e5>
		nr=1;
   16e70:	b3 01                	mov    $0x1,%bl
	bottom=oldbottom;
   16e72:	4b                   	dec    %ebx
   16e73:	83 fb ff             	cmp    $0xffffffff,%ebx
   16e76:	0f 84 15 04 00 00    	je     17291 <con_write+0x1704>
   16e7c:	8b 15 e0 0c 02 00    	mov    0x20ce0,%edx
   16e82:	89 54 24 60          	mov    %edx,0x60(%esp)
   16e86:	8a 0d d4 0c 02 00    	mov    0x20cd4,%cl
   16e8c:	83 e9 20             	sub    $0x20,%ecx
   16e8f:	88 4c 24 5f          	mov    %cl,0x5f(%esp)
   16e93:	8b 35 dc 0c 02 00    	mov    0x20cdc,%esi
   16e99:	89 74 24 58          	mov    %esi,0x58(%esp)
   16e9d:	66 8b 3d f4 0c 02 00 	mov    0x20cf4,%di
   16ea4:	66 89 7c 24 56       	mov    %di,0x56(%esp)
   16ea9:	89 d0                	mov    %edx,%eax
   16eab:	48                   	dec    %eax
   16eac:	0f af 05 d8 0c 02 00 	imul   0x20cd8,%eax
   16eb3:	d1 e8                	shr    %eax
   16eb5:	89 44 24 50          	mov    %eax,0x50(%esp)
   16eb9:	a1 e8 0c 02 00       	mov    0x20ce8,%eax
   16ebe:	89 44 24 4c          	mov    %eax,0x4c(%esp)
   16ec2:	66 8b 15 f0 0c 02 00 	mov    0x20cf0,%dx
   16ec9:	66 89 54 24 46       	mov    %dx,0x46(%esp)
   16ece:	a1 0c 0d 02 00       	mov    0x20d0c,%eax
   16ed3:	8b 15 10 0d 02 00    	mov    0x20d10,%edx
   16ed9:	8b 0d 08 0d 02 00    	mov    0x20d08,%ecx
   16edf:	89 4c 24 30          	mov    %ecx,0x30(%esp)
   16ee3:	89 74 24 2c          	mov    %esi,0x2c(%esp)
   16ee7:	8b 35 f8 0c 02 00    	mov    0x20cf8,%esi
   16eed:	89 74 24 28          	mov    %esi,0x28(%esp)
   16ef1:	8b 3d 00 0d 02 00    	mov    0x20d00,%edi
   16ef7:	89 7c 24 24          	mov    %edi,0x24(%esp)
   16efb:	8b 0d fc 0c 02 00    	mov    0x20cfc,%ecx
   16f01:	89 4c 24 20          	mov    %ecx,0x20(%esp)
   16f05:	8b 35 ec 0c 02 00    	mov    0x20cec,%esi
   16f0b:	89 74 24 1c          	mov    %esi,0x1c(%esp)
   16f0f:	8b 3d d8 0c 02 00    	mov    0x20cd8,%edi
   16f15:	89 7c 24 18          	mov    %edi,0x18(%esp)
   16f19:	66 8b 0d f2 0c 02 00 	mov    0x20cf2,%cx
   16f20:	66 89 4c 24 16       	mov    %cx,0x16(%esp)
	oldtop=top;
   16f25:	89 44 24 68          	mov    %eax,0x68(%esp)
	oldbottom=bottom;
   16f29:	89 54 24 64          	mov    %edx,0x64(%esp)
	top=y;
   16f2d:	8b 44 24 30          	mov    0x30(%esp),%eax
	bottom = video_num_lines;
   16f31:	8b 54 24 60          	mov    0x60(%esp),%edx
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   16f35:	80 7c 24 5f 01       	cmpb   $0x1,0x5f(%esp)
   16f3a:	0f 87 0c 01 00 00    	ja     1704c <con_write+0x14bf>
		if (!top && bottom == video_num_lines) {
   16f40:	85 c0                	test   %eax,%eax
   16f42:	0f 85 c8 00 00 00    	jne    17010 <con_write+0x1483>
			origin += video_size_row;
   16f48:	8b 74 24 28          	mov    0x28(%esp),%esi
   16f4c:	03 74 24 58          	add    0x58(%esp),%esi
   16f50:	89 74 24 28          	mov    %esi,0x28(%esp)
			pos += video_size_row;
   16f54:	8b 7c 24 24          	mov    0x24(%esp),%edi
   16f58:	03 7c 24 58          	add    0x58(%esp),%edi
   16f5c:	89 7c 24 04          	mov    %edi,0x4(%esp)
   16f60:	89 7c 24 24          	mov    %edi,0x24(%esp)
			scr_end += video_size_row;
   16f64:	8b 54 24 20          	mov    0x20(%esp),%edx
   16f68:	03 54 24 58          	add    0x58(%esp),%edx
   16f6c:	89 54 24 20          	mov    %edx,0x20(%esp)
			if (scr_end > video_mem_end) {
   16f70:	3b 54 24 1c          	cmp    0x1c(%esp),%edx
   16f74:	76 33                	jbe    16fa9 <con_write+0x141c>
				__asm__("cld\n\t"
   16f76:	66 8b 44 24 56       	mov    0x56(%esp),%ax
   16f7b:	8b 4c 24 50          	mov    0x50(%esp),%ecx
   16f7f:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
   16f83:	fc                   	cld    
   16f84:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   16f86:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   16f8c:	f3 66 ab             	rep stos %ax,%es:(%edi)
				scr_end -= origin-video_mem_start;
   16f8f:	89 f0                	mov    %esi,%eax
   16f91:	29 f8                	sub    %edi,%eax
   16f93:	29 c2                	sub    %eax,%edx
   16f95:	89 54 24 20          	mov    %edx,0x20(%esp)
				pos -= origin-video_mem_start;
   16f99:	8b 54 24 04          	mov    0x4(%esp),%edx
   16f9d:	29 c2                	sub    %eax,%edx
   16f9f:	89 54 24 24          	mov    %edx,0x24(%esp)
				origin = video_mem_start;
   16fa3:	89 7c 24 28          	mov    %edi,0x28(%esp)
   16fa7:	eb 17                	jmp    16fc0 <con_write+0x1433>
				__asm__("cld\n\t"
   16fa9:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   16fad:	2b 4c 24 58          	sub    0x58(%esp),%ecx
   16fb1:	89 cf                	mov    %ecx,%edi
   16fb3:	66 8b 44 24 56       	mov    0x56(%esp),%ax
   16fb8:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   16fbc:	fc                   	cld    
   16fbd:	f3 66 ab             	rep stos %ax,%es:(%edi)
	cli();
   16fc0:	fa                   	cli    
	outb_p(12, video_port_reg);
   16fc1:	b8 0c 00 00 00       	mov    $0xc,%eax
   16fc6:	66 8b 54 24 46       	mov    0x46(%esp),%dx
   16fcb:	ee                   	out    %al,(%dx)
   16fcc:	eb 00                	jmp    16fce <con_write+0x1441>
   16fce:	eb 00                	jmp    16fd0 <con_write+0x1443>
	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
   16fd0:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   16fd4:	2b 4c 24 4c          	sub    0x4c(%esp),%ecx
   16fd8:	89 c8                	mov    %ecx,%eax
   16fda:	c1 e8 09             	shr    $0x9,%eax
   16fdd:	25 ff 00 00 00       	and    $0xff,%eax
   16fe2:	66 8b 74 24 16       	mov    0x16(%esp),%si
   16fe7:	89 f2                	mov    %esi,%edx
   16fe9:	ee                   	out    %al,(%dx)
   16fea:	eb 00                	jmp    16fec <con_write+0x145f>
   16fec:	eb 00                	jmp    16fee <con_write+0x1461>
	outb_p(13, video_port_reg);
   16fee:	b8 0d 00 00 00       	mov    $0xd,%eax
   16ff3:	66 8b 54 24 46       	mov    0x46(%esp),%dx
   16ff8:	ee                   	out    %al,(%dx)
   16ff9:	eb 00                	jmp    16ffb <con_write+0x146e>
   16ffb:	eb 00                	jmp    16ffd <con_write+0x1470>
	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
   16ffd:	89 c8                	mov    %ecx,%eax
   16fff:	d1 e8                	shr    %eax
   17001:	25 ff 00 00 00       	and    $0xff,%eax
   17006:	89 f2                	mov    %esi,%edx
   17008:	ee                   	out    %al,(%dx)
   17009:	eb 00                	jmp    1700b <con_write+0x147e>
   1700b:	eb 00                	jmp    1700d <con_write+0x1480>
	sti();
   1700d:	fb                   	sti    
   1700e:	eb 7c                	jmp    1708c <con_write+0x14ff>
			__asm__("cld\n\t"
   17010:	89 c6                	mov    %eax,%esi
   17012:	89 d1                	mov    %edx,%ecx
   17014:	29 c1                	sub    %eax,%ecx
   17016:	49                   	dec    %ecx
   17017:	0f af 4c 24 18       	imul   0x18(%esp),%ecx
   1701c:	d1 e9                	shr    %ecx
   1701e:	0f af 44 24 58       	imul   0x58(%esp),%eax
   17023:	89 44 24 40          	mov    %eax,0x40(%esp)
   17027:	8b 44 24 28          	mov    0x28(%esp),%eax
   1702b:	8b 7c 24 40          	mov    0x40(%esp),%edi
   1702f:	01 c7                	add    %eax,%edi
   17031:	46                   	inc    %esi
   17032:	0f af 74 24 2c       	imul   0x2c(%esp),%esi
   17037:	01 c6                	add    %eax,%esi
   17039:	66 8b 44 24 56       	mov    0x56(%esp),%ax
   1703e:	fc                   	cld    
   1703f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   17041:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   17047:	f3 66 ab             	rep stos %ax,%es:(%edi)
   1704a:	eb 40                	jmp    1708c <con_write+0x14ff>
		__asm__("cld\n\t"
   1704c:	89 c6                	mov    %eax,%esi
   1704e:	89 d1                	mov    %edx,%ecx
   17050:	29 c1                	sub    %eax,%ecx
   17052:	49                   	dec    %ecx
   17053:	0f af 4c 24 18       	imul   0x18(%esp),%ecx
   17058:	d1 e9                	shr    %ecx
   1705a:	0f af 44 24 58       	imul   0x58(%esp),%eax
   1705f:	89 44 24 38          	mov    %eax,0x38(%esp)
   17063:	8b 44 24 28          	mov    0x28(%esp),%eax
   17067:	8b 54 24 38          	mov    0x38(%esp),%edx
   1706b:	01 c2                	add    %eax,%edx
   1706d:	89 54 24 34          	mov    %edx,0x34(%esp)
   17071:	46                   	inc    %esi
   17072:	0f af 74 24 2c       	imul   0x2c(%esp),%esi
   17077:	01 c6                	add    %eax,%esi
   17079:	66 8b 44 24 56       	mov    0x56(%esp),%ax
   1707e:	89 d7                	mov    %edx,%edi
   17080:	fc                   	cld    
   17081:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   17083:	8b 0d d8 0c 02 00    	mov    0x20cd8,%ecx
   17089:	f3 66 ab             	rep stos %ax,%es:(%edi)
	top=oldtop;
   1708c:	8b 44 24 68          	mov    0x68(%esp),%eax
	bottom=oldbottom;
   17090:	8b 54 24 64          	mov    0x64(%esp),%edx
   17094:	4b                   	dec    %ebx
   17095:	83 fb ff             	cmp    $0xffffffff,%ebx
   17098:	0f 85 87 fe ff ff    	jne    16f25 <con_write+0x1398>
   1709e:	8b 4c 24 20          	mov    0x20(%esp),%ecx
   170a2:	89 0d fc 0c 02 00    	mov    %ecx,0x20cfc
   170a8:	8b 5c 24 24          	mov    0x24(%esp),%ebx
   170ac:	89 1d 00 0d 02 00    	mov    %ebx,0x20d00
   170b2:	8b 74 24 28          	mov    0x28(%esp),%esi
   170b6:	89 35 f8 0c 02 00    	mov    %esi,0x20cf8
   170bc:	89 15 10 0d 02 00    	mov    %edx,0x20d10
   170c2:	a3 0c 0d 02 00       	mov    %eax,0x20d0c
						break;
   170c7:	e9 c5 01 00 00       	jmp    17291 <con_write+0x1704>
{
   170cc:	8b 1d 20 0d 02 00    	mov    0x20d20,%ebx
	if (nr > video_num_columns)
   170d2:	3b 1d d8 0c 02 00    	cmp    0x20cd8,%ebx
   170d8:	76 08                	jbe    170e2 <con_write+0x1555>
		nr = video_num_columns;
   170da:	8b 1d d8 0c 02 00    	mov    0x20cd8,%ebx
   170e0:	eb 06                	jmp    170e8 <con_write+0x155b>
	else if (!nr)
   170e2:	85 db                	test   %ebx,%ebx
   170e4:	75 02                	jne    170e8 <con_write+0x155b>
		nr = 1;
   170e6:	b3 01                	mov    $0x1,%bl
	*p = video_erase_char;
   170e8:	4b                   	dec    %ebx
   170e9:	83 fb ff             	cmp    $0xffffffff,%ebx
   170ec:	0f 84 9f 01 00 00    	je     17291 <con_write+0x1704>
	unsigned short * p = (unsigned short *) pos;
   170f2:	8b 0d 00 0d 02 00    	mov    0x20d00,%ecx
	if (x>=video_num_columns)
   170f8:	a1 04 0d 02 00       	mov    0x20d04,%eax
   170fd:	3b 05 d8 0c 02 00    	cmp    0x20cd8,%eax
   17103:	73 27                	jae    1712c <con_write+0x159f>
		p++;
   17105:	8d 50 01             	lea    0x1(%eax),%edx
   17108:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   1710e:	73 13                	jae    17123 <con_write+0x1596>
		*p = *(p+1);
   17110:	66 8b 41 02          	mov    0x2(%ecx),%ax
   17114:	66 89 01             	mov    %ax,(%ecx)
		p++;
   17117:	83 c1 02             	add    $0x2,%ecx
   1711a:	42                   	inc    %edx
   1711b:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   17121:	72 ed                	jb     17110 <con_write+0x1583>
	*p = video_erase_char;
   17123:	66 a1 f4 0c 02 00    	mov    0x20cf4,%ax
   17129:	66 89 01             	mov    %ax,(%ecx)
   1712c:	4b                   	dec    %ebx
   1712d:	83 fb ff             	cmp    $0xffffffff,%ebx
   17130:	75 c0                	jne    170f2 <con_write+0x1565>
						break;
   17132:	e9 5a 01 00 00       	jmp    17291 <con_write+0x1704>
{
   17137:	8b 35 20 0d 02 00    	mov    0x20d20,%esi
	if (nr > video_num_columns)
   1713d:	3b 35 d8 0c 02 00    	cmp    0x20cd8,%esi
   17143:	76 08                	jbe    1714d <con_write+0x15c0>
		nr = video_num_columns;
   17145:	8b 35 d8 0c 02 00    	mov    0x20cd8,%esi
   1714b:	eb 08                	jmp    17155 <con_write+0x15c8>
	else if (!nr)
   1714d:	85 f6                	test   %esi,%esi
   1714f:	75 04                	jne    17155 <con_write+0x15c8>
		nr = 1;
   17151:	66 be 01 00          	mov    $0x1,%si
		p++;
   17155:	4e                   	dec    %esi
   17156:	83 fe ff             	cmp    $0xffffffff,%esi
   17159:	0f 84 32 01 00 00    	je     17291 <con_write+0x1704>
	int i=x;
   1715f:	8b 0d 04 0d 02 00    	mov    0x20d04,%ecx
	unsigned short tmp, old = video_erase_char;
   17165:	66 8b 1d f4 0c 02 00 	mov    0x20cf4,%bx
	unsigned short * p = (unsigned short *) pos;
   1716c:	8b 15 00 0d 02 00    	mov    0x20d00,%edx
		p++;
   17172:	89 c8                	mov    %ecx,%eax
   17174:	41                   	inc    %ecx
   17175:	3b 05 d8 0c 02 00    	cmp    0x20cd8,%eax
   1717b:	73 16                	jae    17193 <con_write+0x1606>
		tmp=*p;
   1717d:	66 8b 02             	mov    (%edx),%ax
		*p=old;
   17180:	66 89 1a             	mov    %bx,(%edx)
		old=tmp;
   17183:	89 c3                	mov    %eax,%ebx
		p++;
   17185:	83 c2 02             	add    $0x2,%edx
   17188:	89 c8                	mov    %ecx,%eax
   1718a:	41                   	inc    %ecx
   1718b:	3b 05 d8 0c 02 00    	cmp    0x20cd8,%eax
   17191:	72 ea                	jb     1717d <con_write+0x15f0>
   17193:	4e                   	dec    %esi
   17194:	83 fe ff             	cmp    $0xffffffff,%esi
   17197:	75 c6                	jne    1715f <con_write+0x15d2>
						break;
   17199:	e9 f3 00 00 00       	jmp    17291 <con_write+0x1704>
	for (i=0;i<=npar;i++)
   1719e:	ba 00 00 00 00       	mov    $0x0,%edx
		switch (par[i]) {
   171a3:	b8 20 0d 02 00       	mov    $0x20d20,%eax
   171a8:	83 3c 90 1b          	cmpl   $0x1b,(%eax,%edx,4)
   171ac:	77 35                	ja     171e3 <con_write+0x1656>
   171ae:	8b 04 90             	mov    (%eax,%edx,4),%eax
   171b1:	ff 24 85 50 99 01 00 	jmp    *0x19950(,%eax,4)
			case 0:attr=0x07;break;
   171b8:	c6 05 58 e4 01 00 07 	movb   $0x7,0x1e458
   171bf:	eb 22                	jmp    171e3 <con_write+0x1656>
			case 1:attr=0x0f;break;
   171c1:	c6 05 58 e4 01 00 0f 	movb   $0xf,0x1e458
   171c8:	eb 19                	jmp    171e3 <con_write+0x1656>
			case 4:attr=0x0f;break;
   171ca:	c6 05 58 e4 01 00 0f 	movb   $0xf,0x1e458
   171d1:	eb 10                	jmp    171e3 <con_write+0x1656>
			case 7:attr=0x70;break;
   171d3:	c6 05 58 e4 01 00 70 	movb   $0x70,0x1e458
   171da:	eb 07                	jmp    171e3 <con_write+0x1656>
			case 27:attr=0x07;break;
   171dc:	c6 05 58 e4 01 00 07 	movb   $0x7,0x1e458
	for (i=0;i<=npar;i++)
   171e3:	42                   	inc    %edx
   171e4:	3b 15 14 0d 02 00    	cmp    0x20d14,%edx
   171ea:	76 b7                	jbe    171a3 <con_write+0x1616>
						break;
   171ec:	e9 a0 00 00 00       	jmp    17291 <con_write+0x1704>
						if (par[0]) par[0]--;
   171f1:	83 3d 20 0d 02 00 01 	cmpl   $0x1,0x20d20
   171f8:	a1 20 0d 02 00       	mov    0x20d20,%eax
   171fd:	83 d0 ff             	adc    $0xffffffff,%eax
   17200:	a3 20 0d 02 00       	mov    %eax,0x20d20
						if (!par[1]) par[1] = video_num_lines;
   17205:	83 3d 24 0d 02 00 00 	cmpl   $0x0,0x20d24
   1720c:	75 0a                	jne    17218 <con_write+0x168b>
   1720e:	a1 e0 0c 02 00       	mov    0x20ce0,%eax
   17213:	a3 24 0d 02 00       	mov    %eax,0x20d24
						if (par[0] < par[1] &&
   17218:	a1 20 0d 02 00       	mov    0x20d20,%eax
   1721d:	3b 05 24 0d 02 00    	cmp    0x20d24,%eax
   17223:	73 6c                	jae    17291 <con_write+0x1704>
   17225:	8b 15 24 0d 02 00    	mov    0x20d24,%edx
   1722b:	3b 15 e0 0c 02 00    	cmp    0x20ce0,%edx
   17231:	77 5e                	ja     17291 <con_write+0x1704>
							top=par[0];
   17233:	a3 0c 0d 02 00       	mov    %eax,0x20d0c
							bottom=par[1];
   17238:	89 15 10 0d 02 00    	mov    %edx,0x20d10
						break;
   1723e:	eb 51                	jmp    17291 <con_write+0x1704>
	saved_x=x;
   17240:	a1 04 0d 02 00       	mov    0x20d04,%eax
   17245:	a3 cc 0c 02 00       	mov    %eax,0x20ccc
	saved_y=y;
   1724a:	a1 08 0d 02 00       	mov    0x20d08,%eax
   1724f:	a3 d0 0c 02 00       	mov    %eax,0x20cd0
						break;
   17254:	eb 3b                	jmp    17291 <con_write+0x1704>
{
   17256:	8b 15 cc 0c 02 00    	mov    0x20ccc,%edx
   1725c:	a1 d0 0c 02 00       	mov    0x20cd0,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   17261:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   17267:	77 28                	ja     17291 <con_write+0x1704>
   17269:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   1726f:	73 20                	jae    17291 <con_write+0x1704>
	x=new_x;
   17271:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	y=new_y;
   17277:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   1727c:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   17283:	03 05 f8 0c 02 00    	add    0x20cf8,%eax
   17289:	8d 04 50             	lea    (%eax,%edx,2),%eax
   1728c:	a3 00 0d 02 00       	mov    %eax,0x20d00
						break;
   17291:	4d                   	dec    %ebp
   17292:	83 fd ff             	cmp    $0xffffffff,%ebp
   17295:	0f 85 21 e9 ff ff    	jne    15bbc <con_write+0x2f>
	cli();
   1729b:	fa                   	cli    
	outb_p(14, video_port_reg);
   1729c:	b8 0e 00 00 00       	mov    $0xe,%eax
   172a1:	66 8b 0d f0 0c 02 00 	mov    0x20cf0,%cx
   172a8:	89 ca                	mov    %ecx,%edx
   172aa:	ee                   	out    %al,(%dx)
   172ab:	eb 00                	jmp    172ad <con_write+0x1720>
   172ad:	eb 00                	jmp    172af <con_write+0x1722>
	outb_p(0xff&((pos-video_mem_start)>>9), video_port_val);
   172af:	a1 00 0d 02 00       	mov    0x20d00,%eax
   172b4:	89 c3                	mov    %eax,%ebx
   172b6:	2b 1d e8 0c 02 00    	sub    0x20ce8,%ebx
   172bc:	89 d8                	mov    %ebx,%eax
   172be:	c1 e8 09             	shr    $0x9,%eax
   172c1:	25 ff 00 00 00       	and    $0xff,%eax
   172c6:	66 8b 35 f2 0c 02 00 	mov    0x20cf2,%si
   172cd:	89 f2                	mov    %esi,%edx
   172cf:	ee                   	out    %al,(%dx)
   172d0:	eb 00                	jmp    172d2 <con_write+0x1745>
   172d2:	eb 00                	jmp    172d4 <con_write+0x1747>
	outb_p(15, video_port_reg);
   172d4:	b8 0f 00 00 00       	mov    $0xf,%eax
   172d9:	89 ca                	mov    %ecx,%edx
   172db:	ee                   	out    %al,(%dx)
   172dc:	eb 00                	jmp    172de <con_write+0x1751>
   172de:	eb 00                	jmp    172e0 <con_write+0x1753>
	outb_p(0xff&((pos-video_mem_start)>>1), video_port_val);
   172e0:	89 d8                	mov    %ebx,%eax
   172e2:	d1 e8                	shr    %eax
   172e4:	25 ff 00 00 00       	and    $0xff,%eax
   172e9:	89 f2                	mov    %esi,%edx
   172eb:	ee                   	out    %al,(%dx)
   172ec:	eb 00                	jmp    172ee <con_write+0x1761>
   172ee:	eb 00                	jmp    172f0 <con_write+0x1763>
	sti();
   172f0:	fb                   	sti    
				}
		}
	}
	set_cursor();
}
   172f1:	81 c4 cc 00 00 00    	add    $0xcc,%esp
   172f7:	5b                   	pop    %ebx
   172f8:	5e                   	pop    %esi
   172f9:	5f                   	pop    %edi
   172fa:	5d                   	pop    %ebp
   172fb:	c3                   	ret    

000172fc <con_init>:
{
	register unsigned char a;
	char *display_desc = "????";
	char *display_ptr;

	video_num_columns = ORIG_VIDEO_COLS;
   172fc:	0f b7 05 06 00 09 00 	movzwl 0x90006,%eax
   17303:	89 c2                	mov    %eax,%edx
   17305:	c1 ea 08             	shr    $0x8,%edx
   17308:	89 15 d8 0c 02 00    	mov    %edx,0x20cd8
	video_size_row = video_num_columns * 2;
   1730e:	d1 e2                	shl    %edx
   17310:	89 15 dc 0c 02 00    	mov    %edx,0x20cdc
	video_num_lines = ORIG_VIDEO_LINES;
   17316:	c7 05 e0 0c 02 00 19 	movl   $0x19,0x20ce0
   1731d:	00 00 00 
	video_page = ORIG_VIDEO_PAGE;
   17320:	8b 15 04 00 09 00    	mov    0x90004,%edx
   17326:	88 15 e4 0c 02 00    	mov    %dl,0x20ce4
	video_erase_char = 0x0720;
   1732c:	66 c7 05 f4 0c 02 00 	movw   $0x720,0x20cf4
   17333:	20 07 
	
	if (ORIG_VIDEO_MODE == 7)			/* Is this a monochrome display? */
   17335:	3c 07                	cmp    $0x7,%al
   17337:	75 55                	jne    1738e <con_init+0x92>
	{
		video_mem_start = 0xb0000;
   17339:	c7 05 e8 0c 02 00 00 	movl   $0xb0000,0x20ce8
   17340:	00 0b 00 
		video_port_reg = 0x3b4;
   17343:	66 c7 05 f0 0c 02 00 	movw   $0x3b4,0x20cf0
   1734a:	b4 03 
		video_port_val = 0x3b5;
   1734c:	66 c7 05 f2 0c 02 00 	movw   $0x3b5,0x20cf2
   17353:	b5 03 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   17355:	80 3d 0a 00 09 00 10 	cmpb   $0x10,0x9000a
   1735c:	74 18                	je     17376 <con_init+0x7a>
		{
			video_type = VIDEO_TYPE_EGAM;
   1735e:	c6 05 d4 0c 02 00 20 	movb   $0x20,0x20cd4
			video_mem_end = 0xb8000;
   17365:	c7 05 ec 0c 02 00 00 	movl   $0xb8000,0x20cec
   1736c:	80 0b 00 
			display_desc = "EGAm";
   1736f:	b9 c8 99 01 00       	mov    $0x199c8,%ecx
   17374:	eb 6b                	jmp    173e1 <con_init+0xe5>
		}
		else
		{
			video_type = VIDEO_TYPE_MDA;
   17376:	c6 05 d4 0c 02 00 10 	movb   $0x10,0x20cd4
			video_mem_end	= 0xb2000;
   1737d:	c7 05 ec 0c 02 00 00 	movl   $0xb2000,0x20cec
   17384:	20 0b 00 
			display_desc = "*MDA";
   17387:	b9 cd 99 01 00       	mov    $0x199cd,%ecx
   1738c:	eb 53                	jmp    173e1 <con_init+0xe5>
		}
	}
	else								/* If not, it is color. */
	{
		video_mem_start = 0xb8000;
   1738e:	c7 05 e8 0c 02 00 00 	movl   $0xb8000,0x20ce8
   17395:	80 0b 00 
		video_port_reg	= 0x3d4;
   17398:	66 c7 05 f0 0c 02 00 	movw   $0x3d4,0x20cf0
   1739f:	d4 03 
		video_port_val	= 0x3d5;
   173a1:	66 c7 05 f2 0c 02 00 	movw   $0x3d5,0x20cf2
   173a8:	d5 03 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   173aa:	80 3d 0a 00 09 00 10 	cmpb   $0x10,0x9000a
   173b1:	74 18                	je     173cb <con_init+0xcf>
		{
			video_type = VIDEO_TYPE_EGAC;
   173b3:	c6 05 d4 0c 02 00 21 	movb   $0x21,0x20cd4
			video_mem_end = 0xbc000;
   173ba:	c7 05 ec 0c 02 00 00 	movl   $0xbc000,0x20cec
   173c1:	c0 0b 00 
			display_desc = "EGAc";
   173c4:	b9 d2 99 01 00       	mov    $0x199d2,%ecx
   173c9:	eb 16                	jmp    173e1 <con_init+0xe5>
		}
		else
		{
			video_type = VIDEO_TYPE_CGA;
   173cb:	c6 05 d4 0c 02 00 11 	movb   $0x11,0x20cd4
			video_mem_end = 0xba000;
   173d2:	c7 05 ec 0c 02 00 00 	movl   $0xba000,0x20cec
   173d9:	a0 0b 00 
			display_desc = "*CGA";
   173dc:	b9 d7 99 01 00       	mov    $0x199d7,%ecx
		}
	}

	/* Let the user known what kind of display driver we are using */
	
	display_ptr = ((char *)video_mem_start) + video_size_row - 8;
   173e1:	a1 e8 0c 02 00       	mov    0x20ce8,%eax
   173e6:	89 c2                	mov    %eax,%edx
   173e8:	03 15 dc 0c 02 00    	add    0x20cdc,%edx
   173ee:	83 ea 08             	sub    $0x8,%edx
	while (*display_desc)
	{
		*display_ptr++ = *display_desc++;
		display_ptr++;
   173f1:	80 39 00             	cmpb   $0x0,(%ecx)
   173f4:	74 0d                	je     17403 <con_init+0x107>
		*display_ptr++ = *display_desc++;
   173f6:	8a 01                	mov    (%ecx),%al
   173f8:	41                   	inc    %ecx
   173f9:	88 02                	mov    %al,(%edx)
		display_ptr++;
   173fb:	83 c2 02             	add    $0x2,%edx
   173fe:	80 39 00             	cmpb   $0x0,(%ecx)
   17401:	75 f3                	jne    173f6 <con_init+0xfa>
	}
	
	/* Initialize the variables used for scrolling (mostly EGA/VGA)	*/
	
	origin	= video_mem_start;
   17403:	8b 0d e8 0c 02 00    	mov    0x20ce8,%ecx
   17409:	89 0d f8 0c 02 00    	mov    %ecx,0x20cf8
	scr_end	= video_mem_start + video_num_lines * video_size_row;
   1740f:	8b 15 e0 0c 02 00    	mov    0x20ce0,%edx
   17415:	89 d0                	mov    %edx,%eax
   17417:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   1741e:	01 c8                	add    %ecx,%eax
   17420:	a3 fc 0c 02 00       	mov    %eax,0x20cfc
	top	= 0;
   17425:	c7 05 0c 0d 02 00 00 	movl   $0x0,0x20d0c
   1742c:	00 00 00 
	bottom	= video_num_lines;
   1742f:	89 15 10 0d 02 00    	mov    %edx,0x20d10
{
   17435:	0f b6 15 00 00 09 00 	movzbl 0x90000,%edx
   1743c:	0f b6 05 01 00 09 00 	movzbl 0x90001,%eax
	if (new_x > video_num_columns || new_y >= video_num_lines)
   17443:	3b 15 d8 0c 02 00    	cmp    0x20cd8,%edx
   17449:	77 24                	ja     1746f <con_init+0x173>
   1744b:	3b 05 e0 0c 02 00    	cmp    0x20ce0,%eax
   17451:	73 1c                	jae    1746f <con_init+0x173>
	x=new_x;
   17453:	89 15 04 0d 02 00    	mov    %edx,0x20d04
	y=new_y;
   17459:	a3 08 0d 02 00       	mov    %eax,0x20d08
	pos=origin + y*video_size_row + (x<<1);
   1745e:	0f af 05 dc 0c 02 00 	imul   0x20cdc,%eax
   17465:	01 c8                	add    %ecx,%eax
   17467:	8d 04 50             	lea    (%eax,%edx,2),%eax
   1746a:	a3 00 0d 02 00       	mov    %eax,0x20d00

	gotoxy(ORIG_X,ORIG_Y);
	set_trap_gate(0x21,&keyboard_interrupt);
   1746f:	ba 03 75 01 00       	mov    $0x17503,%edx
   17474:	b8 00 00 08 00       	mov    $0x80000,%eax
   17479:	66 89 d0             	mov    %dx,%ax
   1747c:	66 ba 00 8f          	mov    $0x8f00,%dx
   17480:	a3 c0 55 00 00       	mov    %eax,0x55c0
   17485:	89 15 c4 55 00 00    	mov    %edx,0x55c4
	outb_p(inb_p(0x21)&0xfd,0x21);
   1748b:	ba 21 00 00 00       	mov    $0x21,%edx
   17490:	ec                   	in     (%dx),%al
   17491:	eb 00                	jmp    17493 <con_init+0x197>
   17493:	eb 00                	jmp    17495 <con_init+0x199>
   17495:	25 fd 00 00 00       	and    $0xfd,%eax
   1749a:	ee                   	out    %al,(%dx)
   1749b:	eb 00                	jmp    1749d <con_init+0x1a1>
   1749d:	eb 00                	jmp    1749f <con_init+0x1a3>
	a=inb_p(0x61);
   1749f:	b2 61                	mov    $0x61,%dl
   174a1:	ec                   	in     (%dx),%al
   174a2:	eb 00                	jmp    174a4 <con_init+0x1a8>
   174a4:	eb 00                	jmp    174a6 <con_init+0x1aa>
   174a6:	88 c1                	mov    %al,%cl
	outb_p(a|0x80,0x61);
   174a8:	83 c8 80             	or     $0xffffff80,%eax
   174ab:	0f b6 c0             	movzbl %al,%eax
   174ae:	ee                   	out    %al,(%dx)
   174af:	eb 00                	jmp    174b1 <con_init+0x1b5>
   174b1:	eb 00                	jmp    174b3 <con_init+0x1b7>
	outb(a,0x61);
   174b3:	88 c8                	mov    %cl,%al
   174b5:	ee                   	out    %al,(%dx)
}
   174b6:	c3                   	ret    

000174b7 <sysbeepstop>:
/* from bsd-net-2: */

void sysbeepstop(void)
{
	/* disable counter 2 */
	outb(inb_p(0x61)&0xFC, 0x61);
   174b7:	ba 61 00 00 00       	mov    $0x61,%edx
   174bc:	ec                   	in     (%dx),%al
   174bd:	eb 00                	jmp    174bf <sysbeepstop+0x8>
   174bf:	eb 00                	jmp    174c1 <sysbeepstop+0xa>
   174c1:	25 fc 00 00 00       	and    $0xfc,%eax
   174c6:	ee                   	out    %al,(%dx)
}
   174c7:	c3                   	ret    

000174c8 <sysbeep>:
int beepcount = 0;

static void sysbeep(void)
{
	/* enable counter 2 */
	outb_p(inb_p(0x61)|3, 0x61);
   174c8:	ba 61 00 00 00       	mov    $0x61,%edx
   174cd:	ec                   	in     (%dx),%al
   174ce:	eb 00                	jmp    174d0 <sysbeep+0x8>
   174d0:	eb 00                	jmp    174d2 <sysbeep+0xa>
   174d2:	83 c8 03             	or     $0x3,%eax
   174d5:	0f b6 c0             	movzbl %al,%eax
   174d8:	ee                   	out    %al,(%dx)
   174d9:	eb 00                	jmp    174db <sysbeep+0x13>
   174db:	eb 00                	jmp    174dd <sysbeep+0x15>
	/* set command for counter 2, 2 byte write */
	outb_p(0xB6, 0x43);
   174dd:	b8 b6 00 00 00       	mov    $0xb6,%eax
   174e2:	b2 43                	mov    $0x43,%dl
   174e4:	ee                   	out    %al,(%dx)
   174e5:	eb 00                	jmp    174e7 <sysbeep+0x1f>
   174e7:	eb 00                	jmp    174e9 <sysbeep+0x21>
	/* send 0x637 for 750 HZ */
	outb_p(0x37, 0x42);
   174e9:	b0 37                	mov    $0x37,%al
   174eb:	b2 42                	mov    $0x42,%dl
   174ed:	ee                   	out    %al,(%dx)
   174ee:	eb 00                	jmp    174f0 <sysbeep+0x28>
   174f0:	eb 00                	jmp    174f2 <sysbeep+0x2a>
	outb(0x06, 0x42);
   174f2:	b0 06                	mov    $0x6,%al
   174f4:	ee                   	out    %al,(%dx)
	/* 1/8 second */
	beepcount = HZ/8;	
   174f5:	c7 05 c0 0c 02 00 0c 	movl   $0xc,0x20cc0
   174fc:	00 00 00 
}
   174ff:	c3                   	ret    

00017500 <mode>:
	...

00017501 <leds>:
   17501:	02                   	.byte 0x2

00017502 <e0>:
	...

00017503 <keyboard_interrupt>:
   17503:	50                   	push   %eax
   17504:	53                   	push   %ebx
   17505:	51                   	push   %ecx
   17506:	52                   	push   %edx
   17507:	1e                   	push   %ds
   17508:	06                   	push   %es
   17509:	b8 10 00 00 00       	mov    $0x10,%eax
   1750e:	8e d8                	mov    %eax,%ds
   17510:	8e c0                	mov    %eax,%es
   17512:	30 c0                	xor    %al,%al
   17514:	e4 60                	in     $0x60,%al
   17516:	3c e0                	cmp    $0xe0,%al
   17518:	74 3d                	je     17557 <set_e0>
   1751a:	3c e1                	cmp    $0xe1,%al
   1751c:	74 42                	je     17560 <set_e1>
   1751e:	ff 14 85 c5 78 01 00 	call   *0x178c5(,%eax,4)
   17525:	c6 05 02 75 01 00 00 	movb   $0x0,0x17502

0001752c <e0_e1>:
   1752c:	e4 61                	in     $0x61,%al
   1752e:	eb 00                	jmp    17530 <e0_e1+0x4>
   17530:	eb 00                	jmp    17532 <e0_e1+0x6>
   17532:	0c 80                	or     $0x80,%al
   17534:	eb 00                	jmp    17536 <e0_e1+0xa>
   17536:	eb 00                	jmp    17538 <e0_e1+0xc>
   17538:	e6 61                	out    %al,$0x61
   1753a:	eb 00                	jmp    1753c <e0_e1+0x10>
   1753c:	eb 00                	jmp    1753e <e0_e1+0x12>
   1753e:	24 7f                	and    $0x7f,%al
   17540:	e6 61                	out    %al,$0x61
   17542:	b0 20                	mov    $0x20,%al
   17544:	e6 20                	out    %al,$0x20
   17546:	6a 00                	push   $0x0
   17548:	e8 cc e5 ff ff       	call   15b19 <do_tty_interrupt>
   1754d:	83 c4 04             	add    $0x4,%esp
   17550:	07                   	pop    %es
   17551:	1f                   	pop    %ds
   17552:	5a                   	pop    %edx
   17553:	59                   	pop    %ecx
   17554:	5b                   	pop    %ebx
   17555:	58                   	pop    %eax
   17556:	cf                   	iret   

00017557 <set_e0>:
   17557:	c6 05 02 75 01 00 01 	movb   $0x1,0x17502
   1755e:	eb cc                	jmp    1752c <e0_e1>

00017560 <set_e1>:
   17560:	c6 05 02 75 01 00 02 	movb   $0x2,0x17502
   17567:	eb c3                	jmp    1752c <e0_e1>

00017569 <put_queue>:
   17569:	51                   	push   %ecx
   1756a:	52                   	push   %edx
   1756b:	8b 15 40 e4 01 00    	mov    0x1e440,%edx
   17571:	8b 4a 04             	mov    0x4(%edx),%ecx
   17574:	88 44 0a 10          	mov    %al,0x10(%edx,%ecx,1)
   17578:	41                   	inc    %ecx
   17579:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
   1757f:	3b 4a 08             	cmp    0x8(%edx),%ecx
   17582:	74 1b                	je     1759f <put_queue+0x36>
   17584:	0f ac d8 08          	shrd   $0x8,%ebx,%eax
   17588:	74 05                	je     1758f <put_queue+0x26>
   1758a:	c1 eb 08             	shr    $0x8,%ebx
   1758d:	eb e5                	jmp    17574 <put_queue+0xb>
   1758f:	89 4a 04             	mov    %ecx,0x4(%edx)
   17592:	8b 4a 0c             	mov    0xc(%edx),%ecx
   17595:	85 c9                	test   %ecx,%ecx
   17597:	74 06                	je     1759f <put_queue+0x36>
   17599:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
   1759f:	5a                   	pop    %edx
   175a0:	59                   	pop    %ecx
   175a1:	c3                   	ret    

000175a2 <ctrl>:
   175a2:	b0 04                	mov    $0x4,%al
   175a4:	eb 02                	jmp    175a8 <alt+0x2>

000175a6 <alt>:
   175a6:	b0 10                	mov    $0x10,%al
   175a8:	80 3d 02 75 01 00 00 	cmpb   $0x0,0x17502
   175af:	74 02                	je     175b3 <alt+0xd>
   175b1:	00 c0                	add    %al,%al
   175b3:	08 05 00 75 01 00    	or     %al,0x17500
   175b9:	c3                   	ret    

000175ba <unctrl>:
   175ba:	b0 04                	mov    $0x4,%al
   175bc:	eb 02                	jmp    175c0 <unalt+0x2>

000175be <unalt>:
   175be:	b0 10                	mov    $0x10,%al
   175c0:	80 3d 02 75 01 00 00 	cmpb   $0x0,0x17502
   175c7:	74 02                	je     175cb <unalt+0xd>
   175c9:	00 c0                	add    %al,%al
   175cb:	f6 d0                	not    %al
   175cd:	20 05 00 75 01 00    	and    %al,0x17500
   175d3:	c3                   	ret    

000175d4 <lshift>:
   175d4:	80 0d 00 75 01 00 01 	orb    $0x1,0x17500
   175db:	c3                   	ret    

000175dc <unlshift>:
   175dc:	80 25 00 75 01 00 fe 	andb   $0xfe,0x17500
   175e3:	c3                   	ret    

000175e4 <rshift>:
   175e4:	80 0d 00 75 01 00 02 	orb    $0x2,0x17500
   175eb:	c3                   	ret    

000175ec <unrshift>:
   175ec:	80 25 00 75 01 00 fd 	andb   $0xfd,0x17500
   175f3:	c3                   	ret    

000175f4 <caps>:
   175f4:	f6 05 00 75 01 00 80 	testb  $0x80,0x17500
   175fb:	0f 85 8d 00 00 00    	jne    1768e <cur2+0x28>
   17601:	80 35 01 75 01 00 04 	xorb   $0x4,0x17501
   17608:	80 35 00 75 01 00 40 	xorb   $0x40,0x17500
   1760f:	80 0d 00 75 01 00 80 	orb    $0x80,0x17500

00017616 <set_leds>:
   17616:	e8 aa 06 00 00       	call   17cc5 <kb_wait>
   1761b:	b0 ed                	mov    $0xed,%al
   1761d:	e6 60                	out    %al,$0x60
   1761f:	e8 a1 06 00 00       	call   17cc5 <kb_wait>
   17624:	a0 01 75 01 00       	mov    0x17501,%al
   17629:	e6 60                	out    %al,$0x60
   1762b:	c3                   	ret    

0001762c <uncaps>:
   1762c:	80 25 00 75 01 00 7f 	andb   $0x7f,0x17500
   17633:	c3                   	ret    

00017634 <scroll>:
   17634:	80 35 01 75 01 00 01 	xorb   $0x1,0x17501
   1763b:	eb d9                	jmp    17616 <set_leds>

0001763d <num>:
   1763d:	80 35 01 75 01 00 02 	xorb   $0x2,0x17501
   17644:	eb d0                	jmp    17616 <set_leds>

00017646 <cursor>:
   17646:	2c 47                	sub    $0x47,%al
   17648:	72 44                	jb     1768e <cur2+0x28>
   1764a:	3c 0c                	cmp    $0xc,%al
   1764c:	77 40                	ja     1768e <cur2+0x28>
   1764e:	75 16                	jne    17666 <cur2>
   17650:	f6 05 00 75 01 00 0c 	testb  $0xc,0x17500
   17657:	74 0d                	je     17666 <cur2>
   17659:	f6 05 00 75 01 00 30 	testb  $0x30,0x17500
   17660:	0f 85 68 06 00 00    	jne    17cce <reboot>

00017666 <cur2>:
   17666:	80 3d 02 75 01 00 01 	cmpb   $0x1,0x17502
   1766d:	74 20                	je     1768f <cur>
   1766f:	f6 05 01 75 01 00 02 	testb  $0x2,0x17501
   17676:	74 17                	je     1768f <cur>
   17678:	f6 05 00 75 01 00 03 	testb  $0x3,0x17500
   1767f:	75 0e                	jne    1768f <cur>
   17681:	31 db                	xor    %ebx,%ebx
   17683:	8a 80 a9 76 01 00    	mov    0x176a9(%eax),%al
   17689:	e9 db fe ff ff       	jmp    17569 <put_queue>
   1768e:	c3                   	ret    

0001768f <cur>:
   1768f:	8a 80 b6 76 01 00    	mov    0x176b6(%eax),%al
   17695:	3c 39                	cmp    $0x39,%al
   17697:	77 02                	ja     1769b <ok_cur>
   17699:	b4 7e                	mov    $0x7e,%ah

0001769b <ok_cur>:
   1769b:	c1 e0 10             	shl    $0x10,%eax
   1769e:	66 b8 1b 5b          	mov    $0x5b1b,%ax
   176a2:	31 db                	xor    %ebx,%ebx
   176a4:	e9 c0 fe ff ff       	jmp    17569 <put_queue>

000176a9 <num_table>:
   176a9:	37                   	aaa    
   176aa:	38 39                	cmp    %bh,(%ecx)
   176ac:	20 34 35 36 20 31 32 	and    %dh,0x32312036(,%esi,1)
   176b3:	33 30                	xor    (%eax),%esi
   176b5:	2c                   	.byte 0x2c

000176b6 <cur_table>:
   176b6:	48                   	dec    %eax
   176b7:	41                   	inc    %ecx
   176b8:	35 20 44 47 43       	xor    $0x43474420,%eax
   176bd:	20 59 42             	and    %bl,0x42(%ecx)
   176c0:	36 32 33             	xor    %ss:(%ebx),%dh

000176c3 <func>:
   176c3:	50                   	push   %eax
   176c4:	51                   	push   %ecx
   176c5:	52                   	push   %edx
   176c6:	e8 f8 f2 fe ff       	call   69c3 <show_stat>
   176cb:	5a                   	pop    %edx
   176cc:	59                   	pop    %ecx
   176cd:	58                   	pop    %eax
   176ce:	2c 3b                	sub    $0x3b,%al
   176d0:	72 21                	jb     176f3 <end_func>
   176d2:	3c 09                	cmp    $0x9,%al
   176d4:	76 0a                	jbe    176e0 <ok_func>
   176d6:	2c 12                	sub    $0x12,%al
   176d8:	3c 0a                	cmp    $0xa,%al
   176da:	72 17                	jb     176f3 <end_func>
   176dc:	3c 0b                	cmp    $0xb,%al
   176de:	77 13                	ja     176f3 <end_func>

000176e0 <ok_func>:
   176e0:	83 f9 04             	cmp    $0x4,%ecx
   176e3:	7c 0e                	jl     176f3 <end_func>
   176e5:	8b 04 85 f4 76 01 00 	mov    0x176f4(,%eax,4),%eax
   176ec:	31 db                	xor    %ebx,%ebx
   176ee:	e9 76 fe ff ff       	jmp    17569 <put_queue>

000176f3 <end_func>:
   176f3:	c3                   	ret    

000176f4 <func_table>:
   176f4:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   176f7:	41                   	inc    %ecx
   176f8:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   176fb:	42                   	inc    %edx
   176fc:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   176ff:	43                   	inc    %ebx
   17700:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   17703:	44                   	inc    %esp
   17704:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   17707:	45                   	inc    %ebp
   17708:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1770b:	46                   	inc    %esi
   1770c:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1770f:	47                   	inc    %edi
   17710:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   17713:	48                   	dec    %eax
   17714:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   17717:	49                   	dec    %ecx
   17718:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1771b:	4a                   	dec    %edx
   1771c:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1771f:	4b                   	dec    %ebx
   17720:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   17723:	4c                   	dec    %esp

00017724 <key_map>:
   17724:	00 1b                	add    %bl,(%ebx)
   17726:	31 32                	xor    %esi,(%edx)
   17728:	33 34 35 36 37 38 39 	xor    0x39383736(,%esi,1),%esi
   1772f:	30 2d 3d 7f 09 71    	xor    %ch,0x71097f3d
   17735:	77 65                	ja     1779c <shift_map+0x17>
   17737:	72 74                	jb     177ad <shift_map+0x28>
   17739:	79 75                	jns    177b0 <shift_map+0x2b>
   1773b:	69 6f 70 5b 5d 0d 00 	imul   $0xd5d5b,0x70(%edi),%ebp
   17742:	61                   	popa   
   17743:	73 64                	jae    177a9 <shift_map+0x24>
   17745:	66 67 68 6a 6b       	addr16 pushw $0x6b6a
   1774a:	6c                   	insb   (%dx),%es:(%edi)
   1774b:	3b 27                	cmp    (%edi),%esp
   1774d:	60                   	pusha  
   1774e:	00 5c 7a 78          	add    %bl,0x78(%edx,%edi,2)
   17752:	63 76 62             	arpl   %si,0x62(%esi)
   17755:	6e                   	outsb  %ds:(%esi),(%dx)
   17756:	6d                   	insl   (%dx),%es:(%edi)
   17757:	2c 2e                	sub    $0x2e,%al
   17759:	2f                   	das    
   1775a:	00 2a                	add    %ch,(%edx)
   1775c:	00 20                	add    %ah,(%eax)
	...
   1776e:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   17773:	00 00                	add    %al,(%eax)
   17775:	00 00                	add    %al,(%eax)
   17777:	00 00                	add    %al,(%eax)
   17779:	00 3c 00             	add    %bh,(%eax,%eax,1)
	...

00017785 <shift_map>:
   17785:	00 1b                	add    %bl,(%ebx)
   17787:	21 40 23             	and    %eax,0x23(%eax)
   1778a:	24 25                	and    $0x25,%al
   1778c:	5e                   	pop    %esi
   1778d:	26 2a 28             	sub    %es:(%eax),%ch
   17790:	29 5f 2b             	sub    %ebx,0x2b(%edi)
   17793:	7f 09                	jg     1779e <shift_map+0x19>
   17795:	51                   	push   %ecx
   17796:	57                   	push   %edi
   17797:	45                   	inc    %ebp
   17798:	52                   	push   %edx
   17799:	54                   	push   %esp
   1779a:	59                   	pop    %ecx
   1779b:	55                   	push   %ebp
   1779c:	49                   	dec    %ecx
   1779d:	4f                   	dec    %edi
   1779e:	50                   	push   %eax
   1779f:	7b 7d                	jnp    1781e <alt_map+0x38>
   177a1:	0d 00 41 53 44       	or     $0x44534100,%eax
   177a6:	46                   	inc    %esi
   177a7:	47                   	inc    %edi
   177a8:	48                   	dec    %eax
   177a9:	4a                   	dec    %edx
   177aa:	4b                   	dec    %ebx
   177ab:	4c                   	dec    %esp
   177ac:	3a 22                	cmp    (%edx),%ah
   177ae:	7e 00                	jle    177b0 <shift_map+0x2b>
   177b0:	7c 5a                	jl     1780c <alt_map+0x26>
   177b2:	58                   	pop    %eax
   177b3:	43                   	inc    %ebx
   177b4:	56                   	push   %esi
   177b5:	42                   	inc    %edx
   177b6:	4e                   	dec    %esi
   177b7:	4d                   	dec    %ebp
   177b8:	3c 3e                	cmp    $0x3e,%al
   177ba:	3f                   	aas    
   177bb:	00 2a                	add    %ch,(%edx)
   177bd:	00 20                	add    %ah,(%eax)
	...
   177cf:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   177d4:	00 00                	add    %al,(%eax)
   177d6:	00 00                	add    %al,(%eax)
   177d8:	00 00                	add    %al,(%eax)
   177da:	00 3e                	add    %bh,(%esi)
	...

000177e6 <alt_map>:
   177e6:	00 00                	add    %al,(%eax)
   177e8:	00 40 00             	add    %al,0x0(%eax)
   177eb:	24 00                	and    $0x0,%al
   177ed:	00 7b 5b             	add    %bh,0x5b(%ebx)
   177f0:	5d                   	pop    %ebp
   177f1:	7d 5c                	jge    1784f <do_self+0x8>
	...
   177ff:	00 00                	add    %al,(%eax)
   17801:	7e 0d                	jle    17810 <alt_map+0x2a>
	...
   1783b:	00 7c 00 00          	add    %bh,0x0(%eax,%eax,1)
	...

00017847 <do_self>:
   17847:	8d 1d e6 77 01 00    	lea    0x177e6,%ebx
   1784d:	f6 05 00 75 01 00 20 	testb  $0x20,0x17500
   17854:	75 15                	jne    1786b <do_self+0x24>
   17856:	8d 1d 85 77 01 00    	lea    0x17785,%ebx
   1785c:	f6 05 00 75 01 00 03 	testb  $0x3,0x17500
   17863:	75 06                	jne    1786b <do_self+0x24>
   17865:	8d 1d 24 77 01 00    	lea    0x17724,%ebx
   1786b:	8a 04 03             	mov    (%ebx,%eax,1),%al
   1786e:	08 c0                	or     %al,%al
   17870:	74 3d                	je     178af <none>
   17872:	f6 05 00 75 01 00 4c 	testb  $0x4c,0x17500
   17879:	74 0a                	je     17885 <do_self+0x3e>
   1787b:	3c 61                	cmp    $0x61,%al
   1787d:	72 06                	jb     17885 <do_self+0x3e>
   1787f:	3c 7d                	cmp    $0x7d,%al
   17881:	77 02                	ja     17885 <do_self+0x3e>
   17883:	2c 20                	sub    $0x20,%al
   17885:	f6 05 00 75 01 00 0c 	testb  $0xc,0x17500
   1788c:	74 0a                	je     17898 <do_self+0x51>
   1788e:	3c 40                	cmp    $0x40,%al
   17890:	72 06                	jb     17898 <do_self+0x51>
   17892:	3c 60                	cmp    $0x60,%al
   17894:	73 02                	jae    17898 <do_self+0x51>
   17896:	2c 40                	sub    $0x40,%al
   17898:	f6 05 00 75 01 00 10 	testb  $0x10,0x17500
   1789f:	74 02                	je     178a3 <do_self+0x5c>
   178a1:	0c 80                	or     $0x80,%al
   178a3:	25 ff 00 00 00       	and    $0xff,%eax
   178a8:	31 db                	xor    %ebx,%ebx
   178aa:	e8 ba fc ff ff       	call   17569 <put_queue>

000178af <none>:
   178af:	c3                   	ret    

000178b0 <minus>:
   178b0:	80 3d 02 75 01 00 01 	cmpb   $0x1,0x17502
   178b7:	75 8e                	jne    17847 <do_self>
   178b9:	b8 2f 00 00 00       	mov    $0x2f,%eax
   178be:	31 db                	xor    %ebx,%ebx
   178c0:	e9 a4 fc ff ff       	jmp    17569 <put_queue>

000178c5 <key_table>:
   178c5:	af                   	scas   %es:(%edi),%eax
   178c6:	78 01                	js     178c9 <key_table+0x4>
   178c8:	00 47 78             	add    %al,0x78(%edi)
   178cb:	01 00                	add    %eax,(%eax)
   178cd:	47                   	inc    %edi
   178ce:	78 01                	js     178d1 <key_table+0xc>
   178d0:	00 47 78             	add    %al,0x78(%edi)
   178d3:	01 00                	add    %eax,(%eax)
   178d5:	47                   	inc    %edi
   178d6:	78 01                	js     178d9 <key_table+0x14>
   178d8:	00 47 78             	add    %al,0x78(%edi)
   178db:	01 00                	add    %eax,(%eax)
   178dd:	47                   	inc    %edi
   178de:	78 01                	js     178e1 <key_table+0x1c>
   178e0:	00 47 78             	add    %al,0x78(%edi)
   178e3:	01 00                	add    %eax,(%eax)
   178e5:	47                   	inc    %edi
   178e6:	78 01                	js     178e9 <key_table+0x24>
   178e8:	00 47 78             	add    %al,0x78(%edi)
   178eb:	01 00                	add    %eax,(%eax)
   178ed:	47                   	inc    %edi
   178ee:	78 01                	js     178f1 <key_table+0x2c>
   178f0:	00 47 78             	add    %al,0x78(%edi)
   178f3:	01 00                	add    %eax,(%eax)
   178f5:	47                   	inc    %edi
   178f6:	78 01                	js     178f9 <key_table+0x34>
   178f8:	00 47 78             	add    %al,0x78(%edi)
   178fb:	01 00                	add    %eax,(%eax)
   178fd:	47                   	inc    %edi
   178fe:	78 01                	js     17901 <key_table+0x3c>
   17900:	00 47 78             	add    %al,0x78(%edi)
   17903:	01 00                	add    %eax,(%eax)
   17905:	47                   	inc    %edi
   17906:	78 01                	js     17909 <key_table+0x44>
   17908:	00 47 78             	add    %al,0x78(%edi)
   1790b:	01 00                	add    %eax,(%eax)
   1790d:	47                   	inc    %edi
   1790e:	78 01                	js     17911 <key_table+0x4c>
   17910:	00 47 78             	add    %al,0x78(%edi)
   17913:	01 00                	add    %eax,(%eax)
   17915:	47                   	inc    %edi
   17916:	78 01                	js     17919 <key_table+0x54>
   17918:	00 47 78             	add    %al,0x78(%edi)
   1791b:	01 00                	add    %eax,(%eax)
   1791d:	47                   	inc    %edi
   1791e:	78 01                	js     17921 <key_table+0x5c>
   17920:	00 47 78             	add    %al,0x78(%edi)
   17923:	01 00                	add    %eax,(%eax)
   17925:	47                   	inc    %edi
   17926:	78 01                	js     17929 <key_table+0x64>
   17928:	00 47 78             	add    %al,0x78(%edi)
   1792b:	01 00                	add    %eax,(%eax)
   1792d:	47                   	inc    %edi
   1792e:	78 01                	js     17931 <key_table+0x6c>
   17930:	00 47 78             	add    %al,0x78(%edi)
   17933:	01 00                	add    %eax,(%eax)
   17935:	47                   	inc    %edi
   17936:	78 01                	js     17939 <key_table+0x74>
   17938:	00 a2 75 01 00 47    	add    %ah,0x47000175(%edx)
   1793e:	78 01                	js     17941 <key_table+0x7c>
   17940:	00 47 78             	add    %al,0x78(%edi)
   17943:	01 00                	add    %eax,(%eax)
   17945:	47                   	inc    %edi
   17946:	78 01                	js     17949 <key_table+0x84>
   17948:	00 47 78             	add    %al,0x78(%edi)
   1794b:	01 00                	add    %eax,(%eax)
   1794d:	47                   	inc    %edi
   1794e:	78 01                	js     17951 <key_table+0x8c>
   17950:	00 47 78             	add    %al,0x78(%edi)
   17953:	01 00                	add    %eax,(%eax)
   17955:	47                   	inc    %edi
   17956:	78 01                	js     17959 <key_table+0x94>
   17958:	00 47 78             	add    %al,0x78(%edi)
   1795b:	01 00                	add    %eax,(%eax)
   1795d:	47                   	inc    %edi
   1795e:	78 01                	js     17961 <key_table+0x9c>
   17960:	00 47 78             	add    %al,0x78(%edi)
   17963:	01 00                	add    %eax,(%eax)
   17965:	47                   	inc    %edi
   17966:	78 01                	js     17969 <key_table+0xa4>
   17968:	00 47 78             	add    %al,0x78(%edi)
   1796b:	01 00                	add    %eax,(%eax)
   1796d:	d4 75                	aam    $0x75
   1796f:	01 00                	add    %eax,(%eax)
   17971:	47                   	inc    %edi
   17972:	78 01                	js     17975 <key_table+0xb0>
   17974:	00 47 78             	add    %al,0x78(%edi)
   17977:	01 00                	add    %eax,(%eax)
   17979:	47                   	inc    %edi
   1797a:	78 01                	js     1797d <key_table+0xb8>
   1797c:	00 47 78             	add    %al,0x78(%edi)
   1797f:	01 00                	add    %eax,(%eax)
   17981:	47                   	inc    %edi
   17982:	78 01                	js     17985 <key_table+0xc0>
   17984:	00 47 78             	add    %al,0x78(%edi)
   17987:	01 00                	add    %eax,(%eax)
   17989:	47                   	inc    %edi
   1798a:	78 01                	js     1798d <key_table+0xc8>
   1798c:	00 47 78             	add    %al,0x78(%edi)
   1798f:	01 00                	add    %eax,(%eax)
   17991:	47                   	inc    %edi
   17992:	78 01                	js     17995 <key_table+0xd0>
   17994:	00 47 78             	add    %al,0x78(%edi)
   17997:	01 00                	add    %eax,(%eax)
   17999:	b0 78                	mov    $0x78,%al
   1799b:	01 00                	add    %eax,(%eax)
   1799d:	e4 75                	in     $0x75,%al
   1799f:	01 00                	add    %eax,(%eax)
   179a1:	47                   	inc    %edi
   179a2:	78 01                	js     179a5 <key_table+0xe0>
   179a4:	00 a6 75 01 00 47    	add    %ah,0x47000175(%esi)
   179aa:	78 01                	js     179ad <key_table+0xe8>
   179ac:	00 f4                	add    %dh,%ah
   179ae:	75 01                	jne    179b1 <key_table+0xec>
   179b0:	00 c3                	add    %al,%bl
   179b2:	76 01                	jbe    179b5 <key_table+0xf0>
   179b4:	00 c3                	add    %al,%bl
   179b6:	76 01                	jbe    179b9 <key_table+0xf4>
   179b8:	00 c3                	add    %al,%bl
   179ba:	76 01                	jbe    179bd <key_table+0xf8>
   179bc:	00 c3                	add    %al,%bl
   179be:	76 01                	jbe    179c1 <key_table+0xfc>
   179c0:	00 c3                	add    %al,%bl
   179c2:	76 01                	jbe    179c5 <key_table+0x100>
   179c4:	00 c3                	add    %al,%bl
   179c6:	76 01                	jbe    179c9 <key_table+0x104>
   179c8:	00 c3                	add    %al,%bl
   179ca:	76 01                	jbe    179cd <key_table+0x108>
   179cc:	00 c3                	add    %al,%bl
   179ce:	76 01                	jbe    179d1 <key_table+0x10c>
   179d0:	00 c3                	add    %al,%bl
   179d2:	76 01                	jbe    179d5 <key_table+0x110>
   179d4:	00 c3                	add    %al,%bl
   179d6:	76 01                	jbe    179d9 <key_table+0x114>
   179d8:	00 3d 76 01 00 34    	add    %bh,0x34000176
   179de:	76 01                	jbe    179e1 <key_table+0x11c>
   179e0:	00 46 76             	add    %al,0x76(%esi)
   179e3:	01 00                	add    %eax,(%eax)
   179e5:	46                   	inc    %esi
   179e6:	76 01                	jbe    179e9 <key_table+0x124>
   179e8:	00 46 76             	add    %al,0x76(%esi)
   179eb:	01 00                	add    %eax,(%eax)
   179ed:	47                   	inc    %edi
   179ee:	78 01                	js     179f1 <key_table+0x12c>
   179f0:	00 46 76             	add    %al,0x76(%esi)
   179f3:	01 00                	add    %eax,(%eax)
   179f5:	46                   	inc    %esi
   179f6:	76 01                	jbe    179f9 <key_table+0x134>
   179f8:	00 46 76             	add    %al,0x76(%esi)
   179fb:	01 00                	add    %eax,(%eax)
   179fd:	47                   	inc    %edi
   179fe:	78 01                	js     17a01 <key_table+0x13c>
   17a00:	00 46 76             	add    %al,0x76(%esi)
   17a03:	01 00                	add    %eax,(%eax)
   17a05:	46                   	inc    %esi
   17a06:	76 01                	jbe    17a09 <key_table+0x144>
   17a08:	00 46 76             	add    %al,0x76(%esi)
   17a0b:	01 00                	add    %eax,(%eax)
   17a0d:	46                   	inc    %esi
   17a0e:	76 01                	jbe    17a11 <key_table+0x14c>
   17a10:	00 46 76             	add    %al,0x76(%esi)
   17a13:	01 00                	add    %eax,(%eax)
   17a15:	af                   	scas   %es:(%edi),%eax
   17a16:	78 01                	js     17a19 <key_table+0x154>
   17a18:	00 af 78 01 00 47    	add    %ch,0x47000178(%edi)
   17a1e:	78 01                	js     17a21 <key_table+0x15c>
   17a20:	00 c3                	add    %al,%bl
   17a22:	76 01                	jbe    17a25 <key_table+0x160>
   17a24:	00 c3                	add    %al,%bl
   17a26:	76 01                	jbe    17a29 <key_table+0x164>
   17a28:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a2e:	78 01                	js     17a31 <key_table+0x16c>
   17a30:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a36:	78 01                	js     17a39 <key_table+0x174>
   17a38:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a3e:	78 01                	js     17a41 <key_table+0x17c>
   17a40:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a46:	78 01                	js     17a49 <key_table+0x184>
   17a48:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a4e:	78 01                	js     17a51 <key_table+0x18c>
   17a50:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a56:	78 01                	js     17a59 <key_table+0x194>
   17a58:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a5e:	78 01                	js     17a61 <key_table+0x19c>
   17a60:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a66:	78 01                	js     17a69 <key_table+0x1a4>
   17a68:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a6e:	78 01                	js     17a71 <key_table+0x1ac>
   17a70:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a76:	78 01                	js     17a79 <key_table+0x1b4>
   17a78:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a7e:	78 01                	js     17a81 <key_table+0x1bc>
   17a80:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a86:	78 01                	js     17a89 <key_table+0x1c4>
   17a88:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a8e:	78 01                	js     17a91 <key_table+0x1cc>
   17a90:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a96:	78 01                	js     17a99 <key_table+0x1d4>
   17a98:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17a9e:	78 01                	js     17aa1 <key_table+0x1dc>
   17aa0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17aa6:	78 01                	js     17aa9 <key_table+0x1e4>
   17aa8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17aae:	78 01                	js     17ab1 <key_table+0x1ec>
   17ab0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ab6:	78 01                	js     17ab9 <key_table+0x1f4>
   17ab8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17abe:	78 01                	js     17ac1 <key_table+0x1fc>
   17ac0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ac6:	78 01                	js     17ac9 <key_table+0x204>
   17ac8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ace:	78 01                	js     17ad1 <key_table+0x20c>
   17ad0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ad6:	78 01                	js     17ad9 <key_table+0x214>
   17ad8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ade:	78 01                	js     17ae1 <key_table+0x21c>
   17ae0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ae6:	78 01                	js     17ae9 <key_table+0x224>
   17ae8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17aee:	78 01                	js     17af1 <key_table+0x22c>
   17af0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17af6:	78 01                	js     17af9 <key_table+0x234>
   17af8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17afe:	78 01                	js     17b01 <key_table+0x23c>
   17b00:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b06:	78 01                	js     17b09 <key_table+0x244>
   17b08:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b0e:	78 01                	js     17b11 <key_table+0x24c>
   17b10:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b16:	78 01                	js     17b19 <key_table+0x254>
   17b18:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b1e:	78 01                	js     17b21 <key_table+0x25c>
   17b20:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b26:	78 01                	js     17b29 <key_table+0x264>
   17b28:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b2e:	78 01                	js     17b31 <key_table+0x26c>
   17b30:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b36:	78 01                	js     17b39 <key_table+0x274>
   17b38:	00 ba 75 01 00 af    	add    %bh,-0x50fffe8b(%edx)
   17b3e:	78 01                	js     17b41 <key_table+0x27c>
   17b40:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b46:	78 01                	js     17b49 <key_table+0x284>
   17b48:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b4e:	78 01                	js     17b51 <key_table+0x28c>
   17b50:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b56:	78 01                	js     17b59 <key_table+0x294>
   17b58:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b5e:	78 01                	js     17b61 <key_table+0x29c>
   17b60:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b66:	78 01                	js     17b69 <key_table+0x2a4>
   17b68:	00 af 78 01 00 dc    	add    %ch,-0x23fffe88(%edi)
   17b6e:	75 01                	jne    17b71 <key_table+0x2ac>
   17b70:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b76:	78 01                	js     17b79 <key_table+0x2b4>
   17b78:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b7e:	78 01                	js     17b81 <key_table+0x2bc>
   17b80:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b86:	78 01                	js     17b89 <key_table+0x2c4>
   17b88:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b8e:	78 01                	js     17b91 <key_table+0x2cc>
   17b90:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17b96:	78 01                	js     17b99 <key_table+0x2d4>
   17b98:	00 af 78 01 00 ec    	add    %ch,-0x13fffe88(%edi)
   17b9e:	75 01                	jne    17ba1 <key_table+0x2dc>
   17ba0:	00 af 78 01 00 be    	add    %ch,-0x41fffe88(%edi)
   17ba6:	75 01                	jne    17ba9 <key_table+0x2e4>
   17ba8:	00 af 78 01 00 2c    	add    %ch,0x2c000178(%edi)
   17bae:	76 01                	jbe    17bb1 <key_table+0x2ec>
   17bb0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bb6:	78 01                	js     17bb9 <key_table+0x2f4>
   17bb8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bbe:	78 01                	js     17bc1 <key_table+0x2fc>
   17bc0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bc6:	78 01                	js     17bc9 <key_table+0x304>
   17bc8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bce:	78 01                	js     17bd1 <key_table+0x30c>
   17bd0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bd6:	78 01                	js     17bd9 <key_table+0x314>
   17bd8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bde:	78 01                	js     17be1 <key_table+0x31c>
   17be0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17be6:	78 01                	js     17be9 <key_table+0x324>
   17be8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bee:	78 01                	js     17bf1 <key_table+0x32c>
   17bf0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bf6:	78 01                	js     17bf9 <key_table+0x334>
   17bf8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17bfe:	78 01                	js     17c01 <key_table+0x33c>
   17c00:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c06:	78 01                	js     17c09 <key_table+0x344>
   17c08:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c0e:	78 01                	js     17c11 <key_table+0x34c>
   17c10:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c16:	78 01                	js     17c19 <key_table+0x354>
   17c18:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c1e:	78 01                	js     17c21 <key_table+0x35c>
   17c20:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c26:	78 01                	js     17c29 <key_table+0x364>
   17c28:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c2e:	78 01                	js     17c31 <key_table+0x36c>
   17c30:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c36:	78 01                	js     17c39 <key_table+0x374>
   17c38:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c3e:	78 01                	js     17c41 <key_table+0x37c>
   17c40:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c46:	78 01                	js     17c49 <key_table+0x384>
   17c48:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c4e:	78 01                	js     17c51 <key_table+0x38c>
   17c50:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c56:	78 01                	js     17c59 <key_table+0x394>
   17c58:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c5e:	78 01                	js     17c61 <key_table+0x39c>
   17c60:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c66:	78 01                	js     17c69 <key_table+0x3a4>
   17c68:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c6e:	78 01                	js     17c71 <key_table+0x3ac>
   17c70:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c76:	78 01                	js     17c79 <key_table+0x3b4>
   17c78:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c7e:	78 01                	js     17c81 <key_table+0x3bc>
   17c80:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c86:	78 01                	js     17c89 <key_table+0x3c4>
   17c88:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c8e:	78 01                	js     17c91 <key_table+0x3cc>
   17c90:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c96:	78 01                	js     17c99 <key_table+0x3d4>
   17c98:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17c9e:	78 01                	js     17ca1 <key_table+0x3dc>
   17ca0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17ca6:	78 01                	js     17ca9 <key_table+0x3e4>
   17ca8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17cae:	78 01                	js     17cb1 <key_table+0x3ec>
   17cb0:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17cb6:	78 01                	js     17cb9 <key_table+0x3f4>
   17cb8:	00 af 78 01 00 af    	add    %ch,-0x50fffe88(%edi)
   17cbe:	78 01                	js     17cc1 <key_table+0x3fc>
   17cc0:	00                   	.byte 0x0
   17cc1:	af                   	scas   %es:(%edi),%eax
   17cc2:	78 01                	js     17cc5 <kb_wait>
	...

00017cc5 <kb_wait>:
   17cc5:	50                   	push   %eax
   17cc6:	e4 64                	in     $0x64,%al
   17cc8:	a8 02                	test   $0x2,%al
   17cca:	75 fa                	jne    17cc6 <kb_wait+0x1>
   17ccc:	58                   	pop    %eax
   17ccd:	c3                   	ret    

00017cce <reboot>:
   17cce:	e8 f2 ff ff ff       	call   17cc5 <kb_wait>
   17cd3:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
   17cda:	34 12 
   17cdc:	b0 fc                	mov    $0xfc,%al
   17cde:	e6 64                	out    %al,$0x64

00017ce0 <die>:
   17ce0:	eb fe                	jmp    17ce0 <die>

00017ce2 <rs_init>:
	outb_p(0x0d,port+1);	/* enable all intrs but writes */
	(void)inb(port);	/* read data port to reset things (?) */
}

void rs_init(void)
{
   17ce2:	56                   	push   %esi
   17ce3:	53                   	push   %ebx
	set_intr_gate(0x24,rs1_interrupt);
   17ce4:	ba e4 7d 01 00       	mov    $0x17de4,%edx
   17ce9:	b8 00 00 08 00       	mov    $0x80000,%eax
   17cee:	66 89 d0             	mov    %dx,%ax
   17cf1:	66 ba 00 8e          	mov    $0x8e00,%dx
   17cf5:	a3 d8 55 00 00       	mov    %eax,0x55d8
   17cfa:	89 15 dc 55 00 00    	mov    %edx,0x55dc
	set_intr_gate(0x23,rs2_interrupt);
   17d00:	ba ec 7d 01 00       	mov    $0x17dec,%edx
   17d05:	66 89 d0             	mov    %dx,%ax
   17d08:	66 ba 00 8e          	mov    $0x8e00,%dx
   17d0c:	a3 d0 55 00 00       	mov    %eax,0x55d0
   17d11:	89 15 d4 55 00 00    	mov    %edx,0x55d4
{
   17d17:	8b 0d b0 cb 01 00    	mov    0x1cbb0,%ecx
	outb_p(0x80,port+3);	/* set DLAB of line control reg */
   17d1d:	b8 80 00 00 00       	mov    $0x80,%eax
   17d22:	8d 71 03             	lea    0x3(%ecx),%esi
   17d25:	89 f2                	mov    %esi,%edx
   17d27:	ee                   	out    %al,(%dx)
   17d28:	eb 00                	jmp    17d2a <rs_init+0x48>
   17d2a:	eb 00                	jmp    17d2c <rs_init+0x4a>
	outb_p(0x30,port);	/* LS of divisor (48 -> 2400 bps */
   17d2c:	b0 30                	mov    $0x30,%al
   17d2e:	89 ca                	mov    %ecx,%edx
   17d30:	ee                   	out    %al,(%dx)
   17d31:	eb 00                	jmp    17d33 <rs_init+0x51>
   17d33:	eb 00                	jmp    17d35 <rs_init+0x53>
	outb_p(0x00,port+1);	/* MS of divisor */
   17d35:	b0 00                	mov    $0x0,%al
   17d37:	8d 59 01             	lea    0x1(%ecx),%ebx
   17d3a:	89 da                	mov    %ebx,%edx
   17d3c:	ee                   	out    %al,(%dx)
   17d3d:	eb 00                	jmp    17d3f <rs_init+0x5d>
   17d3f:	eb 00                	jmp    17d41 <rs_init+0x5f>
	outb_p(0x03,port+3);	/* reset DLAB */
   17d41:	b0 03                	mov    $0x3,%al
   17d43:	89 f2                	mov    %esi,%edx
   17d45:	ee                   	out    %al,(%dx)
   17d46:	eb 00                	jmp    17d48 <rs_init+0x66>
   17d48:	eb 00                	jmp    17d4a <rs_init+0x68>
	outb_p(0x0b,port+4);	/* set DTR,RTS, OUT_2 */
   17d4a:	b0 0b                	mov    $0xb,%al
   17d4c:	8d 51 04             	lea    0x4(%ecx),%edx
   17d4f:	ee                   	out    %al,(%dx)
   17d50:	eb 00                	jmp    17d52 <rs_init+0x70>
   17d52:	eb 00                	jmp    17d54 <rs_init+0x72>
	outb_p(0x0d,port+1);	/* enable all intrs but writes */
   17d54:	b0 0d                	mov    $0xd,%al
   17d56:	89 da                	mov    %ebx,%edx
   17d58:	ee                   	out    %al,(%dx)
   17d59:	eb 00                	jmp    17d5b <rs_init+0x79>
   17d5b:	eb 00                	jmp    17d5d <rs_init+0x7b>
	(void)inb(port);	/* read data port to reset things (?) */
   17d5d:	89 ca                	mov    %ecx,%edx
   17d5f:	ec                   	in     (%dx),%al
{
   17d60:	8b 0d 10 d8 01 00    	mov    0x1d810,%ecx
	outb_p(0x80,port+3);	/* set DLAB of line control reg */
   17d66:	b8 80 00 00 00       	mov    $0x80,%eax
   17d6b:	8d 71 03             	lea    0x3(%ecx),%esi
   17d6e:	89 f2                	mov    %esi,%edx
   17d70:	ee                   	out    %al,(%dx)
   17d71:	eb 00                	jmp    17d73 <rs_init+0x91>
   17d73:	eb 00                	jmp    17d75 <rs_init+0x93>
	outb_p(0x30,port);	/* LS of divisor (48 -> 2400 bps */
   17d75:	b0 30                	mov    $0x30,%al
   17d77:	89 ca                	mov    %ecx,%edx
   17d79:	ee                   	out    %al,(%dx)
   17d7a:	eb 00                	jmp    17d7c <rs_init+0x9a>
   17d7c:	eb 00                	jmp    17d7e <rs_init+0x9c>
	outb_p(0x00,port+1);	/* MS of divisor */
   17d7e:	b0 00                	mov    $0x0,%al
   17d80:	8d 59 01             	lea    0x1(%ecx),%ebx
   17d83:	89 da                	mov    %ebx,%edx
   17d85:	ee                   	out    %al,(%dx)
   17d86:	eb 00                	jmp    17d88 <rs_init+0xa6>
   17d88:	eb 00                	jmp    17d8a <rs_init+0xa8>
	outb_p(0x03,port+3);	/* reset DLAB */
   17d8a:	b0 03                	mov    $0x3,%al
   17d8c:	89 f2                	mov    %esi,%edx
   17d8e:	ee                   	out    %al,(%dx)
   17d8f:	eb 00                	jmp    17d91 <rs_init+0xaf>
   17d91:	eb 00                	jmp    17d93 <rs_init+0xb1>
	outb_p(0x0b,port+4);	/* set DTR,RTS, OUT_2 */
   17d93:	b0 0b                	mov    $0xb,%al
   17d95:	8d 51 04             	lea    0x4(%ecx),%edx
   17d98:	ee                   	out    %al,(%dx)
   17d99:	eb 00                	jmp    17d9b <rs_init+0xb9>
   17d9b:	eb 00                	jmp    17d9d <rs_init+0xbb>
	outb_p(0x0d,port+1);	/* enable all intrs but writes */
   17d9d:	b0 0d                	mov    $0xd,%al
   17d9f:	89 da                	mov    %ebx,%edx
   17da1:	ee                   	out    %al,(%dx)
   17da2:	eb 00                	jmp    17da4 <rs_init+0xc2>
   17da4:	eb 00                	jmp    17da6 <rs_init+0xc4>
	(void)inb(port);	/* read data port to reset things (?) */
   17da6:	89 ca                	mov    %ecx,%edx
   17da8:	ec                   	in     (%dx),%al
	init(tty_table[1].read_q.data);
	init(tty_table[2].read_q.data);
	outb(inb_p(0x21)&0xE7,0x21);
   17da9:	ba 21 00 00 00       	mov    $0x21,%edx
   17dae:	ec                   	in     (%dx),%al
   17daf:	eb 00                	jmp    17db1 <rs_init+0xcf>
   17db1:	eb 00                	jmp    17db3 <rs_init+0xd1>
   17db3:	25 e7 00 00 00       	and    $0xe7,%eax
   17db8:	ee                   	out    %al,(%dx)
}
   17db9:	5b                   	pop    %ebx
   17dba:	5e                   	pop    %esi
   17dbb:	c3                   	ret    

00017dbc <rs_write>:
 * set the interrupt register accordingly
 *
 *	void _rs_write(struct tty_struct * tty);
 */
void rs_write(struct tty_struct * tty)
{
   17dbc:	8b 54 24 04          	mov    0x4(%esp),%edx
	cli();
   17dc0:	fa                   	cli    
	if (!EMPTY(tty->write_q))
   17dc1:	8b 82 44 04 00 00    	mov    0x444(%edx),%eax
   17dc7:	3b 82 48 04 00 00    	cmp    0x448(%edx),%eax
   17dcd:	74 13                	je     17de2 <rs_write+0x26>
		outb(inb_p(tty->write_q.data+1)|0x02,tty->write_q.data+1);
   17dcf:	8b 92 40 04 00 00    	mov    0x440(%edx),%edx
   17dd5:	42                   	inc    %edx
   17dd6:	ec                   	in     (%dx),%al
   17dd7:	eb 00                	jmp    17dd9 <rs_write+0x1d>
   17dd9:	eb 00                	jmp    17ddb <rs_write+0x1f>
   17ddb:	83 c8 02             	or     $0x2,%eax
   17dde:	0f b6 c0             	movzbl %al,%eax
   17de1:	ee                   	out    %al,(%dx)
	sti();
   17de2:	fb                   	sti    
}
   17de3:	c3                   	ret    

00017de4 <rs1_interrupt>:
   17de4:	68 48 e4 01 00       	push   $0x1e448
   17de9:	eb 06                	jmp    17df1 <rs_int>
   17deb:	90                   	nop

00017dec <rs2_interrupt>:
   17dec:	68 50 e4 01 00       	push   $0x1e450

00017df1 <rs_int>:
   17df1:	52                   	push   %edx
   17df2:	51                   	push   %ecx
   17df3:	53                   	push   %ebx
   17df4:	50                   	push   %eax
   17df5:	06                   	push   %es
   17df6:	1e                   	push   %ds
   17df7:	6a 10                	push   $0x10
   17df9:	1f                   	pop    %ds
   17dfa:	6a 10                	push   $0x10
   17dfc:	07                   	pop    %es
   17dfd:	8b 54 24 18          	mov    0x18(%esp),%edx
   17e01:	8b 12                	mov    (%edx),%edx
   17e03:	8b 12                	mov    (%edx),%edx
   17e05:	83 c2 02             	add    $0x2,%edx

00017e08 <rep_int>:
   17e08:	31 c0                	xor    %eax,%eax
   17e0a:	ec                   	in     (%dx),%al
   17e0b:	a8 01                	test   $0x1,%al
   17e0d:	75 16                	jne    17e25 <end>
   17e0f:	3c 06                	cmp    $0x6,%al
   17e11:	77 12                	ja     17e25 <end>
   17e13:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   17e17:	52                   	push   %edx
   17e18:	83 ea 02             	sub    $0x2,%edx
   17e1b:	ff 14 45 33 7e 01 00 	call   *0x17e33(,%eax,2)
   17e22:	5a                   	pop    %edx
   17e23:	eb e3                	jmp    17e08 <rep_int>

00017e25 <end>:
   17e25:	b0 20                	mov    $0x20,%al
   17e27:	e6 20                	out    %al,$0x20
   17e29:	1f                   	pop    %ds
   17e2a:	07                   	pop    %es
   17e2b:	58                   	pop    %eax
   17e2c:	5b                   	pop    %ebx
   17e2d:	59                   	pop    %ecx
   17e2e:	5a                   	pop    %edx
   17e2f:	83 c4 04             	add    $0x4,%esp
   17e32:	cf                   	iret   

00017e33 <jmp_table>:
   17e33:	44                   	inc    %esp
   17e34:	7e 01                	jle    17e37 <jmp_table+0x4>
   17e36:	00 7e 7e             	add    %bh,0x7e(%esi)
   17e39:	01 00                	add    %eax,(%eax)
   17e3b:	50                   	push   %eax
   17e3c:	7e 01                	jle    17e3f <jmp_table+0xc>
   17e3e:	00 4a 7e             	add    %cl,0x7e(%edx)
   17e41:	01 00                	add    %eax,(%eax)
   17e43:	90                   	nop

00017e44 <modem_status>:
   17e44:	83 c2 06             	add    $0x6,%edx
   17e47:	ec                   	in     (%dx),%al
   17e48:	c3                   	ret    
   17e49:	90                   	nop

00017e4a <line_status>:
   17e4a:	83 c2 05             	add    $0x5,%edx
   17e4d:	ec                   	in     (%dx),%al
   17e4e:	c3                   	ret    
   17e4f:	90                   	nop

00017e50 <read_char>:
   17e50:	ec                   	in     (%dx),%al
   17e51:	89 ca                	mov    %ecx,%edx
   17e53:	81 ea 40 e4 01 00    	sub    $0x1e440,%edx
   17e59:	c1 ea 03             	shr    $0x3,%edx
   17e5c:	8b 09                	mov    (%ecx),%ecx
   17e5e:	8b 59 04             	mov    0x4(%ecx),%ebx
   17e61:	88 44 19 10          	mov    %al,0x10(%ecx,%ebx,1)
   17e65:	43                   	inc    %ebx
   17e66:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   17e6c:	3b 59 08             	cmp    0x8(%ecx),%ebx
   17e6f:	74 03                	je     17e74 <read_char+0x24>
   17e71:	89 59 04             	mov    %ebx,0x4(%ecx)
   17e74:	52                   	push   %edx
   17e75:	e8 9f dc ff ff       	call   15b19 <do_tty_interrupt>
   17e7a:	83 c4 04             	add    $0x4,%esp
   17e7d:	c3                   	ret    

00017e7e <write_char>:
   17e7e:	8b 49 04             	mov    0x4(%ecx),%ecx
   17e81:	8b 59 04             	mov    0x4(%ecx),%ebx
   17e84:	2b 59 08             	sub    0x8(%ecx),%ebx
   17e87:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   17e8d:	74 2d                	je     17ebc <write_buffer_empty>
   17e8f:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
   17e95:	77 0d                	ja     17ea4 <write_char+0x26>
   17e97:	8b 59 0c             	mov    0xc(%ecx),%ebx
   17e9a:	85 db                	test   %ebx,%ebx
   17e9c:	74 06                	je     17ea4 <write_char+0x26>
   17e9e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   17ea4:	8b 59 08             	mov    0x8(%ecx),%ebx
   17ea7:	8a 44 19 10          	mov    0x10(%ecx,%ebx,1),%al
   17eab:	ee                   	out    %al,(%dx)
   17eac:	43                   	inc    %ebx
   17ead:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   17eb3:	89 59 08             	mov    %ebx,0x8(%ecx)
   17eb6:	3b 59 04             	cmp    0x4(%ecx),%ebx
   17eb9:	74 01                	je     17ebc <write_buffer_empty>
   17ebb:	c3                   	ret    

00017ebc <write_buffer_empty>:
   17ebc:	8b 59 0c             	mov    0xc(%ecx),%ebx
   17ebf:	85 db                	test   %ebx,%ebx
   17ec1:	74 06                	je     17ec9 <write_buffer_empty+0xd>
   17ec3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   17ec9:	42                   	inc    %edx
   17eca:	ec                   	in     (%dx),%al
   17ecb:	eb 00                	jmp    17ecd <write_buffer_empty+0x11>
   17ecd:	eb 00                	jmp    17ecf <write_buffer_empty+0x13>
   17ecf:	24 0d                	and    $0xd,%al
   17ed1:	ee                   	out    %al,(%dx)
   17ed2:	c3                   	ret    

00017ed3 <tty_ioctl>:
	change_speed(tty);
	return 0;
}

int tty_ioctl(int dev, int cmd, int arg)
{
   17ed3:	55                   	push   %ebp
   17ed4:	57                   	push   %edi
   17ed5:	56                   	push   %esi
   17ed6:	53                   	push   %ebx
   17ed7:	83 ec 2c             	sub    $0x2c,%esp
   17eda:	8b 5c 24 40          	mov    0x40(%esp),%ebx
   17ede:	8b 7c 24 48          	mov    0x48(%esp),%edi
	struct tty_struct * tty;
	if (MAJOR(dev) == 5) {
   17ee2:	89 d8                	mov    %ebx,%eax
   17ee4:	c1 e8 08             	shr    $0x8,%eax
   17ee7:	83 f8 05             	cmp    $0x5,%eax
   17eea:	75 21                	jne    17f0d <tty_ioctl+0x3a>
		dev=current->tty;
   17eec:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   17ef1:	8b 98 68 02 00 00    	mov    0x268(%eax),%ebx
		if (dev<0)
   17ef7:	85 db                	test   %ebx,%ebx
   17ef9:	79 18                	jns    17f13 <tty_ioctl+0x40>
			panic("tty_ioctl: dev<0");
   17efb:	83 ec 0c             	sub    $0xc,%esp
   17efe:	68 dc 99 01 00       	push   $0x199dc
   17f03:	e8 11 04 ff ff       	call   8319 <panic>
   17f08:	83 c4 10             	add    $0x10,%esp
   17f0b:	eb 06                	jmp    17f13 <tty_ioctl+0x40>
	} else
		dev=MINOR(dev);
   17f0d:	81 e3 ff 00 00 00    	and    $0xff,%ebx
	tty = dev + tty_table;
   17f13:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
   17f16:	8d 04 80             	lea    (%eax,%eax,4),%eax
   17f19:	c1 e0 02             	shl    $0x2,%eax
   17f1c:	29 d8                	sub    %ebx,%eax
   17f1e:	c1 e0 05             	shl    $0x5,%eax
   17f21:	8d 98 20 bf 01 00    	lea    0x1bf20(%eax),%ebx
	switch (cmd) {
   17f27:	8b 54 24 44          	mov    0x44(%esp),%edx
   17f2b:	81 ea 01 54 00 00    	sub    $0x5401,%edx
		case TIOCGSOFTCAR:
			return -EINVAL; /* not implemented */
		case TIOCSSOFTCAR:
			return -EINVAL; /* not implemented */
		default:
			return -EINVAL;
   17f31:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	switch (cmd) {
   17f36:	83 fa 1a             	cmp    $0x1a,%edx
   17f39:	0f 87 05 03 00 00    	ja     18244 <tty_ioctl+0x371>
   17f3f:	ff 24 95 f0 99 01 00 	jmp    *0x199f0(,%edx,4)
{
   17f46:	89 de                	mov    %ebx,%esi
   17f48:	89 fb                	mov    %edi,%ebx
	verify_area(termios, sizeof (*termios));
   17f4a:	83 ec 08             	sub    $0x8,%esp
   17f4d:	6a 24                	push   $0x24
   17f4f:	57                   	push   %edi
   17f50:	e8 17 ff fe ff       	call   7e6c <verify_area>
   17f55:	83 c4 10             	add    $0x10,%esp
	for (i=0 ; i< (sizeof (*termios)) ; i++)
   17f58:	ba 00 00 00 00       	mov    $0x0,%edx
{
   17f5d:	8a 04 16             	mov    (%esi,%edx,1),%al
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
   17f60:	64 88 04 13          	mov    %al,%fs:(%ebx,%edx,1)
   17f64:	42                   	inc    %edx
   17f65:	83 fa 23             	cmp    $0x23,%edx
   17f68:	76 f3                	jbe    17f5d <tty_ioctl+0x8a>
{
   17f6a:	b8 00 00 00 00       	mov    $0x0,%eax
   17f6f:	e9 d0 02 00 00       	jmp    18244 <tty_ioctl+0x371>
{
   17f74:	8d 53 30             	lea    0x30(%ebx),%edx
	cli();
   17f77:	fa                   	cli    
	queue->head = queue->tail;
   17f78:	8b 42 08             	mov    0x8(%edx),%eax
   17f7b:	89 42 04             	mov    %eax,0x4(%edx)
	sti();
   17f7e:	fb                   	sti    
{
   17f7f:	89 da                	mov    %ebx,%edx
   17f81:	89 fb                	mov    %edi,%ebx
	for (i=0 ; i< (sizeof (*termios)) ; i++)
   17f83:	b9 00 00 00 00       	mov    $0x0,%ecx
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
   17f88:	64 8a 04 0b          	mov    %fs:(%ebx,%ecx,1),%al
{
   17f8c:	88 04 0a             	mov    %al,(%edx,%ecx,1)
   17f8f:	41                   	inc    %ecx
   17f90:	83 f9 23             	cmp    $0x23,%ecx
   17f93:	76 f3                	jbe    17f88 <tty_ioctl+0xb5>
	if (!(port = tty->read_q.data))
   17f95:	66 8b 72 30          	mov    0x30(%edx),%si
   17f99:	66 85 f6             	test   %si,%si
   17f9c:	74 41                	je     17fdf <tty_ioctl+0x10c>
	quot = quotient[tty->termios.c_cflag & CBAUD];
   17f9e:	8b 42 08             	mov    0x8(%edx),%eax
   17fa1:	83 e0 0f             	and    $0xf,%eax
   17fa4:	66 8b 9c 00 60 e4 01 	mov    0x1e460(%eax,%eax,1),%bx
   17fab:	00 
	cli();
   17fac:	fa                   	cli    
	outb_p(0x80,port+3);		/* set DLAB */
   17fad:	b8 80 00 00 00       	mov    $0x80,%eax
   17fb2:	0f b7 fe             	movzwl %si,%edi
   17fb5:	8d 4f 03             	lea    0x3(%edi),%ecx
   17fb8:	89 ca                	mov    %ecx,%edx
   17fba:	ee                   	out    %al,(%dx)
   17fbb:	eb 00                	jmp    17fbd <tty_ioctl+0xea>
   17fbd:	eb 00                	jmp    17fbf <tty_ioctl+0xec>
	outb_p(quot & 0xff,port);	/* LS of divisor */
   17fbf:	0f b6 c3             	movzbl %bl,%eax
   17fc2:	89 f2                	mov    %esi,%edx
   17fc4:	ee                   	out    %al,(%dx)
   17fc5:	eb 00                	jmp    17fc7 <tty_ioctl+0xf4>
   17fc7:	eb 00                	jmp    17fc9 <tty_ioctl+0xf6>
	outb_p(quot >> 8,port+1);	/* MS of divisor */
   17fc9:	0f b6 df             	movzbl %bh,%ebx
   17fcc:	8d 57 01             	lea    0x1(%edi),%edx
   17fcf:	89 d8                	mov    %ebx,%eax
   17fd1:	ee                   	out    %al,(%dx)
   17fd2:	eb 00                	jmp    17fd4 <tty_ioctl+0x101>
   17fd4:	eb 00                	jmp    17fd6 <tty_ioctl+0x103>
	outb(0x03,port+3);		/* reset DLAB */
   17fd6:	b8 03 00 00 00       	mov    $0x3,%eax
   17fdb:	89 ca                	mov    %ecx,%edx
   17fdd:	ee                   	out    %al,(%dx)
	sti();
   17fde:	fb                   	sti    
{
   17fdf:	b8 00 00 00 00       	mov    $0x0,%eax
   17fe4:	e9 5b 02 00 00       	jmp    18244 <tty_ioctl+0x371>
{
   17fe9:	89 dd                	mov    %ebx,%ebp
   17feb:	89 fe                	mov    %edi,%esi
	verify_area(termio, sizeof (*termio));
   17fed:	83 ec 08             	sub    $0x8,%esp
   17ff0:	6a 12                	push   $0x12
   17ff2:	57                   	push   %edi
   17ff3:	e8 74 fe fe ff       	call   7e6c <verify_area>
   17ff8:	83 c4 10             	add    $0x10,%esp
	tmp_termio.c_iflag = tty->termios.c_iflag;
   17ffb:	8b 03                	mov    (%ebx),%eax
   17ffd:	66 89 04 24          	mov    %ax,(%esp)
	tmp_termio.c_oflag = tty->termios.c_oflag;
   18001:	8b 43 04             	mov    0x4(%ebx),%eax
   18004:	66 89 44 24 02       	mov    %ax,0x2(%esp)
	tmp_termio.c_cflag = tty->termios.c_cflag;
   18009:	8b 43 08             	mov    0x8(%ebx),%eax
   1800c:	66 89 44 24 04       	mov    %ax,0x4(%esp)
	tmp_termio.c_lflag = tty->termios.c_lflag;
   18011:	8b 43 0c             	mov    0xc(%ebx),%eax
   18014:	66 89 44 24 06       	mov    %ax,0x6(%esp)
	tmp_termio.c_line = tty->termios.c_line;
   18019:	8a 43 10             	mov    0x10(%ebx),%al
   1801c:	88 44 24 08          	mov    %al,0x8(%esp)
	for(i=0 ; i < NCC ; i++)
   18020:	ba 00 00 00 00       	mov    $0x0,%edx
		tmp_termio.c_cc[i] = tty->termios.c_cc[i];
   18025:	8a 44 2a 11          	mov    0x11(%edx,%ebp,1),%al
   18029:	88 44 14 09          	mov    %al,0x9(%esp,%edx,1)
	for(i=0 ; i < NCC ; i++)
   1802d:	42                   	inc    %edx
   1802e:	83 fa 07             	cmp    $0x7,%edx
   18031:	7e f2                	jle    18025 <tty_ioctl+0x152>
	for (i=0 ; i< (sizeof (*termio)) ; i++)
   18033:	ba 00 00 00 00       	mov    $0x0,%edx
{
   18038:	8a 04 14             	mov    (%esp,%edx,1),%al
__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
   1803b:	64 88 04 16          	mov    %al,%fs:(%esi,%edx,1)
   1803f:	42                   	inc    %edx
   18040:	83 fa 11             	cmp    $0x11,%edx
   18043:	76 f3                	jbe    18038 <tty_ioctl+0x165>
{
   18045:	b8 00 00 00 00       	mov    $0x0,%eax
   1804a:	e9 f5 01 00 00       	jmp    18244 <tty_ioctl+0x371>
{
   1804f:	8d 53 30             	lea    0x30(%ebx),%edx
	cli();
   18052:	fa                   	cli    
	queue->head = queue->tail;
   18053:	8b 42 08             	mov    0x8(%edx),%eax
   18056:	89 42 04             	mov    %eax,0x4(%edx)
	sti();
   18059:	fb                   	sti    
{
   1805a:	89 da                	mov    %ebx,%edx
   1805c:	89 fb                	mov    %edi,%ebx
	for (i=0 ; i< (sizeof (*termio)) ; i++)
   1805e:	b9 00 00 00 00       	mov    $0x0,%ecx
	__asm__ ("movb %%fs:%1,%0":"=r" (_v):"m" (*addr));
   18063:	64 8a 04 0b          	mov    %fs:(%ebx,%ecx,1),%al
{
   18067:	88 04 0c             	mov    %al,(%esp,%ecx,1)
   1806a:	41                   	inc    %ecx
   1806b:	83 f9 11             	cmp    $0x11,%ecx
   1806e:	76 f3                	jbe    18063 <tty_ioctl+0x190>
	*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;
   18070:	8b 04 24             	mov    (%esp),%eax
   18073:	66 89 02             	mov    %ax,(%edx)
	*(unsigned short *)&tty->termios.c_oflag = tmp_termio.c_oflag;
   18076:	66 8b 44 24 02       	mov    0x2(%esp),%ax
   1807b:	66 89 42 04          	mov    %ax,0x4(%edx)
	*(unsigned short *)&tty->termios.c_cflag = tmp_termio.c_cflag;
   1807f:	8b 44 24 04          	mov    0x4(%esp),%eax
   18083:	66 89 42 08          	mov    %ax,0x8(%edx)
	*(unsigned short *)&tty->termios.c_lflag = tmp_termio.c_lflag;
   18087:	66 8b 44 24 06       	mov    0x6(%esp),%ax
   1808c:	66 89 42 0c          	mov    %ax,0xc(%edx)
	tty->termios.c_line = tmp_termio.c_line;
   18090:	8a 44 24 08          	mov    0x8(%esp),%al
   18094:	88 42 10             	mov    %al,0x10(%edx)
	for(i=0 ; i < NCC ; i++)
   18097:	b9 00 00 00 00       	mov    $0x0,%ecx
		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
   1809c:	8a 44 0c 09          	mov    0x9(%esp,%ecx,1),%al
   180a0:	88 44 11 11          	mov    %al,0x11(%ecx,%edx,1)
	for(i=0 ; i < NCC ; i++)
   180a4:	41                   	inc    %ecx
   180a5:	83 f9 07             	cmp    $0x7,%ecx
   180a8:	7e f2                	jle    1809c <tty_ioctl+0x1c9>
	if (!(port = tty->read_q.data))
   180aa:	66 8b 72 30          	mov    0x30(%edx),%si
   180ae:	66 85 f6             	test   %si,%si
   180b1:	74 41                	je     180f4 <tty_ioctl+0x221>
	quot = quotient[tty->termios.c_cflag & CBAUD];
   180b3:	8b 42 08             	mov    0x8(%edx),%eax
   180b6:	83 e0 0f             	and    $0xf,%eax
   180b9:	66 8b 9c 00 60 e4 01 	mov    0x1e460(%eax,%eax,1),%bx
   180c0:	00 
	cli();
   180c1:	fa                   	cli    
	outb_p(0x80,port+3);		/* set DLAB */
   180c2:	b8 80 00 00 00       	mov    $0x80,%eax
   180c7:	0f b7 fe             	movzwl %si,%edi
   180ca:	8d 4f 03             	lea    0x3(%edi),%ecx
   180cd:	89 ca                	mov    %ecx,%edx
   180cf:	ee                   	out    %al,(%dx)
   180d0:	eb 00                	jmp    180d2 <tty_ioctl+0x1ff>
   180d2:	eb 00                	jmp    180d4 <tty_ioctl+0x201>
	outb_p(quot & 0xff,port);	/* LS of divisor */
   180d4:	0f b6 c3             	movzbl %bl,%eax
   180d7:	89 f2                	mov    %esi,%edx
   180d9:	ee                   	out    %al,(%dx)
   180da:	eb 00                	jmp    180dc <tty_ioctl+0x209>
   180dc:	eb 00                	jmp    180de <tty_ioctl+0x20b>
	outb_p(quot >> 8,port+1);	/* MS of divisor */
   180de:	0f b6 df             	movzbl %bh,%ebx
   180e1:	8d 57 01             	lea    0x1(%edi),%edx
   180e4:	89 d8                	mov    %ebx,%eax
   180e6:	ee                   	out    %al,(%dx)
   180e7:	eb 00                	jmp    180e9 <tty_ioctl+0x216>
   180e9:	eb 00                	jmp    180eb <tty_ioctl+0x218>
	outb(0x03,port+3);		/* reset DLAB */
   180eb:	b8 03 00 00 00       	mov    $0x3,%eax
   180f0:	89 ca                	mov    %ecx,%edx
   180f2:	ee                   	out    %al,(%dx)
	sti();
   180f3:	fb                   	sti    
{
   180f4:	b8 00 00 00 00       	mov    $0x0,%eax
   180f9:	e9 46 01 00 00       	jmp    18244 <tty_ioctl+0x371>
			return 0;
   180fe:	b8 00 00 00 00       	mov    $0x0,%eax
   18103:	e9 3c 01 00 00       	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18108:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1810d:	e9 32 01 00 00       	jmp    18244 <tty_ioctl+0x371>
			if (arg==0)
   18112:	85 ff                	test   %edi,%edi
   18114:	75 0d                	jne    18123 <tty_ioctl+0x250>
{
   18116:	8d 53 30             	lea    0x30(%ebx),%edx
	cli();
   18119:	fa                   	cli    
	queue->head = queue->tail;
   1811a:	8b 42 08             	mov    0x8(%edx),%eax
   1811d:	89 42 04             	mov    %eax,0x4(%edx)
	sti();
   18120:	fb                   	sti    
   18121:	eb 3c                	jmp    1815f <tty_ioctl+0x28c>
			else if (arg==1)
   18123:	83 ff 01             	cmp    $0x1,%edi
   18126:	75 10                	jne    18138 <tty_ioctl+0x265>
{
   18128:	8d 93 40 04 00 00    	lea    0x440(%ebx),%edx
	cli();
   1812e:	fa                   	cli    
	queue->head = queue->tail;
   1812f:	8b 42 08             	mov    0x8(%edx),%eax
   18132:	89 42 04             	mov    %eax,0x4(%edx)
	sti();
   18135:	fb                   	sti    
   18136:	eb 27                	jmp    1815f <tty_ioctl+0x28c>
				return -EINVAL;
   18138:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			else if (arg==2) {
   1813d:	83 ff 02             	cmp    $0x2,%edi
   18140:	0f 85 fe 00 00 00    	jne    18244 <tty_ioctl+0x371>
{
   18146:	8d 53 30             	lea    0x30(%ebx),%edx
	cli();
   18149:	fa                   	cli    
	queue->head = queue->tail;
   1814a:	8b 42 08             	mov    0x8(%edx),%eax
   1814d:	89 42 04             	mov    %eax,0x4(%edx)
	sti();
   18150:	fb                   	sti    
{
   18151:	8d 93 40 04 00 00    	lea    0x440(%ebx),%edx
	cli();
   18157:	fa                   	cli    
	queue->head = queue->tail;
   18158:	8b 42 08             	mov    0x8(%edx),%eax
   1815b:	89 42 04             	mov    %eax,0x4(%edx)
	sti();
   1815e:	fb                   	sti    
			return 0;
   1815f:	b8 00 00 00 00       	mov    $0x0,%eax
   18164:	e9 db 00 00 00       	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18169:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1816e:	e9 d1 00 00 00       	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18173:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18178:	e9 c7 00 00 00       	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* set controlling term NI */
   1817d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18182:	e9 bd 00 00 00       	jmp    18244 <tty_ioctl+0x371>
			verify_area((void *) arg,4);
   18187:	83 ec 08             	sub    $0x8,%esp
   1818a:	6a 04                	push   $0x4
   1818c:	57                   	push   %edi
   1818d:	e8 da fc fe ff       	call   7e6c <verify_area>
{
__asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
}

static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
   18192:	83 c4 10             	add    $0x10,%esp
   18195:	8b 43 24             	mov    0x24(%ebx),%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
   18198:	64 89 07             	mov    %eax,%fs:(%edi)
			return 0;
   1819b:	b8 00 00 00 00       	mov    $0x0,%eax
   181a0:	e9 9f 00 00 00       	jmp    18244 <tty_ioctl+0x371>
	__asm__ ("movl %%fs:%1,%0":"=r" (_v):"m" (*addr)); \
   181a5:	64 8b 07             	mov    %fs:(%edi),%eax
{
   181a8:	89 43 24             	mov    %eax,0x24(%ebx)
			return 0;
   181ab:	b8 00 00 00 00       	mov    $0x0,%eax
   181b0:	e9 8f 00 00 00       	jmp    18244 <tty_ioctl+0x371>
			verify_area((void *) arg,4);
   181b5:	83 ec 08             	sub    $0x8,%esp
   181b8:	6a 04                	push   $0x4
   181ba:	57                   	push   %edi
   181bb:	e8 ac fc fe ff       	call   7e6c <verify_area>
{
   181c0:	83 c4 10             	add    $0x10,%esp
   181c3:	8b 83 44 04 00 00    	mov    0x444(%ebx),%eax
   181c9:	2b 83 48 04 00 00    	sub    0x448(%ebx),%eax
   181cf:	25 ff 03 00 00       	and    $0x3ff,%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
   181d4:	64 89 07             	mov    %eax,%fs:(%edi)
			return 0;
   181d7:	b8 00 00 00 00       	mov    $0x0,%eax
   181dc:	eb 66                	jmp    18244 <tty_ioctl+0x371>
			verify_area((void *) arg,4);
   181de:	83 ec 08             	sub    $0x8,%esp
   181e1:	6a 04                	push   $0x4
   181e3:	57                   	push   %edi
   181e4:	e8 83 fc fe ff       	call   7e6c <verify_area>
{
   181e9:	83 c4 10             	add    $0x10,%esp
   181ec:	8b 83 54 08 00 00    	mov    0x854(%ebx),%eax
   181f2:	2b 83 58 08 00 00    	sub    0x858(%ebx),%eax
   181f8:	25 ff 03 00 00       	and    $0x3ff,%eax
__asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
   181fd:	64 89 07             	mov    %eax,%fs:(%edi)
			return 0;
   18200:	b8 00 00 00 00       	mov    $0x0,%eax
   18205:	eb 3d                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18207:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1820c:	eb 36                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   1820e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18213:	eb 2f                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18215:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1821a:	eb 28                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   1821c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18221:	eb 21                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18223:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18228:	eb 1a                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   1822a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1822f:	eb 13                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18231:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18236:	eb 0c                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   18238:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1823d:	eb 05                	jmp    18244 <tty_ioctl+0x371>
			return -EINVAL; /* not implemented */
   1823f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}
}
   18244:	83 c4 2c             	add    $0x2c,%esp
   18247:	5b                   	pop    %ebx
   18248:	5e                   	pop    %esi
   18249:	5f                   	pop    %edi
   1824a:	5d                   	pop    %ebp
   1824b:	c3                   	ret    

0001824c <math_emulate>:
void math_emulate(long edi, long esi, long ebp, long sys_call_ret,
	long eax,long ebx,long ecx,long edx,
	unsigned short fs,unsigned short es,unsigned short ds,
	unsigned long eip,unsigned short cs,unsigned long eflags,
	unsigned short ss, unsigned long esp)
{
   1824c:	56                   	push   %esi
   1824d:	53                   	push   %ebx
   1824e:	83 ec 04             	sub    $0x4,%esp
   18251:	8b 74 24 3c          	mov    0x3c(%esp),%esi
   18255:	8b 5c 24 40          	mov    0x40(%esp),%ebx
	unsigned char first, second;

/* 0x0007 means user code space */
	if (cs != 0x000F) {
   18259:	66 83 fb 0f          	cmp    $0xf,%bx
   1825d:	74 21                	je     18280 <math_emulate+0x34>
		printk("math_emulate: %04x:%08x\n\r",cs,eip);
   1825f:	83 ec 04             	sub    $0x4,%esp
   18262:	56                   	push   %esi
   18263:	0f b7 c3             	movzwl %bx,%eax
   18266:	50                   	push   %eax
   18267:	68 5c 9a 01 00       	push   $0x19a5c
   1826c:	e8 e2 00 ff ff       	call   8353 <printk>
		panic("Math emulation needed in kernel");
   18271:	c7 04 24 8c 9a 01 00 	movl   $0x19a8c,(%esp)
   18278:	e8 9c 00 ff ff       	call   8319 <panic>
   1827d:	83 c4 10             	add    $0x10,%esp
static inline unsigned char get_fs_byte(const char * addr)
{
   18280:	64 8a 0e             	mov    %fs:(%esi),%cl
   18283:	8d 46 01             	lea    0x1(%esi),%eax
   18286:	64 8a 10             	mov    %fs:(%eax),%dl
	}
	first = get_fs_byte((char *)((*&eip)++));
	second = get_fs_byte((char *)((*&eip)++));
	printk("%04x:%08x %02x %02x\n\r",cs,eip-2,first,second);
   18289:	83 ec 0c             	sub    $0xc,%esp
   1828c:	0f b6 d2             	movzbl %dl,%edx
   1828f:	52                   	push   %edx
   18290:	0f b6 c9             	movzbl %cl,%ecx
   18293:	51                   	push   %ecx
   18294:	48                   	dec    %eax
   18295:	50                   	push   %eax
   18296:	0f b7 c3             	movzwl %bx,%eax
   18299:	50                   	push   %eax
   1829a:	68 76 9a 01 00       	push   $0x19a76
   1829f:	e8 af 00 ff ff       	call   8353 <printk>
	current->signal |= 1<<(SIGFPE-1);
   182a4:	a1 20 bc 01 00       	mov    0x1bc20,%eax
   182a9:	81 48 0c 80 00 00 00 	orl    $0x80,0xc(%eax)
}
   182b0:	83 c4 24             	add    $0x24,%esp
   182b3:	5b                   	pop    %ebx
   182b4:	5e                   	pop    %esi
   182b5:	c3                   	ret    

000182b6 <math_error>:

void math_error(void)
{
	__asm__("fnclex");
   182b6:	db e2                	fnclex 
	if (last_task_used_math)
   182b8:	83 3d c8 e9 01 00 00 	cmpl   $0x0,0x1e9c8
   182bf:	74 0c                	je     182cd <math_error+0x17>
		last_task_used_math->signal |= 1<<(SIGFPE-1);
   182c1:	a1 c8 e9 01 00       	mov    0x1e9c8,%eax
   182c6:	81 48 0c 80 00 00 00 	orl    $0x80,0xc(%eax)
   182cd:	c3                   	ret    

000182ce <_exit>:

#define __LIBRARY__
#include <unistd.h>

volatile void _exit(int exit_code)
{
   182ce:	53                   	push   %ebx
   182cf:	8b 5c 24 08          	mov    0x8(%esp),%ebx
	__asm__("int $0x80"::"a" (__NR_exit),"b" (exit_code));
   182d3:	b8 01 00 00 00       	mov    $0x1,%eax
   182d8:	cd 80                	int    $0x80
}
   182da:	5b                   	pop    %ebx
   182db:	c3                   	ret    

000182dc <open>:
#define __LIBRARY__
#include <unistd.h>
#include <stdarg.h>

int open(const char * filename, int flag, ...)
{
   182dc:	53                   	push   %ebx
   182dd:	8b 5c 24 08          	mov    0x8(%esp),%ebx
	register int res;
	va_list arg;

	va_start(arg,flag);
	__asm__("int $0x80"
   182e1:	b8 05 00 00 00       	mov    $0x5,%eax
   182e6:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   182ea:	8b 54 24 10          	mov    0x10(%esp),%edx
   182ee:	cd 80                	int    $0x80
		:"=a" (res)
		:"0" (__NR_open),"b" (filename),"c" (flag),
		"d" (va_arg(arg,int)));
	if (res>=0)
		return res;
   182f0:	89 c2                	mov    %eax,%edx
	if (res>=0)
   182f2:	85 c0                	test   %eax,%eax
   182f4:	79 0c                	jns    18302 <open+0x26>
	errno = -res;
   182f6:	f7 d8                	neg    %eax
   182f8:	a3 68 2e 02 00       	mov    %eax,0x22e68
	return -1;
   182fd:	ba ff ff ff ff       	mov    $0xffffffff,%edx
}
   18302:	89 d0                	mov    %edx,%eax
   18304:	5b                   	pop    %ebx
   18305:	c3                   	ret    

00018306 <close>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall1(int,close,int,fd)
   18306:	53                   	push   %ebx
   18307:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1830b:	b8 06 00 00 00       	mov    $0x6,%eax
   18310:	cd 80                	int    $0x80
   18312:	89 c2                	mov    %eax,%edx
   18314:	85 c0                	test   %eax,%eax
   18316:	79 0c                	jns    18324 <close+0x1e>
   18318:	f7 d8                	neg    %eax
   1831a:	a3 68 2e 02 00       	mov    %eax,0x22e68
   1831f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   18324:	89 d0                	mov    %edx,%eax
   18326:	5b                   	pop    %ebx
   18327:	c3                   	ret    

00018328 <write>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall3(int,write,int,fd,const char *,buf,off_t,count)
   18328:	53                   	push   %ebx
   18329:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1832d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   18331:	8b 54 24 10          	mov    0x10(%esp),%edx
   18335:	b8 04 00 00 00       	mov    $0x4,%eax
   1833a:	cd 80                	int    $0x80
   1833c:	89 c2                	mov    %eax,%edx
   1833e:	85 c0                	test   %eax,%eax
   18340:	79 0c                	jns    1834e <write+0x26>
   18342:	f7 d8                	neg    %eax
   18344:	a3 68 2e 02 00       	mov    %eax,0x22e68
   18349:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   1834e:	89 d0                	mov    %edx,%eax
   18350:	5b                   	pop    %ebx
   18351:	c3                   	ret    

00018352 <dup>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall1(int,dup,int,fd)
   18352:	53                   	push   %ebx
   18353:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   18357:	b8 29 00 00 00       	mov    $0x29,%eax
   1835c:	cd 80                	int    $0x80
   1835e:	89 c2                	mov    %eax,%edx
   18360:	85 c0                	test   %eax,%eax
   18362:	79 0c                	jns    18370 <dup+0x1e>
   18364:	f7 d8                	neg    %eax
   18366:	a3 68 2e 02 00       	mov    %eax,0x22e68
   1836b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   18370:	89 d0                	mov    %edx,%eax
   18372:	5b                   	pop    %ebx
   18373:	c3                   	ret    

00018374 <setsid>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall0(pid_t,setsid)
   18374:	b8 42 00 00 00       	mov    $0x42,%eax
   18379:	cd 80                	int    $0x80
   1837b:	89 c2                	mov    %eax,%edx
   1837d:	85 c0                	test   %eax,%eax
   1837f:	79 0c                	jns    1838d <setsid+0x19>
   18381:	f7 d8                	neg    %eax
   18383:	a3 68 2e 02 00       	mov    %eax,0x22e68
   18388:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   1838d:	89 d0                	mov    %edx,%eax
   1838f:	c3                   	ret    

00018390 <execve>:
 */

#define __LIBRARY__
#include <unistd.h>

_syscall3(int,execve,const char *,file,char **,argv,char **,envp)
   18390:	53                   	push   %ebx
   18391:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   18395:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   18399:	8b 54 24 10          	mov    0x10(%esp),%edx
   1839d:	b8 0b 00 00 00       	mov    $0xb,%eax
   183a2:	cd 80                	int    $0x80
   183a4:	89 c2                	mov    %eax,%edx
   183a6:	85 c0                	test   %eax,%eax
   183a8:	79 0c                	jns    183b6 <execve+0x26>
   183aa:	f7 d8                	neg    %eax
   183ac:	a3 68 2e 02 00       	mov    %eax,0x22e68
   183b1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   183b6:	89 d0                	mov    %edx,%eax
   183b8:	5b                   	pop    %ebx
   183b9:	c3                   	ret    

000183ba <waitpid>:

#define __LIBRARY__
#include <unistd.h>
#include <sys/wait.h>

_syscall3(pid_t,waitpid,pid_t,pid,int *,wait_stat,int,options)
   183ba:	53                   	push   %ebx
   183bb:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   183bf:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   183c3:	8b 54 24 10          	mov    0x10(%esp),%edx
   183c7:	b8 07 00 00 00       	mov    $0x7,%eax
   183cc:	cd 80                	int    $0x80
   183ce:	89 c2                	mov    %eax,%edx
   183d0:	85 c0                	test   %eax,%eax
   183d2:	79 0c                	jns    183e0 <waitpid+0x26>
   183d4:	f7 d8                	neg    %eax
   183d6:	a3 68 2e 02 00       	mov    %eax,0x22e68
   183db:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   183e0:	89 d0                	mov    %edx,%eax
   183e2:	5b                   	pop    %ebx
   183e3:	c3                   	ret    

000183e4 <wait>:

pid_t wait(int * wait_stat)
{
   183e4:	53                   	push   %ebx
   183e5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
_syscall3(pid_t,waitpid,pid_t,pid,int *,wait_stat,int,options)
   183e9:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
   183ee:	ba 00 00 00 00       	mov    $0x0,%edx
   183f3:	b8 07 00 00 00       	mov    $0x7,%eax
   183f8:	cd 80                	int    $0x80
   183fa:	89 c2                	mov    %eax,%edx
   183fc:	85 c0                	test   %eax,%eax
   183fe:	79 0c                	jns    1840c <wait+0x28>
   18400:	f7 d8                	neg    %eax
   18402:	a3 68 2e 02 00       	mov    %eax,0x22e68
   18407:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	return waitpid(-1,wait_stat,0);
}
   1840c:	89 d0                	mov    %edx,%eax
   1840e:	5b                   	pop    %ebx
   1840f:	c3                   	ret    

00018410 <strcpy>:
 *
 *		(C) 1991 Linus Torvalds
 */
 
extern inline char * strcpy(char * dest,const char *src)
{
   18410:	57                   	push   %edi
   18411:	56                   	push   %esi
   18412:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   18416:	8b 74 24 10          	mov    0x10(%esp),%esi
__asm__("cld\n"
   1841a:	fc                   	cld    
   1841b:	ac                   	lods   %ds:(%esi),%al
   1841c:	aa                   	stos   %al,%es:(%edi)
   1841d:	84 c0                	test   %al,%al
   1841f:	75 fa                	jne    1841b <strcpy+0xb>
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b"
	::"S" (src),"D" (dest));
return dest;
}
   18421:	89 f8                	mov    %edi,%eax
   18423:	5e                   	pop    %esi
   18424:	5f                   	pop    %edi
   18425:	c3                   	ret    

00018426 <strcat>:
	::"S" (src),"D" (dest),"c" (count));
return dest;
}

extern inline char * strcat(char * dest,const char * src)
{
   18426:	57                   	push   %edi
   18427:	56                   	push   %esi
   18428:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   1842c:	8b 74 24 10          	mov    0x10(%esp),%esi
__asm__("cld\n\t"
   18430:	b8 00 00 00 00       	mov    $0x0,%eax
   18435:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1843a:	fc                   	cld    
   1843b:	f2 ae                	repnz scas %es:(%edi),%al
   1843d:	4f                   	dec    %edi
   1843e:	ac                   	lods   %ds:(%esi),%al
   1843f:	aa                   	stos   %al,%es:(%edi)
   18440:	84 c0                	test   %al,%al
   18442:	75 fa                	jne    1843e <strcat+0x18>
	"stosb\n\t"
	"testb %%al,%%al\n\t"
	"jne 1b"
	::"S" (src),"D" (dest),"a" (0),"c" (0xffffffff));
return dest;
}
   18444:	89 f8                	mov    %edi,%eax
   18446:	5e                   	pop    %esi
   18447:	5f                   	pop    %edi
   18448:	c3                   	ret    

00018449 <strcmp>:
	);
return dest;
}

extern inline int strcmp(const char * cs,const char * ct)
{
   18449:	57                   	push   %edi
   1844a:	56                   	push   %esi
   1844b:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   1844f:	8b 74 24 10          	mov    0x10(%esp),%esi
register int __res ;
__asm__("cld\n"
   18453:	fc                   	cld    
   18454:	ac                   	lods   %ds:(%esi),%al
   18455:	ae                   	scas   %es:(%edi),%al
   18456:	75 08                	jne    18460 <strcmp+0x17>
   18458:	84 c0                	test   %al,%al
   1845a:	75 f8                	jne    18454 <strcmp+0xb>
   1845c:	31 c0                	xor    %eax,%eax
   1845e:	eb 09                	jmp    18469 <strcmp+0x20>
   18460:	b8 01 00 00 00       	mov    $0x1,%eax
   18465:	7c 02                	jl     18469 <strcmp+0x20>
   18467:	f7 d8                	neg    %eax
	"jl 3f\n\t"
	"negl %%eax\n"
	"3:"
	:"=a" (__res):"D" (cs),"S" (ct));
return __res;
}
   18469:	5e                   	pop    %esi
   1846a:	5f                   	pop    %edi
   1846b:	c3                   	ret    

0001846c <strspn>:
	:"=d" (__res):"0" (0),"S" (s),"a" (c));
return __res;
}

extern inline int strspn(const char * cs, const char * ct)
{
   1846c:	56                   	push   %esi
register char * __res;
__asm__("cld\n\t"
   1846d:	b8 00 00 00 00       	mov    $0x0,%eax
   18472:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   18477:	8b 74 24 08          	mov    0x8(%esp),%esi
   1847b:	fc                   	cld    
   1847c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   18480:	f2 ae                	repnz scas %es:(%edi),%al
   18482:	f7 d1                	not    %ecx
   18484:	49                   	dec    %ecx
   18485:	89 ca                	mov    %ecx,%edx
   18487:	ac                   	lods   %ds:(%esi),%al
   18488:	84 c0                	test   %al,%al
   1848a:	74 0a                	je     18496 <strspn+0x2a>
   1848c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   18490:	89 d1                	mov    %edx,%ecx
   18492:	f2 ae                	repnz scas %es:(%edi),%al
   18494:	74 f1                	je     18487 <strspn+0x1b>
   18496:	4e                   	dec    %esi
   18497:	89 f0                	mov    %esi,%eax
	"scasb\n\t"
	"je 1b\n"
	"2:\tdecl %0"
	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
	);
return __res-cs;
   18499:	2b 44 24 08          	sub    0x8(%esp),%eax
}
   1849d:	5e                   	pop    %esi
   1849e:	c3                   	ret    

0001849f <strcspn>:

extern inline int strcspn(const char * cs, const char * ct)
{
   1849f:	56                   	push   %esi
register char * __res;
__asm__("cld\n\t"
   184a0:	b8 00 00 00 00       	mov    $0x0,%eax
   184a5:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   184aa:	8b 74 24 08          	mov    0x8(%esp),%esi
   184ae:	fc                   	cld    
   184af:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   184b3:	f2 ae                	repnz scas %es:(%edi),%al
   184b5:	f7 d1                	not    %ecx
   184b7:	49                   	dec    %ecx
   184b8:	89 ca                	mov    %ecx,%edx
   184ba:	ac                   	lods   %ds:(%esi),%al
   184bb:	84 c0                	test   %al,%al
   184bd:	74 0a                	je     184c9 <strcspn+0x2a>
   184bf:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   184c3:	89 d1                	mov    %edx,%ecx
   184c5:	f2 ae                	repnz scas %es:(%edi),%al
   184c7:	75 f1                	jne    184ba <strcspn+0x1b>
   184c9:	4e                   	dec    %esi
   184ca:	89 f0                	mov    %esi,%eax
	"scasb\n\t"
	"jne 1b\n"
	"2:\tdecl %0"
	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
	);
return __res-cs;
   184cc:	2b 44 24 08          	sub    0x8(%esp),%eax
}
   184d0:	5e                   	pop    %esi
   184d1:	c3                   	ret    

000184d2 <strpbrk>:

extern inline char * strpbrk(const char * cs,const char * ct)
{
   184d2:	56                   	push   %esi
   184d3:	8b 74 24 08          	mov    0x8(%esp),%esi
register char * __res ;
__asm__("cld\n\t"
   184d7:	b8 00 00 00 00       	mov    $0x0,%eax
   184dc:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   184e1:	fc                   	cld    
   184e2:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   184e6:	f2 ae                	repnz scas %es:(%edi),%al
   184e8:	f7 d1                	not    %ecx
   184ea:	49                   	dec    %ecx
   184eb:	89 ca                	mov    %ecx,%edx
   184ed:	ac                   	lods   %ds:(%esi),%al
   184ee:	84 c0                	test   %al,%al
   184f0:	74 0d                	je     184ff <strpbrk+0x2d>
   184f2:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   184f6:	89 d1                	mov    %edx,%ecx
   184f8:	f2 ae                	repnz scas %es:(%edi),%al
   184fa:	75 f1                	jne    184ed <strpbrk+0x1b>
   184fc:	4e                   	dec    %esi
   184fd:	eb 02                	jmp    18501 <strpbrk+0x2f>
   184ff:	31 f6                	xor    %esi,%esi
	"2:\txorl %0,%0\n"
	"3:"
	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
	);
return __res;
}
   18501:	89 f0                	mov    %esi,%eax
   18503:	5e                   	pop    %esi
   18504:	c3                   	ret    

00018505 <strstr>:

extern inline char * strstr(const char * cs,const char * ct)
{
   18505:	56                   	push   %esi
   18506:	8b 74 24 08          	mov    0x8(%esp),%esi
register char * __res ;
__asm__("cld\n\t" \
   1850a:	b8 00 00 00 00       	mov    $0x0,%eax
   1850f:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   18514:	fc                   	cld    
   18515:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   18519:	f2 ae                	repnz scas %es:(%edi),%al
   1851b:	f7 d1                	not    %ecx
   1851d:	49                   	dec    %ecx
   1851e:	89 ca                	mov    %ecx,%edx
   18520:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   18524:	89 f0                	mov    %esi,%eax
   18526:	89 d1                	mov    %edx,%ecx
   18528:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
   1852a:	74 0a                	je     18536 <strstr+0x31>
   1852c:	96                   	xchg   %eax,%esi
   1852d:	46                   	inc    %esi
   1852e:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
   18532:	75 ec                	jne    18520 <strstr+0x1b>
   18534:	31 c0                	xor    %eax,%eax
	"xorl %%eax,%%eax\n\t"
	"2:"
	:"=a" (__res):"0" (0),"c" (0xffffffff),"S" (cs),"g" (ct)
	);
return __res;
}
   18536:	5e                   	pop    %esi
   18537:	c3                   	ret    

00018538 <strlen>:

extern inline int strlen(const char * s)
{
   18538:	57                   	push   %edi
   18539:	8b 7c 24 08          	mov    0x8(%esp),%edi
register int __res ;
__asm__("cld\n\t"
   1853d:	b8 00 00 00 00       	mov    $0x0,%eax
   18542:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   18547:	fc                   	cld    
   18548:	f2 ae                	repnz scas %es:(%edi),%al
   1854a:	f7 d1                	not    %ecx
   1854c:	49                   	dec    %ecx
	"scasb\n\t"
	"notl %0\n\t"
	"decl %0"
	:"=c" (__res):"D" (s),"a" (0),"0" (0xffffffff));
return __res;
}
   1854d:	89 c8                	mov    %ecx,%eax
   1854f:	5f                   	pop    %edi
   18550:	c3                   	ret    

00018551 <strtok>:

extern char * ___strtok;

extern inline char * strtok(char * s,const char * ct)
{
   18551:	56                   	push   %esi
   18552:	53                   	push   %ebx
   18553:	8b 74 24 0c          	mov    0xc(%esp),%esi
register char * __res ;
__asm__("testl %1,%1\n\t"
   18557:	8b 1d 6c 2e 02 00    	mov    0x22e6c,%ebx
   1855d:	85 f6                	test   %esi,%esi
   1855f:	75 06                	jne    18567 <strtok+0x16>
   18561:	85 db                	test   %ebx,%ebx
   18563:	74 5a                	je     185bf <strtok+0x6e>
   18565:	89 de                	mov    %ebx,%esi
   18567:	31 db                	xor    %ebx,%ebx
   18569:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1856e:	31 c0                	xor    %eax,%eax
   18570:	fc                   	cld    
   18571:	8b 7c 24 10          	mov    0x10(%esp),%edi
   18575:	f2 ae                	repnz scas %es:(%edi),%al
   18577:	f7 d1                	not    %ecx
   18579:	49                   	dec    %ecx
   1857a:	74 3d                	je     185b9 <strtok+0x68>
   1857c:	89 ca                	mov    %ecx,%edx
   1857e:	ac                   	lods   %ds:(%esi),%al
   1857f:	84 c0                	test   %al,%al
   18581:	74 36                	je     185b9 <strtok+0x68>
   18583:	8b 7c 24 10          	mov    0x10(%esp),%edi
   18587:	89 d1                	mov    %edx,%ecx
   18589:	f2 ae                	repnz scas %es:(%edi),%al
   1858b:	74 f1                	je     1857e <strtok+0x2d>
   1858d:	4e                   	dec    %esi
   1858e:	80 3e 00             	cmpb   $0x0,(%esi)
   18591:	74 26                	je     185b9 <strtok+0x68>
   18593:	89 f3                	mov    %esi,%ebx
   18595:	ac                   	lods   %ds:(%esi),%al
   18596:	84 c0                	test   %al,%al
   18598:	74 16                	je     185b0 <strtok+0x5f>
   1859a:	8b 7c 24 10          	mov    0x10(%esp),%edi
   1859e:	89 d1                	mov    %edx,%ecx
   185a0:	f2 ae                	repnz scas %es:(%edi),%al
   185a2:	75 f1                	jne    18595 <strtok+0x44>
   185a4:	4e                   	dec    %esi
   185a5:	80 3e 00             	cmpb   $0x0,(%esi)
   185a8:	74 06                	je     185b0 <strtok+0x5f>
   185aa:	c6 06 00             	movb   $0x0,(%esi)
   185ad:	46                   	inc    %esi
   185ae:	eb 02                	jmp    185b2 <strtok+0x61>
   185b0:	31 f6                	xor    %esi,%esi
   185b2:	80 3b 00             	cmpb   $0x0,(%ebx)
   185b5:	75 02                	jne    185b9 <strtok+0x68>
   185b7:	31 db                	xor    %ebx,%ebx
   185b9:	85 db                	test   %ebx,%ebx
   185bb:	75 02                	jne    185bf <strtok+0x6e>
   185bd:	89 de                	mov    %ebx,%esi
   185bf:	89 35 6c 2e 02 00    	mov    %esi,0x22e6c
	"8:"
	:"=b" (__res),"=S" (___strtok)
	:"0" (___strtok),"1" (s),"g" (ct)
	);
return __res;
}
   185c5:	89 d8                	mov    %ebx,%eax
   185c7:	5b                   	pop    %ebx
   185c8:	5e                   	pop    %esi
   185c9:	c3                   	ret    

000185ca <memcpy>:
 * Changes by falcon<zhangjinw@gmail.com>, the original return value is static
 * inline ... it can not be called by other functions in another files.
 */

extern inline void * memcpy(void * dest,const void * src, int n)
{
   185ca:	57                   	push   %edi
   185cb:	56                   	push   %esi
   185cc:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   185d0:	8b 74 24 10          	mov    0x10(%esp),%esi
   185d4:	8b 4c 24 14          	mov    0x14(%esp),%ecx
__asm__("cld\n\t"
   185d8:	fc                   	cld    
   185d9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	"rep\n\t"
	"movsb"
	::"c" (n),"S" (src),"D" (dest)
	);
return dest;
}
   185db:	89 f8                	mov    %edi,%eax
   185dd:	5e                   	pop    %esi
   185de:	5f                   	pop    %edi
   185df:	c3                   	ret    

000185e0 <memmove>:

extern inline void * memmove(void * dest,const void * src, int n)
{
   185e0:	57                   	push   %edi
   185e1:	56                   	push   %esi
   185e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
   185e6:	8b 74 24 10          	mov    0x10(%esp),%esi
   185ea:	8b 4c 24 14          	mov    0x14(%esp),%ecx
if (dest<src)
   185ee:	39 f0                	cmp    %esi,%eax
   185f0:	73 07                	jae    185f9 <memmove+0x19>
__asm__("cld\n\t"
   185f2:	89 c7                	mov    %eax,%edi
   185f4:	fc                   	cld    
   185f5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   185f7:	eb 0b                	jmp    18604 <memmove+0x24>
	"rep\n\t"
	"movsb"
	::"c" (n),"S" (src),"D" (dest)
	);
else
__asm__("std\n\t"
   185f9:	8d 74 0e ff          	lea    -0x1(%esi,%ecx,1),%esi
   185fd:	8d 7c 08 ff          	lea    -0x1(%eax,%ecx,1),%edi
   18601:	fd                   	std    
   18602:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	"rep\n\t"
	"movsb"
	::"c" (n),"S" (src+n-1),"D" (dest+n-1)
	);
return dest;
}
   18604:	5e                   	pop    %esi
   18605:	5f                   	pop    %edi
   18606:	c3                   	ret    

00018607 <memchr>:
	);
return __res;
}

extern inline void * memchr(const void * cs,char c,int count)
{
   18607:	57                   	push   %edi
   18608:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1860c:	8a 44 24 0c          	mov    0xc(%esp),%al
register void * __res ;
if (!count)
	return NULL;
   18610:	ba 00 00 00 00       	mov    $0x0,%edx
if (!count)
   18615:	85 c9                	test   %ecx,%ecx
   18617:	74 11                	je     1862a <memchr+0x23>
	"je 1f\n\t"
	"movl $1,%0\n"
	"1:\tdecl %0"
	:"=D" (__res):"a" (c),"D" (cs),"c" (count)
	);
return __res;
   18619:	8b 7c 24 08          	mov    0x8(%esp),%edi
   1861d:	fc                   	cld    
   1861e:	f2 ae                	repnz scas %es:(%edi),%al
   18620:	74 05                	je     18627 <memchr+0x20>
   18622:	bf 01 00 00 00       	mov    $0x1,%edi
   18627:	4f                   	dec    %edi
   18628:	89 fa                	mov    %edi,%edx
}
   1862a:	89 d0                	mov    %edx,%eax
   1862c:	5f                   	pop    %edi
   1862d:	c3                   	ret    
